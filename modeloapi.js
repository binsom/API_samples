/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview gl-matrix - High performance matrix and vector operations
	 * @author Brandon Jones
	 * @author Colin MacKenzie IV
	 * @version 2.3.2
	 */

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	// END HEADER

	exports.glMatrix = __webpack_require__(1);
	exports.mat2 = __webpack_require__(2);
	exports.mat2d = __webpack_require__(3);
	exports.mat3 = __webpack_require__(4);
	exports.mat4 = __webpack_require__(5);
	exports.quat = __webpack_require__(6);
	exports.vec2 = __webpack_require__(9);
	exports.vec3 = __webpack_require__(7);
	exports.vec4 = __webpack_require__(8);

/***/ },
/* 1 */
/***/ function(module, exports) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	/**
	 * @class Common utilities
	 * @name glMatrix
	 */
	var glMatrix = {};

	// Configuration Constants
	glMatrix.EPSILON = 0.000001;
	glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	glMatrix.RANDOM = Math.random;
	glMatrix.ENABLE_SIMD = false;

	// Capability detection
	glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
	glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

	/**
	 * Sets the type of array used when creating new vectors and matrices
	 *
	 * @param {Type} type Array type, such as Float32Array or Array
	 */
	glMatrix.setMatrixArrayType = function(type) {
	    glMatrix.ARRAY_TYPE = type;
	}

	var degree = Math.PI / 180;

	/**
	* Convert Degree To Radian
	*
	* @param {Number} Angle in Degrees
	*/
	glMatrix.toRadian = function(a){
	     return a * degree;
	}

	module.exports = glMatrix;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 2x2 Matrix
	 * @name mat2
	 */
	var mat2 = {};

	/**
	 * Creates a new identity mat2
	 *
	 * @returns {mat2} a new 2x2 matrix
	 */
	mat2.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Creates a new mat2 initialized with values from an existing matrix
	 *
	 * @param {mat2} a matrix to clone
	 * @returns {mat2} a new 2x2 matrix
	 */
	mat2.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Copy the values from one mat2 to another
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Set a mat2 to the identity matrix
	 *
	 * @param {mat2} out the receiving matrix
	 * @returns {mat2} out
	 */
	mat2.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a1 = a[1];
	        out[1] = a[2];
	        out[2] = a1;
	    } else {
	        out[0] = a[0];
	        out[1] = a[2];
	        out[2] = a[1];
	        out[3] = a[3];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.invert = function(out, a) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

	        // Calculate the determinant
	        det = a0 * a3 - a2 * a1;

	    if (!det) {
	        return null;
	    }
	    det = 1.0 / det;
	    
	    out[0] =  a3 * det;
	    out[1] = -a1 * det;
	    out[2] = -a2 * det;
	    out[3] =  a0 * det;

	    return out;
	};

	/**
	 * Calculates the adjugate of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.adjoint = function(out, a) {
	    // Caching this value is nessecary if out == a
	    var a0 = a[0];
	    out[0] =  a[3];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] =  a0;

	    return out;
	};

	/**
	 * Calculates the determinant of a mat2
	 *
	 * @param {mat2} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat2.determinant = function (a) {
	    return a[0] * a[3] - a[2] * a[1];
	};

	/**
	 * Multiplies two mat2's
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	mat2.multiply = function (out, a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    out[0] = a0 * b0 + a2 * b1;
	    out[1] = a1 * b0 + a3 * b1;
	    out[2] = a0 * b2 + a2 * b3;
	    out[3] = a1 * b2 + a3 * b3;
	    return out;
	};

	/**
	 * Alias for {@link mat2.multiply}
	 * @function
	 */
	mat2.mul = mat2.multiply;

	/**
	 * Rotates a mat2 by the given angle
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	mat2.rotate = function (out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = a0 *  c + a2 * s;
	    out[1] = a1 *  c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    return out;
	};

	/**
	 * Scales the mat2 by the dimensions in the given vec2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2} out
	 **/
	mat2.scale = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0 * v0;
	    out[1] = a1 * v0;
	    out[2] = a2 * v1;
	    out[3] = a3 * v1;
	    return out;
	};

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2.identity(dest);
	 *     mat2.rotate(dest, dest, rad);
	 *
	 * @param {mat2} out mat2 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	mat2.fromRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = c;
	    out[1] = s;
	    out[2] = -s;
	    out[3] = c;
	    return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2.identity(dest);
	 *     mat2.scale(dest, dest, vec);
	 *
	 * @param {mat2} out mat2 receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat2} out
	 */
	mat2.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = v[1];
	    return out;
	}

	/**
	 * Returns a string representation of a mat2
	 *
	 * @param {mat2} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat2.str = function (a) {
	    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat2
	 *
	 * @param {mat2} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat2.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
	};

	/**
	 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
	 * @param {mat2} L the lower triangular matrix 
	 * @param {mat2} D the diagonal matrix 
	 * @param {mat2} U the upper triangular matrix 
	 * @param {mat2} a the input matrix to factorize
	 */

	mat2.LDU = function (L, D, U, a) { 
	    L[2] = a[2]/a[0]; 
	    U[0] = a[0]; 
	    U[1] = a[1]; 
	    U[3] = a[3] - L[2] * U[1]; 
	    return [L, D, U];       
	}; 


	module.exports = mat2;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 2x3 Matrix
	 * @name mat2d
	 * 
	 * @description 
	 * A mat2d contains six elements defined as:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty]
	 * </pre>
	 * This is a short form for the 3x3 matrix:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty,
	 *  0, 0, 1]
	 * </pre>
	 * The last row is ignored so the array is shorter and operations are faster.
	 */
	var mat2d = {};

	/**
	 * Creates a new identity mat2d
	 *
	 * @returns {mat2d} a new 2x3 matrix
	 */
	mat2d.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(6);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	};

	/**
	 * Creates a new mat2d initialized with values from an existing matrix
	 *
	 * @param {mat2d} a matrix to clone
	 * @returns {mat2d} a new 2x3 matrix
	 */
	mat2d.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(6);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    return out;
	};

	/**
	 * Copy the values from one mat2d to another
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	mat2d.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    return out;
	};

	/**
	 * Set a mat2d to the identity matrix
	 *
	 * @param {mat2d} out the receiving matrix
	 * @returns {mat2d} out
	 */
	mat2d.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	};

	/**
	 * Inverts a mat2d
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	mat2d.invert = function(out, a) {
	    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
	        atx = a[4], aty = a[5];

	    var det = aa * ad - ab * ac;
	    if(!det){
	        return null;
	    }
	    det = 1.0 / det;

	    out[0] = ad * det;
	    out[1] = -ab * det;
	    out[2] = -ac * det;
	    out[3] = aa * det;
	    out[4] = (ac * aty - ad * atx) * det;
	    out[5] = (ab * atx - aa * aty) * det;
	    return out;
	};

	/**
	 * Calculates the determinant of a mat2d
	 *
	 * @param {mat2d} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat2d.determinant = function (a) {
	    return a[0] * a[3] - a[1] * a[2];
	};

	/**
	 * Multiplies two mat2d's
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	mat2d.multiply = function (out, a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
	    out[0] = a0 * b0 + a2 * b1;
	    out[1] = a1 * b0 + a3 * b1;
	    out[2] = a0 * b2 + a2 * b3;
	    out[3] = a1 * b2 + a3 * b3;
	    out[4] = a0 * b4 + a2 * b5 + a4;
	    out[5] = a1 * b4 + a3 * b5 + a5;
	    return out;
	};

	/**
	 * Alias for {@link mat2d.multiply}
	 * @function
	 */
	mat2d.mul = mat2d.multiply;

	/**
	 * Rotates a mat2d by the given angle
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	mat2d.rotate = function (out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = a0 *  c + a2 * s;
	    out[1] = a1 *  c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    out[4] = a4;
	    out[5] = a5;
	    return out;
	};

	/**
	 * Scales the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2d} out
	 **/
	mat2d.scale = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0 * v0;
	    out[1] = a1 * v0;
	    out[2] = a2 * v1;
	    out[3] = a3 * v1;
	    out[4] = a4;
	    out[5] = a5;
	    return out;
	};

	/**
	 * Translates the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to translate the matrix by
	 * @returns {mat2d} out
	 **/
	mat2d.translate = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0;
	    out[1] = a1;
	    out[2] = a2;
	    out[3] = a3;
	    out[4] = a0 * v0 + a2 * v1 + a4;
	    out[5] = a1 * v0 + a3 * v1 + a5;
	    return out;
	};

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.rotate(dest, dest, rad);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	mat2d.fromRotation = function(out, rad) {
	    var s = Math.sin(rad), c = Math.cos(rad);
	    out[0] = c;
	    out[1] = s;
	    out[2] = -s;
	    out[3] = c;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.scale(dest, dest, vec);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat2d} out
	 */
	mat2d.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = v[1];
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	}

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.translate(dest, dest, vec);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {vec2} v Translation vector
	 * @returns {mat2d} out
	 */
	mat2d.fromTranslation = function(out, v) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = v[0];
	    out[5] = v[1];
	    return out;
	}

	/**
	 * Returns a string representation of a mat2d
	 *
	 * @param {mat2d} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat2d.str = function (a) {
	    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat2d
	 *
	 * @param {mat2d} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat2d.frob = function (a) { 
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
	}; 

	module.exports = mat2d;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 3x3 Matrix
	 * @name mat3
	 */
	var mat3 = {};

	/**
	 * Creates a new identity mat3
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */
	mat3.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(9);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Copies the upper-left 3x3 values into the given mat3.
	 *
	 * @param {mat3} out the receiving 3x3 matrix
	 * @param {mat4} a   the source 4x4 matrix
	 * @returns {mat3} out
	 */
	mat3.fromMat4 = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[4];
	    out[4] = a[5];
	    out[5] = a[6];
	    out[6] = a[8];
	    out[7] = a[9];
	    out[8] = a[10];
	    return out;
	};

	/**
	 * Creates a new mat3 initialized with values from an existing matrix
	 *
	 * @param {mat3} a matrix to clone
	 * @returns {mat3} a new 3x3 matrix
	 */
	mat3.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(9);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Copy the values from one mat3 to another
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Set a mat3 to the identity matrix
	 *
	 * @param {mat3} out the receiving matrix
	 * @returns {mat3} out
	 */
	mat3.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a12 = a[5];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a01;
	        out[5] = a[7];
	        out[6] = a02;
	        out[7] = a12;
	    } else {
	        out[0] = a[0];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a[1];
	        out[4] = a[4];
	        out[5] = a[7];
	        out[6] = a[2];
	        out[7] = a[5];
	        out[8] = a[8];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        b01 = a22 * a11 - a12 * a21,
	        b11 = -a22 * a10 + a12 * a20,
	        b21 = a21 * a10 - a11 * a20,

	        // Calculate the determinant
	        det = a00 * b01 + a01 * b11 + a02 * b21;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = b01 * det;
	    out[1] = (-a22 * a01 + a02 * a21) * det;
	    out[2] = (a12 * a01 - a02 * a11) * det;
	    out[3] = b11 * det;
	    out[4] = (a22 * a00 - a02 * a20) * det;
	    out[5] = (-a12 * a00 + a02 * a10) * det;
	    out[6] = b21 * det;
	    out[7] = (-a21 * a00 + a01 * a20) * det;
	    out[8] = (a11 * a00 - a01 * a10) * det;
	    return out;
	};

	/**
	 * Calculates the adjugate of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.adjoint = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];

	    out[0] = (a11 * a22 - a12 * a21);
	    out[1] = (a02 * a21 - a01 * a22);
	    out[2] = (a01 * a12 - a02 * a11);
	    out[3] = (a12 * a20 - a10 * a22);
	    out[4] = (a00 * a22 - a02 * a20);
	    out[5] = (a02 * a10 - a00 * a12);
	    out[6] = (a10 * a21 - a11 * a20);
	    out[7] = (a01 * a20 - a00 * a21);
	    out[8] = (a00 * a11 - a01 * a10);
	    return out;
	};

	/**
	 * Calculates the determinant of a mat3
	 *
	 * @param {mat3} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat3.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];

	    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	};

	/**
	 * Multiplies two mat3's
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	mat3.multiply = function (out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        b00 = b[0], b01 = b[1], b02 = b[2],
	        b10 = b[3], b11 = b[4], b12 = b[5],
	        b20 = b[6], b21 = b[7], b22 = b[8];

	    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

	    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

	    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	    return out;
	};

	/**
	 * Alias for {@link mat3.multiply}
	 * @function
	 */
	mat3.mul = mat3.multiply;

	/**
	 * Translate a mat3 by the given vector
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to translate
	 * @param {vec2} v vector to translate by
	 * @returns {mat3} out
	 */
	mat3.translate = function(out, a, v) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	        x = v[0], y = v[1];

	    out[0] = a00;
	    out[1] = a01;
	    out[2] = a02;

	    out[3] = a10;
	    out[4] = a11;
	    out[5] = a12;

	    out[6] = x * a00 + y * a10 + a20;
	    out[7] = x * a01 + y * a11 + a21;
	    out[8] = x * a02 + y * a12 + a22;
	    return out;
	};

	/**
	 * Rotates a mat3 by the given angle
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	mat3.rotate = function (out, a, rad) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        s = Math.sin(rad),
	        c = Math.cos(rad);

	    out[0] = c * a00 + s * a10;
	    out[1] = c * a01 + s * a11;
	    out[2] = c * a02 + s * a12;

	    out[3] = c * a10 - s * a00;
	    out[4] = c * a11 - s * a01;
	    out[5] = c * a12 - s * a02;

	    out[6] = a20;
	    out[7] = a21;
	    out[8] = a22;
	    return out;
	};

	/**
	 * Scales the mat3 by the dimensions in the given vec2
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat3} out
	 **/
	mat3.scale = function(out, a, v) {
	    var x = v[0], y = v[1];

	    out[0] = x * a[0];
	    out[1] = x * a[1];
	    out[2] = x * a[2];

	    out[3] = y * a[3];
	    out[4] = y * a[4];
	    out[5] = y * a[5];

	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.translate(dest, dest, vec);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {vec2} v Translation vector
	 * @returns {mat3} out
	 */
	mat3.fromTranslation = function(out, v) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = v[0];
	    out[7] = v[1];
	    out[8] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.rotate(dest, dest, rad);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	mat3.fromRotation = function(out, rad) {
	    var s = Math.sin(rad), c = Math.cos(rad);

	    out[0] = c;
	    out[1] = s;
	    out[2] = 0;

	    out[3] = -s;
	    out[4] = c;
	    out[5] = 0;

	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.scale(dest, dest, vec);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat3} out
	 */
	mat3.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;

	    out[3] = 0;
	    out[4] = v[1];
	    out[5] = 0;

	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	}

	/**
	 * Copies the values from a mat2d into a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat2d} a the matrix to copy
	 * @returns {mat3} out
	 **/
	mat3.fromMat2d = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = 0;

	    out[3] = a[2];
	    out[4] = a[3];
	    out[5] = 0;

	    out[6] = a[4];
	    out[7] = a[5];
	    out[8] = 1;
	    return out;
	};

	/**
	* Calculates a 3x3 matrix from the given quaternion
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {quat} q Quaternion to create matrix from
	*
	* @returns {mat3} out
	*/
	mat3.fromQuat = function (out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[3] = yx - wz;
	    out[6] = zx + wy;

	    out[1] = yx + wz;
	    out[4] = 1 - xx - zz;
	    out[7] = zy - wx;

	    out[2] = zx - wy;
	    out[5] = zy + wx;
	    out[8] = 1 - xx - yy;

	    return out;
	};

	/**
	* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {mat4} a Mat4 to derive the normal matrix from
	*
	* @returns {mat3} out
	*/
	mat3.normalFromMat4 = function (out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

	    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

	    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

	    return out;
	};

	/**
	 * Returns a string representation of a mat3
	 *
	 * @param {mat3} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat3.str = function (a) {
	    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
	                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat3
	 *
	 * @param {mat3} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat3.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
	};


	module.exports = mat3;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 4x4 Matrix
	 * @name mat4
	 */
	var mat4 = {
	  scalar: {},
	  SIMD: {},
	};

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */
	mat4.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(16);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {mat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */
	mat4.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	mat4.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};
    
	/**
	 * Scale the values of a mat4 with same value
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} mat the source matrix
	 * @param {Number} c the scale value
	 * @returns {mat4} out
	 */
	mat4.multiplyScalar = function(out, mat, c) {
	    out[0] = mat[0] * c;
	    out[1] = mat[1] * c;
	    out[2] = mat[2] * c;
	    out[3] = mat[3] * c;
	    out[4] = mat[4] * c;
	    out[5] = mat[5] * c;
	    out[6] = mat[6] * c;
	    out[7] = mat[7] * c;
	    out[8] = mat[8] * c;
	    out[9] = mat[9] * c;
	    out[10] = mat[10] * c;
	    out[11] = mat[11] * c;
	    out[12] = mat[12] * c;
	    out[13] = mat[13] * c;
	    out[14] = mat[14] * c;
	    out[15] = mat[15] * c;
	
	    return out;
	};
    
    /**
	 * Add two mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} mat the first add matrix
	 * @param {mat4} mat2 the second add matrix
	 * @returns {mat4} out
	 */
	mat4.add = function(out, mat, mat2) {
	    out[0] = mat[0] + mat2[0];
	    out[1] = mat[1] + mat2[1];
	    out[2] = mat[2] + mat2[2];
	    out[3] = mat[3] + mat2[3];
	    out[4] = mat[4] + mat2[4];
	    out[5] = mat[5] + mat2[5];
	    out[6] = mat[6] + mat2[6];
	    out[7] = mat[7] + mat2[7];
	    out[8] = mat[8] + mat2[8];
	    out[9] = mat[9] + mat2[9];
	    out[10] = mat[10] + mat2[10];
	    out[11] = mat[11] + mat2[11];
	    out[12] = mat[12] + mat2[12];
	    out[13] = mat[13] + mat2[13];
	    out[14] = mat[14] + mat2[14];
	    out[15] = mat[15] + mat2[15];
	
	return out;
	};
    
    
	/**
	 * Transpose the values of a mat4 not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.scalar.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];

	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }

	    return out;
	};

	/**
	 * Transpose the values of a mat4 using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.SIMD.transpose = function(out, a) {
	    var a0, a1, a2, a3,
	        tmp01, tmp23,
	        out0, out1, out2, out3;

	    a0 = SIMD.Float32x4.load(a, 0);
	    a1 = SIMD.Float32x4.load(a, 4);
	    a2 = SIMD.Float32x4.load(a, 8);
	    a3 = SIMD.Float32x4.load(a, 12);

	    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
	    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
	    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
	    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
	    SIMD.Float32x4.store(out, 0,  out0);
	    SIMD.Float32x4.store(out, 4,  out1);

	    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
	    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
	    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
	    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
	    SIMD.Float32x4.store(out, 8,  out2);
	    SIMD.Float32x4.store(out, 12, out3);

	    return out;
	};

	/**
	 * Transpse a mat4 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

	/**
	 * Inverts a mat4 not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.scalar.invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) {
	        return null;
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	};

	/**
	 * Inverts a mat4 using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.SIMD.invert = function(out, a) {
	  var row0, row1, row2, row3,
	      tmp1,
	      minor0, minor1, minor2, minor3,
	      det,
	      a0 = SIMD.Float32x4.load(a, 0),
	      a1 = SIMD.Float32x4.load(a, 4),
	      a2 = SIMD.Float32x4.load(a, 8),
	      a3 = SIMD.Float32x4.load(a, 12);

	  // Compute matrix adjugate
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
	  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
	  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
	  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
	  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
	  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
	  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

	  tmp1   = SIMD.Float32x4.mul(row2, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.mul(row1, tmp1);
	  minor1 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
	  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
	  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

	  tmp1   = SIMD.Float32x4.mul(row1, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
	  minor3 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
	  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

	  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
	  minor2 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
	  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

	  tmp1   = SIMD.Float32x4.mul(row0, row1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

	  tmp1   = SIMD.Float32x4.mul(row0, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
	  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

	  tmp1   = SIMD.Float32x4.mul(row0, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

	  // Compute matrix determinant
	  det   = SIMD.Float32x4.mul(row0, minor0);
	  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
	  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
	  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
	  det   = SIMD.Float32x4.sub(
	               SIMD.Float32x4.add(tmp1, tmp1),
	               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
	  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
	  if (!det) {
	      return null;
	  }

	  // Compute matrix inverse
	  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
	  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
	  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
	  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
	  return out;
	}

	/**
	 * Inverts a mat4 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

	/**
	 * Calculates the adjugate of a mat4 not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.scalar.adjoint = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
	    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
	    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
	    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
	    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
	    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
	    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
	    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
	    return out;
	};

	/**
	 * Calculates the adjugate of a mat4 using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.SIMD.adjoint = function(out, a) {
	  var a0, a1, a2, a3;
	  var row0, row1, row2, row3;
	  var tmp1;
	  var minor0, minor1, minor2, minor3;

	  var a0 = SIMD.Float32x4.load(a, 0);
	  var a1 = SIMD.Float32x4.load(a, 4);
	  var a2 = SIMD.Float32x4.load(a, 8);
	  var a3 = SIMD.Float32x4.load(a, 12);

	  // Transpose the source matrix.  Sort of.  Not a true transpose operation
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
	  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
	  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
	  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
	  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
	  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
	  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

	  tmp1   = SIMD.Float32x4.mul(row2, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.mul(row1, tmp1);
	  minor1 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
	  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
	  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

	  tmp1   = SIMD.Float32x4.mul(row1, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
	  minor3 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
	  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

	  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
	  minor2 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
	  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

	  tmp1   = SIMD.Float32x4.mul(row0, row1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

	  tmp1   = SIMD.Float32x4.mul(row0, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
	  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

	  tmp1   = SIMD.Float32x4.mul(row0, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

	  SIMD.Float32x4.store(out, 0,  minor0);
	  SIMD.Float32x4.store(out, 4,  minor1);
	  SIMD.Float32x4.store(out, 8,  minor2);
	  SIMD.Float32x4.store(out, 12, minor3);
	  return out;
	};

	/**
	 * Calculates the adjugate of a mat4 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat4.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;

	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	};

	/**
	 * Multiplies two mat4's explicitly using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand, must be a Float32Array
	 * @param {mat4} b the second operand, must be a Float32Array
	 * @returns {mat4} out
	 */
	mat4.SIMD.multiply = function (out, a, b) {
	    var a0 = SIMD.Float32x4.load(a, 0);
	    var a1 = SIMD.Float32x4.load(a, 4);
	    var a2 = SIMD.Float32x4.load(a, 8);
	    var a3 = SIMD.Float32x4.load(a, 12);

	    var b0 = SIMD.Float32x4.load(b, 0);
	    var out0 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
	                       SIMD.Float32x4.add(
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 0, out0);

	    var b1 = SIMD.Float32x4.load(b, 4);
	    var out1 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
	                       SIMD.Float32x4.add(
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 4, out1);

	    var b2 = SIMD.Float32x4.load(b, 8);
	    var out2 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
	                       SIMD.Float32x4.add(
	                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
	                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 8, out2);

	    var b3 = SIMD.Float32x4.load(b, 12);
	    var out3 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
	                        SIMD.Float32x4.add(
	                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
	                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 12, out3);

	    return out;
	};

	/**
	 * Multiplies two mat4's explicitly not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.scalar.multiply = function (out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	};

	/**
	 * Multiplies two mat4's using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

	/**
	 * Alias for {@link mat4.multiply}
	 * @function
	 */
	mat4.mul = mat4.multiply;

	/**
	 * Translate a mat4 by the given vector not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.scalar.translate = function (out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	};

	/**
	 * Translates a mat4 by the given vector using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.SIMD.translate = function (out, a, v) {
	    var a0 = SIMD.Float32x4.load(a, 0),
	        a1 = SIMD.Float32x4.load(a, 4),
	        a2 = SIMD.Float32x4.load(a, 8),
	        a3 = SIMD.Float32x4.load(a, 12),
	        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

	    if (a !== out) {
	        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
	        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
	        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
	    }

	    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
	    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
	    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

	    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
	    SIMD.Float32x4.store(out, 12, t0);

	    return out;
	};

	/**
	 * Translates a mat4 by the given vector using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

	/**
	 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	mat4.scalar.scale = function(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];

	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Scales the mat4 by the dimensions in the given vec3 using vectorization
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	mat4.SIMD.scale = function(out, a, v) {
	    var a0, a1, a2;
	    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

	    a0 = SIMD.Float32x4.load(a, 0);
	    SIMD.Float32x4.store(
	        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

	    a1 = SIMD.Float32x4.load(a, 4);
	    SIMD.Float32x4.store(
	        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

	    a2 = SIMD.Float32x4.load(a, 8);
	    SIMD.Float32x4.store(
	        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 */
	mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

	/**
	 * Rotates a mat4 by the given angle around the given axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	mat4.rotate = function (out, a, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;

	    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the X axis not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.scalar.rotateX = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the X axis using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.SIMD.rotateX = function (out, a, rad) {
	    var s = SIMD.Float32x4.splat(Math.sin(rad)),
	        c = SIMD.Float32x4.splat(Math.cos(rad));

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	      out[0]  = a[0];
	      out[1]  = a[1];
	      out[2]  = a[2];
	      out[3]  = a[3];
	      out[12] = a[12];
	      out[13] = a[13];
	      out[14] = a[14];
	      out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    var a_1 = SIMD.Float32x4.load(a, 4);
	    var a_2 = SIMD.Float32x4.load(a, 8);
	    SIMD.Float32x4.store(out, 4,
	                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
	    SIMD.Float32x4.store(out, 8,
	                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

	/**
	 * Rotates a matrix by the given angle around the Y axis not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.scalar.rotateY = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Y axis using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.SIMD.rotateY = function (out, a, rad) {
	    var s = SIMD.Float32x4.splat(Math.sin(rad)),
	        c = SIMD.Float32x4.splat(Math.cos(rad));

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    var a_0 = SIMD.Float32x4.load(a, 0);
	    var a_2 = SIMD.Float32x4.load(a, 8);
	    SIMD.Float32x4.store(out, 0,
	                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
	    SIMD.Float32x4.store(out, 8,
	                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

	/**
	 * Rotates a matrix by the given angle around the Z axis not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.scalar.rotateZ = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Z axis using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.SIMD.rotateZ = function (out, a, rad) {
	    var s = SIMD.Float32x4.splat(Math.sin(rad)),
	        c = SIMD.Float32x4.splat(Math.cos(rad));

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    var a_0 = SIMD.Float32x4.load(a, 0);
	    var a_1 = SIMD.Float32x4.load(a, 4);
	    SIMD.Float32x4.store(out, 0,
	                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
	    SIMD.Float32x4.store(out, 4,
	                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	mat4.fromTranslation = function(out, v) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.scale(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Scaling vector
	 * @returns {mat4} out
	 */
	mat4.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = v[1];
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = v[2];
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from a given angle around a given axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotate(dest, dest, rad, axis);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	mat4.fromRotation = function(out, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t;

	    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = x * x * t + c;
	    out[1] = y * x * t + z * s;
	    out[2] = z * x * t - y * s;
	    out[3] = 0;
	    out[4] = x * y * t - z * s;
	    out[5] = y * y * t + c;
	    out[6] = z * y * t + x * s;
	    out[7] = 0;
	    out[8] = x * z * t + y * s;
	    out[9] = y * z * t - x * s;
	    out[10] = z * z * t + c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from the given angle around the X axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateX(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.fromXRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);

	    // Perform axis-specific matrix multiplication
	    out[0]  = 1;
	    out[1]  = 0;
	    out[2]  = 0;
	    out[3]  = 0;
	    out[4] = 0;
	    out[5] = c;
	    out[6] = s;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = -s;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from the given angle around the Y axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateY(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.fromYRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);

	    // Perform axis-specific matrix multiplication
	    out[0]  = c;
	    out[1]  = 0;
	    out[2]  = -s;
	    out[3]  = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = s;
	    out[9] = 0;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from the given angle around the Z axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateZ(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.fromZRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);

	    // Perform axis-specific matrix multiplication
	    out[0]  = c;
	    out[1]  = s;
	    out[2]  = 0;
	    out[3]  = 0;
	    out[4] = -s;
	    out[5] = c;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslation = function (out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;

	    return out;
	};

	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @param {vec3} s Scaling vector
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslationScale = function (out, q, v, s) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2,
	        sx = s[0],
	        sy = s[1],
	        sz = s[2];

	    out[0] = (1 - (yy + zz)) * sx;
	    out[1] = (xy + wz) * sx;
	    out[2] = (xz - wy) * sx;
	    out[3] = 0;
	    out[4] = (xy - wz) * sy;
	    out[5] = (1 - (xx + zz)) * sy;
	    out[6] = (yz + wx) * sy;
	    out[7] = 0;
	    out[8] = (xz + wy) * sz;
	    out[9] = (yz - wx) * sz;
	    out[10] = (1 - (xx + yy)) * sz;
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;

	    return out;
	};

	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     mat4.translate(dest, origin);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *     mat4.translate(dest, negativeOrigin);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @param {vec3} s Scaling vector
	 * @param {vec3} o The origin vector around which to scale and rotate
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
	  // Quaternion math
	  var x = q[0], y = q[1], z = q[2], w = q[3],
	      x2 = x + x,
	      y2 = y + y,
	      z2 = z + z,

	      xx = x * x2,
	      xy = x * y2,
	      xz = x * z2,
	      yy = y * y2,
	      yz = y * z2,
	      zz = z * z2,
	      wx = w * x2,
	      wy = w * y2,
	      wz = w * z2,

	      sx = s[0],
	      sy = s[1],
	      sz = s[2],

	      ox = o[0],
	      oy = o[1],
	      oz = o[2];

	  out[0] = (1 - (yy + zz)) * sx;
	  out[1] = (xy + wz) * sx;
	  out[2] = (xz - wy) * sx;
	  out[3] = 0;
	  out[4] = (xy - wz) * sy;
	  out[5] = (1 - (xx + zz)) * sy;
	  out[6] = (yz + wx) * sy;
	  out[7] = 0;
	  out[8] = (xz + wy) * sz;
	  out[9] = (yz - wx) * sz;
	  out[10] = (1 - (xx + yy)) * sz;
	  out[11] = 0;
	  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
	  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
	  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
	  out[15] = 1;

	  return out;
	};

	mat4.fromQuat = function (out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;

	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;

	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;

	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;

	    return out;
	};

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.frustum = function (out, left, right, bottom, top, near, far) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	};

	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.perspective = function (out, fovy, aspect, near, far) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	};

	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
	    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
	        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
	        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
	        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
	        xScale = 2.0 / (leftTan + rightTan),
	        yScale = 2.0 / (upTan + downTan);

	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	}

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.ortho = function (out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	mat4.lookAt = function (out, eye, center, up) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];

	    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
	        Math.abs(eyey - centery) < glMatrix.EPSILON &&
	        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
	        return mat4.identity(out);
	    }

	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;

	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;

	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }

	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;

	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }

	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;

	    return out;
	};

	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {mat4} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat4.str = function (a) {
	    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
	                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
	                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
	                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat4
	 *
	 * @param {mat4} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat4.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
	};


	module.exports = mat4;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);
	var mat3 = __webpack_require__(4);
	var vec3 = __webpack_require__(7);
	var vec4 = __webpack_require__(8);

	/**
	 * @class Quaternion
	 * @name quat
	 */
	var quat = {};

	/**
	 * Creates a new identity quat
	 *
	 * @returns {quat} a new quaternion
	 */
	quat.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {quat} out the receiving quaternion.
	 * @param {vec3} a the initial vector
	 * @param {vec3} b the destination vector
	 * @returns {quat} out
	 */
	quat.rotationTo = (function() {
	    var tmpvec3 = vec3.create();
	    var xUnitVec3 = vec3.fromValues(1,0,0);
	    var yUnitVec3 = vec3.fromValues(0,1,0);

	    return function(out, a, b) {
	        var dot = vec3.dot(a, b);
	        if (dot < -0.999999) {
	            vec3.cross(tmpvec3, xUnitVec3, a);
	            if (vec3.length(tmpvec3) < 0.000001)
	                vec3.cross(tmpvec3, yUnitVec3, a);
	            vec3.normalize(tmpvec3, tmpvec3);
	            quat.setAxisAngle(out, tmpvec3, Math.PI);
	            return out;
	        } else if (dot > 0.999999) {
	            out[0] = 0;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            return out;
	        } else {
	            vec3.cross(tmpvec3, a, b);
	            out[0] = tmpvec3[0];
	            out[1] = tmpvec3[1];
	            out[2] = tmpvec3[2];
	            out[3] = 1 + dot;
	            return quat.normalize(out, out);
	        }
	    };
	})();

	/**
	 * Sets the specified quaternion with values corresponding to the given
	 * axes. Each axis is a vec3 and is expected to be unit length and
	 * perpendicular to all other specified axes.
	 *
	 * @param {vec3} view  the vector representing the viewing direction
	 * @param {vec3} right the vector representing the local "right" direction
	 * @param {vec3} up    the vector representing the local "up" direction
	 * @returns {quat} out
	 */
	quat.setAxes = (function() {
	    var matr = mat3.create();

	    return function(out, view, right, up) {
	        matr[0] = right[0];
	        matr[3] = right[1];
	        matr[6] = right[2];

	        matr[1] = up[0];
	        matr[4] = up[1];
	        matr[7] = up[2];

	        matr[2] = -view[0];
	        matr[5] = -view[1];
	        matr[8] = -view[2];

	        return quat.normalize(out, quat.fromMat3(out, matr));
	    };
	})();

	/**
	 * Creates a new quat initialized with values from an existing quaternion
	 *
	 * @param {quat} a quaternion to clone
	 * @returns {quat} a new quaternion
	 * @function
	 */
	quat.clone = vec4.clone;

	/**
	 * Creates a new quat initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} a new quaternion
	 * @function
	 */
	quat.fromValues = vec4.fromValues;

	/**
	 * Copy the values from one quat to another
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the source quaternion
	 * @returns {quat} out
	 * @function
	 */
	quat.copy = vec4.copy;

	/**
	 * Set the components of a quat to the given values
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} out
	 * @function
	 */
	quat.set = vec4.set;

	/**
	 * Set a quat to the identity quaternion
	 *
	 * @param {quat} out the receiving quaternion
	 * @returns {quat} out
	 */
	quat.identity = function(out) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {vec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {quat} out
	 **/
	quat.setAxisAngle = function(out, axis, rad) {
	    rad = rad * 0.5;
	    var s = Math.sin(rad);
	    out[0] = s * axis[0];
	    out[1] = s * axis[1];
	    out[2] = s * axis[2];
	    out[3] = Math.cos(rad);
	    return out;
	};

	/**
	 * Adds two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 * @function
	 */
	quat.add = vec4.add;

	/**
	 * Multiplies two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 */
	quat.multiply = function(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];

	    out[0] = ax * bw + aw * bx + ay * bz - az * by;
	    out[1] = ay * bw + aw * by + az * bx - ax * bz;
	    out[2] = az * bw + aw * bz + ax * by - ay * bx;
	    out[3] = aw * bw - ax * bx - ay * by - az * bz;
	    return out;
	};

	/**
	 * Alias for {@link quat.multiply}
	 * @function
	 */
	quat.mul = quat.multiply;

	/**
	 * Scales a quat by a scalar number
	 *
	 * @param {quat} out the receiving vector
	 * @param {quat} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {quat} out
	 * @function
	 */
	quat.scale = vec4.scale;

	/**
	 * Rotates a quaternion by the given angle about the X axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateX = function (out, a, rad) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw + aw * bx;
	    out[1] = ay * bw + az * bx;
	    out[2] = az * bw - ay * bx;
	    out[3] = aw * bw - ax * bx;
	    return out;
	};

	/**
	 * Rotates a quaternion by the given angle about the Y axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateY = function (out, a, rad) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        by = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw - az * by;
	    out[1] = ay * bw + aw * by;
	    out[2] = az * bw + ax * by;
	    out[3] = aw * bw - ay * by;
	    return out;
	};

	/**
	 * Rotates a quaternion by the given angle about the Z axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateZ = function (out, a, rad) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bz = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw + ay * bz;
	    out[1] = ay * bw - ax * bz;
	    out[2] = az * bw + aw * bz;
	    out[3] = aw * bw - az * bz;
	    return out;
	};

	/**
	 * Calculates the quat from the Eular alpha, beta and gamma angle
	 * with Y-X-Z order
	 * @param {quat} out the receiving quaternion
	 * @param {number} a rad angle of alpha
	 * @param {number} a rad angle of beta
	 * @param {number} a rad angle of gamma
	 * @returns {quat} out
	 */
	quat.fromYXZ = function (out, alpha, beta, gamma) {
		var c1 = Math.cos( beta / 2 );
		var c2 = Math.cos( alpha / 2 );
		var c3 = Math.cos( gamma / 2 );
		var s1 = Math.sin( beta / 2 );
		var s2 = Math.sin( alpha / 2 );
		var s3 = Math.sin( gamma / 2 );
        
		out[0] = s1 * c2 * c3 + c1 * s2 * s3;
		out[1] = c1 * s2 * c3 - s1 * c2 * s3;
		out[2] = c1 * c2 * s3 - s1 * s2 * c3;
		out[3] = c1 * c2 * c3 + s1 * s2 * s3;
		return out;
	};
    
	/**
	 * Calculates the W component of a quat from the X, Y, and Z components.
	 * Assumes that quaternion is 1 unit in length.
	 * Any existing W component will be ignored.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate W component of
	 * @returns {quat} out
	 */
	quat.calculateW = function (out, a) {
	    var x = a[0], y = a[1], z = a[2];

	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
	    return out;
	};

	/**
	 * Calculates the dot product of two quat's
	 *
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 */
	quat.dot = vec4.dot;

	/**
	 * Performs a linear interpolation between two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 * @function
	 */
	quat.lerp = vec4.lerp;

	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 */
	quat.slerp = function (out, a, b, t) {
	    // benchmarks:
	    //    http://jsperf.com/quaternion-slerp-implementations

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];

	    var        omega, cosom, sinom, scale0, scale1;

	    // calc cosine
	    cosom = ax * bx + ay * by + az * bz + aw * bw;
	    // adjust signs (if necessary)
	    if ( cosom < 0.0 ) {
	        cosom = -cosom;
	        bx = - bx;
	        by = - by;
	        bz = - bz;
	        bw = - bw;
	    }
	    // calculate coefficients
	    if ( (1.0 - cosom) > 0.000001 ) {
	        // standard case (slerp)
	        omega  = Math.acos(cosom);
	        sinom  = Math.sin(omega);
	        scale0 = Math.sin((1.0 - t) * omega) / sinom;
	        scale1 = Math.sin(t * omega) / sinom;
	    } else {        
	        // "from" and "to" quaternions are very close 
	        //  ... so we can do a linear interpolation
	        scale0 = 1.0 - t;
	        scale1 = t;
	    }
	    // calculate final values
	    out[0] = scale0 * ax + scale1 * bx;
	    out[1] = scale0 * ay + scale1 * by;
	    out[2] = scale0 * az + scale1 * bz;
	    out[3] = scale0 * aw + scale1 * bw;
	    
	    return out;
	};

	/**
	 * Performs a spherical linear interpolation with two control points
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {quat} c the third operand
	 * @param {quat} d the fourth operand
	 * @param {Number} t interpolation amount
	 * @returns {quat} out
	 */
	quat.sqlerp = (function () {
	  var temp1 = quat.create();
	  var temp2 = quat.create();
	  
	  return function (out, a, b, c, d, t) {
	    quat.slerp(temp1, a, d, t);
	    quat.slerp(temp2, b, c, t);
	    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
	    
	    return out;
	  };
	}());

	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate inverse of
	 * @returns {quat} out
	 */
	quat.invert = function(out, a) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
	        invDot = dot ? 1.0/dot : 0;
	    
	    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

	    out[0] = -a0*invDot;
	    out[1] = -a1*invDot;
	    out[2] = -a2*invDot;
	    out[3] = a3*invDot;
	    return out;
	};

	/**
	 * Calculates the conjugate of a quat
	 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate conjugate of
	 * @returns {quat} out
	 */
	quat.conjugate = function (out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Calculates the length of a quat
	 *
	 * @param {quat} a vector to calculate length of
	 * @returns {Number} length of a
	 * @function
	 */
	quat.length = vec4.length;

	/**
	 * Alias for {@link quat.length}
	 * @function
	 */
	quat.len = quat.length;

	/**
	 * Calculates the squared length of a quat
	 *
	 * @param {quat} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 */
	quat.squaredLength = vec4.squaredLength;

	/**
	 * Alias for {@link quat.squaredLength}
	 * @function
	 */
	quat.sqrLen = quat.squaredLength;

	/**
	 * Normalize a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quaternion to normalize
	 * @returns {quat} out
	 * @function
	 */
	quat.normalize = vec4.normalize;

	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {mat3} m rotation matrix
	 * @returns {quat} out
	 * @function
	 */
	quat.fromMat3 = function(out, m) {
	    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	    // article "Quaternion Calculus and Fast Animation".
	    var fTrace = m[0] + m[4] + m[8];
	    var fRoot;

	    if ( fTrace > 0.0 ) {
	        // |w| > 1/2, may as well choose w > 1/2
	        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
	        out[3] = 0.5 * fRoot;
	        fRoot = 0.5/fRoot;  // 1/(4w)
	        out[0] = (m[5]-m[7])*fRoot;
	        out[1] = (m[6]-m[2])*fRoot;
	        out[2] = (m[1]-m[3])*fRoot;
	    } else {
	        // |w| <= 1/2
	        var i = 0;
	        if ( m[4] > m[0] )
	          i = 1;
	        if ( m[8] > m[i*3+i] )
	          i = 2;
	        var j = (i+1)%3;
	        var k = (i+2)%3;
	        
	        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
	        out[i] = 0.5 * fRoot;
	        fRoot = 0.5 / fRoot;
	        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
	        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
	        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
	    }
	    
	    return out;
	};

	/**
	 * Returns a string representation of a quatenion
	 *
	 * @param {quat} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	quat.str = function (a) {
	    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	module.exports = quat;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 3 Dimensional Vector
	 * @name vec3
	 */
	var vec3 = {};

	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {vec3} a new 3D vector
	 */
	vec3.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(3);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    return out;
	};

	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {vec3} a vector to clone
	 * @returns {vec3} a new 3D vector
	 */
	vec3.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(3);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};

	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */
	vec3.fromValues = function(x, y, z) {
	    var out = new glMatrix.ARRAY_TYPE(3);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};

	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the source vector
	 * @returns {vec3} out
	 */
	vec3.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};

	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} out
	 */
	vec3.set = function(out, x, y, z) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};

	/**
	 * Adds two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.subtract}
	 * @function
	 */
	vec3.sub = vec3.subtract;

	/**
	 * Multiplies two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.multiply}
	 * @function
	 */
	vec3.mul = vec3.multiply;

	/**
	 * Divides two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.divide}
	 * @function
	 */
	vec3.div = vec3.divide;

	/**
	 * Returns the minimum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    return out;
	};

	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec3} out
	 */
	vec3.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    return out;
	};

	/**
	 * Adds two vec3's after scaling the second operand by a scalar value
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec3} out
	 */
	vec3.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec3.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Alias for {@link vec3.distance}
	 * @function
	 */
	vec3.dist = vec3.distance;

	/**
	 * Calculates the squared euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec3.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return x*x + y*y + z*z;
	};

	/**
	 * Alias for {@link vec3.squaredDistance}
	 * @function
	 */
	vec3.sqrDist = vec3.squaredDistance;

	/**
	 * Calculates the length of a vec3
	 *
	 * @param {vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec3.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Alias for {@link vec3.length}
	 * @function
	 */
	vec3.len = vec3.length;

	/**
	 * Calculates the squared length of a vec3
	 *
	 * @param {vec3} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec3.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return x*x + y*y + z*z;
	};

	/**
	 * Alias for {@link vec3.squaredLength}
	 * @function
	 */
	vec3.sqrLen = vec3.squaredLength;

	/**
	 * Negates the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to negate
	 * @returns {vec3} out
	 */
	vec3.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    return out;
	};

	/**
	 * Returns the inverse of the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to invert
	 * @returns {vec3} out
	 */
	vec3.inverse = function(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  return out;
	};

	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to normalize
	 * @returns {vec3} out
	 */
	vec3.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    var len = x*x + y*y + z*z;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	        out[2] = a[2] * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec3.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	};

	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.cross = function(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2],
	        bx = b[0], by = b[1], bz = b[2];

	    out[0] = ay * bz - az * by;
	    out[1] = az * bx - ax * bz;
	    out[2] = ax * by - ay * bx;
	    return out;
	};

	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    return out;
	};

	/**
	 * Performs a hermite interpolation with two control points
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {vec3} c the third operand
	 * @param {vec3} d the fourth operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.hermite = function (out, a, b, c, d, t) {
	  var factorTimes2 = t * t,
	      factor1 = factorTimes2 * (2 * t - 3) + 1,
	      factor2 = factorTimes2 * (t - 2) + t,
	      factor3 = factorTimes2 * (t - 1),
	      factor4 = factorTimes2 * (3 - 2 * t);
	  
	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
	  
	  return out;
	};

	/**
	 * Performs a bezier interpolation with two control points
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {vec3} c the third operand
	 * @param {vec3} d the fourth operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.bezier = function (out, a, b, c, d, t) {
	  var inverseFactor = 1 - t,
	      inverseFactorTimesTwo = inverseFactor * inverseFactor,
	      factorTimes2 = t * t,
	      factor1 = inverseFactorTimesTwo * inverseFactor,
	      factor2 = 3 * t * inverseFactorTimesTwo,
	      factor3 = 3 * factorTimes2 * inverseFactor,
	      factor4 = factorTimes2 * t;
	  
	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
	  
	  return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec3} out
	 */
	vec3.random = function (out, scale) {
	    scale = scale || 1.0;

	    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
	    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
	    var zScale = Math.sqrt(1.0-z*z) * scale;

	    out[0] = Math.cos(r) * zScale;
	    out[1] = Math.sin(r) * zScale;
	    out[2] = z * scale;
	    return out;
	};

	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec3} out
	 */
	vec3.transformMat4 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2],
	        w = m[3] * x + m[7] * y + m[11] * z + m[15];
	    w = w || 1.0;
	    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
	    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
	    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
	    return out;
	};

	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m the 3x3 matrix to transform with
	 * @returns {vec3} out
	 */
	vec3.transformMat3 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2];
	    out[0] = x * m[0] + y * m[3] + z * m[6];
	    out[1] = x * m[1] + y * m[4] + z * m[7];
	    out[2] = x * m[2] + y * m[5] + z * m[8];
	    return out;
	};

	/**
	 * Transforms the vec3 with a quat
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec3} out
	 */
	vec3.transformQuat = function(out, a, q) {
	    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return out;
	};

	/**
	 * Rotate a 3D vector around the x-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	vec3.rotateX = function(out, a, b, c){
	   var p = [], r=[];
		  //Translate point to the origin
		  p[0] = a[0] - b[0];
		  p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];

		  //perform rotation
		  r[0] = p[0];
		  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
		  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

		  //translate to correct position
		  out[0] = r[0] + b[0];
		  out[1] = r[1] + b[1];
		  out[2] = r[2] + b[2];

	  	return out;
	};

	/**
	 * Rotate a 3D vector around the y-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	vec3.rotateY = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
	  	r[1] = p[1];
	  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};

	/**
	 * Rotate a 3D vector around the z-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	vec3.rotateZ = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
	  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
	  	r[2] = p[2];
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};

	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec3.forEach = (function() {
	    var vec = vec3.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 3;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Get the angle between two 3D vectors
	 * @param {vec3} a The first operand
	 * @param {vec3} b The second operand
	 * @returns {Number} The angle in radians
	 */
	vec3.angle = function(a, b) {
	   
	    var tempA = vec3.fromValues(a[0], a[1], a[2]);
	    var tempB = vec3.fromValues(b[0], b[1], b[2]);
	 
	    vec3.normalize(tempA, tempA);
	    vec3.normalize(tempB, tempB);
	 
	    var cosine = vec3.dot(tempA, tempB);

	    if(cosine > 1.0){
	        return 0;
	    } else {
	        return Math.acos(cosine);
	    }     
	};

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec3} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec3.str = function (a) {
	    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
	};

	module.exports = vec3;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 4 Dimensional Vector
	 * @name vec4
	 */
	var vec4 = {};

	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {vec4} a new 4D vector
	 */
	vec4.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    return out;
	};

	/**
	 * Creates a new vec4 initialized with values from an existing vector
	 *
	 * @param {vec4} a vector to clone
	 * @returns {vec4} a new 4D vector
	 */
	vec4.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} a new 4D vector
	 */
	vec4.fromValues = function(x, y, z, w) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};

	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the source vector
	 * @returns {vec4} out
	 */
	vec4.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} out
	 */
	vec4.set = function(out, x, y, z, w) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};

	/**
	 * Adds two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.subtract}
	 * @function
	 */
	vec4.sub = vec4.subtract;

	/**
	 * Multiplies two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    out[3] = a[3] * b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.multiply}
	 * @function
	 */
	vec4.mul = vec4.multiply;

	/**
	 * Divides two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    out[3] = a[3] / b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.divide}
	 * @function
	 */
	vec4.div = vec4.divide;

	/**
	 * Returns the minimum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    out[3] = Math.min(a[3], b[3]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    out[3] = Math.max(a[3], b[3]);
	    return out;
	};

	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec4} out
	 */
	vec4.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    return out;
	};

	/**
	 * Adds two vec4's after scaling the second operand by a scalar value
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec4} out
	 */
	vec4.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec4.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};

	/**
	 * Alias for {@link vec4.distance}
	 * @function
	 */
	vec4.dist = vec4.distance;

	/**
	 * Calculates the squared euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec4.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return x*x + y*y + z*z + w*w;
	};

	/**
	 * Alias for {@link vec4.squaredDistance}
	 * @function
	 */
	vec4.sqrDist = vec4.squaredDistance;

	/**
	 * Calculates the length of a vec4
	 *
	 * @param {vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec4.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};

	/**
	 * Alias for {@link vec4.length}
	 * @function
	 */
	vec4.len = vec4.length;

	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec4.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return x*x + y*y + z*z + w*w;
	};

	/**
	 * Alias for {@link vec4.squaredLength}
	 * @function
	 */
	vec4.sqrLen = vec4.squaredLength;

	/**
	 * Negates the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to negate
	 * @returns {vec4} out
	 */
	vec4.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = -a[3];
	    return out;
	};

	/**
	 * Returns the inverse of the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to invert
	 * @returns {vec4} out
	 */
	vec4.inverse = function(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  out[3] = 1.0 / a[3];
	  return out;
	};

	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to normalize
	 * @returns {vec4} out
	 */
	vec4.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    var len = x*x + y*y + z*z + w*w;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	        out[0] = x * len;
	        out[1] = y * len;
	        out[2] = z * len;
	        out[3] = w * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec4.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	};

	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec4} out
	 */
	vec4.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2],
	        aw = a[3];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    out[3] = aw + t * (b[3] - aw);
	    return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec4} out
	 */
	vec4.random = function (out, scale) {
	    scale = scale || 1.0;

	    //TODO: This is a pretty awful way of doing this. Find something better.
	    out[0] = glMatrix.RANDOM();
	    out[1] = glMatrix.RANDOM();
	    out[2] = glMatrix.RANDOM();
	    out[3] = glMatrix.RANDOM();
	    vec4.normalize(out, out);
	    vec4.scale(out, out, scale);
	    return out;
	};

	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec4} out
	 */
	vec4.transformMat4 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2], w = a[3];
	    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	    return out;
	};

	/**
	 * Transforms the vec4 with a quat
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec4} out
	 */
	vec4.transformQuat = function(out, a, q) {
	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Perform some operation over an array of vec4s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec4.forEach = (function() {
	    var vec = vec4.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 4;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec4} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec4.str = function (a) {
	    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	module.exports = vec4;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var glMatrix = __webpack_require__(1);

	/**
	 * @class 2 Dimensional Vector
	 * @name vec2
	 */
	var vec2 = {};

	/**
	 * Creates a new, empty vec2
	 *
	 * @returns {vec2} a new 2D vector
	 */
	vec2.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(2);
	    out[0] = 0;
	    out[1] = 0;
	    return out;
	};

	/**
	 * Creates a new vec2 initialized with values from an existing vector
	 *
	 * @param {vec2} a vector to clone
	 * @returns {vec2} a new 2D vector
	 */
	vec2.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(2);
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};

	/**
	 * Creates a new vec2 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} a new 2D vector
	 */
	vec2.fromValues = function(x, y) {
	    var out = new glMatrix.ARRAY_TYPE(2);
	    out[0] = x;
	    out[1] = y;
	    return out;
	};

	/**
	 * Copy the values from one vec2 to another
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the source vector
	 * @returns {vec2} out
	 */
	vec2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};

	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	vec2.set = function(out, x, y) {
	    out[0] = x;
	    out[1] = y;
	    return out;
	};

	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    return out;
	};

	/**
	 * Alias for {@link vec2.subtract}
	 * @function
	 */
	vec2.sub = vec2.subtract;

	/**
	 * Multiplies two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    return out;
	};

	/**
	 * Alias for {@link vec2.multiply}
	 * @function
	 */
	vec2.mul = vec2.multiply;

	/**
	 * Divides two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    return out;
	};

	/**
	 * Alias for {@link vec2.divide}
	 * @function
	 */
	vec2.div = vec2.divide;

	/**
	 * Returns the minimum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    return out;
	};

	/**
	 * Scales a vec2 by a scalar number
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec2} out
	 */
	vec2.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    return out;
	};

	/**
	 * Adds two vec2's after scaling the second operand by a scalar value
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec2} out
	 */
	vec2.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec2.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return Math.sqrt(x*x + y*y);
	};

	/**
	 * Alias for {@link vec2.distance}
	 * @function
	 */
	vec2.dist = vec2.distance;

	/**
	 * Calculates the squared euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec2.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return x*x + y*y;
	};

	/**
	 * Alias for {@link vec2.squaredDistance}
	 * @function
	 */
	vec2.sqrDist = vec2.squaredDistance;

	/**
	 * Calculates the length of a vec2
	 *
	 * @param {vec2} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec2.length = function (a) {
	    var x = a[0],
	        y = a[1];
	    return Math.sqrt(x*x + y*y);
	};

	/**
	 * Alias for {@link vec2.length}
	 * @function
	 */
	vec2.len = vec2.length;

	/**
	 * Calculates the squared length of a vec2
	 *
	 * @param {vec2} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec2.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1];
	    return x*x + y*y;
	};

	/**
	 * Alias for {@link vec2.squaredLength}
	 * @function
	 */
	vec2.sqrLen = vec2.squaredLength;

	/**
	 * Negates the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to negate
	 * @returns {vec2} out
	 */
	vec2.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    return out;
	};

	/**
	 * Returns the inverse of the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to invert
	 * @returns {vec2} out
	 */
	vec2.inverse = function(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  return out;
	};

	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	vec2.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1];
	    var len = x*x + y*y;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	    }
	    return out;
	};

    vec2.rotate = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  
	  	//perform rotation
	  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
	  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  
	  	return out;
	};
    
	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec2.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	};

	/**
	 * Computes the cross product of two vec2's
	 * Note that the cross product must by definition produce a 3D vector
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec3} out
	 */
	vec2.cross = function(out, a, b) {
	    var z = a[0] * b[1] - a[1] * b[0];
	    out[0] = out[1] = 0;
	    out[2] = z;
	    return out;
	};

	/**
	 * Performs a linear interpolation between two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec2} out
	 */
	vec2.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec2} out
	 */
	vec2.random = function (out, scale) {
	    scale = scale || 1.0;
	    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
	    out[0] = Math.cos(r) * scale;
	    out[1] = Math.sin(r) * scale;
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat2 = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[2] * y;
	    out[1] = m[1] * x + m[3] * y;
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat2d
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2d} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat2d = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[2] * y + m[4];
	    out[1] = m[1] * x + m[3] * y + m[5];
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat3
	 * 3rd vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat3} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat3 = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[3] * y + m[6];
	    out[1] = m[1] * x + m[4] * y + m[7];
	    return out;
	};

	/**
	 * Transforms the vec2 with a mat4
	 * 3rd vector component is implicitly '0'
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat4 = function(out, a, m) {
	    var x = a[0], 
	        y = a[1];
	    out[0] = m[0] * x + m[4] * y + m[12];
	    out[1] = m[1] * x + m[5] * y + m[13];
	    return out;
	};

	/**
	 * Perform some operation over an array of vec2s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec2.forEach = (function() {
	    var vec = vec2.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 2;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec2} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec2.str = function (a) {
	    return 'vec2(' + a[0] + ', ' + a[1] + ')';
	};

	module.exports = vec2;


/***/ }
/******/ ])
});
;
/*
 * Copyright 2010, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * @fileoverview This file contains functions every webgl program will need
 * a version of one way or another.
 *
 * Instead of setting up a context manually it is recommended to
 * use. This will check for success or failure. On failure it
 * will attempt to present an approriate message to the user.
 *
 *       gl = WebGLUtils.setupWebGL(canvas);
 *
 * For animated WebGL apps use of setTimeout or setInterval are
 * discouraged. It is recommended you structure your rendering
 * loop like this.
 *
 *       function render() {
 *         window.requestAnimFrame(render, canvas);
 *
 *         // do rendering
 *         ...
 *       }
 *       render();
 *
 * This will call your rendering function up to the refresh rate
 * of your display but will stop rendering if your app is not
 * visible.
 */

WebGLUtils = function() {

/**
 * Creates the HTLM for a failure message
 * @param {string} canvasContainerId id of container of th
 *        canvas.
 * @return {string} The html.
 */
var makeFailHTML = function(msg) {
  return '' +
    '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
    '<td align="center">' +
    '<div style="display: table-cell; vertical-align: middle;">' +
    '<div style="">' + msg + '</div>' +
    '</div>' +
    '</td></tr></table>';
};

/**
 * Mesasge for getting a webgl browser
 * @type {string}
 */
var GET_A_WEBGL_BROWSER = '' +
  'This page requires a browser that supports WebGL.<br/>' +
  '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

/**
 * Mesasge for need better hardware
 * @type {string}
 */
var OTHER_PROBLEM = '' +
  "It doesn't appear your computer can support WebGL.<br/>" +
  '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

/**
 * Creates a webgl context. If creation fails it will
 * change the contents of the container of the <canvas>
 * tag to an error message with the correct links for WebGL.
 * @param {Element} canvas. The canvas element to create a
 *     context from.
 * @param {WebGLContextCreationAttirbutes} opt_attribs Any
 *     creation attributes you want to pass in.
 * @return {WebGLRenderingContext} The created context.
 */
var setupWebGL = function(canvas, opt_attribs) {
  function showLink(str) {
    var container = canvas.parentNode;
    if (container) {
      container.innerHTML = makeFailHTML(str);
    }
  };

  if (!window.WebGLRenderingContext) {
    showLink(GET_A_WEBGL_BROWSER);
    return null;
  }

  var context = create3DContext(canvas, opt_attribs);
  //if (!context) {
  //  showLink(OTHER_PROBLEM);
  //}
  return context;
};

/**
 * Creates a webgl context.
 * @param {!Canvas} canvas The canvas tag to get context
 *     from. If one is not passed in one will be created.
 * @return {!WebGLContext} The created context.
 */
var create3DContext = function (canvas, opt_attribs) {
    var context = null;
    if (opt_attribs.webgl2) {
        context = canvas.getContext("webgl2", opt_attribs);
        console.log("Try to use webgl2.0.");
        var isWebGL2 = !!context;
        if (isWebGL2) {
            return context;
        } else {
            console.warn("webgl2.0 is not supported on this browser!");
        }
    }
    
    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
    for (var ii = 0; ii < names.length; ++ii) {
        try {
            context = canvas.getContext(names[ii], opt_attribs);
        } catch(e) {}
        if (context) {
            break;
        }
    }
    return context;
}

return {
  create3DContext: create3DContext,
  setupWebGL: setupWebGL
};
}();

/**
 * Provides requestAnimationFrame in a cross browser way.
 */
window.requestAnimFrame = (function() {
  return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
           return window.setTimeout(callback, 1000/60);
         };
})();

/**
 * Provides cancelAnimationFrame in a cross browser way.
 */
window.cancelAnimFrame = (function() {
  return window.cancelAnimationFrame ||
         window.webkitCancelAnimationFrame ||
         window.mozCancelAnimationFrame ||
         window.oCancelAnimationFrame ||
         window.msCancelAnimationFrame ||
         window.clearTimeout;
})();



/*!
 * UAParser.js v0.7.18
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright  2012-2016 Faisal Salman <fyzlman@gmail.com>
 * Dual licensed under GPLv2 or MIT
 */

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.18',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major', // deprecated
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded';


    ///////////
    // Helper
    //////////


    var util = {
        extend : function (regexes, extensions) {
            var margedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    margedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    margedRegexes[i] = regexes[i];
                }
            }
            return margedRegexes;
        },
        has : function (str1, str2) {
          if (typeof str1 === "string") {
            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
          } else {
            return false;
          }
        },
        lowerize : function (str) {
            return str.toLowerCase();
        },
        major : function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined;
        },
        trim : function (str) {
          return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function (ua, arrays) {

            //var result = {},
            var i = 0, j, k, p, q, matches, match;//, args = arguments;

            /*// construct object barebones
            for (p = 0; p < args[1].length; p++) {
                q = args[1][p];
                result[typeof q === OBJ_TYPE ? q[0] : q] = undefined;
            }*/

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
            // console.log(this);
            //return this;
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            oldsafari : {
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            }
        },

        device : {
            amazon : {
                model : {
                    'Fire Phone' : ['SD', 'KF']
                }
            },
            sprint : {
                model : {
                    'Evo Shift 4G' : '7373KT'
                },
                vendor : {
                    'HTC'       : 'APA',
                    'Sprint'    : 'Sprint'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    '10'        : ['NT 6.4', 'NT 10.0'],
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            // Presto based
            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
            ], [NAME, VERSION], [

            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
            ], [[NAME, 'Opera Mini'], VERSION], [

            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
            ], [[NAME, 'Opera'], VERSION], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

            // Trident based
            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
                                                                                // Avant/IEMobile/SlimBrowser/Baidu
            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

            // Webkit/KHTML based
            /(rekonq)\/([\w\.]*)/i,                                             // Rekonq
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i
                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser
            ], [NAME, VERSION], [

            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
            ], [[NAME, 'IE'], VERSION], [

            /(edge|edgios|edgea)\/((\d+)?[\w\.]+)/i                             // Microsoft Edge
            ], [[NAME, 'Edge'], VERSION], [

            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
            ], [[NAME, 'Yandex'], VERSION], [

            /(puffin)\/([\w\.]+)/i                                              // Puffin
            ], [[NAME, 'Puffin'], VERSION], [

            /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i
                                                                                // UCBrowser
            ], [[NAME, 'UCBrowser'], VERSION], [

            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [

            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
            ], [[NAME, 'WeChat'], VERSION], [

            /(qqbrowserlite)\/([\w\.]+)/i                                       // QQBrowserLite
            ], [NAME, VERSION], [

            /(QQ)\/([\d\.]+)/i                                                  // QQ, aka ShouQ
            ], [NAME, VERSION], [

            /m?(qqbrowser)[\/\s]?([\w\.]+)/i                                    // QQBrowser
            ], [NAME, VERSION], [

            /(BIDUBrowser)[\/\s]?([\w\.]+)/i                                    // Baidu Browser
            ], [NAME, VERSION], [

            /(2345Explorer)[\/\s]?([\w\.]+)/i                                   // 2345 Browser
            ], [NAME, VERSION], [

            /(MetaSr)[\/\s]?([\w\.]+)/i                                         // SouGouBrowser
            ], [NAME], [

            /(LBBROWSER)/i                                      // LieBao Browser
            ], [NAME], [

            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
            ], [VERSION, [NAME, 'MIUI Browser']], [

            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android
            ], [VERSION, [NAME, 'Facebook']], [

            /headlesschrome(?:\/([\w\.]+)|\s)/i                                 // Chrome Headless
            ], [VERSION, [NAME, 'Chrome Headless']], [

            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

            /((?:oculus|samsung)browser)\/([\w\.]+)/i
            ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser

            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
            ], [VERSION, [NAME, 'Android Browser']], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
            ], [[NAME, 'Dolphin'], VERSION], [

            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
            ], [[NAME, 'Chrome'], VERSION], [

            /(coast)\/([\w\.]+)/i                                               // Opera Coast
            ], [[NAME, 'Opera Coast'], VERSION], [

            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, 'Firefox']], [

            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [

            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
            ], [VERSION, NAME], [

            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
            ], [[NAME, 'GSA'], VERSION], [

            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,

                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
            /(links)\s\(([\w\.]+)/i,                                            // Links
            /(gobrowser)\/?([\w\.]*)/i,                                         // GoBrowser
            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
            ], [NAME, VERSION]

            /* /////////////////////
            // Media players BEGIN
            ////////////////////////

            , [

            /(apple(?:coremedia|))\/((\d+)[\w\._]+)/i,                          // Generic Apple CoreMedia
            /(coremedia) v((\d+)[\w\._]+)/i
            ], [NAME, VERSION], [

            /(aqualung|lyssna|bsplayer)\/((\d+)?[\w\.-]+)/i                     // Aqualung/Lyssna/BSPlayer
            ], [NAME, VERSION], [

            /(ares|ossproxy)\s((\d+)[\w\.-]+)/i                                 // Ares/OSSProxy
            ], [NAME, VERSION], [

            /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\/((\d+)[\w\.-]+)/i,
                                                                                // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC
                                                                                // NSPlayer/PSP-InternetRadioPlayer/Videos
            /(clementine|music player daemon)\s((\d+)[\w\.-]+)/i,               // Clementine/MPD
            /(lg player|nexplayer)\s((\d+)[\d\.]+)/i,
            /player\/(nexplayer|lg player)\s((\d+)[\w\.-]+)/i                   // NexPlayer/LG Player
            ], [NAME, VERSION], [
            /(nexplayer)\s((\d+)[\w\.-]+)/i                                     // Nexplayer
            ], [NAME, VERSION], [

            /(flrp)\/((\d+)[\w\.-]+)/i                                          // Flip Player
            ], [[NAME, 'Flip Player'], VERSION], [

            /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i
                                                                                // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit
            ], [NAME], [

            /(gstreamer) souphttpsrc (?:\([^\)]+\)){0,1} libsoup\/((\d+)[\w\.-]+)/i
                                                                                // Gstreamer
            ], [NAME, VERSION], [

            /(htc streaming player)\s[\w_]+\s\/\s((\d+)[\d\.]+)/i,              // HTC Streaming Player
            /(java|python-urllib|python-requests|wget|libcurl)\/((\d+)[\w\.-_]+)/i,
                                                                                // Java/urllib/requests/wget/cURL
            /(lavf)((\d+)[\d\.]+)/i                                             // Lavf (FFMPEG)
            ], [NAME, VERSION], [

            /(htc_one_s)\/((\d+)[\d\.]+)/i                                      // HTC One S
            ], [[NAME, /_/g, ' '], VERSION], [

            /(mplayer)(?:\s|\/)(?:(?:sherpya-){0,1}svn)(?:-|\s)(r\d+(?:-\d+[\w\.-]+){0,1})/i
                                                                                // MPlayer SVN
            ], [NAME, VERSION], [

            /(mplayer)(?:\s|\/|[unkow-]+)((\d+)[\w\.-]+)/i                      // MPlayer
            ], [NAME, VERSION], [

            /(mplayer)/i,                                                       // MPlayer (no other info)
            /(yourmuze)/i,                                                      // YourMuze
            /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime
            ], [NAME], [

            /(nero (?:home|scout))\/((\d+)[\w\.-]+)/i                           // Nero Home/Nero Scout
            ], [NAME, VERSION], [

            /(nokia\d+)\/((\d+)[\w\.-]+)/i                                      // Nokia
            ], [NAME, VERSION], [

            /\s(songbird)\/((\d+)[\w\.-]+)/i                                    // Songbird/Philips-Songbird
            ], [NAME, VERSION], [

            /(winamp)3 version ((\d+)[\w\.-]+)/i,                               // Winamp
            /(winamp)\s((\d+)[\w\.-]+)/i,
            /(winamp)mpeg\/((\d+)[\w\.-]+)/i
            ], [NAME, VERSION], [

            /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)
                                                                                // inlight radio
            ], [NAME], [

            /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\/((\d+)[\w\.-]+)/i
                                                                                // QuickTime/RealMedia/RadioApp/RadioClientApplication/
                                                                                // SoundTap/Totem/Stagefright/Streamium
            ], [NAME, VERSION], [

            /(smp)((\d+)[\d\.]+)/i                                              // SMP
            ], [NAME, VERSION], [

            /(vlc) media player - version ((\d+)[\w\.]+)/i,                     // VLC Videolan
            /(vlc)\/((\d+)[\w\.-]+)/i,
            /(xbmc|gvfs|xine|xmms|irapp)\/((\d+)[\w\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp
            /(foobar2000)\/((\d+)[\d\.]+)/i,                                    // Foobar2000
            /(itunes)\/((\d+)[\d\.]+)/i                                         // iTunes
            ], [NAME, VERSION], [

            /(wmplayer)\/((\d+)[\w\.-]+)/i,                                     // Windows Media Player
            /(windows-media-player)\/((\d+)[\w\.-]+)/i
            ], [[NAME, /-/g, ' '], VERSION], [

            /windows\/((\d+)[\w\.-]+) upnp\/[\d\.]+ dlnadoc\/[\d\.]+ (home media server)/i
                                                                                // Windows Media Server
            ], [VERSION, [NAME, 'Windows']], [

            /(com\.riseupradioalarm)\/((\d+)[\d\.]*)/i                          // RiseUP Radio Alarm
            ], [NAME, VERSION], [

            /(rad.io)\s((\d+)[\d\.]+)/i,                                        // Rad.io
            /(radio.(?:de|at|fr))\s((\d+)[\d\.]+)/i
            ], [[NAME, 'rad.io'], VERSION]

            //////////////////////
            // Media players END
            ////////////////////*/

        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32
            ], [[ARCHITECTURE, 'ia32']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, util.lowerize]]
        ],

        device : [[

            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [

            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            /(apple\s{0,1}tv)/i                                                 // Apple TV
            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

            /(archos)\s(gamepad2?)/i,                                           // Archos
            /(hp).+(touchpad)/i,                                                // HP TouchPad
            /(hp).+(tablet)/i,                                                  // HP Tablet
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(kf[A-z]+)\sbuild\/.+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
            /(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i                         // Fire Phone
            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [

            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i                                                    // Asus
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
                                                                                // Asus Tablets
            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i
            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
            /(sony)?(?:sgp.+)\sbuild\//i
            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
            /android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /\s(ouya)\s/i,                                                      // Ouya
            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

            /android.+;\s(shield)\sbuild/i                                      // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

            /(playstation\s[34portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

            /(sprint\s(\w+))/i                                                  // Sprint Phones
            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

            /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
            /(zte)-(\w*)/i,                                                     // ZTE
            /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                // Alcatel/GeeksPhone/Lenovo/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            /(nexus\s9)/i                                                       // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

            /d\/huawei([\w\s-]+)[;\)]/i,
            /(nexus\s6p)/i                                                      // Huawei
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

                                                                                // Motorola
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,
            /mot[\s-]?(\w*)/i,
            /(XT\d{3,4}) build\//i,
            /(nexus\s6)/i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
            /((SM-T\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
            /smart-tv.+(samsung)/i
            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,
            /sec-((sgh\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

            /sie-(\w*)/i                                                        // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
            /(nokia)[\s_-]?([\w-]*)/i
            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

            /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            /android.+([vl]k\-?\d{3})\s+build/i                                 // LG Tablet
            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
            /(lg) netcast\.tv/i                                                 // LG SmartTV
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /(nexus\s[45])/i,                                                   // LG
            /lg[e;\s\/-]+(\w*)/i,
            /android.+lg(\-?[\d\w]+)\s+build/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            /linux;.+((jolla));/i                                               // Jolla
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

            /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i                            // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google']], [

            /android.+;\s(glass)\s\d/i                                          // Google Glass
            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

            /android.+;\s(pixel c)\s/i                                          // Google Pixel C
            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

            /android.+;\s(pixel xl|pixel)\s/i                                   // Google Pixel
            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

            /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
            /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,    // Xiaomi Mi
            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i       // Redmi Phones
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i            // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
            /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu Tablet
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, TABLET]], [

            /android.+a000(1)\s+build/i,                                        // OnePlus
            /android.+oneplus\s(a\d{4})\s+build/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [

            /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [

            /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i     // Barnes & Noble Tablet
            ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i                           // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [

            /android.+;\s(k88)\sbuild/i                                         // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i                         // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(zur\d{3})\s+build/i                              // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i                         // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [

            /(android).+[;\/]\s+([YR]\d{2})\s+build/i,
            /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i        // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i                            // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i                    // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones

            /android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i                     // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [

            /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i          // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i          // Le Pan Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i                         // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i                // Trinity Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [

            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [

            /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
            ], [[TYPE, util.lowerize], VENDOR, MODEL], [

            /(android[\w\.\s\-]{0,9});.+build/i                                 // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]


        /*//////////////////////////
            // TODO: move to string map
            ////////////////////////////

            /(C6603)/i                                                          // Sony Xperia Z C6603
            ], [[MODEL, 'Xperia Z C6603'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [
            /(C6903)/i                                                          // Sony Xperia Z 1
            ], [[MODEL, 'Xperia Z 1'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /(SM-G900[F|H])/i                                                   // Samsung Galaxy S5
            ], [[MODEL, 'Galaxy S5'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G7102)/i                                                       // Samsung Galaxy Grand 2
            ], [[MODEL, 'Galaxy Grand 2'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G530H)/i                                                       // Samsung Galaxy Grand Prime
            ], [[MODEL, 'Galaxy Grand Prime'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G313HZ)/i                                                      // Samsung Galaxy V
            ], [[MODEL, 'Galaxy V'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-T805)/i                                                        // Samsung Galaxy Tab S 10.5
            ], [[MODEL, 'Galaxy Tab S 10.5'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [
            /(SM-G800F)/i                                                       // Samsung Galaxy S5 Mini
            ], [[MODEL, 'Galaxy S5 Mini'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-T311)/i                                                        // Samsung Galaxy Tab 3 8.0
            ], [[MODEL, 'Galaxy Tab 3 8.0'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [

            /(T3C)/i                                                            // Advan Vandroid T3C
            ], [MODEL, [VENDOR, 'Advan'], [TYPE, TABLET]], [
            /(ADVAN T1J\+)/i                                                    // Advan Vandroid T1J+
            ], [[MODEL, 'Vandroid T1J+'], [VENDOR, 'Advan'], [TYPE, TABLET]], [
            /(ADVAN S4A)/i                                                      // Advan Vandroid S4A
            ], [[MODEL, 'Vandroid S4A'], [VENDOR, 'Advan'], [TYPE, MOBILE]], [

            /(V972M)/i                                                          // ZTE V972M
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [

            /(i-mobile)\s(IQ\s[\d\.]+)/i                                        // i-mobile IQ
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(IQ6.3)/i                                                          // i-mobile IQ IQ 6.3
            ], [[MODEL, 'IQ 6.3'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [
            /(i-mobile)\s(i-style\s[\d\.]+)/i                                   // i-mobile i-STYLE
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(i-STYLE2.1)/i                                                     // i-mobile i-STYLE 2.1
            ], [[MODEL, 'i-STYLE 2.1'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [

            /(mobiistar touch LAI 512)/i                                        // mobiistar touch LAI 512
            ], [[MODEL, 'Touch LAI 512'], [VENDOR, 'mobiistar'], [TYPE, MOBILE]], [

            /////////////
            // END TODO
            ///////////*/

        ],

        engine : [[

            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, 'EdgeHTML']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9}).+(gecko)/i                                       // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows based
            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,                   // Windows Phone
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // Mobile/Embedded OS
            /\((bb)(10);/i                                                      // BlackBerry 10
            ], [[NAME, 'BlackBerry'], VERSION], [
            /(blackberry)\w*\/?([\w\.]*)/i,                                     // Blackberry
            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i,
                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
            /linux;.+(sailfish);/i                                              // Sailfish OS
            ], [NAME, VERSION], [
            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i                  // Symbian
            ], [[NAME, 'Symbian'], VERSION], [
            /\((series40);/i                                                    // Series 40
            ], [NAME], [
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS'], VERSION], [

            // Console
            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

            // GNU/Linux based
            /(mint)[\/\s\(]?(\w*)/i,                                            // Mint
            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
            /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
            /(hurd|linux)\s?([\w\.]*)/i,                                        // Hurd/Linux
            /(gnu)\s?([\w\.]*)/i                                                // GNU
            ], [NAME, VERSION], [

            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Solaris
            /(sunos)\s?([\w\.\d]*)/i                                            // Solaris
            ], [[NAME, 'Solaris'], VERSION], [

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i                    // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            ], [NAME, VERSION],[

            /(haiku)\s(\w+)/i                                                   // Haiku
            ], [NAME, VERSION],[

            /cfnetwork\/.+darwin/i,
            /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i             // iOS
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [

            /(mac\sos\sx)\s?([\w\s\.]*)/i,
            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Other
            /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,                             // Solaris
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,                                // AIX
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
            /(unix)\s?([\w\.]*)/i                                               // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////
    /*
    var Browser = function (name, version) {
        this[NAME] = name;
        this[VERSION] = version;
    };
    var CPU = function (arch) {
        this[ARCHITECTURE] = arch;
    };
    var Device = function (vendor, model, type) {
        this[VENDOR] = vendor;
        this[MODEL] = model;
        this[TYPE] = type;
    };
    var Engine = Browser;
    var OS = Browser;
    */
    var UAParser = function (uastring, extensions) {

        if (typeof uastring === 'object') {
            extensions = uastring;
            uastring = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(uastring, extensions).getResult();
        }

        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
        //var browser = new Browser();
        //var cpu = new CPU();
        //var device = new Device();
        //var engine = new Engine();
        //var os = new OS();

        this.getBrowser = function () {
            var browser = { name: undefined, version: undefined };
            mapper.rgx.call(browser, ua, rgxmap.browser);
            browser.major = util.major(browser.version); // deprecated
            return browser;
        };
        this.getCPU = function () {
            var cpu = { architecture: undefined };
            mapper.rgx.call(cpu, ua, rgxmap.cpu);
            return cpu;
        };
        this.getDevice = function () {
            var device = { vendor: undefined, model: undefined, type: undefined };
            mapper.rgx.call(device, ua, rgxmap.device);
            return device;
        };
        this.getEngine = function () {
            var engine = { name: undefined, version: undefined };
            mapper.rgx.call(engine, ua, rgxmap.engine);
            return engine;
        };
        this.getOS = function () {
            var os = { name: undefined, version: undefined };
            mapper.rgx.call(os, ua, rgxmap.os);
            return os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return ua;
        };
        this.setUA = function (uastring) {
            ua = uastring;
            //browser = new Browser();
            //cpu = new CPU();
            //device = new Device();
            //engine = new Engine();
            //os = new OS();
            return this;
        };
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = {
        NAME    : NAME,
        MAJOR   : MAJOR, // deprecated
        VERSION : VERSION
    };
    UAParser.CPU = {
        ARCHITECTURE : ARCHITECTURE
    };
    UAParser.DEVICE = {
        MODEL   : MODEL,
        VENDOR  : VENDOR,
        TYPE    : TYPE,
        CONSOLE : CONSOLE,
        MOBILE  : MOBILE,
        SMARTTV : SMARTTV,
        TABLET  : TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
    };
    UAParser.ENGINE = {
        NAME    : NAME,
        VERSION : VERSION
    };
    UAParser.OS = {
        NAME    : NAME,
        VERSION : VERSION
    };
    //UAParser.Utils = util;

    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        // TODO: test!!!!!!!!
        /*
        if (require && require.main === module && process) {
            // cli
            var jsonize = function (arr) {
                var res = [];
                for (var i in arr) {
                    res.push(new UAParser(arr[i]).getResult());
                }
                process.stdout.write(JSON.stringify(res, null, 2) + '\n');
            };
            if (process.stdin.isTTY) {
                // via args
                jsonize(process.argv.slice(2));
            } else {
                // via pipe
                var str = '';
                process.stdin.on('readable', function() {
                    var read = process.stdin.read();
                    if (read !== null) {
                        str += read;
                    }
                });
                process.stdin.on('end', function () {
                    jsonize(str.replace(/\n$/, '').split('\n'));
                });
            }
        }
        */
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (typeof(define) === FUNC_TYPE && define.amd) {
            define(function () {
                return UAParser;
            });
        } else if (window) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = window && (window.jQuery || window.Zepto);
    if (typeof $ !== UNDEF_TYPE) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (uastring) {
            parser.setUA(uastring);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Modelo", [], factory);
	else if(typeof exports === 'object')
		exports["Modelo"] = factory();
	else
		root["Modelo"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!**************************************************************************!*\
  !*** ../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }

    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;

        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;

                return true;
            }

            return false;
        });

        return result;
    }

    return (function () {
        function anonymous() {
            this.__entries__ = [];
        }

        var prototypeAccessors = { size: { configurable: true } };

        /**
         * @returns {boolean}
         */
        prototypeAccessors.size.get = function () {
            return this.__entries__.length;
        };

        /**
         * @param {*} key
         * @returns {*}
         */
        anonymous.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];

            return entry && entry[1];
        };

        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        anonymous.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);

            if (~index) {
                this.__entries__[index][1] = value;
            } else {
                this.__entries__.push([key, value]);
            }
        };

        /**
         * @param {*} key
         * @returns {void}
         */
        anonymous.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);

            if (~index) {
                entries.splice(index, 1);
            }
        };

        /**
         * @param {*} key
         * @returns {void}
         */
        anonymous.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };

        /**
         * @returns {void}
         */
        anonymous.prototype.clear = function () {
            this.__entries__.splice(0);
        };

        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        anonymous.prototype.forEach = function (callback, ctx) {
            var this$1 = this;
            if ( ctx === void 0 ) ctx = null;

            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {
                var entry = list[i];

                callback.call(ctx, entry[1], entry[0]);
            }
        };

        Object.defineProperties( anonymous.prototype, prototypeAccessors );

        return anonymous;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }

    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }

    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }

    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }

    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;

/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
var throttle = function (callback, delay) {
    var leadingCall = false,
        trailingCall = false,
        lastCallTime = 0;

    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;

            callback();
        }

        if (trailingCall) {
            proxy();
        }
    }

    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }

    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();

        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }

            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        } else {
            leadingCall = true;
            trailingCall = false;

            setTimeout(timeoutCallback, delay);
        }

        lastCallTime = timeStamp;
    }

    return proxy;
};

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;

// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];

// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';

/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = function() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];

    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
};

/**
 * Adds observer to observers list.
 *
 * @param {ResizeObserverSPI} observer - Observer to be added.
 * @returns {void}
 */


/**
 * Holds reference to the controller's instance.
 *
 * @private {ResizeObserverController}
 */


/**
 * Keeps reference to the instance of MutationObserver.
 *
 * @private {MutationObserver}
 */

/**
 * Indicates whether DOM listeners have been added.
 *
 * @private {boolean}
 */
ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
    }

    // Add listeners if they haven't been added yet.
    if (!this.connected_) {
        this.connect_();
    }
};

/**
 * Removes observer from observers list.
 *
 * @param {ResizeObserverSPI} observer - Observer to be removed.
 * @returns {void}
 */
ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer);

    // Remove observer if it's present in registry.
    if (~index) {
        observers.splice(index, 1);
    }

    // Remove listeners if controller has no connected observers.
    if (!observers.length && this.connected_) {
        this.disconnect_();
    }
};

/**
 * Invokes the update of observers. It will continue running updates insofar
 * it detects changes.
 *
 * @returns {void}
 */
ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_();

    // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.
    if (changesDetected) {
        this.refresh();
    }
};

/**
 * Updates every observer from observers list and notifies them of queued
 * entries.
 *
 * @private
 * @returns {boolean} Returns "true" if any observer has detected changes in
 *  dimensions of it's elements.
 */
ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
        return observer.gatherActive(), observer.hasActive();
    });

    // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.
    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });

    return activeObservers.length > 0;
};

/**
 * Initializes DOM listeners.
 *
 * @private
 * @returns {void}
 */
ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
        return;
    }

    // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.
    document.addEventListener('transitionend', this.onTransitionEnd_);

    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);

        this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
        });
    } else {
        document.addEventListener('DOMSubtreeModified', this.refresh);

        this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
};

/**
 * Removes DOM listeners.
 *
 * @private
 * @returns {void}
 */
ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
        return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
        document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
};

/**
 * "Transitionend" event handler.
 *
 * @private
 * @param {TransitionEvent} event
 * @returns {void}
 */
ResizeObserverController.prototype.onTransitionEnd_ = function (ref) {
        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';

    // Detect whether transition may affect dimensions of an element.
    var isReflowProperty = transitionKeys.some(function (key) {
        return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
        this.refresh();
    }
};

/**
 * Returns instance of the ResizeObserverController.
 *
 * @returns {ResizeObserverController}
 */
ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
};

ResizeObserverController.instance_ = null;

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {
        var key = list[i];

        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }

    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;

    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);

/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}

/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [], len = arguments.length - 1;
    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];

    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];

        return size + toFloat(value);
    }, 0);
}

/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};

    for (var i = 0, list = positions; i < list.length; i += 1) {
        var position = list[i];

        var value = styles['padding-' + position];

        paddings[position] = toFloat(value);
    }

    return paddings;
}

/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();

    return createRectInit(0, 0, bbox.width, bbox.height);
}

/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth;
    var clientHeight = target.clientHeight;

    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }

    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;

    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width),
        height = toFloat(styles.height);

    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }

        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }

    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;

        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }

        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }

    return createRectInit(paddings.left, paddings.top, width, height);
}

/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }

    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };
})();

/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}

/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }

    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }

    return getHTMLElementContentRect(target);
}

/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(ref) {
    var x = ref.x;
    var y = ref.y;
    var width = ref.width;
    var height = ref.height;

    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);

    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });

    return rect;
}

/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = function(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);

    this.target = target;
};

/**
 * Updates content rectangle and tells whether it's width or height properties
 * have changed since the last broadcast.
 *
 * @returns {boolean}
 */


/**
 * Reference to the last observed content rectangle.
 *
 * @private {DOMRectInit}
 */


/**
 * Broadcasted width of content rectangle.
 *
 * @type {number}
 */
ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);

    this.contentRect_ = rect;

    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
};

/**
 * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
 * from the corresponding properties of the last observed content rectangle.
 *
 * @returns {DOMRectInit} Last observed content rectangle.
 */
ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;

    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;

    return rect;
};

var ResizeObserverEntry = function(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);

    // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.
    defineConfigurable(this, { target: target, contentRect: contentRect });
};

var ResizeObserverSPI = function(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
        throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
};

/**
 * Starts observing provided element.
 *
 * @param {Element} target - Element to be observed.
 * @returns {void}
 */


/**
 * Registry of the ResizeObservation instances.
 *
 * @private {Map<Element, ResizeObservation>}
 */


/**
 * Public ResizeObserver instance which will be passed to the callback
 * function and used as a value of it's "this" binding.
 *
 * @private {ResizeObserver}
 */

/**
 * Collection of resize observations that have detected changes in dimensions
 * of elements.
 *
 * @private {Array<ResizeObservation>}
 */
ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
    }

    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_;

    // Do nothing if element is already being observed.
    if (observations.has(target)) {
        return;
    }

    observations.set(target, new ResizeObservation(target));

    this.controller_.addObserver(this);

    // Force the update of observations.
    this.controller_.refresh();
};

/**
 * Stops observing provided element.
 *
 * @param {Element} target - Element to stop observing.
 * @returns {void}
 */
ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
    }

    // Do nothing if current environment doesn't have the Element interface.
    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_;

    // Do nothing if element is not being observed.
    if (!observations.has(target)) {
        return;
    }

    observations.delete(target);

    if (!observations.size) {
        this.controller_.removeObserver(this);
    }
};

/**
 * Stops observing all elements.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
};

/**
 * Collects observation instances the associated element of which has changed
 * it's content rectangle.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.gatherActive = function () {
        var this$1 = this;

    this.clearActive();

    this.observations_.forEach(function (observation) {
        if (observation.isActive()) {
            this$1.activeObservations_.push(observation);
        }
    });
};

/**
 * Invokes initial callback function with a list of ResizeObserverEntry
 * instances collected from active resize observations.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
        return;
    }

    var ctx = this.callbackCtx_;

    // Create ResizeObserverEntry instance for every active observation.
    var entries = this.activeObservations_.map(function (observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });

    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
};

/**
 * Clears the collection of active observations.
 *
 * @returns {void}
 */
ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
};

/**
 * Tells whether observer has active observations.
 *
 * @returns {boolean}
 */
ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
};

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();

/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = function(callback) {
    if (!(this instanceof ResizeObserver)) {
        throw new TypeError('Cannot call a class as a function.');
    }
    if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);

    observers.set(this, observer);
};

// Expose public methods of ResizeObserver.
['observe', 'unobserve', 'disconnect'].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        return (ref = observers.get(this))[method].apply(ref, arguments);
        var ref;
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }

    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../modelo3d/node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./00utility/m3d_hwinfo.js":
/*!*********************************!*\
  !*** ./00utility/m3d_hwinfo.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_hwinfo.js
// Detect the RAM and other hardware information.
//
// Copyright Modelo XX - 2017, All rights reserved.
//
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function HWInfo() {
        // public:
        this.vramSize = 0; // RAM size in MB
        this.littleEndian = true; // bit order
        // Initialize
        var uaparse = new UAParser();
        var uainfo = uaparse.getResult();
        var type = (uainfo.device.model || "").toLowerCase();
        this.browserName = (uainfo.browser && uainfo.browser.name || "").toLowerCase();
        this.browserVersion = (uainfo.browser && uainfo.browser.major || "").toLowerCase();
        switch (type) {
            case "iphone":
                // Since on iOS, CPU mem and GPU mem share the same
                // piece of RAM. Its total available memory left
                // for Safari is only a few hundreds MBs.
                this.vramSize = 1024; // 1GB 
                break;
            case "ipad":
                this.vramSize = 2048; // 2GB
                break;
            default:
                this.vramSize = 4096; // 4GB
                break;
        }
    }
    ;
    return HWInfo;
})());


/***/ }),

/***/ "./00utility/m3d_interpolator.js":
/*!***************************************!*\
  !*** ./00utility/m3d_interpolator.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_interpolator.js
// Util functions for  interpolating two values.
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var Interpolator = {};
    Interpolator.linear = {};
    Interpolator.linear.vec3 = function (out, start, end, ratio) {
        var r0 = 1.0 - ratio;
        out[0] = r0 * start[0] + ratio * end[0];
        out[1] = r0 * start[1] + ratio * end[1];
        out[2] = r0 * start[2] + ratio * end[2];
    };
    Interpolator.linear.scalar = function (start, end, ratio) {
        return (1.0 - ratio) * start + ratio * end;
    };
    Interpolator.cubic = {};
    Interpolator.cubic.vec3 = function (out, start, end, ratio) {
        ratio = 3.0 * ratio * ratio - 2.0 * ratio * ratio * ratio;
        var r0 = 1.0 - ratio;
        out[0] = r0 * start[0] + ratio * end[0];
        out[1] = r0 * start[1] + ratio * end[1];
        out[2] = r0 * start[2] + ratio * end[2];
    };
    Interpolator.cubic.scalar = function (out, start, end, ratio) {
        ratio = 3.0 * ratio * ratio - 2.0 * ratio * ratio * ratio;
        var r0 = 1.0 - ratio;
        return r0 * start + ratio * end;
    };
    return Interpolator;
})());


/***/ }),

/***/ "./00utility/m3d_math.js":
/*!*******************************!*\
  !*** ./00utility/m3d_math.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_math.js
// math
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var MyMath = {};
    // Cone
    MyMath.cone = {
        // Frustum cone
        _theta: 0,
        _tanTheta: 0
    };
    MyMath.cone.create = function () {
        var ret = {
            tip: vec3.create(),
            direction: vec3.create(),
            cosThetaSquared: 0,
            sinThetaSquared: 0,
            invSinTheta: 0
        };
        return ret;
    };
    MyMath.cone.updateShape = function (cone, fov, aspect) {
        this._theta = fov * 0.017453293 * 0.5;
        this._tanTheta = Math.tan(this._theta);
        this._tanTheta *= Math.sqrt(1 + aspect * aspect);
        cone.cosThetaSquared = 1.0 / (this._tanTheta * this._tanTheta + 1.0);
        cone.sinThetaSquared = 1.0 - cone.cosThetaSquared;
        cone.invSinTheta = 1.0 / Math.sqrt(cone.sinThetaSquared);
    };
    //
    // Axis aligned bounding box
    //
    MyMath.aabb = {
        _vec: new Float32Array(3)
    };
    MyMath.aabb.createFromArray = function (from) {
        var out = new Float32Array(6);
        out[0] = from[0];
        out[1] = from[1];
        out[2] = from[2];
        out[3] = from[3];
        out[4] = from[4];
        out[5] = from[5];
        return out;
    };
    MyMath.aabb.createFromSphere = function (sphere) {
        var ret = new Float32Array(6);
        ret[0] = sphere[0] - sphere[3];
        ret[1] = sphere[1] - sphere[3];
        ret[2] = sphere[2] - sphere[3];
        ret[3] = sphere[0] + sphere[3];
        ret[4] = sphere[1] + sphere[3];
        ret[5] = sphere[2] + sphere[3];
        return ret;
    };
    // Find the aabb of 8 points' world position
    MyMath.aabb.createFromPoints = function (out, points) {
        out[0] = points[0][0];
        out[3] = points[0][0];
        out[1] = points[0][1];
        out[4] = points[0][1];
        out[2] = points[0][2];
        out[5] = points[0][2];
        for (var i = 1, len = points.length; i < len; i++) {
            if (out[0] > points[i][0]) {
                out[0] = points[i][0];
            }
            if (out[3] < points[i][0]) {
                out[3] = points[i][0];
            }
            if (out[1] > points[i][1]) {
                out[1] = points[i][1];
            }
            if (out[4] < points[i][1]) {
                out[4] = points[i][1];
            }
            if (out[2] > points[i][2]) {
                out[2] = points[i][2];
            }
            if (out[5] < points[i][2]) {
                out[5] = points[i][2];
            }
        }
        return out;
    };
    MyMath.aabb.copy = function (out, from) {
        out[0] = from[0];
        out[1] = from[1];
        out[2] = from[2];
        out[3] = from[3];
        out[4] = from[4];
        out[5] = from[5];
        return out;
    };
    var AABB_MIN = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
    var AABB_MAX = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
    // create an invalid bbox.
    MyMath.aabb.create = function (min, max) {
        var out = new Float32Array(6);
        min = min || AABB_MIN;
        max = max || AABB_MAX;
        out[0] = min[0];
        out[1] = min[1];
        out[2] = min[2];
        out[3] = max[0];
        out[4] = max[1];
        out[5] = max[2];
        return out;
    };
    MyMath.aabb.min = function (aabb) {
        return vec3.fromValues(aabb[0], aabb[1], aabb[2]);
    };
    MyMath.aabb.max = function (aabb) {
        return vec3.fromValues(aabb[3], aabb[4], aabb[5]);
    };
    MyMath.aabb.length = function (aabb) {
        var x = aabb[3] - aabb[0];
        var y = aabb[4] - aabb[1];
        var z = aabb[5] - aabb[2];
        return Math.sqrt(x * x + y * y + z * z);
    };
    MyMath.aabb.isEqual = function (a, b) {
        return Math.abs(a[0] - b[0]) < 1e-6 &&
            Math.abs(a[1] - b[1]) < 1e-6 &&
            Math.abs(a[2] - b[2]) < 1e-6 &&
            Math.abs(a[3] - b[3]) < 1e-6 &&
            Math.abs(a[4] - b[4]) < 1e-6 &&
            Math.abs(a[5] - b[5]) < 1e-6;
    };
    MyMath.aabb.union = function (out, b1, b2) {
        out[0] = Math.min(b1[0], b2[0]);
        out[1] = Math.min(b1[1], b2[1]);
        out[2] = Math.min(b1[2], b2[2]);
        out[3] = Math.max(b1[3], b2[3]);
        out[4] = Math.max(b1[4], b2[4]);
        out[5] = Math.max(b1[5], b2[5]);
        return out;
    };
    // scale the aabb by a scaling factor
    MyMath.aabb.scale = function (out, src, scaling) {
        var t0 = 0.5 - scaling * 0.5;
        var t1 = 0.5 + scaling * 0.5;
        var lx = src[0] * t1 + src[3] * t0;
        var rx = src[0] * t0 + src[3] * t1;
        var ly = src[1] * t1 + src[4] * t0;
        var ry = src[1] * t0 + src[4] * t1;
        var lz = src[2] * t1 + src[5] * t0;
        var rz = src[2] * t0 + src[5] * t1;
        out[0] = lx;
        out[3] = rx;
        out[1] = ly;
        out[4] = ry;
        out[2] = lz;
        out[5] = rz;
    };
    MyMath.aabb.expand = function (out, value) {
        if (value === undefined) {
            value = 1e-4;
        }
        out[0] -= value;
        out[1] -= value;
        out[2] -= value;
        out[3] += value;
        out[4] += value;
        out[5] += value;
    };
    // Fetch 8 corners of AABB
    MyMath.aabb.points = function (aabb) {
        var points = [];
        points.push(vec3.fromValues(aabb[0], aabb[1], aabb[2]));
        points.push(vec3.fromValues(aabb[3], aabb[1], aabb[2]));
        points.push(vec3.fromValues(aabb[3], aabb[4], aabb[2]));
        points.push(vec3.fromValues(aabb[0], aabb[4], aabb[2]));
        points.push(vec3.fromValues(aabb[0], aabb[1], aabb[5]));
        points.push(vec3.fromValues(aabb[3], aabb[1], aabb[5]));
        points.push(vec3.fromValues(aabb[3], aabb[4], aabb[5]));
        points.push(vec3.fromValues(aabb[0], aabb[4], aabb[5]));
        return points;
    };
    MyMath.aabb.points2 = function (aabb, points) {
        points[0][0] = aabb[0];
        points[0][1] = aabb[1];
        points[0][2] = aabb[2];
        points[1][0] = aabb[3];
        points[1][1] = aabb[1];
        points[1][2] = aabb[2];
        points[2][0] = aabb[3];
        points[2][1] = aabb[4];
        points[2][2] = aabb[2];
        points[3][0] = aabb[0];
        points[3][1] = aabb[4];
        points[3][2] = aabb[2];
        points[4][0] = aabb[0];
        points[4][1] = aabb[1];
        points[4][2] = aabb[5];
        points[5][0] = aabb[3];
        points[5][1] = aabb[1];
        points[5][2] = aabb[5];
        points[6][0] = aabb[3];
        points[6][1] = aabb[4];
        points[6][2] = aabb[5];
        points[7][0] = aabb[0];
        points[7][1] = aabb[4];
        points[7][2] = aabb[5];
        return points;
    };
    MyMath.aabb.points3 = function (aabb, points) {
        points[0][0] = aabb[0];
        points[0][1] = aabb[1];
        points[0][2] = aabb[2];
        points[1][0] = aabb[3];
        points[1][1] = aabb[1];
        points[1][2] = aabb[2];
        points[2][0] = aabb[3];
        points[2][1] = aabb[1];
        points[2][2] = aabb[5];
        points[3][0] = aabb[0];
        points[3][1] = aabb[1];
        points[3][2] = aabb[5];
        points[4][0] = aabb[0];
        points[4][1] = aabb[4];
        points[4][2] = aabb[2];
        points[5][0] = aabb[3];
        points[5][1] = aabb[4];
        points[5][2] = aabb[2];
        points[6][0] = aabb[3];
        points[6][1] = aabb[4];
        points[6][2] = aabb[5];
        points[7][0] = aabb[0];
        points[7][1] = aabb[4];
        points[7][2] = aabb[5];
        return points;
    };
    // return 6 planes of aabb
    MyMath.aabb.planes = function (aabb) {
        var planes = [];
        // aabb planes: left, near, bottom, right, far, top
        planes.push(vec4.fromValues(-1, 0, 0, aabb[0]));
        planes.push(vec4.fromValues(0, -1, 0, aabb[1]));
        planes.push(vec4.fromValues(0, 0, -1, aabb[2]));
        planes.push(vec4.fromValues(1, 0, 0, -aabb[3]));
        planes.push(vec4.fromValues(0, 1, 0, -aabb[4]));
        planes.push(vec4.fromValues(0, 0, 1, -aabb[5]));
        return planes;
    };
    MyMath.aabb.volume = function (aabb) {
        var width = aabb[3] - aabb[0];
        var height = aabb[4] - aabb[1];
        var depth = aabb[5] - aabb[2];
        return width * height * depth;
    };
    var aabbSize_ret = {
        width: 0,
        height: 0,
        depth: 0,
    };
    MyMath.aabb.size = function (aabb) {
        aabbSize_ret.width = aabb[3] - aabb[0];
        aabbSize_ret.height = aabb[4] - aabb[1];
        aabbSize_ret.depth = aabb[5] - aabb[2];
        return aabbSize_ret;
    };
    MyMath.aabb.center = function (aabb) {
        return [(aabb[0] + aabb[3]) * 0.5,
            (aabb[1] + aabb[4]) * 0.5,
            (aabb[2] + aabb[5]) * 0.5];
    };
    /**
     * @description Transform the box with a SRT matrix.
     * @param {object} box - the box in aabb format.
     * @param {array} transform - a 4x4 transform matrix.
     */
    var aabb_transform_points = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ];
    MyMath.aabb.transform = function (out, aabb, transform) {
        MyMath.aabb.points2(aabb, aabb_transform_points);
        vec3.transformMat4(aabb_transform_points[0], aabb_transform_points[0], transform);
        vec3.transformMat4(aabb_transform_points[1], aabb_transform_points[1], transform);
        vec3.transformMat4(aabb_transform_points[2], aabb_transform_points[2], transform);
        vec3.transformMat4(aabb_transform_points[3], aabb_transform_points[3], transform);
        vec3.transformMat4(aabb_transform_points[4], aabb_transform_points[4], transform);
        vec3.transformMat4(aabb_transform_points[5], aabb_transform_points[5], transform);
        vec3.transformMat4(aabb_transform_points[6], aabb_transform_points[6], transform);
        vec3.transformMat4(aabb_transform_points[7], aabb_transform_points[7], transform);
        out[0] = aabb_transform_points[0][0];
        out[3] = aabb_transform_points[0][0];
        out[1] = aabb_transform_points[0][1];
        out[4] = aabb_transform_points[0][1];
        out[2] = aabb_transform_points[0][2];
        out[5] = aabb_transform_points[0][2];
        for (var i = 1; i < 8; i++) {
            if (out[0] > aabb_transform_points[i][0]) {
                out[0] = aabb_transform_points[i][0];
            }
            if (out[3] < aabb_transform_points[i][0]) {
                out[3] = aabb_transform_points[i][0];
            }
            if (out[1] > aabb_transform_points[i][1]) {
                out[1] = aabb_transform_points[i][1];
            }
            if (out[4] < aabb_transform_points[i][1]) {
                out[4] = aabb_transform_points[i][1];
            }
            if (out[2] > aabb_transform_points[i][2]) {
                out[2] = aabb_transform_points[i][2];
            }
            if (out[5] < aabb_transform_points[i][2]) {
                out[5] = aabb_transform_points[i][2];
            }
        }
    };
    //
    // Plane
    //
    MyMath.plane = {};
    MyMath.plane.create = function (pt0, pt1, pt2) {
        var e10x = pt1[0] - pt0[0];
        var e10y = pt1[1] - pt0[1];
        var e10z = pt1[2] - pt0[2];
        var e20x = pt2[0] - pt0[0];
        var e20y = pt2[1] - pt0[1];
        var e20z = pt2[2] - pt0[2];
        var plane = vec4.create();
        plane[0] = e10y * e20z - e10z * e20y;
        plane[1] = e10z * e20x - e10x * e20z;
        plane[2] = e10x * e20y - e10y * e20x;
        plane[3] = -(plane[0] * pt0[0] + plane[1] * pt0[1] + plane[2] * pt0[2]);
        this.normalize(plane);
        return plane;
    };
    MyMath.plane.createABCD = function (A, B, C, D) {
        var plane = vec4.fromValues(A, B, C, D);
        this.normalize(plane);
        return plane;
    };
    MyMath.plane.normalize = function (plane) {
        var len = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
        plane[0] /= len;
        plane[1] /= len;
        plane[2] /= len;
        plane[3] /= len;
    };
    //
    // Sphere
    //
    MyMath.sphere = {};
    MyMath.sphere.createFromAABB = function (aabb) {
        var ret = new Float32Array(4);
        ret[0] = (aabb[0] + aabb[3]) * 0.5;
        ret[1] = (aabb[1] + aabb[4]) * 0.5;
        ret[2] = (aabb[2] + aabb[5]) * 0.5;
        ret[3] = MyMath.aabb.length(aabb) * 0.5;
        return ret;
    };
    //
    // Frustum
    //
    MyMath.frustum = {};
    var invVpMatrix = mat4.create();
    // create 6 planes in world space of a frustum given the view-projection matrix.
    // http://ruh.li/CameraViewFrustum.html
    MyMath.frustum.createFromMatrix = function (vpMatrix) {
        var frustum = [];
        var i;
        for (i = 0; i < 14; ++i) {
            frustum.push(vec4.create());
        }
        mat4.invert(invVpMatrix, vpMatrix);
        vec4.transformMat4(frustum[6], [-1, -1, -1, 1], invVpMatrix);
        vec4.transformMat4(frustum[7], [1, -1, -1, 1], invVpMatrix);
        vec4.transformMat4(frustum[8], [1, -1, 1, 1], invVpMatrix);
        vec4.transformMat4(frustum[9], [-1, -1, 1, 1], invVpMatrix);
        vec4.transformMat4(frustum[10], [-1, 1, -1, 1], invVpMatrix);
        vec4.transformMat4(frustum[11], [1, 1, -1, 1], invVpMatrix);
        vec4.transformMat4(frustum[12], [1, 1, 1, 1], invVpMatrix);
        vec4.transformMat4(frustum[13], [-1, 1, 1, 1], invVpMatrix);
        // 6-13 are 8 corners of frustum
        for (i = 6; i < 14; ++i) {
            vec4.scale(frustum[i], frustum[i], 1.0 / frustum[i][3]);
        }
        // 0-5 are 6 planes of frustum : near, far, top, bottom, left, right
        // The plane normals point to the outside of frustum.
        var a = -vpMatrix[3];
        var b = -vpMatrix[7];
        var c = -vpMatrix[11];
        var d = -vpMatrix[15];
        frustum[0] = MyMath.plane.createABCD(a - vpMatrix[2], b - vpMatrix[6], c - vpMatrix[10], d - vpMatrix[14]);
        frustum[1] = MyMath.plane.createABCD(a + vpMatrix[2], b + vpMatrix[6], c + vpMatrix[10], d + vpMatrix[14]);
        frustum[2] = MyMath.plane.createABCD(a + vpMatrix[1], b + vpMatrix[5], c + vpMatrix[9], d + vpMatrix[13]);
        frustum[3] = MyMath.plane.createABCD(a - vpMatrix[1], b - vpMatrix[5], c - vpMatrix[9], d - vpMatrix[13]);
        frustum[4] = MyMath.plane.createABCD(a - vpMatrix[0], b - vpMatrix[4], c - vpMatrix[8], d - vpMatrix[12]);
        frustum[5] = MyMath.plane.createABCD(a + vpMatrix[0], b + vpMatrix[4], c + vpMatrix[8], d + vpMatrix[12]);
        //var frustum0 = MyMath.plane.create(frustum[11], frustum[10], frustum[7]);
        //var frustum1 = MyMath.plane.create(frustum[13], frustum[12], frustum[8]);
        //var frustum2 = MyMath.plane.create(frustum[11], frustum[12], frustum[13]);
        //var frustum3 = MyMath.plane.create(frustum[9],  frustum[8],  frustum[7]);
        //var frustum4 = MyMath.plane.create(frustum[10], frustum[13], frustum[9]);
        //var frustum5 = MyMath.plane.create(frustum[12], frustum[11], frustum[7]);
        return frustum;
    };
    // find 8 corners of frustum in world space 
    MyMath.frustum.points = function (frustum) {
        return frustum.slice(6);
    };
    //find 6 planes of frustum
    MyMath.frustum.planes = function (frustum) {
        var planes = [];
        planes.push(frustum[0]);
        planes.push(frustum[1]);
        planes.push(frustum[2]);
        planes.push(frustum[3]);
        planes.push(frustum[4]);
        planes.push(frustum[5]);
        return planes;
    };
    //
    // Intersection test
    //
    MyMath.intersect = {
        // Temporary variables
        _temp: [0, 0, 0],
        _U: [0, 0, 0],
        _D: [0, 0, 0],
        _vec: [0, 0, 0],
        _diff: [0, 0, 0],
        _v0: [0, 0, 0],
        _v1: [0, 0, 0],
        _v2: [0, 0, 0]
    };
    MyMath.intersect.line_plane = function (point1, point2, plane) {
        vec3.subtract(this._diff, point1, point2);
        vec3.normalize(this._vec, this._diff);
        var tmp2 = vec3.dot(this._vec, plane);
        if (Math.abs(tmp2) <= 1e-3) { // parallel
            return null;
        }
        var m = -(vec3.dot(point2, plane) + plane[3]) / tmp2;
        for (var i = 0; i < 3; ++i) {
            if (m * this._vec[i] / this._diff[i] < 0 ||
                m * this._vec[i] / this._diff[i] > 1) {
                return null;
            }
        }
        var intersection = vec3.create();
        intersection[0] = point2[0] + m * this._vec[0];
        intersection[1] = point2[1] + m * this._vec[1];
        intersection[2] = point2[2] + m * this._vec[2];
        return intersection;
    };
    MyMath.intersect.line_frustum = function (point1, point2, frustum, intersections) {
        var pointIdx = [[0, 1, 5, 4],
            [2, 3, 7, 6],
            [4, 5, 6, 7],
            [0, 3, 2, 1],
            [0, 4, 7, 3],
            [1, 2, 6, 5]];
        var isIntersect = false;
        for (var i = 0; i < 6; i++) {
            var plane = frustum[i]; // frustum planes stars from frustum[0]
            // get the four points of the ith plane
            // frustum points starts from frustum[6]
            var planePoints = [];
            planePoints.push(frustum[pointIdx[i][0] + 6]);
            planePoints.push(frustum[pointIdx[i][1] + 6]);
            planePoints.push(frustum[pointIdx[i][2] + 6]);
            planePoints.push(frustum[pointIdx[i][3] + 6]);
            var p = MyMath.intersect.line_frustum_quad(point1, point2, plane, planePoints);
            if (p !== null) {
                intersections.push(p);
                isIntersect = true;
            }
        }
        return isIntersect;
    };
    MyMath.intersect.line_aabb = function (point1, point2, aabb, intersections) {
        var aabbPlanes = MyMath.aabb.planes(aabb);
        var isIntersect = false;
        for (var i = 0; i < 6; i++) {
            var p = MyMath.intersect.line_aabb_quad(point1, point2, aabbPlanes[i], aabb, i);
            if (p != null) {
                intersections.push(p);
                isIntersect = true;
            }
        }
        return isIntersect;
    };
    MyMath.intersect.line_frustum_quad = function (point1, point2, plane, planePoints) {
        var p = null;
        p = MyMath.intersect.line_plane(point1, point2, plane);
        if (p == null) {
            return null;
        }
        if (MyMath.inside.point_triangle(planePoints[0], planePoints[1], planePoints[2], p) ||
            MyMath.inside.point_triangle(planePoints[2], planePoints[3], planePoints[0], p)) {
            return p;
        }
        else {
            return null;
        }
    };
    MyMath.intersect.line_aabb_quad = function (point1, point2, plane, aabb, planeId) {
        var p = null;
        p = MyMath.intersect.line_plane(point1, point2, plane);
        if (p === null) {
            return null;
        }
        var isInPlane = false;
        switch (planeId) {
            case 1: // near
            case 4: // far 
                isInPlane = MyMath.inside.point_slab(p[0], aabb[0], aabb[3]) &&
                    MyMath.inside.point_slab(p[2], aabb[2], aabb[5]);
                break;
            case 5: // top
            case 2: // bottom 
                isInPlane = MyMath.inside.point_slab(p[0], aabb[0], aabb[3]) &&
                    MyMath.inside.point_slab(p[1], aabb[1], aabb[4]);
                break;
            case 0: // left
            case 3: // right
                isInPlane = MyMath.inside.point_slab(p[1], aabb[1], aabb[4]) &&
                    MyMath.inside.point_slab(p[2], aabb[2], aabb[5]);
                break;
        }
        if (isInPlane) {
            return p;
        }
        else {
            return null;
        }
    };
    var ray_aabb_intersection = new Array(4);
    // Compute the ray-box intersection.
    // http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
    // return: the intersection point and the intersection plane
    // [x, y, z, planeIndex]. 
    // planeIndex: 0 : -x, 1 : +x, 2: -y, 3: +y, 4: -z, 5: +z
    MyMath.intersect.ray_aabb = function (point, direction, aabb) {
        var tnearMax = Number.NEGATIVE_INFINITY;
        var tfarMin = Number.POSITIVE_INFINITY;
        var intersected = true;
        var intersectPlane = -1;
        for (var i = 0; i < 3; i++) {
            var d = direction[i];
            var o = point[i];
            var n = aabb[i];
            var f = aabb[i + 3];
            if (d !== 0) {
                var t0 = (n - o) / d;
                var t1 = (f - o) / d;
                var inc = 0;
                if (t0 > t1) {
                    var c = t1;
                    t1 = t0;
                    t0 = c;
                    inc = 1;
                }
                if (t0 > tnearMax) {
                    tnearMax = t0;
                    intersectPlane = i * 2 + inc;
                }
                tnearMax = Math.max(t0, tnearMax);
                tfarMin = Math.min(t1, tfarMin);
                if (tnearMax > tfarMin) {
                    intersected = false;
                    break;
                }
                if (tfarMin < 0) {
                    intersected = false;
                    break;
                }
            }
            else {
                if (d < n || d > f) {
                    intersected = false;
                    break;
                }
            }
        }
        if (intersected) {
            ray_aabb_intersection[0] = point[0] + direction[0] * tnearMax;
            ray_aabb_intersection[1] = point[1] + direction[1] * tnearMax;
            ray_aabb_intersection[2] = point[2] + direction[2] * tnearMax;
            ray_aabb_intersection[3] = intersectPlane;
            return ray_aabb_intersection;
        }
        return null;
    };
    // See if sphere intersects frustum. Only returns true or false.
    MyMath.intersect.sphere_frustum = function (sphere, frustum) {
        return vec3.dot(frustum[0], sphere) + frustum[0][3] < sphere[3] &&
            vec3.dot(frustum[1], sphere) + frustum[1][3] < sphere[3] &&
            vec3.dot(frustum[2], sphere) + frustum[2][3] < sphere[3] &&
            vec3.dot(frustum[3], sphere) + frustum[3][3] < sphere[3] &&
            vec3.dot(frustum[4], sphere) + frustum[4][3] < sphere[3] &&
            vec3.dot(frustum[5], sphere) + frustum[5][3] < sphere[3];
    };
    // http://www.geometrictools.com/Documentation/IntersectionSphereCone.pdf
    MyMath.intersect.sphere_cone = function (sphere, cone) {
        vec3.scale(this._temp, cone.direction, cone.invSinTheta * sphere[3]);
        vec3.subtract(this._U, cone.tip, this._temp);
        vec3.subtract(this._D, sphere, this._U);
        var DSquared = vec3.dot(this._D, this._D);
        var e = vec3.dot(cone.direction, this._D);
        if (e > 0 && e * e >= DSquared * cone.cosThetaSquared) {
            vec3.subtract(this._D, sphere, cone.tip);
            DSquared = vec3.dot(this._D, this._D);
            e = -vec3.dot(cone.direction, this._D);
            if (e > 0 && e * e >= DSquared * cone.sinThetaSquared) {
                return DSquared <= sphere[3] * sphere[3];
            }
            else {
                return true;
            }
        }
        return false;
    };
    // return culled frustum by aabb
    MyMath.intersect.aabb_frustum = function (aabb, frustum) {
        var segmentPair = [[0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]];
        var aabbPoints = MyMath.aabb.points(aabb);
        var frustumPoints = MyMath.frustum.points(frustum);
        var intersections = [];
        var i;
        // Check the intersection of 12 lines in aabb with frustum.
        for (i = 0; i < 12; i++) {
            MyMath.intersect.line_frustum(aabbPoints[segmentPair[i][0]], aabbPoints[segmentPair[i][1]], frustum, intersections);
        }
        // Check the intersections of 12 lines in frustum with aabb
        for (i = 0; i < 12; i++) {
            MyMath.intersect.line_aabb(frustumPoints[segmentPair[i][0]], frustumPoints[segmentPair[i][1]], aabb, intersections);
        }
        // Check if 8 corners of aabb is inside frustum
        for (i = 0; i < 8; i++) {
            var ap = aabbPoints[i];
            if (MyMath.inside.point_frustum(ap, frustum)) {
                intersections.push(ap);
            }
        }
        // Check if 8 corners of frustum is inside aabb
        for (i = 0; i < 8; i++) {
            var fp = frustumPoints[i];
            if (MyMath.inside.point_aabb(fp, aabb)) {
                intersections.push(fp);
            }
        }
        return intersections;
    };
    MyMath.intersect.aabb_aabb = function (aabb1, aabb2) {
        // does 1st touch 2nd or inside 2nd
        return ((MyMath.inside.point_slab(aabb1[0], aabb2[0], aabb2[3]) ||
            MyMath.inside.point_slab(aabb1[3], aabb2[0], aabb2[3])) &&
            (MyMath.inside.point_slab(aabb1[1], aabb2[1], aabb2[4]) ||
                MyMath.inside.point_slab(aabb1[4], aabb2[1], aabb2[4])) &&
            (MyMath.inside.point_slab(aabb1[2], aabb2[2], aabb2[5]) ||
                MyMath.inside.point_slab(aabb1[5], aabb2[2], aabb2[5]))) ||
            // does 2nd touch 1st or inside 1st
            ((MyMath.inside.point_slab(aabb2[0], aabb1[0], aabb1[3]) ||
                MyMath.inside.point_slab(aabb2[3], aabb1[0], aabb1[3])) &&
                (MyMath.inside.point_slab(aabb2[1], aabb1[1], aabb1[4]) ||
                    MyMath.inside.point_slab(aabb2[4], aabb1[1], aabb1[4])) &&
                (MyMath.inside.point_slab(aabb2[2], aabb1[2], aabb1[5]) ||
                    MyMath.inside.point_slab(aabb2[5], aabb1[2], aabb1[5])));
    };
    //
    // Inside test
    //
    MyMath.inside = {
        _v0: new Float32Array(3),
        _v1: new Float32Array(3),
        _v2: new Float32Array(3)
    };
    // If P is in triangle ABC
    MyMath.inside.point_triangle = function (A, B, C, P) {
        vec3.subtract(this._v0, C, A);
        vec3.subtract(this._v1, B, A);
        vec3.subtract(this._v2, P, A);
        var dot00 = vec3.dot(this._v0, this._v0);
        var dot01 = vec3.dot(this._v0, this._v1);
        var dot02 = vec3.dot(this._v0, this._v2);
        var dot11 = vec3.dot(this._v1, this._v1);
        var dot12 = vec3.dot(this._v1, this._v2);
        var inverDeno = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * inverDeno;
        if (u < 0 || u > 1) { // if u out of range, return directly
            return false;
        }
        var v = (dot00 * dot12 - dot01 * dot02) * inverDeno;
        if (v < 0 || v > 1) { // if v out of range, return directly
            return false;
        }
        return u + v <= 1;
    };
    MyMath.inside.point_aabb = function (point, aabb) {
        return point[0] > aabb[0] &&
            point[1] > aabb[1] &&
            point[2] > aabb[2] &&
            point[0] < aabb[3] &&
            point[1] < aabb[4] &&
            point[2] < aabb[5];
    };
    MyMath.inside.point_frustum = function (point, frustum) {
        return vec3.dot(frustum[0], point) + frustum[0][3] < 0 &&
            vec3.dot(frustum[1], point) + frustum[1][3] < 0 &&
            vec3.dot(frustum[2], point) + frustum[2][3] < 0 &&
            vec3.dot(frustum[3], point) + frustum[3][3] < 0 &&
            vec3.dot(frustum[4], point) + frustum[4][3] < 0 &&
            vec3.dot(frustum[5], point) + frustum[5][3] < 0;
    };
    MyMath.inside.sphere_frustum = function (sphere, frustum) {
        return vec3.dot(frustum[0], sphere) + frustum[0][3] < -sphere[3] &&
            vec3.dot(frustum[1], sphere) + frustum[1][3] < -sphere[3] &&
            vec3.dot(frustum[2], sphere) + frustum[2][3] < -sphere[3] &&
            vec3.dot(frustum[3], sphere) + frustum[3][3] < -sphere[3] &&
            vec3.dot(frustum[4], sphere) + frustum[4][3] < -sphere[3] &&
            vec3.dot(frustum[5], sphere) + frustum[5][3] < -sphere[3];
    };
    MyMath.inside.point_slab = function (v, min0, max0) {
        return v < max0 && v > min0;
    };
    MyMath.inside.aabb_frustum = function (aabb, frustum) {
        var points = MyMath.aabb.points(aabb);
        return MyMath.inside.point_frustum(points[0], frustum) &&
            MyMath.inside.point_frustum(points[1], frustum) &&
            MyMath.inside.point_frustum(points[2], frustum) &&
            MyMath.inside.point_frustum(points[3], frustum) &&
            MyMath.inside.point_frustum(points[4], frustum) &&
            MyMath.inside.point_frustum(points[5], frustum) &&
            MyMath.inside.point_frustum(points[6], frustum) &&
            MyMath.inside.point_frustum(points[7], frustum);
    };
    MyMath.outside = {};
    MyMath.outside.point_frustum = function (point, frustum) {
        // Interesting thing is inlining this function 
        return vec3.dot(frustum[0], point) + frustum[0][3] > 0 ||
            vec3.dot(frustum[1], point) + frustum[1][3] > 0 ||
            vec3.dot(frustum[2], point) + frustum[2][3] > 0 ||
            vec3.dot(frustum[3], point) + frustum[3][3] > 0 ||
            vec3.dot(frustum[4], point) + frustum[4][3] > 0 ||
            vec3.dot(frustum[5], point) + frustum[5][3] > 0;
    };
    MyMath.outside.sphere_frustum = function (sphere, frustum) {
        return vec3.dot(frustum[0], sphere) + frustum[0][3] > sphere[3] ||
            vec3.dot(frustum[1], sphere) + frustum[1][3] > sphere[3] ||
            vec3.dot(frustum[2], sphere) + frustum[2][3] > sphere[3] ||
            vec3.dot(frustum[3], sphere) + frustum[3][3] > sphere[3] ||
            vec3.dot(frustum[4], sphere) + frustum[4][3] > sphere[3] ||
            vec3.dot(frustum[5], sphere) + frustum[5][3] > sphere[3];
    };
    // see if aabb is entirely at the position side of plane.
    MyMath.outside.aabb_frustum = function (aabb, frustum) {
        // See if the aabb is outside of frustum 
        for (var i = 0; i < 6; i++) {
            // Brute force way. It is 40% slower than p-vertex, so we comment it out. 
            //if (frustum[i][0] * aabb[0][0] + frustum[i][1] * aabb[0][1] + frustum[i][2] * aabb[0][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[1][0] + frustum[i][1] * aabb[0][1] + frustum[i][2] * aabb[0][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[0][0] + frustum[i][1] * aabb[1][1] + frustum[i][2] * aabb[0][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[1][0] + frustum[i][1] * aabb[1][1] + frustum[i][2] * aabb[0][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[0][0] + frustum[i][1] * aabb[0][1] + frustum[i][2] * aabb[1][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[1][0] + frustum[i][1] * aabb[0][1] + frustum[i][2] * aabb[1][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[0][0] + frustum[i][1] * aabb[1][1] + frustum[i][2] * aabb[1][2] + frustum[i][3] > 0 &&
            //    frustum[i][0] * aabb[1][0] + frustum[i][1] * aabb[1][1] + frustum[i][2] * aabb[1][2] + frustum[i][3] > 0) {
            //    return true;
            //}
            // Use p-vertex
            // http://www.txutxi.com/?p=584
            var x = (frustum[i][0] > 0 ? aabb[0] : aabb[3]);
            var y = (frustum[i][1] > 0 ? aabb[1] : aabb[4]);
            var z = (frustum[i][2] > 0 ? aabb[2] : aabb[5]);
            if (frustum[i][0] * x + frustum[i][1] * y + frustum[i][2] * z + frustum[i][3] > 0) {
                return true;
            }
        }
        // if frustum is outside of aabb
        for (var i = 0; i < 3; i++) {
            if (frustum[6][i] > aabb[1][i] &&
                frustum[7][i] > aabb[1][i] &&
                frustum[8][i] > aabb[1][i] &&
                frustum[9][i] > aabb[1][i] &&
                frustum[10][i] > aabb[1][i] &&
                frustum[11][i] > aabb[1][i] &&
                frustum[12][i] > aabb[1][i] &&
                frustum[13][i] > aabb[1][i]) {
                return true;
            }
            if (frustum[6][i] < aabb[0][i] &&
                frustum[7][i] < aabb[0][i] &&
                frustum[8][i] < aabb[0][i] &&
                frustum[9][i] < aabb[0][i] &&
                frustum[10][i] < aabb[0][i] &&
                frustum[11][i] < aabb[0][i] &&
                frustum[12][i] < aabb[0][i] &&
                frustum[13][i] < aabb[0][i]) {
                return true;
            }
        }
        return false;
    };
    MyMath.outside.aabb_aabb = function (aabb1, aabb2) {
        return aabb1[3] <= aabb2[0] || aabb1[0] >= aabb2[3] ||
            aabb1[4] <= aabb2[1] || aabb1[1] >= aabb2[4] ||
            aabb1[5] <= aabb2[2] || aabb1[2] >= aabb2[5];
    };
    MyMath.clamp = function (val, min, max) {
        return Math.min(Math.max(val, min), max);
    };
    MyMath.lerp = function (start, end, ratio) {
        return start + (end - start) * ratio;
    };
    return MyMath;
})());


/***/ }),

/***/ "./00utility/m3d_utils.js":
/*!********************************!*\
  !*** ./00utility/m3d_utils.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_utils.js
// Utilities
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var Utils = {};
    Utils.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };
    Utils.indexOf = function (arr, elem) {
        if (!Utils.isArray(arr)) {
            console.error("Not an array!");
            return -1;
        }
        for (var i = 0, len = arr.length; i < len; ++i) {
            if (arr[i] === elem) {
                return i;
            }
        }
        return -1;
    };
    return Utils;
})());


/***/ }),

/***/ "./01wrapper/m3d_wgl.release.js":
/*!**************************************!*\
  !*** ./01wrapper/m3d_wgl.release.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
//
// m3d_wgl.release.js
// setup webGL
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function SetupWebGL(canvas, parameters) {
        parameters.antialias = (parameters.webgl2 ? false : parameters.samples > 1);
        parameters.depth = (parameters.webgl2 ? false : parameters.depth);
        var gl = WebGLUtils.setupWebGL(canvas, parameters);
        gl.version = gl.getParameter(gl.VERSION);
        var isWebGL2 = (gl.version.match("WebGL 2.0") !== null);
        // Extension detect
        if (isWebGL2) {
            gl.floatTextureExtension = gl.getExtension("EXT_color_buffer_float");
            gl.floatTextureExtension2 = gl.getExtension("OES_texture_float_linear");
            gl.instancingExtension = parameters.instancing; // enable/disable instancing
        }
        else {
            if (parameters.instancing) {
                gl.instancingExtension = gl.getExtension("ANGLE_instanced_arrays");
            }
            if (gl.instancingExtension) {
                //We turn off vao if instance drawing been turned on and supported by browser.
                if (parameters.vao) {
                    console.warn("Instance drawing and VAO cannot use at same time. Turn off VAO.");
                }
                gl.drawElementsInstanced = function (mode, count, type, offset, instanceCount) {
                    gl.instancingExtension.drawElementsInstancedANGLE(mode, count, type, offset, instanceCount);
                };
                gl.vertexAttribDivisor = function (index, divisor) {
                    gl.instancingExtension.vertexAttribDivisorANGLE(index, divisor);
                };
            }
            else {
                if (parameters.vao) {
                    gl.vaoExtension = gl.getExtension("OES_vertex_array_object");
                }
                if (gl.vaoExtension) {
                    gl.deleteVertexArray = function (vao) {
                        return gl.vaoExtension.deleteVertexArrayOES(vao);
                    };
                    gl.bindVertexArray = function (vao) {
                        return gl.vaoExtension.bindVertexArrayOES(vao);
                    };
                    gl.createVertexArray = function () {
                        return gl.vaoExtension.createVertexArrayOES();
                    };
                }
            }
            gl.floatTextureExtension = (gl.getExtension("OES_texture_float") || gl.getExtension("WEBGL_color_buffer_float")) &&
                gl.getExtension("OES_texture_float_linear");
            gl.depthTextureExtension = gl.getExtension("WEBGL_depth_texture") ||
                gl.getExtension("WEBKIT_WEBGL_depth_texture") ||
                gl.getExtension("MOZ_WEBGL_depth_texture");
            gl.uintIBOExtension = gl.getExtension("OES_element_index_uint");
        }
        var syncBuffer = new Uint8Array(4);
        gl.syncGPU = function () {
            if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].browserName === "chrome") {
                gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, syncBuffer);
            }
            else {
                gl.finish(); // gl.finish is not working in Chrome
            }
        };
        gl.isWebGL2 = isWebGL2;
        // The parameters of window buffer.
        gl.wbSamples = parameters.samples;
        gl.wbFormat = (parameters.alpha ? gl.RGBA8 : gl.RGB8);
        gl.wbDepthFormat = (parameters.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24);
        return gl;
    }
    ;
    return SetupWebGL;
})());


/***/ }),

/***/ "./02resource/m3d_buffer.js":
/*!**********************************!*\
  !*** ./02resource/m3d_buffer.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_buffer.js
// The array, element array buffer.
// Only used by m3d_mesh.js now.
//
// Copyright Modelo XX - 2018, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Buffer(name, resourceManager) {
        // private:
        this._name = name;
        this._target = gl.ARRAY_BUFFER;
        // public:
        this.manager = resourceManager;
        this.buffer = gl.createBuffer();
        this.ready = false;
    }
    ;
    Buffer.prototype.destroy = function () {
        if (this.buffer !== null) {
            gl.deleteBuffer(this.buffer);
        }
        if (this.ready) {
            this.ready = false;
            if (this.manager) {
                delete this.manager._buffers[this._name];
                this.manager = null;
            }
        }
    };
    Buffer.prototype.create = function (target, data) {
        if (this.ready) {
            return;
        }
        this._target = target;
        gl.bindBuffer(target, this.buffer);
        gl.bufferData(target, data, gl.STATIC_DRAW);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            // It is very likely out of memory.
            // Clean at the exist.
            gl.deleteBuffer(this.buffer);
            this.buffer = null;
            this.ready = false;
        }
    };
    Buffer.prototype.update = function (data) {
        gl.bindBuffer(this._target, this.buffer);
        gl.bufferData(this._target, data, gl.STATIC_DRAW);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            // It is very likely out of memory.
            // Clean at the exist.
            gl.deleteBuffer(this.buffer);
            this.buffer = null;
            this.ready = false;
        }
    };
    return Buffer;
})());


/***/ }),

/***/ "./02resource/m3d_framebuffer.js":
/*!***************************************!*\
  !*** ./02resource/m3d_framebuffer.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_framebuffer.js
// The OGL resource manager (debug version)
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Framebuffer(name, resourceManager) {
        // private:
        this._name = name;
        this._framebuffer = null;
        this._colorBuffer = null;
        this._depthBuffer = null;
        // public:
        this.ready = false;
        this.manager = resourceManager;
    }
    ;
    Framebuffer.prototype.create = function (colorBuffer, depthBuffer) {
        if (this.ready) {
            return;
        }
        if (!colorBuffer.ready || (depthBuffer && !depthBuffer.ready)) {
            return;
        }
        this._colorBuffer = colorBuffer;
        this._depthBuffer = depthBuffer;
        this._framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        if (this._colorBuffer._rbo) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._colorBuffer._texture);
        }
        else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._colorBuffer._texture, 0);
        }
        if (!this._depthBuffer) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, null, 0);
        }
        else if (this._depthBuffer._rbo) {
            if (this._depthBuffer._format === gl.DEPTH_COMPONENT) {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthBuffer._texture);
            }
            else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthBuffer._texture);
            }
        }
        else {
            if (this._depthBuffer._format === gl.DEPTH_COMPONENT) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
            }
            else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
            }
        }
        this.ready = this._checkCompleteness();
    };
    Framebuffer.prototype._destroy = function () {
        if (this.ready) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, null, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, null);
            gl.deleteFramebuffer(this._framebuffer);
            delete this._framebuffer;
        }
        var err;
        if ((err = gl.getError()) !== gl.NO_ERROR) {
            console.log("GL error in framebuffer._destroy(): " + err);
        }
    };
    Framebuffer.prototype.destroy = function () {
        if (this.ready) {
            this._destroy();
            this.ready = false;
            //modelo3d.debug("framebuffer %s is destroyed.", this._name);
        }
        if (this.manager) {
            delete this.manager._framebuffers[this._name];
            this.manager = null;
        }
    };
    Framebuffer.prototype.resize = function (width, height) {
        if (!this.ready) {
            return;
        }
        // Don't add duplication check here such as if the color buffer and depth
        // buffer are already as the same as required resolution. Since framebuffers
        // can share textures with other framebuffers, these textures may get 
        // updated elsewhere and need to rebind to this framebuffer.
        // 4096 is the max resolution in WebGL 1.0.
        if (width > 4096 || height > 4096) {
            if (width >= height) {
                height = Math.floor(height * 4096 / width);
                width = 4096;
            }
            else {
                width = Math.floor(width * 4096 / height);
                height = 4096;
            }
        }
        this.ready = false;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        // Resize the textures. Note that textures may be shared by multiple framebuffer,
        // but since we are in a single thread, we won't resize the same texture twice given
        // the sanity check in the beginning of texture.resize().
        this._colorBuffer.resize(width, height);
        this._depthBuffer.resize(width, height);
        if (!this._colorBuffer.ready || !this._depthBuffer.ready) {
            this.destroy();
            return;
        }
        if (this._colorBuffer._rbo) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._colorBuffer._texture);
        }
        else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._colorBuffer._texture, 0);
        }
        if (!this._depthBuffer) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, null, 0);
        }
        else if (this._depthBuffer._rbo) {
            if (this._depthBuffer._format === gl.DEPTH_COMPONENT) {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthBuffer._texture);
            }
            else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthBuffer._texture);
            }
        }
        else {
            if (this._depthBuffer._format === gl.DEPTH_COMPONENT) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
            }
            else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
            }
        }
        this.ready = this._checkCompleteness();
    };
    Framebuffer.prototype._checkCompleteness = function () {
        var completed = false;
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        switch (status) {
            case gl.FRAMEBUFFER_COMPLETE:
                completed = true;
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                console.log("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                console.log("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETEDIMENSIONS:
                console.log("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                console.log("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                break;
            default:
                console.log("Incomplete framebuffer: " + status);
                break;
        }
        if (gl.getError() !== gl.NO_ERROR) {
            completed = false;
        }
        return completed;
    };
    Framebuffer.prototype.getWidth = function () {
        if (!this.ready) {
            return -1;
        }
        return this._colorBuffer.width;
    };
    Framebuffer.prototype.getHeight = function () {
        if (!this.ready) {
            return -1;
        }
        return this._colorBuffer.height;
    };
    Framebuffer.prototype.use = function () {
        if (!this.ready) {
            console.error("framebuffer " + this._name + " is not ready.");
            return;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    };
    Framebuffer.prototype.getColorBuffer = function () {
        if (this.ready) {
            return this._colorBuffer;
        }
        return null;
    };
    Framebuffer.prototype.getDepthBuffer = function () {
        if (this.ready) {
            return this._depthBuffer;
        }
        return null;
    };
    Framebuffer.prototype.discard = function () {
        if (this.ready) {
            if (this._depthBuffer) {
                this._depthBuffer.discard();
            }
            this._colorBuffer.discard();
            gl.deleteFramebuffer(this._framebuffer);
            this._framebuffer = null;
            this.ready = false;
        }
    };
    Framebuffer.prototype.restore = function () {
        if (!this.ready) {
            if (this._depthBuffer) {
                this._depthBuffer.restore();
            }
            this._colorBuffer.restore();
            if (!this._colorBuffer.ready || (this._depthBuffer && !this._depthBuffer.ready)) {
                return;
            }
            this._framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
            if (this._colorBuffer._rbo) {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._colorBuffer._texture, 0);
            }
            else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._colorBuffer._texture, 0);
            }
            if (!this._depthBuffer) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, null, 0);
            }
            else if (this._depthBuffer._rbo) {
                if (this._depthBuffer._format === gl.DEPTH_COMPONENT) {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthBuffer._texture);
                }
                else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthBuffer._texture);
                }
            }
            else {
                if (this._depthBuffer._format === gl.DEPTH_COMPONENT) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
                }
                else {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
                }
            }
            this.ready = this._checkCompleteness();
        }
    };
    Framebuffer.prototype.copy = function (other, mask) {
        if (this._name === other._name) {
            return;
        }
        if (gl.isWebGL2) {
            var w = this._colorBuffer.width;
            var h = this._colorBuffer.height;
            // Save the current binding.
            var drawFramebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, other._framebuffer);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._framebuffer);
            gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, mask, gl.NEAREST);
            // Restore
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, drawFramebuffer);
        }
    };
    return Framebuffer;
})());


/***/ }),

/***/ "./02resource/m3d_geometric_shape.js":
/*!*******************************************!*\
  !*** ./02resource/m3d_geometric_shape.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_mesh_attribute.js */ "./02resource/m3d_mesh_attribute.js");
//
// m3d_geometric_shape.js
// Create vertices and indices data of a few geometric primitives
//
// Copyright Modelo XX - 2017, All rights reserved.
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function GeometricShape() {
        this.vertices = null;
        this.indices = null;
        this.attributes = null;
        this.indexType = null;
        this.primitive = null;
    }
    ;
    // transform the geometry by 4x4 matrix
    GeometricShape.prototype.transform = function (matrix) {
        if (!this.attributes) {
            return;
        }
        var numFloats = this.attributes.values[0].stride / 4;
        var hasNormal = this.attributes.hasNormal;
        var out = [0, 0, 0, 0];
        var v = [0, 0, 0];
        // FIXME: We don't use normal matrix.
        if (hasNormal) {
            modelo3d.debug("suppose no scaling in transform.");
        }
        for (var i = 0, len = this.vertices.length; i < len; i += numFloats) {
            v[0] = this.vertices[i];
            v[1] = this.vertices[i + 1];
            v[2] = this.vertices[i + 2];
            vec3.transformMat4(out, v, matrix);
            this.vertices[i] = out[0];
            this.vertices[i + 1] = out[1];
            this.vertices[i + 2] = out[2];
            if (hasNormal) {
                v[0] = this.vertices[i + 3];
                v[1] = this.vertices[i + 4];
                v[2] = this.vertices[i + 5];
                v[3] = 0;
                vec4.transformMat4(out, v, matrix);
                vec3.normalize(out, out);
                this.vertices[i + 3] = out[0];
                this.vertices[i + 4] = out[1];
                this.vertices[i + 5] = out[2];
            }
        }
    };
    // rotate by z, then by y, and by x finally
    GeometricShape.prototype.rotate = function (x, y, z) {
        var matrix = mat4.create();
        var tmp = mat4.create();
        mat4.rotateZ(matrix, tmp, z);
        mat4.rotateY(tmp, matrix, y);
        mat4.rotateX(matrix, tmp, x);
        this.transform(matrix);
    };
    GeometricShape.prototype.translate = function (x, y, z) {
        var matrix = mat4.create();
        mat4.fromTranslation(matrix, [x, y, z]);
        this.transform(matrix);
    };
    GeometricShape.prototype.scale = function (x, y, z) {
        var matrix = mat4.create();
        mat4.fromScaling(matrix, [x, y, z]);
        this.transform(matrix);
    };
    GeometricShape.prototype.merge = function (a, b) {
        if (a.attributes.values[0].stride !== b.attributes.values[0].stride) {
            return;
        }
        var vertices = new Float32Array(a.vertices.length + b.vertices.length);
        var i, j;
        for (i = 0; i < a.vertices.length; i++) {
            vertices[i] = a.vertices[i];
        }
        for (i = 0, j = a.vertices.length; i < b.vertices.length; i++, j++) {
            vertices[j] = b.vertices[i];
        }
        var indices = new Uint16Array(a.indices.length + b.indices.length);
        for (i = 0; i < a.indices.length; i++) {
            indices[i] = a.indices[i];
        }
        var numVertices = a.vertices.length / (a.attributes.values[0].stride / 4);
        for (i = 0, j = a.indices.length; i < b.indices.length; i++, j++) {
            indices[j] = b.indices[i] + numVertices;
        }
        this.vertices = vertices;
        this.indices = indices;
        this.attributes = a.attributes;
        this.indexType = gl.UNSIGNED_SHORT;
    };
    GeometricShape.prototype.createHeatmapCube = function (backFace) {
        var vertices = new Float32Array(8 * 4 * 6);
        var indices = new Uint8Array(6 * 2 * 3);
        var voff;
        var ioff;
        // -x
        voff = 0;
        ioff = 0;
        vertices[voff + 0] = 0;
        vertices[voff + 1] = 0;
        vertices[voff + 2] = 0;
        vertices[voff + 3] = -1.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 0.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = 0;
        vertices[voff + 9] = 1.0;
        vertices[voff + 10] = 0;
        vertices[voff + 11] = -1.0;
        vertices[voff + 12] = 0.0;
        vertices[voff + 13] = 0.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 1.0;
        vertices[voff + 16] = 0;
        vertices[voff + 17] = 0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = -1.0;
        vertices[voff + 20] = 0.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = 1.0;
        vertices[voff + 24] = 0;
        vertices[voff + 25] = 1.0;
        vertices[voff + 26] = 1.0;
        vertices[voff + 27] = -1.0;
        vertices[voff + 28] = 0.0;
        vertices[voff + 29] = 0.0;
        vertices[voff + 30] = 1.0;
        vertices[voff + 31] = 1.0;
        indices[ioff + 0] = 0;
        indices[ioff + 1] = 2;
        indices[ioff + 2] = 1;
        indices[ioff + 3] = 1;
        indices[ioff + 4] = 2;
        indices[ioff + 5] = 3;
        // +x
        voff += 32;
        ioff += 6;
        vertices[voff + 0] = 1.0;
        vertices[voff + 1] = 0.0;
        vertices[voff + 2] = 0.0;
        vertices[voff + 3] = 1.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 0.0;
        vertices[voff + 7] = 0.0;
        vertices[voff + 8] = 1.0;
        vertices[voff + 9] = 1.0;
        vertices[voff + 10] = 0.0;
        vertices[voff + 11] = 1.0;
        vertices[voff + 12] = 0.0;
        vertices[voff + 13] = 0.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = 1.0;
        vertices[voff + 17] = 0.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 1.0;
        vertices[voff + 20] = 0.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = 0.0;
        vertices[voff + 24] = 1.0;
        vertices[voff + 25] = 1.0;
        vertices[voff + 26] = 1.0;
        vertices[voff + 27] = 1.0;
        vertices[voff + 28] = 0.0;
        vertices[voff + 29] = 0.0;
        vertices[voff + 30] = 1.0;
        vertices[voff + 31] = 0.0;
        indices[ioff + 0] = 4;
        indices[ioff + 1] = 5;
        indices[ioff + 2] = 6;
        indices[ioff + 3] = 5;
        indices[ioff + 4] = 7;
        indices[ioff + 5] = 6;
        // -y
        voff += 32;
        ioff += 6;
        vertices[voff + 0] = 0.0;
        vertices[voff + 1] = 0.0;
        vertices[voff + 2] = 0.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = -1.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 0.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = 0.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = 1.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = -1.0;
        vertices[voff + 13] = 0.0;
        vertices[voff + 14] = 0.0;
        vertices[voff + 15] = 1.0;
        vertices[voff + 16] = 1.0;
        vertices[voff + 17] = 0.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 0.0;
        vertices[voff + 20] = -1.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = 0.0;
        vertices[voff + 24] = 1.0;
        vertices[voff + 25] = 0.0;
        vertices[voff + 26] = 0.0;
        vertices[voff + 27] = 0.0;
        vertices[voff + 28] = -1.0;
        vertices[voff + 29] = 0.0;
        vertices[voff + 30] = 0.0;
        vertices[voff + 31] = 0.0;
        indices[ioff + 0] = 8;
        indices[ioff + 1] = 11;
        indices[ioff + 2] = 9;
        indices[ioff + 3] = 11;
        indices[ioff + 4] = 10;
        indices[ioff + 5] = 9;
        // +y
        voff += 32;
        ioff += 6;
        vertices[voff + 0] = 0.0;
        vertices[voff + 1] = 1.0;
        vertices[voff + 2] = 0.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = 1.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 1.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = 0.0;
        vertices[voff + 9] = 1.0;
        vertices[voff + 10] = 1.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = 1.0;
        vertices[voff + 13] = 0.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 1.0;
        vertices[voff + 16] = 1.0;
        vertices[voff + 17] = 1.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 0.0;
        vertices[voff + 20] = 1.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 1.0;
        vertices[voff + 23] = 0.0;
        vertices[voff + 24] = 1.0;
        vertices[voff + 25] = 1.0;
        vertices[voff + 26] = 0.0;
        vertices[voff + 27] = 0.0;
        vertices[voff + 28] = 1.0;
        vertices[voff + 29] = 0.0;
        vertices[voff + 30] = 1.0;
        vertices[voff + 31] = 0.0;
        indices[ioff + 0] = 12;
        indices[ioff + 1] = 13;
        indices[ioff + 2] = 14;
        indices[ioff + 3] = 12;
        indices[ioff + 4] = 14;
        indices[ioff + 5] = 15;
        // -z
        voff += 32;
        ioff += 6;
        vertices[voff + 0] = 0.0;
        vertices[voff + 1] = 0.0;
        vertices[voff + 2] = 0.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = -1.0;
        vertices[voff + 6] = 0.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = 1.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = 0.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = 0.0;
        vertices[voff + 13] = -1.0;
        vertices[voff + 14] = 0.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = 1.0;
        vertices[voff + 17] = 1.0;
        vertices[voff + 18] = 0.0;
        vertices[voff + 19] = 0.0;
        vertices[voff + 20] = 0.0;
        vertices[voff + 21] = -1.0;
        vertices[voff + 22] = 1.0;
        vertices[voff + 23] = 0.0;
        vertices[voff + 24] = 0.0;
        vertices[voff + 25] = 1.0;
        vertices[voff + 26] = 0.0;
        vertices[voff + 27] = 0.0;
        vertices[voff + 28] = 0.0;
        vertices[voff + 29] = -1.0;
        vertices[voff + 30] = 1.0;
        vertices[voff + 31] = 1.0;
        indices[ioff + 0] = 16;
        indices[ioff + 1] = 19;
        indices[ioff + 2] = 18;
        indices[ioff + 3] = 16;
        indices[ioff + 4] = 18;
        indices[ioff + 5] = 17;
        // +z
        voff += 32;
        ioff += 6;
        vertices[voff + 0] = 0.0;
        vertices[voff + 1] = 0.0;
        vertices[voff + 2] = 1.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = 1.0;
        vertices[voff + 6] = 0.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = 1.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = 1.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = 0.0;
        vertices[voff + 13] = 1.0;
        vertices[voff + 14] = 0.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = 1.0;
        vertices[voff + 17] = 1.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 0.0;
        vertices[voff + 20] = 0.0;
        vertices[voff + 21] = 1.0;
        vertices[voff + 22] = 1.0;
        vertices[voff + 23] = 0.0;
        vertices[voff + 24] = 0.0;
        vertices[voff + 25] = 1.0;
        vertices[voff + 26] = 1.0;
        vertices[voff + 27] = 0.0;
        vertices[voff + 28] = 0.0;
        vertices[voff + 29] = 1.0;
        vertices[voff + 30] = 1.0;
        vertices[voff + 31] = 1.0;
        indices[ioff + 0] = 20;
        indices[ioff + 1] = 21;
        indices[ioff + 2] = 23;
        indices[ioff + 3] = 23;
        indices[ioff + 4] = 21;
        indices[ioff + 5] = 22;
        if (backFace) {
            for (var i = 0; i < indices.length / 3; i++) {
                var temp = indices[i * 3];
                indices[i * 3] = indices[i * 3 + 2];
                indices[i * 3 + 2] = temp;
            }
        }
        this.vertices = vertices;
        this.indices = indices;
        this.primitive = gl.TRIANGLES;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT, gl.FLOAT);
        this.indexType = gl.UNSIGNED_BYTE;
    };
    GeometricShape.prototype.createWiredCube = function () {
        var vertices = new Float32Array(8 * 3);
        var indices = new Uint8Array(12 * 2);
        vertices[0] = -1.0;
        vertices[1] = -1.0;
        vertices[2] = -1.0;
        vertices[3] = 1.0;
        vertices[4] = -1.0;
        vertices[5] = -1.0;
        vertices[6] = 1.0;
        vertices[7] = 1.0;
        vertices[8] = -1.0;
        vertices[9] = -1.0;
        vertices[10] = 1.0;
        vertices[11] = -1.0;
        vertices[12] = -1.0;
        vertices[13] = -1.0;
        vertices[14] = 1.0;
        vertices[15] = 1.0;
        vertices[16] = -1.0;
        vertices[17] = 1.0;
        vertices[18] = 1.0;
        vertices[19] = 1.0;
        vertices[20] = 1.0;
        vertices[21] = -1.0;
        vertices[22] = 1.0;
        vertices[23] = 1.0;
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 1;
        indices[3] = 2;
        indices[4] = 2;
        indices[5] = 3;
        indices[6] = 3;
        indices[7] = 0;
        indices[8] = 0;
        indices[9] = 4;
        indices[10] = 1;
        indices[11] = 5;
        indices[12] = 2;
        indices[13] = 6;
        indices[14] = 3;
        indices[15] = 7;
        indices[16] = 4;
        indices[17] = 5;
        indices[18] = 5;
        indices[19] = 6;
        indices[20] = 6;
        indices[21] = 7;
        indices[22] = 7;
        indices[23] = 4;
        this.vertices = vertices;
        this.indices = indices;
        this.indexType = gl.UNSIGNED_BYTE;
        this.primitive = gl.LINES;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT);
    };
    GeometricShape.prototype.createSolidCube = function () {
        var vertices = new Float32Array(6 * 4 * 6);
        var indices = new Uint8Array(6 * 2 * 3);
        var voff;
        var ioff;
        // -x
        voff = 0;
        ioff = 0;
        vertices[voff + 0] = -1.0;
        vertices[voff + 1] = -1.0;
        vertices[voff + 2] = -1.0;
        vertices[voff + 3] = -1.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = -1.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = -1.0;
        vertices[voff + 9] = -1.0;
        vertices[voff + 10] = 0.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = -1.0;
        vertices[voff + 13] = -1.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = -1.0;
        vertices[voff + 16] = 0.0;
        vertices[voff + 17] = 0.0;
        vertices[voff + 18] = -1.0;
        vertices[voff + 19] = 1.0;
        vertices[voff + 20] = 1.0;
        vertices[voff + 21] = -1.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = 0.0;
        indices[ioff + 0] = 0;
        indices[ioff + 1] = 2;
        indices[ioff + 2] = 1;
        indices[ioff + 3] = 1;
        indices[ioff + 4] = 2;
        indices[ioff + 5] = 3;
        // +x
        voff += 24;
        ioff += 6;
        vertices[voff + 0] = 1.0;
        vertices[voff + 1] = -1.0;
        vertices[voff + 2] = -1.0;
        vertices[voff + 3] = 1.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 1.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = -1.0;
        vertices[voff + 9] = 1.0;
        vertices[voff + 10] = 0.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = 1.0;
        vertices[voff + 13] = -1.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 1.0;
        vertices[voff + 16] = 0.0;
        vertices[voff + 17] = 0.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 1.0;
        vertices[voff + 20] = 1.0;
        vertices[voff + 21] = 1.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = 0.0;
        indices[ioff + 0] = 4;
        indices[ioff + 1] = 5;
        indices[ioff + 2] = 6;
        indices[ioff + 3] = 5;
        indices[ioff + 4] = 7;
        indices[ioff + 5] = 6;
        // -y
        voff += 24;
        ioff += 6;
        vertices[voff + 0] = -1.0;
        vertices[voff + 1] = -1.0;
        vertices[voff + 2] = -1.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = -1.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 1.0;
        vertices[voff + 7] = -1.0;
        vertices[voff + 8] = -1.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = -1.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = -1.0;
        vertices[voff + 13] = -1.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = -1.0;
        vertices[voff + 17] = 0.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = -1.0;
        vertices[voff + 20] = 1.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = -1.0;
        vertices[voff + 23] = 0.0;
        indices[ioff + 0] = 8;
        indices[ioff + 1] = 9;
        indices[ioff + 2] = 11;
        indices[ioff + 3] = 11;
        indices[ioff + 4] = 10;
        indices[ioff + 5] = 8;
        // +y
        voff += 24;
        ioff += 6;
        vertices[voff + 0] = -1.0;
        vertices[voff + 1] = 1.0;
        vertices[voff + 2] = -1.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = 1.0;
        vertices[voff + 5] = 0.0;
        vertices[voff + 6] = 1.0;
        vertices[voff + 7] = 1.0;
        vertices[voff + 8] = -1.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = 1.0;
        vertices[voff + 11] = 0.0;
        vertices[voff + 12] = -1.0;
        vertices[voff + 13] = 1.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = 1.0;
        vertices[voff + 17] = 0.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 1.0;
        vertices[voff + 20] = 1.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 1.0;
        vertices[voff + 23] = 0.0;
        indices[ioff + 0] = 12;
        indices[ioff + 1] = 14;
        indices[ioff + 2] = 13;
        indices[ioff + 3] = 13;
        indices[ioff + 4] = 14;
        indices[ioff + 5] = 15;
        // -z
        voff += 24;
        ioff += 6;
        vertices[voff + 0] = -1.0;
        vertices[voff + 1] = -1.0;
        vertices[voff + 2] = -1.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = -1.0;
        vertices[voff + 6] = 1.0;
        vertices[voff + 7] = -1.0;
        vertices[voff + 8] = -1.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = 0.0;
        vertices[voff + 11] = -1.0;
        vertices[voff + 12] = -1.0;
        vertices[voff + 13] = 1.0;
        vertices[voff + 14] = -1.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = 0.0;
        vertices[voff + 17] = -1.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 1.0;
        vertices[voff + 20] = -1.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = -1.0;
        indices[ioff + 0] = 16;
        indices[ioff + 1] = 19;
        indices[ioff + 2] = 17;
        indices[ioff + 3] = 19;
        indices[ioff + 4] = 16;
        indices[ioff + 5] = 18;
        // +z
        voff += 24;
        ioff += 6;
        vertices[voff + 0] = -1.0;
        vertices[voff + 1] = -1.0;
        vertices[voff + 2] = 1.0;
        vertices[voff + 3] = 0.0;
        vertices[voff + 4] = 0.0;
        vertices[voff + 5] = 1.0;
        vertices[voff + 6] = 1.0;
        vertices[voff + 7] = -1.0;
        vertices[voff + 8] = 1.0;
        vertices[voff + 9] = 0.0;
        vertices[voff + 10] = 0.0;
        vertices[voff + 11] = 1.0;
        vertices[voff + 12] = -1.0;
        vertices[voff + 13] = 1.0;
        vertices[voff + 14] = 1.0;
        vertices[voff + 15] = 0.0;
        vertices[voff + 16] = 0.0;
        vertices[voff + 17] = 1.0;
        vertices[voff + 18] = 1.0;
        vertices[voff + 19] = 1.0;
        vertices[voff + 20] = 1.0;
        vertices[voff + 21] = 0.0;
        vertices[voff + 22] = 0.0;
        vertices[voff + 23] = 1.0;
        indices[ioff + 0] = 20;
        indices[ioff + 1] = 21;
        indices[ioff + 2] = 23;
        indices[ioff + 3] = 23;
        indices[ioff + 4] = 22;
        indices[ioff + 5] = 20;
        this.vertices = vertices;
        this.indices = indices;
        this.primitive = gl.TRIANGLES;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT);
        this.indexType = gl.UNSIGNED_BYTE;
    };
    GeometricShape.prototype.createQuad = function () {
        var vertices = new Float32Array(20);
        var indices = new Uint8Array(6);
        vertices[0] = -1.0;
        vertices[1] = -1.0;
        vertices[2] = 0.0;
        vertices[3] = 0.0;
        vertices[4] = 0.0;
        vertices[5] = 1.0;
        vertices[6] = -1.0;
        vertices[7] = 0.0;
        vertices[8] = 1.0;
        vertices[9] = 0.0;
        vertices[10] = 1.0;
        vertices[11] = 1.0;
        vertices[12] = 0.0;
        vertices[13] = 1.0;
        vertices[14] = 1.0;
        vertices[15] = -1.0;
        vertices[16] = 1.0;
        vertices[17] = 0.0;
        vertices[18] = 0.0;
        vertices[19] = 1.0;
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 2;
        indices[4] = 3;
        indices[5] = 0;
        this.vertices = vertices;
        this.indices = indices;
        this.primitive = gl.TRIANGLES;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, null, gl.FLOAT, null);
        this.indexType = gl.UNSIGNED_BYTE;
    };
    GeometricShape.prototype.createSolidQuad = function () {
        var vertices = new Float32Array(12);
        var indices = new Uint8Array(6);
        vertices[0] = -1.0;
        vertices[1] = -1.0;
        vertices[2] = 0.0;
        vertices[3] = 1.0;
        vertices[4] = -1.0;
        vertices[5] = 0.0;
        vertices[6] = 1.0;
        vertices[7] = 1.0;
        vertices[8] = 0.0;
        vertices[9] = -1.0;
        vertices[10] = 1.0;
        vertices[11] = 0.0;
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 2;
        indices[4] = 3;
        indices[5] = 0;
        this.vertices = vertices;
        this.indices = indices;
        this.primitive = gl.TRIANGLES;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT);
        this.indexType = gl.UNSIGNED_BYTE;
    };
    GeometricShape.prototype.createPoint = function () {
        var vertices = new Float32Array(10);
        var indices = new Uint8Array(1);
        vertices[0] = 0;
        vertices[1] = 0;
        vertices[2] = 0;
        vertices[3] = 0;
        vertices[4] = 0;
        vertices[5] = 1;
        vertices[6] = 0;
        vertices[7] = 0;
        vertices[8] = 0;
        vertices[9] = 0;
        indices[0] = 0;
        this.vertices = vertices;
        this.indices = indices;
        this.primitive = gl.POINTS;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT, null, gl.FLOAT);
        this.indexType = gl.UNSIGNED_BYTE;
    };
    GeometricShape.prototype.createSphere = function (ringNumber, segmentNumber) {
        var vertices = new Float32Array((ringNumber + 1) * (segmentNumber + 1) * 8);
        var indices = new Uint16Array(6 * ringNumber * (segmentNumber + 1));
        var n = new Float32Array(3);
        var deltaRingAngle = Math.PI / ringNumber;
        var deltaSegAngle = 2.0 * Math.PI / segmentNumber;
        var iIndex = 0;
        var vIndex = 0;
        var index = 0;
        for (var ring = 0; ring <= ringNumber; ++ring) {
            var r0 = Math.sin(ring * deltaRingAngle);
            var z0 = Math.cos(ring * deltaRingAngle);
            // Generate the group of segments for the current ring
            for (var seg = 0; seg <= segmentNumber; ++seg) {
                var x0 = r0 * Math.cos(seg * deltaSegAngle);
                var y0 = r0 * Math.sin(seg * deltaSegAngle);
                // Add one vertex to the strip which makes up the sphere
                // Position.
                vertices[index++] = x0;
                vertices[index++] = y0;
                vertices[index++] = z0;
                // Normal
                n[0] = x0;
                n[1] = y0;
                n[2] = z0;
                vec3.normalize(n, n);
                vertices[index++] = n[0];
                vertices[index++] = n[1];
                vertices[index++] = n[2];
                // texture coordinate
                vertices[index++] = seg / segmentNumber;
                vertices[index++] = ring / ringNumber;
                if (ring !== ringNumber) {
                    // each vertex (except the last) has six indices pointing to it
                    indices[iIndex++] = vIndex + segmentNumber + 1;
                    indices[iIndex++] = vIndex;
                    indices[iIndex++] = vIndex + segmentNumber;
                    indices[iIndex++] = vIndex + segmentNumber + 1;
                    indices[iIndex++] = vIndex + 1;
                    indices[iIndex++] = vIndex;
                    vIndex++;
                }
            }
        }
        this.vertices = vertices;
        this.indices = indices;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT, gl.FLOAT);
        this.primitive = gl.TRIANGLES;
        this.indexType = gl.UNSIGNED_SHORT;
    };
    GeometricShape.prototype.createLine = function () {
        var vertices = new Float32Array(6);
        var indices = new Uint8Array(2);
        vertices[0] = -0.5;
        vertices[1] = 0;
        vertices[2] = 0;
        vertices[3] = 0.5;
        vertices[4] = 0;
        vertices[5] = 0;
        indices[0] = 0;
        indices[1] = 1;
        this.vertices = vertices;
        this.indices = indices;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT);
        this.attributes.primitive = gl.LINES;
        this.primitive = gl.LINES;
        this.indexType = gl.UNSIGNED_BYTE;
    };
    GeometricShape.prototype.createTorus = function (majorRadius, minorRadius, majorSegments, minorSegments) {
        var PI2 = Math.PI * 2;
        var vertices = new Float32Array(minorSegments * majorSegments * 8);
        var indices = new Uint16Array(minorSegments * majorSegments * 2 * 3);
        var index = 0;
        var center = [0, 0];
        var vertex = [0, 0, 0];
        var normal = [0, 0, 0];
        var i, j;
        for (j = 0; j < minorSegments; j++) {
            for (i = 0; i < majorSegments; i++) {
                var u = i / majorSegments * PI2;
                var v = j / minorSegments * PI2;
                center[0] = majorRadius * Math.cos(u);
                center[1] = majorRadius * Math.sin(u);
                vertex[0] = (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u);
                vertex[1] = (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u),
                    vertex[2] = minorRadius * Math.sin(v);
                vec3.subtract(normal, vertex, center);
                vec3.normalize(normal, normal);
                vertices[index + 0] = vertex[0];
                vertices[index + 1] = vertex[1];
                vertices[index + 2] = vertex[2];
                vertices[index + 3] = normal[0];
                vertices[index + 4] = normal[1];
                vertices[index + 5] = normal[2];
                vertices[index + 6] = i / majorRadius;
                vertices[index + 7] = j / minorRadius;
                index += 8;
            }
        }
        index = 0;
        for (j = 0; j < minorSegments; j++) {
            for (i = 0; i < majorSegments; i++) {
                var i0 = (i + 1) % majorSegments;
                var j0 = (j + 1) % minorSegments;
                var a = majorSegments * j + i;
                var b = majorSegments * j + i0;
                var c = majorSegments * j0 + i;
                var d = majorSegments * j0 + i0;
                indices[index] = a;
                indices[index + 1] = c;
                indices[index + 2] = b;
                indices[index + 3] = c;
                indices[index + 4] = d;
                indices[index + 5] = b;
                index += 6;
            }
        }
        this.vertices = vertices;
        this.indices = indices;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT, gl.FLOAT);
        this.primitive = gl.TRIANGLES;
        this.indexType = gl.UNSIGNED_SHORT;
    };
    GeometricShape.prototype.createCone = function (radius, height, segments) {
        var PI2 = Math.PI * 2;
        var vertices = new Float32Array(segments * 6 * 3 + 6);
        var indices = new Uint16Array(segments * 9);
        var index = 0;
        var normal = [0, 0, 0];
        var nr = radius * height * height / (radius * radius + height * height);
        var nh = radius * radius * height / (radius * radius + height * height);
        var j;
        for (j = 0; j < segments; j++) {
            var u = j / segments * PI2;
            var cosU = Math.cos(u);
            var sinU = Math.sin(u);
            vertices[index] = radius * cosU;
            vertices[index + 1] = radius * sinU;
            vertices[index + 2] = 0;
            normal[0] = nr * cosU;
            normal[1] = nr * sinU;
            normal[2] = nh;
            vec3.normalize(normal, normal);
            vertices[index + 3] = normal[0];
            vertices[index + 4] = normal[1];
            vertices[index + 5] = normal[2];
            index += 6;
            vertices[index] = 0;
            vertices[index + 1] = 0;
            vertices[index + 2] = height;
            vertices[index + 3] = normal[0];
            vertices[index + 4] = normal[1];
            vertices[index + 5] = normal[2];
            index += 6;
            vertices[index] = 0;
            vertices[index + 1] = 0;
            vertices[index + 2] = height;
            vertices[index + 3] = 0;
            vertices[index + 4] = 0;
            vertices[index + 5] = -1;
            index += 6;
        }
        vertices[index + 0] = 0;
        vertices[index + 1] = 0;
        vertices[index + 2] = 0;
        index = 0;
        for (j = 0; j < segments; j++) {
            var j0 = (j + 1) % segments;
            indices[index] = j * 3 + 1;
            indices[index + 1] = j * 3;
            indices[index + 2] = j0 * 3;
            indices[index + 3] = j0 * 3;
            indices[index + 4] = j0 * 3 + 1;
            indices[index + 5] = j * 3 + 1;
            index += 6;
        }
        for (j = 0; j < segments; j++) {
            var j0 = (j + 1) % segments;
            indices[index] = segments * 3;
            indices[index + 1] = j0 * 3 + 2;
            indices[index + 2] = j * 3 + 2;
            index += 3;
        }
        this.vertices = vertices;
        this.indices = indices;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT);
        this.primitive = gl.TRIANGLES;
        this.indexType = gl.UNSIGNED_SHORT;
    };
    GeometricShape.prototype.createCylinder = function (radius, height, segments) {
        var PI2 = Math.PI * 2;
        var vertices = new Float32Array(segments * 6 * 4 + 6);
        var indices = new Uint16Array(segments * 12);
        var index = 0;
        var j, j0;
        for (j = 0; j < segments; j++) {
            var u = j / segments * PI2;
            var cosU = Math.cos(u);
            var sinU = Math.sin(u);
            vertices[index] = radius * cosU;
            vertices[index + 1] = radius * sinU;
            vertices[index + 2] = 0;
            vertices[index + 3] = cosU;
            vertices[index + 4] = sinU;
            vertices[index + 5] = 0;
            index += 6;
            vertices[index] = radius * cosU;
            vertices[index + 1] = radius * sinU;
            vertices[index + 2] = height;
            vertices[index + 3] = cosU;
            vertices[index + 4] = sinU;
            vertices[index + 5] = 0;
            index += 6;
            vertices[index] = radius * cosU;
            vertices[index + 1] = radius * sinU;
            vertices[index + 2] = 0;
            vertices[index + 3] = 0;
            vertices[index + 4] = 0;
            vertices[index + 5] = -1;
            index += 6;
            vertices[index] = radius * cosU;
            vertices[index + 1] = radius * sinU;
            vertices[index + 2] = height;
            vertices[index + 3] = 0;
            vertices[index + 4] = 0;
            vertices[index + 5] = 1;
            index += 6;
        }
        vertices[index + 0] = 0;
        vertices[index + 1] = 0;
        vertices[index + 2] = 0;
        vertices[index + 3] = 0;
        vertices[index + 4] = 0;
        vertices[index + 5] = height;
        index = 0;
        for (j = 0; j < segments; j++) {
            j0 = (j + 1) % segments;
            indices[index] = j * 4 + 1;
            indices[index + 1] = j * 4;
            indices[index + 2] = j0 * 4;
            indices[index + 3] = j0 * 4;
            indices[index + 4] = j0 * 4 + 1;
            indices[index + 5] = j * 4 + 1;
            index += 6;
        }
        for (j = 0; j < segments; j++) {
            j0 = (j + 1) % segments;
            indices[index] = segments * 4;
            indices[index + 1] = j0 * 4 + 2;
            indices[index + 2] = j * 4 + 2;
            indices[index] = segments * 4 + 1;
            indices[index + 1] = j0 * 4 + 3;
            indices[index + 2] = j * 4 + 3;
            index += 6;
        }
        this.vertices = vertices;
        this.indices = indices;
        this.attributes = new _m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.attributes.builtin(gl.FLOAT, gl.FLOAT);
        this.primitive = gl.TRIANGLES;
        this.indexType = gl.UNSIGNED_SHORT;
    };
    GeometricShape.prototype.createArrow = function (radius, height) {
        var c = new GeometricShape();
        var t = new GeometricShape();
        c.createCylinder(radius * 0.6, height * 0.9, 8); // stem
        t.createCone(radius, height * 0.1, 8); // tip
        t.translate(0, 0, height * 0.9);
        // merge two primitives into one
        var r = new GeometricShape();
        r.merge(c, t);
        this.vertices = r.vertices;
        this.indices = r.indices;
        this.attributes = r.attributes;
        this.indexType = r.indexType;
        this.primitive = gl.TRIANGLES;
    };
    return GeometricShape;
})());


/***/ }),

/***/ "./02resource/m3d_mesh.js":
/*!********************************!*\
  !*** ./02resource/m3d_mesh.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_geometric_shape.js */ "./02resource/m3d_geometric_shape.js");
//
// m3d_mesh.js
// The mesh wrapper
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Mesh(name, resourceManager) {
        // private:
        this._name = name;
        this._vao = null;
        this._vbo = null;
        this._ibo = null;
        this._primitive = 4; // by default it is triangle  
        this._attributes = null;
        this._type = gl.UNSIGNED_INT;
        this._vboBase = 0;
        this._iboBase = 0;
        this._shared = false;
        // public:
        this.ready = false;
        this.length = 0;
        this.bytes = 0;
        this.indexSize = 2;
        this.manager = resourceManager;
    }
    ;
    Mesh.prototype.destroy = function () {
        if (this.ready) {
            if (!this._shared) {
                gl.deleteBuffer(this._vbo);
                this._vbo = false;
                delete this._vbo;
                gl.deleteBuffer(this._ibo);
                this._ibo = false;
                delete this._ibo;
            }
            if (this._vao) {
                gl.deleteVertexArray(this.vao);
                this._vao = false;
                delete this._vao;
            }
            this.ready = false;
            var err;
            if ((err = gl.getError()) !== gl.NO_ERROR) {
                console.log("GL error in mesh.destroy(): " + err);
            }
        }
        if (this.manager) {
            delete this.manager._meshes[this._name];
            this.manager = null;
        }
        //modelo3d.debug("mesh %s is destroyed.", this._name);
    };
    // The vertex buffer and index buffer are shared with many meshes. 
    // Note that when buffer is destroyed, these shared meshes should be destroy explicitly. Otherwise, 
    // it will generate rendering errors.
    Mesh.prototype.createShared = function (primitive, attributes, vertices, indices, type, vertexBuffer, indexBuffer) {
        if (this.ready) {
            return;
        }
        this._primitive = primitive;
        this._attributes = attributes;
        this.bytes = (vertices.byteLength + indices.byteLength);
        this._type = type || gl.UNSIGNED_SHORT;
        if (this._type === gl.UNSIGNED_BYTE) {
            this.length = indices.byteLength;
            this.indexSize = 1;
        }
        else if (this._type === gl.UNSIGNED_INT) {
            this.length = indices.byteLength / 4;
            this.indexSize = 4;
        }
        else {
            this.length = indices.byteLength / 2;
            this.indexSize = 2;
        }
        this._vbo = vertexBuffer.buffer;
        this._ibo = indexBuffer.buffer;
        if ((gl.isWebGL2 || gl.vaoExtension)) {
            this._vao = gl.createVertexArray();
            gl.bindVertexArray(this._vao);
            this._attributes.bind(this._vbo);
            gl.bindVertexArray(null);
        }
        this._shared = true;
        this._iboBase = indices.byteOffset;
        this._vboBase = vertices.byteOffset;
        this.ready = (vertexBuffer.ready && indexBuffer.ready);
    };
    Mesh.prototype.create = function (primitive, attributes, vertices, indices, type) {
        if (this.ready) {
            return;
        }
        this._vbo = gl.createBuffer();
        this._ibo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this._primitive = primitive;
        this._attributes = attributes;
        if ((gl.isWebGL2 || gl.vaoExtension)) {
            this._vao = gl.createVertexArray();
            gl.bindVertexArray(this._vao);
            this._attributes.bind(this._vbo);
            gl.bindVertexArray(null);
        }
        this.bytes = (vertices.byteLength + indices.byteLength);
        this._type = type || gl.UNSIGNED_SHORT;
        if (this._type === gl.UNSIGNED_BYTE) {
            this.length = indices.byteLength;
            this.indexSize = 1;
        }
        else if (this._type === gl.UNSIGNED_INT) {
            this.length = indices.byteLength / 4;
            this.indexSize = 4;
        }
        else {
            this.length = indices.byteLength / 2;
            this.indexSize = 2;
        }
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
            //modelo3d.debug("mesh %s is created.", this._name);
        }
        else {
            // It is very likely out of memory.
            // Clean at the exist.
            gl.deleteBuffer(this._vbo);
            gl.deleteBuffer(this._ibo);
            if (this._vao) {
                gl.deleteVertexArray(this._vao);
            }
        }
    };
    Mesh.prototype.createHeatmapCube = function (backFace) {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createHeatmapCube(backFace);
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createWiredCube = function () {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createWiredCube();
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createArrow = function (g, radius, height) {
        if (this.ready) {
            return;
        }
        if (!g) {
            g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
            g.createArrow(radius, height);
        }
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createSolidCube = function () {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createSolidCube();
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createQuad = function () {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createQuad();
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createSolidQuad = function () {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createSolidQuad();
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createPoint = function () {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createPoint();
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    // ring number is the number of slices in y direction.
    // segmentNumber is the number of slices in longitude direction.
    Mesh.prototype.createSphere = function (ringNumber, segmentNumber) {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createSphere(ringNumber, segmentNumber);
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createLine = function () {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createLine();
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.createTorus = function (majorRadius, minorRadius, majorSegments, minorSegments) {
        if (this.ready) {
            return;
        }
        var g = new _m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        g.createTorus(majorRadius, minorRadius, majorSegments, minorSegments);
        this.create(g.primitive, g.attributes, g.vertices, g.indices, g.indexType);
    };
    Mesh.prototype.render = function () {
        gl.drawElements(this._primitive, this.length, this._type, this._iboBase);
    };
    Mesh.prototype.renderSub = function (offset, count) {
        gl.drawElements(this._primitive, count, this._type, offset + this._iboBase);
    };
    Mesh.prototype.renderInstanced = function (instanceCount) {
        gl.drawElementsInstanced(this._primitive, this.length, this._type, this._iboBase, instanceCount);
    };
    Mesh.prototype.use = function () {
        if (!this.ready) {
            console.error("mesh " + this._name + " is not ready.");
            return;
        }
        if (this._vao) {
            gl.bindVertexArray(this._vao);
        }
        else {
            this._attributes.bind(this._vbo);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
    };
    // FIXME: check if the parameter type is needed?
    Mesh.prototype.update = function (vertices, indices, type) {
        // We assume the attributes don't change.
        if (this.ready) {
            gl.deleteBuffer(this._vbo);
            gl.deleteBuffer(this._ibo);
            if (this._vao) {
                gl.deleteVertexArray(this._vao);
            }
            this._vbo = gl.createBuffer();
            this._ibo = gl.createBuffer();
            this._vboBase = 0;
            this._iboBase = 0;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            if ((gl.isWebGL2 || gl.vaoExtension)) {
                this._vao = gl.createVertexArray();
                gl.bindVertexArray(this._vao);
                this._attributes.bind(this._vbo);
                gl.bindVertexArray(null);
            }
            if (gl.getError() !== gl.NO_ERROR) {
                this.ready = false;
            }
            this._type = type || gl.UNSIGNED_SHORT;
            if (this._type === gl.UNSIGNED_BYTE) {
                this.length = indices.byteLength;
            }
            else if (this._type === gl.UNSIGNED_SHORT) {
                this.length = indices.byteLength / 2;
            }
            else if (this._type === gl.UNSIGNED_INT) {
                this.length = indices.byteLength / 4;
            }
            this.bytes = (vertices.byteLength + indices.byteLength);
        }
    };
    Mesh.prototype.isTriangle = function () {
        return this._primitive >= gl.TRIANGLES;
    };
    Mesh.prototype.isLine = function () {
        return this._primitive === gl.LINES ||
            this._primitive === gl.LINE_LOOP ||
            this._primitive == gl.LINE_STRIP;
    };
    Mesh.prototype.hasColor = function () {
        return this._attributes.hasColor;
    };
    // Create another mesh from this one with specified regions. Each region has 
    // the index count, index offset, vertex offset and vertex count, . 
    // region = { indicesBytes, indicesOffset, verticesBytes, verticesOffset};
    Mesh.prototype.slice = function (regions) {
        if (!gl.isWebGL2) {
            console.error("createSubMesh is only supported in WebGL2");
            return this;
        }
        // Calculate the size of the new mesh. 
        var newVerticesBytes = 0;
        var newIndicesBytes = 0;
        for (var i = 0, len = regions.length; i < len; i++) {
            newVerticesBytes += regions[i].verticesBytes;
            newIndicesBytes += regions[i].indicesBytes;
        }
        var newMesh = this.manager.getMesh((parseFloat(this._name) + Math.random()).toString());
        newMesh._vbo = gl.createBuffer();
        newMesh._ibo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, newMesh._vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(newVerticesBytes), gl.STATIC_DRAW);
        var offset = 0;
        gl.bindBuffer(gl.COPY_READ_BUFFER, this._vbo);
        for (var i = 0, len = regions.length; i < len; i++) {
            gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.ARRAY_BUFFER, this._vboBase + regions[i].verticesOffset, offset, regions[i].verticesBytes);
            offset += regions[i].verticesBytes;
        }
        var indicesBuffer = null;
        var newIndicesBuffer = null;
        switch (this.indexSize) {
            case 2:
                indicesBuffer = new Uint16Array(this.length);
                newIndicesBuffer = new Uint16Array(newIndicesBytes / 2);
                break;
            case 1:
                indicesBuffer = new Uint8Array(this.length);
                newIndicesBuffer = new Uint8Array(newIndicesBytes);
                break;
            case 4:
                indicesBuffer = new Uint32Array(this.length);
                newIndicesBuffer = new Uint32Array(newIndicesBytes / 4);
                break;
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
        gl.getBufferSubData(gl.ELEMENT_ARRAY_BUFFER, this._iboBase, indicesBuffer);
        var dstIndexOffset = 0;
        var dstVertexOffset = 0;
        for (var i = 0, len = regions.length; i < len; i++) {
            var srcVertexOffset = regions[i].verticesOffset / this._attributes.values[0].stride;
            var indexCount = regions[i].indicesBytes / this.indexSize;
            var srcIndexOffset = regions[i].indicesOffset / this.indexSize;
            for (var j = 0; j < indexCount; j++) {
                newIndicesBuffer[j + dstIndexOffset] = indicesBuffer[j + srcIndexOffset] - srcVertexOffset + dstVertexOffset;
            }
            dstIndexOffset += indexCount;
            dstVertexOffset += regions[i].verticesBytes / this._attributes.values[0].stride;
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, newMesh._ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, newIndicesBuffer, gl.STATIC_DRAW);
        newMesh._primitive = this._primitive;
        newMesh._attributes = this._attributes;
        if (gl.isWebGL2 || gl.vaoExtension) {
            newMesh._vao = gl.createVertexArray();
            gl.bindVertexArray(newMesh._vao);
            newMesh._attributes.bind(newMesh._vbo);
            gl.bindVertexArray(null);
        }
        newMesh.bytes = (newIndicesBytes + newVerticesBytes);
        newMesh._type = this._type;
        newMesh.indexSize = this.indexSize;
        newMesh.length = newIndicesBytes / newMesh.indexSize;
        if (gl.getError() === gl.NO_ERROR) {
            newMesh.ready = true;
            //modelo3d.debug("mesh %s is created.", this._name);
        }
        else {
            // It is very likely out of memory.
            // Clean at the exist.
            gl.deleteBuffer(newMesh._vbo);
            gl.deleteBuffer(newMesh._ibo);
            if (newMesh._vao) {
                gl.deleteVertexArray(newMesh._vao);
            }
        }
        return newMesh;
    };
    // Replace the subdata of IBO
    Mesh.prototype.ibSubData = function (offset, bufferData) {
        this.ready = false;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, this._iboBase + offset, bufferData);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            gl.deleteBuffer(this._ibo);
            gl.deleteBuffer(this._vbo);
            if (this._vao) {
                gl.deleteVertexArray(this.vao);
                this._vao = false;
                delete this._vao;
            }
        }
    };
    // Replace the subdata of VBO
    Mesh.prototype.vbSubData = function (offset, bufferData) {
        this.ready = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
        gl.bufferSubData(gl.ARRAY_BUFFER, this._vboBase + offset, bufferData);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            gl.deleteBuffer(this._ibo);
            gl.deleteBuffer(this._vbo);
            if (this._vao) {
                gl.deleteVertexArray(this.vao);
                this._vao = false;
                delete this._vao;
            }
        }
    };
    // Download nbytes of VBO from offset and write the chunk of data to buffer starting at bufferOffset
    Mesh.prototype.getVBSubData = function (offset, buffer) {
        // FIXME: only support in WebGL 2
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
        gl.getBufferSubData(gl.ARRAY_BUFFER, this._vboBase + offset, buffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        // FIXME: handle GL error, e.g., read out of range.
    };
    Mesh.prototype.getIBSubData = function (offset, buffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
        gl.getBufferSubData(gl.ELEMENT_ARRAY_BUFFER, this._iboBase + offset, buffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    };
    return Mesh;
})());


/***/ }),

/***/ "./02resource/m3d_mesh_attribute.js":
/*!******************************************!*\
  !*** ./02resource/m3d_mesh_attribute.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_mesh.js
// The mesh attributes
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function GetSizeOfType(type) {
        switch (type) {
            case gl.UNSIGNED_BYTE:
            case gl.BYTE:
                return 1;
            case gl.UNSIGNED_SHORT:
            case gl.SHORT:
                return 2;
            case gl.FLOAT:
            case gl.INT:
            case gl.UNSIGNED_INT:
                return 4;
            default:
                throw new Error("unknown GL type");
                return 0;
        }
        return -1;
    }
    ;
    //
    // MeshAttribute
    //
    function MeshAttribute(name, type, normalized, size) {
        this.name = name;
        this.index = -1;
        this.type = type;
        this.offset = 0;
        this.stride = 0;
        this.size = size;
        this.normalized = !!normalized;
    }
    ;
    //
    // MeshAttributes
    //
    function MeshAttributes() {
        this.values = [];
        this.hasNormal = false;
        this.hasColor = false;
        this.hasUV = false;
        this.id = 0;
        this.primitive = gl.TRIANGLES;
        // We compress the mesh by absorbing normals into positions.
        // The last 8 bit of position coordinate value carries a 8-bit normal. For
        // example, the x coordinate of position is 32-bit floating number. In compression
        // mode, its last/insignificant 8-bit is for normal.
        this.compressed = false;
    }
    ;
    // Create built-in attributes.
    MeshAttributes.prototype.builtin = function (positionType, normalType, uvType, colorType) {
        var offset = 0;
        var attribute = null;
        if (positionType) {
            attribute = new MeshAttribute("m_aPosition", positionType, false, 3);
            attribute.index = 0;
            attribute.offset = 0;
            this.values.push(attribute);
            offset = 3 * GetSizeOfType(positionType);
        }
        if (normalType) {
            var size = 3;
            var normalized = false;
            size = 3;
            normalized = false;
            if (normalType !== gl.FLOAT) {
                normalized = true;
                size = 4;
            }
            attribute = new MeshAttribute("m_aNormal", normalType, normalized, size);
            attribute.index = 1;
            attribute.offset = offset;
            this.values.push(attribute);
            offset += size * GetSizeOfType(normalType);
            this.hasNormal = true;
        }
        if (uvType) {
            attribute = new MeshAttribute("m_aTexCoord", uvType, false, 2);
            attribute.index = 4;
            attribute.offset = offset;
            this.values.push(attribute);
            offset += 2 * GetSizeOfType(uvType);
            this.hasUV = true;
        }
        if (colorType) {
            attribute = new MeshAttribute("m_aColor", colorType, false, 4);
            attribute.index = 5;
            attribute.offset = offset;
            if (normalType !== gl.FLOAT) {
                attribute.normalized = true;
            }
            this.values.push(attribute);
            offset += 4 * GetSizeOfType(colorType);
            this.hasColor = true;
        }
        for (var i = 0, len = this.values.length; i < len; ++i) {
            this.values[i].stride = offset;
        }
        this.id = (positionType ? 16 : 0) +
            (normalType ? 8 : 0) +
            (uvType ? 4 : 0) +
            (colorType ? 2 : 0);
    };
    MeshAttributes.prototype.compress = function () {
        // we are about to compress normal.
        if (!this.hasNormal || this.compressed) {
            return;
        }
        this.compressed = true;
        this.id += 32;
        var values = [];
        values.push(this.values[0]); // position
        var attribute = null;
        attribute = new MeshAttribute("m_aNormal0", gl.BYTE, true, 1, null);
        attribute.index = 1;
        attribute.offset = 0;
        values.push(attribute);
        attribute = new MeshAttribute("m_aNormal1", gl.BYTE, true, 1, null);
        attribute.index = 2;
        attribute.offset = 4;
        values.push(attribute);
        attribute = new MeshAttribute("m_aNormal2", gl.BYTE, true, 1, null);
        attribute.index = 3;
        attribute.offset = 8;
        values.push(attribute);
        for (var i = 2, len = this.values.length; i < len; i++) {
            this.values[i].offset -= 4;
            values.push(this.values[i]);
        }
        var stride = this.values[0].stride - 4;
        for (var i = 0, len = values.length; i < len; ++i) {
            values[i].stride = stride;
        }
        this.values = values;
    };
    // Clone this mesh attribute to a new one
    MeshAttributes.prototype.clone = function () {
        var ret = new MeshAttributes();
        ret.id = this.id;
        ret.hasNormal = this.hasNormal;
        ret.hasColor = this.hasColor;
        ret.hasUV = this.hasUV;
        ret.compressed = this.compressed;
        ret.primitive = this.primitive;
        ret.values = new Array(this.values.length);
        for (var i = 0, len = this.values.length; i < len; i++) {
            var v = this.values[i];
            ret.values[i] = new MeshAttribute(v.name, v.type, v.normalized, v.size);
            ret.values[i].index = v.index;
            ret.values[i].offset = v.offset;
            ret.values[i].stride = v.stride;
        }
        return ret;
    };
    // Add the customized attributes. It should not have the same
    // name as any of built-in attributes.
    MeshAttributes.prototype.add = function (name, type, normalized, size) {
        if (!this.has(name)) {
            var attribute = new MeshAttribute(name, type, normalized, size);
            this.values.push(attribute);
        }
    };
    MeshAttributes.prototype.has = function (attribute) {
        for (var i = 0, len = this.values.length; i < len; ++i) {
            if (this.values[i].name === attribute) {
                return true;
            }
        }
        return false;
    };
    MeshAttributes.prototype.bind = function (buffer) {
        // FIXME: in Chrome 62, a dangling vertex attrib will crash the context.
        gl.disableVertexAttribArray(1);
        gl.disableVertexAttribArray(2);
        gl.disableVertexAttribArray(3);
        gl.disableVertexAttribArray(4);
        gl.disableVertexAttribArray(5);
        gl.disableVertexAttribArray(6);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        // We already enabled vertex attribute 0 at GL initialization.
        for (var i = 0, len = this.values.length; i < len; i++) {
            var index = this.values[i].index;
            gl.vertexAttribPointer(index, this.values[i].size, this.values[i].type, this.values[i].normalized, this.values[i].stride, this.values[i].offset);
            gl.enableVertexAttribArray(index);
        }
    };
    return MeshAttributes;
})());


/***/ }),

/***/ "./02resource/m3d_resource_manager.js":
/*!********************************************!*\
  !*** ./02resource/m3d_resource_manager.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _m3d_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_texture.js */ "./02resource/m3d_texture.js");
/* harmony import */ var _m3d_mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_mesh.js */ "./02resource/m3d_mesh.js");
/* harmony import */ var _m3d_staged_mesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./m3d_staged_mesh.js */ "./02resource/m3d_staged_mesh.js");
/* harmony import */ var _m3d_framebuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./m3d_framebuffer.js */ "./02resource/m3d_framebuffer.js");
/* harmony import */ var _m3d_shader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./m3d_shader.js */ "./02resource/m3d_shader.js");
/* harmony import */ var _m3d_buffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./m3d_buffer.js */ "./02resource/m3d_buffer.js");
//
// m3d_resourcemanager.js
// The OGL resource manager 
//
// Copyright Modelo XX - 2017, All rights reserved.







/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function ResourceManager() {
        this._shaders = {};
        this._meshes = {};
        this._textures = {};
        this._framebuffers = {};
        this._buffers = {};
        // Create the default framebuffer.
        this._framebuffers["default"] = {
            ready: true,
            manager: null,
            _name: "default",
            _framebuffer: null,
            destroy: function () {
            },
            use: function () {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            },
            resize: function (width, height) {
            },
            discard: function () {
            },
            restore: function () {
            },
            getWidth: function () {
                return _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
            },
            getHeight: function () {
                return _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
            },
            copy: function (other, mask) {
                if (this._name === other._name) {
                    return;
                }
                if (gl.isWebGL2) {
                    var w = other._colorBuffer.width;
                    var h = other._colorBuffer.height;
                    // Save the current binding.
                    var drawFramebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
                    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, other._framebuffer);
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
                    gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, mask, gl.NEAREST);
                    // Restore
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, drawFramebuffer);
                }
            }
        };
    }
    ; // end of ResourceManager
    ResourceManager.prototype.destroy = function () {
        for (var mesh in this._meshes) {
            this._meshes[mesh].manager = null;
            this._meshes[mesh].destroy();
        }
        for (var framebuffer in this._framebuffers) {
            this._framebuffers[framebuffer].manager = null;
            this._framebuffers[framebuffer].destroy();
        }
        for (var texture in this._textures) {
            // Prevent changing the this._textures inside texture.destroy().
            this._textures[texture].manager = null;
            this._textures[texture].destroy();
        }
        for (var shader in this._shaders) {
            this._shaders[shader].manager = null;
            this._shaders[shader].destroy();
        }
        for (var buffer in this._buffers) {
            this._buffers[buffer].manager = null;
            this._buffers[buffer].destroy();
        }
        this._textures = null;
        this._meshes = null;
        this._framebuffers = null;
        this._buffers = null;
        this._shaders = null;
        delete this._textures;
        delete this._meshes;
        delete this._framebuffers;
        delete this._shaders;
        delete this._buffers;
    };
    ResourceManager.prototype.getTexture = function (name) {
        if (!this._textures[name]) {
            this._textures[name] = new _m3d_texture_js__WEBPACK_IMPORTED_MODULE_1__["default"](name, this);
        }
        return this._textures[name];
    };
    // name can be 
    // "default": the default window buffer
    // All above should be used a temporary framebuffer as they will be reused
    // in different modules.
    // "[module-function]": custom name beginning with module, e.g., shadow-src
    ResourceManager.prototype.getFramebuffer = function (name) {
        if (!this._framebuffers[name]) {
            this._framebuffers[name] = new _m3d_framebuffer_js__WEBPACK_IMPORTED_MODULE_4__["default"](name, this);
        }
        return this._framebuffers[name];
    };
    ResourceManager.prototype.getShader = function (name, flags) {
        // So all shaders with same flags will generate unique ID.
        flags = flags || [];
        flags.sort();
        if (flags) {
            name = name + flags.join("_");
        }
        if (!this._shaders[name]) {
            this._shaders[name] = new _m3d_shader_js__WEBPACK_IMPORTED_MODULE_5__["default"](name, this);
        }
        return this._shaders[name];
    };
    ResourceManager.prototype.getBuffer = function (name) {
        if (!this._buffers[name]) {
            this._buffers[name] = new _m3d_buffer_js__WEBPACK_IMPORTED_MODULE_6__["default"](name, this);
        }
        return this._buffers[name];
    };
    ResourceManager.prototype.getMesh = function (name) {
        if (!this._meshes[name]) {
            this._meshes[name] = new _m3d_mesh_js__WEBPACK_IMPORTED_MODULE_2__["default"](name, this);
        }
        return this._meshes[name];
    };
    ResourceManager.prototype.getStagedMesh = function (name) {
        if (!this._meshes[name]) {
            this._meshes[name] = new _m3d_staged_mesh_js__WEBPACK_IMPORTED_MODULE_3__["default"](name, this);
        }
        return this._meshes[name];
    };
    ResourceManager.prototype.hasTexture = function (name) {
        return this._textures.hasOwnProperty(name);
    };
    ResourceManager.prototype.hasFramebuffer = function (name) {
        return this._framebuffers.hasOwnProperty(name);
    };
    ResourceManager.prototype.hasShader = function (name) {
        return this._shaders.hasOwnProperty(name);
    };
    ResourceManager.prototype.hasBuffer = function (name) {
        return this._buffers.hasOwnProperty(name);
    };
    ResourceManager.prototype.hasMesh = function (name) {
        return this._meshes.hasOwnProperty(name);
    };
    // This function will release GPU resources as much
    // as possible when called.
    ResourceManager.prototype.discard = function () {
        for (var framebuffer in this._framebuffers) {
            this._framebuffers[framebuffer].discard();
        }
        ;
    };
    // This function will re-upload resources from CPU to GPU.
    // It is the reverse function to pause().
    ResourceManager.prototype.restore = function () {
        for (var framebuffer in this._framebuffers) {
            this._framebuffers[framebuffer].restore();
        }
    };
    ResourceManager.prototype.openFile = function (file, onSuccess) {
        if (window.cordova) {
            this._openFileFromCordova(file, onSuccess);
        }
        else {
            this._openFileFromBrowser(file, onSuccess);
        }
    };
    ResourceManager.prototype._openFileFromCordova = function (file, onSuccess) {
        if (this.ready) {
            return onSuccess();
        }
        var fileReader = angular.element(document).find("body").injector().get("FileReaderService");
        var path = cordova.file.applicationDirectory + "www";
        var fileUse = file.replace("/", "");
        fileReader.readAsText(path, fileUse)
            .then(function (data) {
            if (onSuccess) {
                onSuccess(data);
            }
        })
            .catch(function (error) {
            console.error(error);
        });
    };
    ResourceManager.prototype._openFileFromBrowser = function (file, onSuccess) {
        if (this.ready) {
            return onSuccess();
        }
        var xhr = new XMLHttpRequest();
        xhr.open("GET", file + "?t=" + cacheBuster);
        xhr.onload = function (eventData) {
            if (xhr.status === 200 || xhr.status === 206) {
                if (onSuccess) {
                    onSuccess(xhr.response);
                }
            }
            else {
                console.error("failed to load " + file + ", http status: " + xhr.status);
            }
        };
        xhr.send();
    };
    // NOTE: Very time consuming. Should be ony called every few seconds.
    ResourceManager.prototype.getMemStats = function (stats) {
        stats.textureKBytes = 0;
        stats.textureCount = 0;
        for (var texture in this._textures) {
            if (this._textures[texture].ready) {
                stats.textureKBytes += this._textures[texture].getSize();
                stats.textureCount++;
            }
        }
        stats.meshKBytes = 0;
        stats.meshCount = 0;
        for (var mesh in this._meshes) {
            if (this._meshes[mesh].ready) {
                stats.meshKBytes += (this._meshes[mesh].bytes) / 1024;
                stats.meshCount++;
            }
        }
        stats.framebufferCount = 0;
        for (var framebuffer in this._framebuffers) {
            if (this._framebuffers[framebuffer].ready) {
                stats.framebufferCount++;
            }
        }
        stats.shaderCount = 0;
        for (var shader in this._shaders) {
            if (this._shaders[shader].ready) {
                stats.shaderCount++;
            }
        }
    };
    return ResourceManager;
})());


/***/ }),

/***/ "./02resource/m3d_shader.js":
/*!**********************************!*\
  !*** ./02resource/m3d_shader.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../00utility/m3d_utils.js */ "./00utility/m3d_utils.js");
//
// m3d_shader.js
// The shader (gl.program) wrapper
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function _UniformObject(loc) {
        this.loc = loc;
        this.upload = null;
    }
    var blockData = null;
    // Initialize uniform block
    _UniformObject.prototype.initialize = function (name, program) {
        this.uniforms = {};
        var uniformLocation = gl.getUniformBlockIndex(program, name);
        gl.uniformBlockBinding(program, uniformLocation, this.loc);
        var blockSize = gl.getActiveUniformBlockParameter(program, uniformLocation, gl.UNIFORM_BLOCK_DATA_SIZE);
        this.blockSize = 0;
        var uniformIndices = gl.getActiveUniformBlockParameter(program, uniformLocation, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES);
        for (var i = 0, len = uniformIndices.length; i < len; i++) {
            var uniform = gl.getActiveUniform(program, uniformIndices[i]);
            var uniformName = uniform.name.replace(/[_\w]+./, '');
            this.uniforms[uniformName] = { type: uniform.type, size: uniform.size };
            switch (uniform.type) {
                case gl.INT:
                case gl.FLOAT:
                    this.blockSize += 4 * uniform.size;
                    break;
                case gl.INT_VEC2:
                case gl.FLOAT_VEC2:
                    this.blockSize += 8 * uniform.size;
                    break;
                case gl.INT_VEC3:
                case gl.FLOAT_VEC3:
                    this.blockSize += 12 * uniform.size;
                    break;
                case gl.INT_VEC4:
                case gl.FLOAT_VEC4:
                    this.blockSize += 16 * uniform.size;
                    break;
                case gl.FLOAT_MAT4:
                    this.blockSize += 64 * uniform.size;
                    break;
                case gl.FLOAT_MAT3:
                    this.blockSize += 48 * uniform.size;
                    break;
            }
        }
        if (this.blockSize !== blockSize) {
            console.warn("uniform block " + name + " has packing problem!");
        }
        if (gl.isWebGL2) {
            this.blockBuffer = null;
            this.blockBuffer = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, this.blockBuffer);
            blockData = new Float32Array(this.blockSize);
            gl.bufferData(gl.UNIFORM_BUFFER, blockData, gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        }
    };
    _UniformObject.prototype.destroy = function () {
        this.uniforms = null;
        delete this.uniforms;
    };
    function UniformUpload1fv(val) {
        gl.uniform1fv(this.loc, val);
    }
    ;
    function UniformUpload1f(val) {
        gl.uniform1f(this.loc, val);
    }
    ;
    function UniformUpload2f(val) {
        gl.uniform2fv(this.loc, val);
    }
    ;
    function UniformUpload3f(val) {
        gl.uniform3fv(this.loc, val);
    }
    ;
    function UniformUpload4f(val) {
        gl.uniform4fv(this.loc, val);
    }
    ;
    function UniformUpload1b(val) {
        gl.uniform1i(this.loc, val ? 1 : 0);
    }
    ;
    function UniformUpload1i(val) {
        gl.uniform1i(this.loc, val);
    }
    ;
    function UniformUpload2i(val) {
        gl.uniform2i(this.loc, val[0], val[1]);
    }
    ;
    function UniformUpload3i(val) {
        gl.uniform3i(this.loc, val[0], val[1], val[2]);
    }
    ;
    function UniformUpload4i(val) {
        gl.uniform4i(this.loc, val[0], val[1], val[2], val[3]);
    }
    ;
    function UniformUploadMat4(val) {
        gl.uniformMatrix4fv(this.loc, false, val);
    }
    ;
    function UniformUploadMat3(val) {
        gl.uniformMatrix3fv(this.loc, false, val);
    }
    ;
    function UniformBlockUpload(buffer) {
        gl.bindBufferBase(gl.UNIFORM_BUFFER, this.loc, this.blockBuffer);
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.blockBuffer);
        gl.bufferSubData(gl.UNIFORM_BUFFER, 0, buffer, 0, buffer.byteLength / 4);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    }
    ;
    function Shader(name, resourceManager) {
        // private:
        this._program = null;
        // public:
        this.manager = resourceManager;
        this.name = name;
        this.ready = false;
        this.reservedUniforms = {};
        this.userUniforms = {};
        this.shaderSource = null; // Available when this shader is created from ShaderSource
        this.flags = []; // Compiling flags
        this.attributes = {}; // The vertex attributes
    }
    ;
    Shader.prototype.destroy = function () {
        if (this.ready) {
            for (var i = 0, len = this.reservedUniforms.length; i < len; i++) {
                this.reservedUniforms[i].destroy();
            }
            this.reservedUniforms = null;
            delete this.reservedUniforms;
            for (var i = 0, len = this.userUniforms.length; i < len; i++) {
                this.userUniforms[i].destroy();
            }
            this.userUniforms = null;
            delete this.userUniforms;
            this.shaderSource = null;
            delete this.shaderSource;
            this.attributes = null;
            delete this.attributes;
            gl.deleteProgram(this._program);
            delete this._program;
            this.ready = false;
            var err;
            if ((err = gl.getError()) !== gl.NO_ERROR) {
                console.log("GL error in shader.destroy(): " + err);
            }
        }
        if (this.manager) {
            delete this.manager._shaders[this.name];
            this.manager = null;
        }
        //modelo3d.debug("shader %s is destroyed.", this.name);
    };
    Shader.prototype.createFromSource = function (vsSource, fsSource, flags) {
        if (this.ready) {
            return;
        }
        if (flags) {
            this.flags = flags.slice(0);
        }
        else {
            this.flags = [];
        }
        var vsSource1 = this._preprocess(vsSource, flags);
        var fsSource1 = this._preprocess(fsSource, flags);
        this._compile(vsSource1, fsSource1);
    };
    Shader.prototype._preprocess = function (str, flags) {
        var includeLines = [true];
        var includeLine = true;
        var lines = str.split("\n");
        var outputLines = [];
        var i, j, len, len1, defines, reversed;
        for (i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            if (line === "") {
                continue;
            }
            if (line[0] === "#" && line[1] !== "v") {
                if (line[1] === "i" && line[2] === "f") {
                    includeLine = true;
                    var defineStr = line.substr(4).replace(/^\s+|\s+$/g, '');
                    defines = null;
                    if (defineStr.indexOf('||') !== -1) {
                        defines = defineStr.split("||");
                        includeLine = false;
                        for (j = 0, len1 = defines.length; j < len1; j++) {
                            var define = defines[j].replace(/^\s+|\s+$/g, '');
                            reversed = false;
                            if (define[0] === '!') {
                                reversed = true;
                                define = define.substring(1);
                            }
                            if (_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].indexOf(flags, define) !== -1) {
                                includeLine = !reversed;
                            }
                        }
                    }
                    else if (defineStr.indexOf('&&') !== -1) {
                        defines = defineStr.split("&&");
                        includeLine = true;
                        for (j = 0, len1 = defines.length; j < len1; j++) {
                            define = defines[j].replace(/^\s+|\s+$/g, '');
                            if (define[0] === '!') {
                                define = define.substring(1);
                                if (_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].indexOf(flags, define) !== -1) {
                                    includeLine = false;
                                    break;
                                }
                            }
                            else {
                                if (_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].indexOf(flags, define) === -1) {
                                    includeLine = false;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        reversed = false;
                        if (defineStr[0] === '!') {
                            reversed = true;
                            defineStr = defineStr.substring(1);
                        }
                        if (_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].indexOf(flags, defineStr) !== -1) {
                            // When the macro is defined and it is not a NOT.
                            includeLine = !reversed;
                        }
                        else {
                            includeLine = reversed;
                        }
                    }
                    includeLines.push(includeLine);
                }
                else if (line[1] === "e" && line[2] === "l" &&
                    line[3] === "s" && line[4] === "e") {
                    includeLines[includeLines.length - 1] = !includeLines[includeLines.length - 1];
                }
                else if (line[1] === "e" && line[2] === "n" &&
                    line[3] === "d" && line[4] === "i" &&
                    line[5] === "f") {
                    includeLines.pop();
                }
                // AND operator of includeLines
                includeLine = true;
                for (j = 0, len1 = includeLines.length; j < len1; ++j) {
                    includeLine = includeLines[j] && includeLine;
                    if (!includeLine) {
                        break;
                    }
                }
            }
            else {
                if (includeLine) {
                    outputLines.push(line);
                }
            }
        }
        return outputLines.join("\n");
    };
    Shader.prototype.createFromShaderSource = function (shaderSource, flags) {
        if (this.ready) {
            return;
        }
        flags = flags || [];
        if (gl.isWebGL2) {
            if (flags.indexOf("WEBGL2") === -1) {
                flags.push("WEBGL2");
            }
        }
        //console.log(shaderSource.name + (flags? "_" + flags.join('_') : ""));
        //
        this.shaderSource = shaderSource;
        if (this.shaderSource.ready) {
            this.createFromSource(shaderSource.vsSource, shaderSource.fsSource, flags);
        }
        else {
            console.warn(name + "'s source is not ready");
        }
    };
    Shader.prototype._compile = function (vsSource, fsSource) {
        if (this.ready) {
            return;
        }
        this.ready = false;
        if (this._program) {
            gl.deleteProgram(this._program);
        }
        this._program = gl.createProgram();
        var vsShader = gl.createShader(gl.VERTEX_SHADER);
        var fsShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vsShader, vsSource);
        gl.compileShader(vsShader);
        gl.shaderSource(fsShader, fsSource);
        gl.compileShader(fsShader);
        if (!gl.getShaderParameter(vsShader, gl.COMPILE_STATUS)) {
            var msg = "failed to compile vertex shader " + this.name + "\n\n" +
                gl.getShaderInfoLog(vsShader);
            console.log(vsSource);
            console.error(msg);
            gl.deleteProgram(this._program);
            gl.deleteShader(vsShader);
            return;
        }
        if (!gl.getShaderParameter(fsShader, gl.COMPILE_STATUS)) {
            var msg = "failed to compile fragment shader " + this.name + "\n\n" +
                gl.getShaderInfoLog(fsShader);
            console.log(fsSource);
            console.error(msg);
            gl.deleteProgram(this._program);
            gl.deleteShader(fsShader);
            return;
        }
        gl.attachShader(this._program, vsShader);
        gl.attachShader(this._program, fsShader);
        // Specify the built-in attribute locations.
        gl.bindAttribLocation(this._program, 0, "m_aPosition");
        gl.bindAttribLocation(this._program, 1, "m_aNormal0");
        gl.bindAttribLocation(this._program, 2, "m_aNormal1");
        gl.bindAttribLocation(this._program, 3, "m_aNormal2");
        gl.bindAttribLocation(this._program, 4, "m_aTexCoord");
        gl.bindAttribLocation(this._program, 5, "m_aColor");
        gl.bindAttribLocation(this._program, 6, "m_aMaterial");
        gl.bindAttribLocation(this._program, 7, "m_aModelMatrix");
        // Linking
        gl.linkProgram(this._program);
        gl.deleteShader(vsShader);
        gl.deleteShader(fsShader);
        if (gl.getError() === gl.NO_ERROR) {
            var linkStatus = gl.getProgramParameter(this._program, gl.LINK_STATUS);
            if (!linkStatus) {
                var msg = gl.getProgramInfoLog(this._program);
                console.log("%s linking error:\n" + msg, this.name);
                gl.deleteProgram(this._program);
                return;
            }
            this.ready = true;
        }
        else {
            gl.deleteProgram(this._program);
            return;
        }
        // Fetch the vertex attribute indices.
        var numAttribs = gl.getProgramParameter(this._program, gl.ACTIVE_ATTRIBUTES);
        var i;
        for (i = 0; i < numAttribs; ++i) {
            var attrib = gl.getActiveAttrib(this._program, i);
            this.attributes[attrib.name] = i;
        }
        // Fetch uniforms from the shader program.
        var numUniforms = gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORMS);
        for (i = 0; i < numUniforms; ++i) {
            var uniform = gl.getActiveUniform(this._program, i);
            var loc = gl.getUniformLocation(this._program, uniform.name);
            var uniformObject = new _UniformObject(loc);
            if (uniform.name[0] === 'm' && uniform.name[1] === '_') {
                if (loc === null && gl.isWebGL2) {
                    // Very likely it is uniform block.
                    continue;
                }
                else {
                    this.reservedUniforms[uniform.name] = uniformObject;
                }
            }
            else {
                this.userUniforms[uniform.name] = uniformObject;
            }
            switch (uniform.type) {
                case gl.FLOAT:
                    if (uniform.size > 1) {
                        uniformObject.upload = UniformUpload1fv;
                    }
                    else {
                        uniformObject.upload = UniformUpload1f;
                    }
                    break;
                case gl.FLOAT_VEC2:
                    uniformObject.upload = UniformUpload2f;
                    break;
                case gl.FLOAT_VEC3:
                    uniformObject.upload = UniformUpload3f;
                    break;
                case gl.FLOAT_VEC4:
                    uniformObject.upload = UniformUpload4f;
                    break;
                case gl.BOOL:
                    uniformObject.upload = UniformUpload1b;
                    break;
                case gl.INT:
                case gl.SAMPLER_2D:
                case gl.SAMPLER_CUBE:
                    uniformObject.upload = UniformUpload1i;
                    break;
                case gl.INT_VEC2:
                case gl.BOOL_VEC2:
                    uniformObject.upload = UniformUpload2i;
                    break;
                case gl.INT_VEC3:
                case gl.BOOL_VEC3:
                    uniformObject.upload = UniformUpload3i;
                    break;
                case gl.INT_VEC4:
                case gl.BOOL_VEC4:
                    uniformObject.upload = UniformUpload4i;
                    break;
                case gl.FLOAT_MAT4:
                    uniformObject.upload = UniformUploadMat4;
                    break;
                case gl.FLOAT_MAT3:
                    uniformObject.upload = UniformUploadMat3;
                    break;
                default:
                    console.error("unsupported shader uniform type for " + uniform.name);
                    break;
            }
        }
        // Fetch uniforms from the shader program.
        if (gl.isWebGL2) {
            var numUniformBlocks = gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORM_BLOCKS);
            for (var i = 0; i < numUniformBlocks; i++) {
                var blockName = gl.getActiveUniformBlockName(this._program, i);
                var uniformBlock;
                if (blockName[0] === 'm' && blockName[1] === '_') {
                    // Sincwe CPU refers to block name while GPU refers to instance name, and these two
                    // names can't be the same in shader, we rename one of them to make it consistent.
                    uniformBlock = new _UniformObject(i);
                    uniformBlock.initialize(blockName, this._program);
                    uniformBlock.upload = UniformBlockUpload;
                    blockName = blockName.replace(/m_b/, "m_u");
                    this.reservedUniforms[blockName] = uniformBlock;
                }
                else {
                    uniformBlock = new _UniformObject(i);
                    uniformBlock.initialize(blockName, this._program);
                    uniformBlock.upload = UniformBlockUpload;
                    this.userUniforms[blockName] = uniformBlock;
                }
            }
        }
        //modelo3d.debug("shader %s is created.", this.name);
    };
    Shader.prototype.use = function () {
        if (!this.ready) {
            console.error("shader " + this.name + " is not ready.");
            return;
        }
        gl.useProgram(this._program);
    };
    return Shader;
})());


/***/ }),

/***/ "./02resource/m3d_shader_chunks.js":
/*!*****************************************!*\
  !*** ./02resource/m3d_shader_chunks.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var ShaderChunks = {};
    ShaderChunks["blit.fs"] = "uniform sampler2D m_uBlitTexture;\r\n#if MOBILE\r\nuniform sampler2D m_uBlitDepthTexture;\r\n#endif\r\nuniform vec2 m_uInvResolution;\r\n\r\n#if WEBGL2\r\n\r\nin vec2 m_vTexCoord;\r\nout vec4 out_color;\r\n\r\n#else \r\n\r\nvarying vec2 m_vTexCoord;\r\n\r\n#endif\r\n\r\n#include <uniform.inc>\r\n\r\n#if MOBILE\r\nvec4 shade(in sampler2D tex, in sampler2D tex2, in vec2 uv, in vec2 invResolution);\r\n#else\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution);\r\n#endif\r\nvoid main() \r\n{ \r\n#if WEBGL2\r\n\r\n#if MOBILE\r\n out_color = shade(m_uBlitTexture, m_uBlitDepthTexture, m_vTexCoord, m_uInvResolution);\r\n#else\r\n out_color = shade(m_uBlitTexture, m_vTexCoord, m_uInvResolution);\r\n#endif\r\n\r\n#else\r\n\r\n#if MOBILE\r\n gl_FragColor = shade(m_uBlitTexture, m_uBlitDepthTexture, m_vTexCoord, m_uInvResolution);\r\n#else\r\n gl_FragColor = shade(m_uBlitTexture, m_vTexCoord, m_uInvResolution);\r\n#endif\r\n\r\n#endif\r\n}\r\n";
    ShaderChunks["blit.vs"] = "#if WEBGL2\r\n\r\nin vec3 m_aPosition;\r\nin vec2 m_aTexCoord;\r\nout vec2 m_vTexCoord;\r\n\r\n#else\r\n\r\nattribute vec3 m_aPosition;\r\nattribute vec2 m_aTexCoord;\r\nvarying vec2 m_vTexCoord;\r\n\r\n#endif\r\n\r\nvoid main() \r\n{ \r\n gl_Position = vec4(m_aPosition.xy, 0.999999, 1.0); \r\n m_vTexCoord = m_aTexCoord;\r\n}\r\n\r\n";
    ShaderChunks["blit_accumulate.inc"] = "uniform sampler2D uTexture0;\r\nuniform float uFrameCount;\r\n\r\nfloat random( vec2 p )\r\n{\r\n return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * (43758.5453 + uFrameCount * 1231.3));\r\n}\r\n \r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n vec4 accum = sampleTexture2D(tex, uv);\r\n vec4 sampleColor = sampleTexture2D(uTexture0, uv); \r\n vec4 result = (sampleColor + (uFrameCount - 1.0) * accum) / uFrameCount;\r\n float dither = 1.0/255.0 * (random(uv - 0.5) - 0.5);\r\n result += vec4(dither,dither, dither, 0.0);\r\n\r\n return result;\r\n}\r\n\r\n";
    ShaderChunks["blit_contour.inc"] = "vec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{ \r\n vec2 coordCenter = uv; \r\n vec2 coordUp = uv + vec2(0.0, -invResolution.y); \r\n vec2 coordDown = uv + vec2(0.0, invResolution.y); \r\n vec2 coordLeft = uv + vec2(-invResolution.x, 0.0); \r\n vec2 coordRight = uv + vec2(invResolution.x, 0.0); \r\n vec2 coordUpLeft = uv + vec2(-invResolution.x, -invResolution.y); \r\n vec2 coordDownLeft = uv + vec2(-invResolution.x, invResolution.y); \r\n vec2 coordUpRight = uv + vec2(-invResolution.x, invResolution.y); \r\n vec2 coordDownRight = uv + vec2(invResolution.x, invResolution.y); \r\n float contour = 0.0; \r\n\r\n float d = sampleTexture2D(tex, coordCenter).r;\r\n if(d < 1.0 &&\r\n (sampleTexture2D(tex, coordUp).r > 0.5 || \r\n sampleTexture2D(tex, coordDown).r > 0.5 || \r\n sampleTexture2D(tex, coordLeft).r > 0.5 || \r\n sampleTexture2D(tex, coordRight).r > 0.5 || \r\n sampleTexture2D(tex, coordUpLeft).r > 0.5 || \r\n sampleTexture2D(tex, coordDownLeft).r > 0.5 || \r\n sampleTexture2D(tex, coordUpRight).r > 0.5 || \r\n sampleTexture2D(tex, coordDownRight).r > 0.5)) \r\n {\r\n contour = 1.0; \r\n }\r\n return vec4(contour); \r\n} \r\n";
    ShaderChunks["blit_contour_overlay.inc"] = "uniform vec4 uColor;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n vec4 scene = sampleTexture2D(tex, uv);\r\n vec2 coord00 = uv + vec2(-invResolution.x * 2.0, -invResolution.y * 2.0);\r\n vec2 coord01 = uv + vec2(-invResolution.x * 2.0, -invResolution.y);\r\n vec2 coord02 = uv + vec2(-invResolution.x * 2.0, 0.0);\r\n vec2 coord03 = uv + vec2(-invResolution.x * 2.0, invResolution.y);\r\n vec2 coord04 = uv + vec2(-invResolution.x * 2.0, invResolution.y * 2.0);\r\n\r\n vec2 coord10 = uv + vec2(-invResolution.x, -invResolution.y * 2.0);\r\n vec2 coord11 = uv + vec2(-invResolution.x, -invResolution.y);\r\n vec2 coord12 = uv + vec2(-invResolution.x, 0.0);\r\n vec2 coord13 = uv + vec2(-invResolution.x, invResolution.y);\r\n vec2 coord14 = uv + vec2(-invResolution.x, invResolution.y * 2.0);\r\n\r\n vec2 coord20 = uv + vec2(0.0, -invResolution.y * 2.0);\r\n vec2 coord21 = uv + vec2(0.0, -invResolution.y);\r\n vec2 coord22 = uv + vec2(0.0, 0.0);\r\n vec2 coord23 = uv + vec2(0.0, invResolution.y);\r\n vec2 coord24 = uv + vec2(0.0, invResolution.y * 2.0);\r\n vec2 coord30 = uv + vec2(invResolution.x, -invResolution.y * 2.0);\r\n vec2 coord31 = uv + vec2(invResolution.x, -invResolution.y);\r\n vec2 coord32 = uv + vec2(invResolution.x, 0.0);\r\n vec2 coord33 = uv + vec2(invResolution.x, invResolution.y);\r\n vec2 coord34 = uv + vec2(invResolution.x, invResolution.y * 2.0);\r\n vec2 coord40 = uv + vec2(invResolution.x * 2.0, -invResolution.y * 2.0);\r\n vec2 coord41 = uv + vec2(invResolution.x * 2.0, -invResolution.y);\r\n vec2 coord42 = uv + vec2(invResolution.x * 2.0, 0.0);\r\n vec2 coord43 = uv + vec2(invResolution.x * 2.0, invResolution.y);\r\n vec2 coord44 = uv + vec2(invResolution.x * 2.0, invResolution.y * 2.0);\r\n\r\n vec4 contour = sampleTexture2D(tex, coord00) * 0.0090 +\r\n sampleTexture2D(tex, coord01) * 0.0399 +\r\n sampleTexture2D(tex, coord02) * 0.0657 +\r\n sampleTexture2D(tex, coord03) * 0.0399 +\r\n sampleTexture2D(tex, coord04) * 0.0090 +\r\n sampleTexture2D(tex, coord10) * 0.0399 +\r\n sampleTexture2D(tex, coord11) * 0.1788 +\r\n sampleTexture2D(tex, coord12) * 0.2949 +\r\n sampleTexture2D(tex, coord13) * 0.1788 +\r\n sampleTexture2D(tex, coord14) * 0.0399 +\r\n sampleTexture2D(tex, coord20) * 0.0657 +\r\n sampleTexture2D(tex, coord21) * 0.2949 +\r\n sampleTexture2D(tex, coord22) * 0.4863 +\r\n sampleTexture2D(tex, coord23) * 0.2949 +\r\n sampleTexture2D(tex, coord24) * 0.0657 +\r\n sampleTexture2D(tex, coord30) * 0.0399 +\r\n sampleTexture2D(tex, coord31) * 0.1788 +\r\n sampleTexture2D(tex, coord32) * 0.2949 +\r\n sampleTexture2D(tex, coord33) * 0.1788 +\r\n sampleTexture2D(tex, coord34) * 0.0399 +\r\n sampleTexture2D(tex, coord40) * 0.0090 +\r\n sampleTexture2D(tex, coord41) * 0.0399 +\r\n sampleTexture2D(tex, coord42) * 0.0657 +\r\n sampleTexture2D(tex, coord43) * 0.0399 +\r\n sampleTexture2D(tex, coord44) * 0.0090;\r\n float a = min(1.0, contour.a);\r\n return uColor * a + scene * (1.0 - a);\r\n} \r\n\r\n";
    ShaderChunks["blit_direct.fs"] = "uniform vec3 uColor;\r\n\r\n#if WEBGL2\r\nout vec4 out_color;\r\n#endif\r\n\r\nvoid main() \r\n{ \r\n#if WEBGL2\r\n out_color = vec4(uColor, 1);\r\n#else\r\n gl_FragColor = vec4(uColor, 1);\r\n#endif\r\n}\r\n";
    ShaderChunks["blit_fog.inc"] = "uniform vec4 uColor;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n vec4 color = sampleTexture2D(tex, uv);\r\n float depth = uv.y;\r\n\r\n return mix(color, uColor, depth);\r\n}\r\n";
    ShaderChunks["blit_glow.inc"] = "uniform int uRange;\r\nuniform float uWeights[32];\r\nuniform vec3 uColor;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n vec4 result = vec4(0, 0, 0, 0);\r\n vec2 coord;\r\n\r\n for (int dy = -uRange; dy <= uRange; ++dy)\r\n {\r\n vec4 color = vec4(0, 0, 0, 0);\r\n for (int dx = 1; dx <= uRange; ++dx)\r\n {\r\n coord = uv + vec2(dx, dy) * invResolution;\r\n color += sampleTexture2D(tex, coord) * uWeights[dx];\r\n\r\n coord = uv + vec2(-dx, dy) * invResolution;\r\n color += sampleTexture2D(tex, coord) * uWeights[dx]; \r\n }\r\n\r\n coord = uv + vec2(0, dy) * invResolution;\r\n color += sampleTexture2D(tex, coord) * uWeights[0];\r\n\r\n result += color * uWeights[abs(dy)];\r\n }\r\n\r\n return vec4(uColor, result.w);\r\n}\r\n\r\n \r\n";
    ShaderChunks["blit_gradient.inc"] = "uniform vec3 uColor;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n \r\n \r\n \r\n vec4 t = sampleTexture2D(tex, uv);\r\n return vec4(uColor, 1.0 - t.r);\r\n}\r\n";
    ShaderChunks["blit_oit.inc"] = "uniform sampler2D uTexture1;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n vec4 accum = sampleTexture2D(tex, uv.xy); \r\n float reveal = sampleTexture2D(uTexture1, uv).r;\r\n \r\n return vec4(accum.rgb / max(accum.a, 0.00001), max(0.0, 1.0 - reveal)); \r\n}\r\n\r\n\r\n";
    ShaderChunks["blit_shadow.inc"] = "const float g0 = 0.0751; const float g1 = 0.1238; const float g2 = 0.0751; \r\nconst float g3 = 0.1238; const float g4 = 0.2042; const float g5 = 0.1238; \r\nconst float g6 = 0.0751; const float g7 = 0.1238; const float g8 = 0.0751; \r\nconst float C = 85.0;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{ \r\n float tmp = 0.0;\r\n vec2 coord; \r\n\r\n float pixelSize = invResolution.x;\r\n\r\n coord = uv + vec2(-pixelSize, -pixelSize); \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g0;\r\n\r\n coord = uv + vec2(0.0, -pixelSize); \r\n \r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g1;\r\n \r\n coord = uv + vec2(pixelSize, -pixelSize); \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g2;\r\n\r\n coord = uv + vec2(-pixelSize, 0.0); \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g3; \r\n\r\n coord = uv; \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g4;\r\n \r\n coord = uv + vec2(pixelSize, 0.0 ); \r\n \r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g5;\r\n\r\n coord = uv + vec2(-pixelSize, pixelSize); \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g6;\r\n \r\n coord = uv + vec2(0.0, pixelSize); \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g7;\r\n \r\n coord = uv + vec2(pixelSize, pixelSize); \r\n\r\n tmp += exp(C * sampleTexture2D(tex, coord).x) * g8;\r\n\r\n return vec4(tmp); \r\n} \r\n\r\n";
    ShaderChunks["blit_simple.inc"] = "vec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n return sampleTexture2D(tex, uv);\r\n}\r\n";
    ShaderChunks["blit_sketch.inc"] = "uniform float uThreshold; \r\nuniform float uContrast; \r\nuniform vec3 uNearAxis; \r\nuniform bool uIsPerspective; \r\n\r\n#if MOBILE\r\nuniform vec2 uNearFar;\r\n\r\nvoid getNormalPosition(in sampler2D tex, in sampler2D tex2, vec2 coord, out vec3 position, out vec3 normal) \r\n{\r\n vec2 uv = coord * 0.5 + vec2(0.5); \r\n vec4 n = sampleTexture2D(tex, uv); \r\n\r\n normal = normalize(n.xyz * 2.0 - 1.0); \r\n vec4 p = sampleTexture2D(tex2, uv);\r\n float depth = p.x * 2.0 -1.0;\r\n \r\n if (uIsPerspective) \r\n {\r\n position.z = -2.0 * uNearFar.x * uNearFar.y / (uNearFar.x + uNearFar.y - depth * (uNearFar.y - uNearFar.x));\r\n position.xy = uNearAxis.xy * coord.xy * position.z / uNearAxis.z; \r\n } \r\n else \r\n {\r\n position.xy = uNearAxis.xy * coord.xy;\r\n position.z = 0.5 * (depth * (uNearFar.y - uNearFar.x) + uNearFar.x + uNearFar.y);\r\n }\r\n} \r\n#else\r\nvoid getNormalPosition(in sampler2D tex, vec2 coord, out vec3 position, out vec3 normal) \r\n{\r\n vec2 uv = coord * 0.5 + vec2(0.5); \r\n vec4 p = sampleTexture2D(tex, uv); \r\n\r\n normal = normalize(p.xyz); \r\n position.z = p.w; \r\n if (uIsPerspective) \r\n { \r\n position.xy = uNearAxis.xy * coord.xy * p.w / uNearAxis.z; \r\n } \r\n else \r\n {\r\n position.xy = uNearAxis.xy * coord.xy;\r\n }\r\n}\r\n#endif\r\n\r\nfloat planeDistance(vec3 posA, vec3 norA, vec3 posB, vec3 norB) \r\n{ \r\n vec3 posDelta = normalize(posB - posA); \r\n float planeDist = max(abs(dot(posDelta, norA)), abs(dot(posDelta, norB))); \r\n float normalDist = max(1.0 - dot(norA, norB), 0.0); \r\n \r\n return max(planeDist, normalDist);\r\n} \r\n\r\nuniform vec3 uColor;\r\n\r\n#if MOBILE\r\nvec4 shade(in sampler2D tex, in sampler2D tex2, in vec2 uv, in vec2 invResolution)\r\n#else \r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n#endif\r\n{\r\n vec2 vFragCoord = uv * 2.0 - vec2(1.0);\r\n vec2 coordCenter = vFragCoord.xy ; \r\n vec2 coordUp = vFragCoord - vec2(0.0, 2.0 * invResolution.y); \r\n vec2 coordDown = vFragCoord + vec2(0.0, 2.0 * invResolution.y); \r\n vec2 coordLeft = vFragCoord - vec2(2.0 * invResolution.x, 0.0); \r\n vec2 coordRight = vFragCoord + vec2(2.0 * invResolution.x, 0.0); \r\n vec3 posUp, norUp; \r\n vec3 posDown, norDown; \r\n vec3 posLeft, norLeft; \r\n vec3 posRight, norRight; \r\n#if MOBILE\r\n getNormalPosition(tex, tex2, coordUp, posUp, norUp); \r\n getNormalPosition(tex, tex2, coordDown, posDown, norDown); \r\n getNormalPosition(tex, tex2, coordLeft, posLeft, norLeft); \r\n getNormalPosition(tex, tex2, coordRight, posRight, norRight); \r\n#else \r\n getNormalPosition(tex, coordUp, posUp, norUp); \r\n getNormalPosition(tex, coordDown, posDown, norDown); \r\n getNormalPosition(tex, coordLeft, posLeft, norLeft); \r\n getNormalPosition(tex, coordRight, posRight, norRight);\r\n#endif\r\n vec2 planeDist = vec2(planeDistance(posLeft, norLeft, posRight, norRight), \r\n planeDistance(posUp, norUp, posDown, norDown)); \r\n float edge = length(planeDist); \r\n float sketch = step(edge, uThreshold); \r\n sketch = clamp(uContrast * (1.0 - sketch), 0.0, 1.0); \r\n \r\n return vec4(uColor, sketch); \r\n}\r\n";
    ShaderChunks["blit_solid.inc"] = "uniform vec3 uColor;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n return vec4(uColor, 1);\r\n}\r\n";
    ShaderChunks["blit_ssao.inc"] = "uniform vec3 uNearAxis;\r\nuniform vec2 uTexTransform;\r\nuniform vec2 SAMPLES[16];\r\nuniform float uRadius;\r\nuniform bool uIsPerspective;\r\n\r\nvec4 getNormalAndDepth(sampler2D tex, vec2 fragCoord)\r\n{\r\n vec2 texcoord = fragCoord * 0.5 + vec2(0.5);\r\n texcoord.x = texcoord.x * uTexTransform.x + uTexTransform.y;\r\n return sampleTexture2D(tex, texcoord);\r\n}\r\n\r\nvec3 getEyePosition(vec2 fragCoord, float depth)\r\n{\r\n vec3 eyeDirection = uNearAxis * vec3(fragCoord, 1.0);\r\n vec3 eyePosition;\r\n eyePosition.z = depth;\r\n if (uIsPerspective) \r\n {\r\n eyePosition.xy = eyeDirection.xy * depth / eyeDirection.z;\r\n } \r\n else \r\n {\r\n eyePosition.xy = eyeDirection.xy;\r\n }\r\n return eyePosition; \r\n}\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n float ao = 0.0;\r\n float radius = uRadius;\r\n float radius2 = radius * radius;\r\n const float bias = 0.0001;\r\n const float epsilon = 0.0001;\r\n vec2 vFragCoord = uv * 2.0 - vec2(1.0);\r\n vec4 p = getNormalAndDepth(tex, vFragCoord);\r\n vec3 eyePosition = getEyePosition(vFragCoord, p.w);\r\n vec3 normal = p.xyz;\r\n for (int i = 0; i < 16; i++)\r\n {\r\n vec2 d = SAMPLES[i] - vec2(0.5);\r\n vec2 sample = vec2(vFragCoord + d * radius / eyePosition.z);\r\n float depth = getNormalAndDepth(tex, sample).w;\r\n vec3 samplePosition = getEyePosition(sample, depth);\r\n vec3 v_i = samplePosition - eyePosition;\r\n float v_v = dot(v_i, v_i);\r\n float f = max(radius2 - v_v, 0.0) / radius2;\r\n ao += f * f * f * max(0.0,(dot(v_i, normal) + eyePosition.z * bias)/(v_v + epsilon));\r\n }\r\n float occ = 1.0 - ao / (4.0 * 16.0);\r\n occ = clamp(pow(occ, 2.04), 0.0, 1.0);\r\n return vec4(occ);\r\n}\r\n\r\n";
    ShaderChunks["blit_ssao2.inc"] = "uniform vec3 uNearAxis; \r\nuniform vec2 uTexTransform; \r\nuniform float uRadius; \r\nuniform bool uIsPerspective; \r\nuniform float uFrameCount; \r\nuniform vec4 uTexSizeAndInv; \r\nuniform vec2 SAMPLES[8]; \r\n\r\n#if MOBILE\r\nuniform vec2 uNearFar;\r\n\r\nvec4 getNormalAndDepth(in sampler2D tex, in sampler2D tex2, vec2 fragCoord) \r\n{\r\n vec2 texcoord = fragCoord * 0.5 + vec2(0.5);\r\n texcoord.x = texcoord.x * uTexTransform.x + uTexTransform.y;\r\n \r\n vec4 ret = sampleTexture2D(tex, texcoord); \r\n ret.xyz = normalize(ret.xyz * 2.0 - 1.0); \r\n \r\n vec4 p = sampleTexture2D(tex2, texcoord);\r\n float depth = p.x * 2.0 -1.0;\r\n if (uIsPerspective) \r\n {\r\n ret.w = -2.0 * uNearFar.x * uNearFar.y / (uNearFar.x + uNearFar.y - depth * (uNearFar.y - uNearFar.x));\r\n } \r\n else \r\n {\r\n ret.w = 0.5 * (depth * (uNearFar.y - uNearFar.x) + uNearFar.x + uNearFar.y);\r\n }\r\n return ret;\r\n} \r\n#else\r\nvec4 getNormalAndDepth(in sampler2D tex, vec2 fragCoord) \r\n{\r\n vec2 texcoord = fragCoord * 0.5 + vec2(0.5);\r\n texcoord.x = texcoord.x * uTexTransform.x + uTexTransform.y;\r\n \r\n return sampleTexture2D(tex, texcoord); \r\n} \r\n#endif\r\n\r\n\r\nvec3 getEyePosition(vec2 fragCoord, float depth) \r\n{\r\n vec3 eyeDirection = uNearAxis * vec3(fragCoord, 1.0); \r\n vec3 eyePosition; \r\n eyePosition.z = depth; \r\n if (uIsPerspective) \r\n { \r\n eyePosition.xy = eyeDirection.xy * depth / eyeDirection.z; \r\n } \r\n else \r\n {\r\n eyePosition.xy = eyeDirection.xy; \r\n } \r\n return eyePosition; \r\n} \r\n\r\nvec3 getScreenPosition(vec3 eyePos) \r\n{ \r\n if (uIsPerspective)\r\n {\r\n return vec3(eyePos.xy * uNearAxis.z / uNearAxis.xy / eyePos.z, eyePos.z); \r\n }\r\n else\r\n {\r\n return vec3(eyePos.xy / uNearAxis.xy, eyePos.z); \r\n }\r\n} \r\n\r\n#if MOBILE\r\nvec3 getOffsetEyePosition(in sampler2D tex, in sampler2D tex2, vec3 viewPos, vec2 offset) \r\n#else\r\nvec3 getOffsetEyePosition(in sampler2D tex, vec3 viewPos, vec2 offset) \r\n#endif\r\n{ \r\n vec2 scnPos = getScreenPosition(viewPos).xy; \r\n vec2 scnOffset = getScreenPosition(vec3(offset, viewPos.z)).xy; \r\n vec2 pixOffset = scnOffset * uTexSizeAndInv.xy * 0.5;\r\n if(length(pixOffset) > 2.0) \r\n {\r\n scnOffset = (floor(pixOffset + 0.5) ) * uTexSizeAndInv.zw * 2.0;\r\n }\r\n#if MOBILE\r\nfloat sampDepth = getNormalAndDepth(tex, tex2, scnPos + scnOffset).w; \r\n#else\r\nfloat sampDepth = getNormalAndDepth(tex, scnPos + scnOffset).w; \r\n#endif\r\n return getEyePosition(scnPos + scnOffset, sampDepth); \r\n} \r\n\r\nvec3 computeMultiBounceColor(float x, vec3 albedo) \r\n{ \r\n vec3 a = 2.0404 * albedo - 0.3324; \r\n vec3 b = -4.7951 * albedo + 0.6417; \r\n vec3 c = 2.7552 * albedo + 0.6903; \r\n return max( vec3(x,x,x), ( ( x * a + b ) * x + c ) * x ); \r\n} \r\n\r\nfloat random(vec2 p) \r\n{ \r\n return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * (43758.5453 + (uFrameCount) * 1231.3));\r\n} \r\n\r\n#if MOBILE\r\nvec4 shade(in sampler2D tex, in sampler2D tex2, in vec2 uv, in vec2 invResolution)\r\n#else \r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n#endif\r\n{ \r\n float maxScreenRadius = 0.4; float falloffDist = 0.0; float randScale = 0.4; const float aoStrength = 1.0; const float PI = 3.1415926535898; \r\n const float HalfPI = 1.570796326794895; \r\n\r\n vec2 vFragCoord = uv * 2.0 - vec2(1.0);\r\n#if MOBILE\r\n vec4 p = getNormalAndDepth(tex, tex2, vFragCoord); \r\n#else\r\n vec4 p = getNormalAndDepth(tex, vFragCoord); \r\n#endif\r\n vec3 eyePosition = getEyePosition(vFragCoord, p.w); \r\n vec3 normal = p.xyz; \r\n float xx = p.w;\r\n if (length(normal) < 0.95) {\r\n return vec4(1.0);\r\n }\r\n\r\n vec2 projScrRadius = getEyePosition(vec2(1.0, 1.0) * maxScreenRadius, p.w).xy; \r\n vec3 viewDir = vec3(0.0, 0.0, 1.0);\r\n\r\n float radiusScale = 1.0 + randScale * (random(vFragCoord * 0.5 - 0.5) - 0.5); \r\n float radius = radiusScale * min(uRadius, min(projScrRadius.x, projScrRadius.y)); \r\n\r\n if (uIsPerspective) {\r\n viewDir = normalize(-uNearAxis * vec3(vFragCoord, 1.0)); \r\n } \r\n\r\n vec3 sliceTan = normalize(vec3(SAMPLES[7], 0.0));\r\n vec3 sliceNorm = normalize(cross(viewDir, sliceTan)); \r\n vec3 normalSliceProj = normal - dot(normal, sliceNorm) * sliceNorm; \r\n vec3 normalSliceDir = normalize(normalSliceProj); \r\n float thetaN = acos(dot(normalSliceDir, viewDir)) * sign(dot(cross(sliceNorm, viewDir), normalSliceDir)); \r\n\r\n float horizon1 = thetaN + HalfPI;\r\n for (int i = 0; i < 8; ++i) \r\n { \r\n vec2 p = SAMPLES[i];\r\n#if MOBILE\r\nvec3 offsetPosition = getOffsetEyePosition(tex, tex2, eyePosition, p * radius); \r\n#else\r\nvec3 offsetPosition = getOffsetEyePosition(tex, eyePosition, p * radius); \r\n#endif\r\n vec3 v_i = offsetPosition - eyePosition; \r\n float h1 = min(acos(dot(normalize(v_i), viewDir)), HalfPI + thetaN); \r\n float weight = 1.0 - clamp((length(v_i) / radius - falloffDist), 0.0, 1.0); \r\n horizon1 = mix(horizon1, min(horizon1, h1), weight); \r\n } \r\n\r\n float horizon2 = -thetaN + HalfPI;\r\n for(int i = 0; i < 8; ++i) \r\n { \r\n vec2 p = -SAMPLES[i]; \r\n#if MOBILE\r\nvec3 offsetPosition = getOffsetEyePosition(tex, tex2, eyePosition, p * radius); \r\n#else\r\nvec3 offsetPosition = getOffsetEyePosition(tex, eyePosition, p * radius); \r\n#endif\r\n vec3 v_i = offsetPosition - eyePosition; \r\n float h2 = min(acos(dot(normalize(v_i), viewDir)), HalfPI - thetaN); \r\n float weight = 1.0 - clamp((length(v_i) / radius - falloffDist), 0.0, 1.0); \r\n horizon2 = mix(horizon2, min(horizon2, h2), weight); \r\n } \r\n\r\n \r\n float occ = 1.0 - (cos(horizon1) + cos(horizon2)) * 0.5 * aoStrength; \r\n vec3 ao = computeMultiBounceColor(occ, vec3(1.0,1.0,1.0));\r\n\r\n return vec4(ao, 1.0); \r\n}\r\n";
    ShaderChunks["blit_vr_wrap.inc"] = "uniform vec2 uLeftCenterOffset; \r\nuniform vec2 uRightCenterOffset; \r\nuniform vec4 uWarpScaleParam; \r\nuniform vec3 uHmdWarpParam; \r\nuniform bool uCalibration;\r\n\r\nvec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\r\n{\r\n vec4 res;\r\n if(m_vTexCoord.x <= 0.5){ \r\n vec2 coord = vec2(m_vTexCoord.x * 2.0, m_vTexCoord.y); \r\n vec2 offset = (coord.xy - uLeftCenterOffset) * uWarpScaleParam.xy;\r\n float dist2 = offset.x * offset.x + offset.y * offset.y;\r\n \r\n vec2 offsetWarp = offset * (uHmdWarpParam.x + uHmdWarpParam.y * dist2 + uHmdWarpParam.z * dist2 * dist2);\r\n vec2 sampLoc = uLeftCenterOffset + offsetWarp * uWarpScaleParam.zw;\r\n \r\n if(all(equal(clamp(sampLoc, 0.0, 1.0), sampLoc)))\r\n res = sampleTexture2D(tex, vec2(sampLoc.x * 0.5, sampLoc.y)); \r\n else\r\n res = vec4(0.0);\r\n \r\n if (uCalibration) {\r\n if(res.w > 0.0 && (mod(sampLoc.x - uLeftCenterOffset.x, 0.1) < 0.002 || mod(sampLoc.y, 0.1) < 0.002))\r\n res = vec4(0.0,0.0,1.0,1.0);\r\n \r\n if(length(coord.xy - uLeftCenterOffset) < 0.01) \r\n res = vec4(0.0, 0.0, 0.0, 1.0);\r\n }\r\n } else { \r\n vec2 coord = vec2((m_vTexCoord.x - 0.5) * 2.0, m_vTexCoord.y); \r\n vec2 offset = (coord.xy - uRightCenterOffset) * uWarpScaleParam.xy;\r\n float dist2 = offset.x * offset.x + offset.y * offset.y;\r\n vec2 offsetWarp = offset * (uHmdWarpParam.x + \r\n uHmdWarpParam.y * dist2 + uHmdWarpParam.z * dist2 * dist2);\r\n vec2 sampLoc = uRightCenterOffset + offsetWarp * uWarpScaleParam.zw;\r\n if(all(equal(clamp(sampLoc, 0.0, 1.0), sampLoc)))\r\n res = sampleTexture2D(tex, vec2(sampLoc.x* 0.5 + 0.5, sampLoc.y));\r\n else\r\n res = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n if (uCalibration) {\r\n if(res.w > 0.0 && (mod(sampLoc.x - uRightCenterOffset.x, 0.1) < 0.002 || mod(sampLoc.y, 0.1) < 0.002))\r\n res = vec4(0.0,0.0,1.0,1.0);\r\n if(length(coord.xy - uRightCenterOffset) < 0.01)\r\n res = vec4(1.0,0.0,0.0,1.0);\r\n }\r\n\r\n }\r\n return res;\r\n}\r\n";
    ShaderChunks["clipping.inc"] = "#if CLIPPING\r\n if (dot(m_vVertex.xyz, m_uGlobal.clipPlanes[0].xyz) > m_uGlobal.clipPlanes[0].w ||\r\n dot(m_vVertex.xyz, m_uGlobal.clipPlanes[1].xyz) > m_uGlobal.clipPlanes[1].w ||\r\n dot(m_vVertex.xyz, m_uGlobal.clipPlanes[2].xyz) > m_uGlobal.clipPlanes[2].w ||\r\n dot(m_vVertex.xyz, m_uGlobal.clipPlanes[3].xyz) > m_uGlobal.clipPlanes[3].w ||\r\n dot(m_vVertex.xyz, m_uGlobal.clipPlanes[4].xyz) > m_uGlobal.clipPlanes[4].w ||\r\n dot(m_vVertex.xyz, m_uGlobal.clipPlanes[5].xyz) > m_uGlobal.clipPlanes[5].w) {\r\n discard;\r\n }\r\n#endif";
    ShaderChunks["depth_main.fs"] = "#include <globalvars.inc>\r\n\r\n#if ENCODE_DEPTH\r\nvec4 encodeDepth(float depth)\r\n{\r\n const vec4 bitShift = vec4(255.0*255.0*255.0, 255.0*255.0, 255.0, 1.0);\r\n const vec4 bitMask = vec4(0.0, 1.0/255.0, 1.0/255.0, 1.0/255.0);\r\n vec4 res = fract(depth * bitShift); \r\n res -= res.xxyz * bitMask; \r\n return res;\r\n}\r\n#endif\r\n\r\n#if WEBGL2\r\n out vec4 out_color;\r\n#endif\r\n\r\n#if ALPHATEST\r\n uniform sampler2D m_uDiffuseTexture;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#include <clipping.inc>\r\n\r\n#if ALPHATEST\r\n vec4 texel = sampleTexture2D(m_uDiffuseTexture, m_vTexCoord.xy);\r\n if (texel.a < 0.15)\r\n {\r\n discard;\r\n }\r\n#endif\r\n\r\n#if ENCODE_DEPTH\r\n vec4 o = encodeDepth(gl_FragCoord.z); \r\n#else\r\n vec4 o = gl_FragCoord.zzzz;\r\n#endif\r\n\r\n#if WEBGL2\r\n out_color = o;\r\n#else\r\n gl_FragColor = o;\r\n#endif\r\n}\r\n";
    ShaderChunks["gamma.inc"] = "float linearTosRGB1(const in float c, const in float gamma)\r\n{\r\n float v = 0.0;\r\n if (c < 0.0031308) \r\n {\r\n if ( c > 0.0) \r\n {\r\n v = c * 12.92;\r\n }\r\n } \r\n else \r\n {\r\n v = 1.055 * pow(c, 1.0 / gamma) - 0.055;\r\n }\r\n return v;\r\n}\r\n\r\nvec3 linearTosRGB(const in vec3 rgb, const in float gamma)\r\n{\r\n vec3 ret;\r\n ret.r = linearTosRGB1(rgb.r, gamma);\r\n ret.g = linearTosRGB1(rgb.g, gamma);\r\n ret.b = linearTosRGB1(rgb.b, gamma);\r\n return ret;\r\n}\r\n\r\nfloat sRGBToLinear1(const in float c, const in float gamma)\r\n{\r\n float v = 0.0;\r\n if (c < 0.04045)\r\n {\r\n if (c >= 0.0)\r\n {\r\n v = c * ( 1.0 / 12.92);\r\n }\r\n } \r\n else \r\n {\r\n v = pow((c + 0.055) * (1.0 / 1.055), gamma);\r\n }\r\n return v;\r\n}\r\n\r\nvec3 sRGBToLinear(const in vec3 srgb, const in float gamma)\r\n{\r\n vec3 ret;\r\n ret.r = sRGBToLinear1(srgb.r, gamma);\r\n ret.g = sRGBToLinear1(srgb.g, gamma);\r\n ret.b = sRGBToLinear1(srgb.b, gamma);\r\n\r\n return ret;\r\n}\r\n";
    ShaderChunks["globalvars.inc"] = "#if CLIPPING\r\nstruct GlobalStruct\r\n{\r\n vec4 clipPlanes[6];\r\n};\r\nuniform GlobalStruct m_uGlobal;\r\n#endif\r\n";
    ShaderChunks["lights.inc"] = "struct SunLightStruct\r\n{\r\n mat4 diffuseMatrix[3];\r\n float intensity;\r\n vec3 direction;\r\n mat4 shadowMatrix0;\r\n mat4 shadowMatrix1;\r\n};\r\nuniform SunLightStruct m_uSunLight;\r\nuniform sampler2D m_uSunLightProbe;\r\n\r\nstruct PointLightStruct\r\n{\r\n vec3 color;\r\n vec3 position;\r\n float radius;\r\n};\r\n\r\nstruct DirectionalLightStruct\r\n{\r\n vec3 color;\r\n vec3 direction;\r\n};\r\n\r\nstruct SpotLightStruct\r\n{\r\n vec3 color;\r\n vec3 position;\r\n vec3 direction;\r\n float cutoff;\r\n float radius;\r\n};\r\n\r\n#if POINT_LIGHT0\r\nuniform PointLightStruct m_uPointLight0;\r\n#endif\r\n#if POINT_LIGHT1\r\nuniform PointLightStruct m_uPointLight1;\r\n#endif\r\n#if POINT_LIGHT2\r\nuniform PointLightStruct m_uPointLight2;\r\n#endif\r\n\r\n#if DIRECTIONAL_LIGHT0\r\nuniform DirectionalLightStruct m_uDirectionalLight0;\r\n#endif\r\n#if DIRECTIONAL_LIGHT1\r\nuniform DirectionalLightStruct m_uDirectionalLight1;\r\n#endif\r\n#if DIRECTIONAL_LIGHT2\r\nuniform DirectionalLightStruct m_uDirectionalLight2;\r\n#endif\r\n\r\n#if SPOT_LIGHT0\r\nuniform SpotLightStruct m_uSpotLight0;\r\n#endif\r\n#if SPOT_LIGHT1\r\nuniform SpotLightStruct m_uSpotLight1;\r\n#endif\r\n#if SPOT_LIGHT2\r\nuniform SpotLightStruct m_uSpotLight2;\r\n#endif\r\n";
    ShaderChunks["main.fs"] = "#if WEBGL2\r\nin vec3 m_vVertex;\r\nin vec3 m_vNormal;\r\nin vec3 m_vTexCoord;\r\nin vec4 m_vColor;\r\nflat in vec4 m_vId;\r\nin float m_vDepth;\r\nin float m_vColorIndex;\r\n#else \r\n\r\nvarying vec3 m_vVertex;\r\nvarying vec3 m_vNormal;\r\nvarying vec3 m_vTexCoord;\r\nvarying vec4 m_vColor;\r\nvarying float m_vDepth;\r\nvarying float m_vColorIndex;\r\n#endif\r\n\r\n#include <uniform.inc>\r\n\r\n\r\n\r\n\r\n";
    ShaderChunks["main.vs"] = "#if WEBGL2\r\nlayout (location = 0) in vec3 m_aPosition;\r\n\r\n#if COMPRESSION\r\nlayout (location = 1) in float m_aNormal0;\r\n#else\r\nlayout (location = 1) in vec3 m_aNormal0;\r\n#endif\r\n\r\nlayout (location = 2) in float m_aNormal1;\r\nlayout (location = 3) in float m_aNormal2;\r\nlayout (location = 4) in vec2 m_aTexCoord;\r\nlayout (location = 5) in vec4 m_aColor;\r\nlayout (location = 6) in float m_aMaterial;\r\n\r\n#if INSTANCING\r\nlayout (location = 7) in mat4 m_aModelMatrix;\r\n#endif\r\n\r\n#else\r\nattribute vec3 m_aPosition;\r\n\r\n#if COMPRESSION\r\nattribute float m_aNormal0;\r\n#else\r\nattribute vec3 m_aNormal0;\r\n#endif\r\n\r\nattribute float m_aNormal1;\r\nattribute float m_aNormal2;\r\nattribute vec2 m_aTexCoord;\r\nattribute vec4 m_aColor;\r\nattribute float m_aMaterial;\r\n\r\n#if INSTANCING\r\nattribute mat4 m_aModelMatrix;\r\n#endif\r\n\r\n#endif\r\n\r\n";
    ShaderChunks["mark_main.fs"] = "#include <globalvars.inc>\r\n\r\nout vec4 out_color;\r\n\r\nvoid main()\r\n{\r\n#include <clipping.inc>\r\n \r\n out_color = m_vId;\r\n}";
    ShaderChunks["material_color.inc"] = "struct MaterialStruct\r\n{\r\n float values[6]; \r\n};\r\nuniform MaterialStruct m_uMaterial;\r\n\r\nconst vec3 dielectricColor = vec3(0.04); \r\nvoid parseMaterial(out vec3 diffuse, out vec3 specular, out float transparent, out float roughness)\r\n{\r\n vec3 albedo = m_vColor.rgb;\r\n\r\n transparent = m_vColor.a * m_uMaterial.values[3];\r\n \r\n#if GAMMA\r\n albedo = sRGBToLinear(albedo, 2.2); \r\n#endif\r\n\r\n diffuse = albedo;\r\n specular = dielectricColor;\r\n}\r\n\r\n";
    ShaderChunks["material_dummy.inc"] = "struct MaterialStruct\r\n{\r\n float values[6]; \r\n};\r\nuniform MaterialStruct m_uMaterial;\r\n\r\nvoid parseMaterial(out vec3 diffuse, out vec3 specular, out float transparent, out float roughness)\r\n{\r\n transparent = 0.5;\r\n return;\r\n}";
    ShaderChunks["material_skybox.inc"] = "#if EQUIRECTANGLE || WALLPAPER\r\nuniform sampler2D m_uSkyTexture;\r\n#else \r\nuniform samplerCube m_uSkyTexture;\r\n#endif \r\n\r\nuniform float m_uTransparency;\r\n\r\nvoid parseMaterial(out vec3 diffuse, out vec3 specular, out float transparent, out float roughness)\r\n{\r\n#if EQUIRECTANGLE || WALLPAPER \r\n diffuse = sampleTexture2D(m_uSkyTexture, m_vTexCoord.xy).xyz; \r\n#endif\r\n#if CUBEMAP\r\n diffuse = sampleTexture3D(m_uSkyTexture, normalize(m_vTexCoord.xyz)).xyz; \r\n#endif \r\n\r\n#if GAMMA\r\n diffuse = sRGBToLinear(diffuse, 2.2); \r\n#endif\r\n\r\n transparent = m_uTransparency;\r\n}\r\n\r\n";
    ShaderChunks["material_solid.inc"] = "struct MaterialStruct\r\n{\r\n float values[6]; \r\n};\r\nuniform MaterialStruct m_uMaterial;\r\n\r\nconst vec3 dielectricColor = vec3(0.04); \r\n#if ALPHATEST\r\n uniform sampler2D m_uDiffuseTexture;\r\n#endif\r\n\r\nvoid parseMaterial(out vec3 diffuse, out vec3 specular, out float transparent, out float roughness)\r\n{\r\n vec3 albedo = vec3(m_uMaterial.values[0], m_uMaterial.values[1], m_uMaterial.values[2]);\r\n transparent = m_uMaterial.values[3];\r\n\r\n#if ALPHATEST\r\n vec4 texel = sampleTexture2D(m_uDiffuseTexture, m_vTexCoord.xy);\r\n float alphatest = texel.a * transparent;\r\n\r\n if (alphatest < 0.15)\r\n {\r\n discard;\r\n }\r\n#endif\r\n \r\n#if GAMMA\r\n albedo = sRGBToLinear(albedo, 2.2); \r\n#endif\r\n \r\n diffuse = albedo;\r\n specular = dielectricColor;\r\n}\r\n\r\n";
    ShaderChunks["material_texture.inc"] = "struct MaterialStruct\r\n{\r\n float values[6]; \r\n};\r\nuniform MaterialStruct m_uMaterial;\r\n\r\nuniform sampler2D m_uDiffuseTexture;\r\n\r\nconst vec3 dielectricColor = vec3(0.04); \r\nvoid parseMaterial(out vec3 diffuse, out vec3 specular, out float transparent, out float roughness)\r\n{\r\n vec4 texel = sampleTexture2D(m_uDiffuseTexture, m_vTexCoord.xy);\r\n\r\n transparent = texel.a * m_uMaterial.values[3];\r\n\r\n#if ALPHATEST\r\n if (transparent < 0.15) \r\n {\r\n discard;\r\n }\r\n#endif\r\n\r\n vec3 albedo = texel.rgb * vec3(m_uMaterial.values[0], m_uMaterial.values[1], m_uMaterial.values[2]);\r\n\r\n#if GAMMA\r\n albedo = sRGBToLinear(albedo, 2.2); \r\n#endif\r\n\r\n diffuse = albedo;\r\n specular = dielectricColor;\r\n\r\n}\r\n\r\n";
    ShaderChunks["modelo_main.fs"] = "#include <globalvars.inc>\r\n#include <gamma.inc>\r\n#include <lights.inc>\r\n#include <shadow.inc>\r\n\r\nvoid parseMaterial(out vec3 diffuse, out vec3 specular, out float transparent, out float roughness);\r\nvec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V);\r\n\r\n#if WEBGL2\r\n out vec4 out_color;\r\n#endif\r\n\r\n#if USE_PLATTE\r\n uniform sampler2D m_uPlatteTexture;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#include <clipping.inc>\r\n\r\n vec3 N = normalize(m_vNormal);\r\n vec3 V = normalize(m_vVertex * m_uPerFrame.cameraPosition.w - m_uPerFrame.cameraPosition.xyz);\r\n vec3 P = m_vVertex;\r\n\r\n#if DOUBLESIDED \r\n N *= -sign(dot(N, V));\r\n#endif\r\n\r\n vec3 diffuse; \r\n float transparent;\r\n vec3 specular;\r\n float roughness;\r\n#if USE_PLATTE\r\n if (m_vColorIndex < 0.495)\r\n {\r\n vec4 platteColor = sampleTexture2D(m_uPlatteTexture, vec2(m_vColorIndex, 0));\r\n diffuse = platteColor.xyz;\r\n transparent = platteColor.w;\r\n }\r\n else\r\n {\r\n parseMaterial(diffuse, specular, transparent, roughness); \r\n }\r\n#else\r\n parseMaterial(diffuse, specular, transparent, roughness);\r\n#endif\r\n\r\n vec3 color = shade(diffuse, specular, roughness, transparent, P, N, V);\r\n#if GAMMA\r\n color = linearTosRGB(color, 2.2);\r\n#endif\r\n\r\n#if WEBGL2\r\n out_color = vec4(color, transparent);\r\n#else\r\n gl_FragColor = vec4(color, transparent); \r\n#endif\r\n \r\n}\r\n";
    ShaderChunks["modelo_main.vs"] = "#if WEBGL2\r\nout vec3 m_vVertex;\r\nout vec3 m_vNormal;\r\nout vec3 m_vTexCoord;\r\nout vec4 m_vColor;\r\nflat out vec4 m_vId;\r\nout float m_vDepth;\r\nout float m_vColorIndex;\r\n#else\r\nvarying vec3 m_vVertex;\r\nvarying vec3 m_vNormal;\r\nvarying vec3 m_vTexCoord;\r\nvarying vec4 m_vColor;\r\nvarying float m_vDepth;\r\nvarying float m_vColorIndex;\r\n#endif\r\n\r\nvoid transform(inout vec4 position, inout vec4 normal, inout vec3 uv, out vec4 worldPosition);\r\n\r\nvoid main()\r\n{\r\n vec4 position = vec4(m_aPosition, 1.0);\r\n#if COMPRESSION\r\nvec4 normal = vec4(m_aNormal0, m_aNormal1, m_aNormal2, 0.0);\r\n#else\r\nvec4 normal = vec4(m_aNormal0, 0.0);\r\n#endif\r\n vec3 uv = vec3(m_aTexCoord, 1.0);\r\n\r\n vec4 worldPosition;\r\n\r\n transform(position, normal, uv, worldPosition);\r\n\r\n#if VISIBILITY\r\n position.z -= step(0.5, m_aMaterial) * position.w * 10000.0;\r\n#endif\r\n\r\n#if USE_PLATTE\r\n m_vColorIndex = m_aMaterial; \r\n#endif\r\n\r\n#include <varying.inc>\r\n\r\n gl_Position = position;\r\n}\r\n\r\n";
    ShaderChunks["normaldepth_main.fs"] = "#include <globalvars.inc>\r\n\r\n#if WEBGL2\r\n out vec4 out_color;\r\n#endif\r\n\r\n#if ALPHATEST\r\n uniform sampler2D m_uDiffuseTexture;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#include <clipping.inc>\r\n\r\n#if ALPHATEST\r\n vec4 texel = sampleTexture2D(m_uDiffuseTexture, m_vTexCoord.xy);\r\n if (texel.a < 0.15)\r\n {\r\n discard;\r\n }\r\n#endif\r\n\r\n vec4 normal = vec4(m_vNormal, 0.0);\r\n\r\n#if !WORLDSPACE_NORMAL\r\n normal = m_uPerFrame.viewMatrix * normal;\r\n#endif\r\n\r\n#if DOUBLESIDED\r\n \r\n#if WORLDSPACE_NORMAL\r\n vec4 eyeNormal = m_uPerFrame.viewMatrix * normal;\r\n#else\r\n vec4 eyeNormal = normal;\r\n#endif\r\n\r\n vec4 eyeDir = m_uPerFrame.viewMatrix * vec4(m_vVertex, 1.0);\r\n normal *= -sign(dot(eyeNormal.xyz, eyeDir.xyz));\r\n\r\n#endif\r\n \r\n vec3 n = normalize(normal.xyz);\r\n\r\n#if ENCODE_NORMAL\r\n vec3 n = (n + vec3(1.0)) * 0.5;\r\n#endif\r\n\r\n#if WEBGL2\r\n out_color = vec4(n, m_vDepth); \r\n#else\r\n gl_FragColor = vec4(n, m_vDepth);\r\n#endif\r\n \r\n}\r\n";
    ShaderChunks["shade_adhoc.inc"] = "\r\n\r\nvec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n float diffuseTerm = dot(vec4(N, 1), m_uSunLight.diffuseMatrix[0] * vec4(N, 1));\r\n \r\n float nv = max(dot(N, -V), 0.0);\r\n float vl = max(dot(V, m_uSunLight.direction), 0.0);\r\n diffuseTerm = diffuseTerm + (nv * (1.0 - vl)) * 0.8;\r\n \r\n vec3 color = m_uSunLight.intensity * vec3(0.5, 0.497, 0.49) * (diffuse * diffuseTerm) + diffuse * 0.5;\r\n \r\n float specularTerm = 0.0;\r\n float nh;\r\n \r\n#if SPECULAR\r\n vec3 H = -normalize(m_uSunLight.direction + V);\r\n nh = max(dot(N, H), 0.0);\r\n specularTerm = pow(nh, 100.0); \r\n color += m_uSunLight.intensity * vec3(0.5, 0.497, 0.49) * specularTerm;\r\n#endif\r\n\r\n#if MANY_SPECULAR\r\n vec3 H1 = -normalize(vec3(-m_uSunLight.direction.xy, m_uSunLight.direction.z) + V);\r\n vec3 H2 = -normalize(vec3(-m_uSunLight.direction.x, m_uSunLight.direction.y, m_uSunLight.direction.z) + V);\r\n vec3 H3 = -normalize(vec3(m_uSunLight.direction.x, -m_uSunLight.direction.y, m_uSunLight.direction.z) + V);\r\n \r\n specularTerm = 0.0; \r\n nh = max(dot(N, H1), 0.0);\r\n specularTerm += pow(nh, 100.0); \r\n nh = max(dot(N, H2), 0.0);\r\n specularTerm += pow(nh, 100.0); \r\n nh = max(dot(N, H3), 0.0);\r\n specularTerm += pow(nh, 100.0); \r\n \r\n color += m_uSunLight.intensity * vec3(0.5, 0.497, 0.49) * specularTerm;\r\n#endif\r\n\r\n \r\n#if SHADOW\r\n color *= shadow(P, N, m_uSunLight.direction);\r\n#endif\r\n \r\n \r\n return color;\r\n}\r\n\r\n\r\n";
    ShaderChunks["shade_direct.inc"] = "vec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n return diffuse;\r\n}\r\n";
    ShaderChunks["shade_glass.inc"] = "\r\nvec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n vec3 color = diffuse * m_uSunLight.intensity;\r\n \r\n#if SPECULAR\r\n vec3 H = -normalize(m_uSunLight.direction + V);\r\n float nh = max(dot(N, H), 0.0);\r\n color += vec3(pow(nh, roughness));\r\n#endif\r\n \r\n \r\n return color;\r\n}\r\n";
    ShaderChunks["shade_nolight.inc"] = "\r\n\r\nvec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n vec3 result = diffuse * m_uSunLight.intensity; \r\n\r\n#if SHADOW\r\n result *= shadow(P, N, m_uSunLight.direction);\r\n#endif\r\n\r\n return result;\r\n}\r\n\r\n\r\n";
    ShaderChunks["shade_oit_accum.inc"] = "float computeOITWeight(float z) \r\n{\r\n return max(0.0, 1.0 - z);\r\n}\r\n\r\nvec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n float diffuseTerm = dot(vec4(N, 1), m_uSunLight.diffuseMatrix[0] * vec4(N, 1));\r\n \r\n float nv = max(dot(N, -V), 0.0);\r\n float vl = max(dot(V, m_uSunLight.direction), 0.0);\r\n diffuseTerm = diffuseTerm + (nv * (1.0 - vl)) * 0.8;\r\n \r\n vec3 color = m_uSunLight.intensity * vec3(0.5, 0.497, 0.49) * (diffuse * diffuseTerm) + diffuse * 0.5;\r\n\r\n float specularTerm = 0.0;\r\n float nh;\r\n \r\n#if SPECULAR\r\n specularTerm = 0.0;\r\n vec3 H = -normalize(m_uSunLight.direction + V);\r\n nh = max(dot(N, H), 0.0);\r\n specularTerm = pow(nh, 100.0); \r\n color += m_uSunLight.intensity * vec3(0.5, 0.497, 0.49) * specularTerm;\r\n#endif\r\n\r\n#if MANY_SPECULAR\r\n vec3 H1 = -normalize(vec3(-m_uSunLight.direction.xy, m_uSunLight.direction.z) + V);\r\n vec3 H2 = -normalize(vec3(-m_uSunLight.direction.x, m_uSunLight.direction.y, m_uSunLight.direction.z) + V);\r\n vec3 H3 = -normalize(vec3(m_uSunLight.direction.x, -m_uSunLight.direction.y, m_uSunLight.direction.z) + V);\r\n\r\n specularTerm = 0.0; \r\n nh = max(dot(N, H1), 0.0);\r\n specularTerm += pow(nh, 100.0); \r\n nh = max(dot(N, H2), 0.0);\r\n specularTerm += pow(nh, 100.0); \r\n nh = max(dot(N, H3), 0.0);\r\n specularTerm += pow(nh, 100.0); \r\n \r\n color += m_uSunLight.intensity * vec3(0.5, 0.497, 0.49) * specularTerm;\r\n#endif\r\n\r\n \r\n \r\n color *= transparent;\r\n\r\n \r\n return color;\r\n}\r\n\r\n\r\n";
    ShaderChunks["shade_oit_reveal.inc"] = "vec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n return vec3(1.0 - transparent);\r\n}\r\n\r\n\r\n";
    ShaderChunks["shade_pbs.inc"] = "";
    ShaderChunks["shadow.inc"] = "#if SHADOW\r\nuniform sampler2D m_uShadowTexture0;\r\nuniform sampler2D m_uShadowTexture1;\r\n#if MOBILE\r\n\r\nfloat shadow(vec3 P, vec3 N, vec3 L, mat4 matrix)\r\n{\r\n float backside = min(1.0, max(0.0, dot(N, -L) * 10.0));\r\n vec4 v = matrix * vec4(P, 1);\r\n vec3 t = (v.xyz / v.w + vec3(1.0)) * 0.5;\r\n\r\n vec2 coord = t.xy;\r\n float fz = sampleTexture2D(m_uShadowTexture0, coord).x;\r\n float fd = exp(85.0 * (fz - t.z));\r\n float lit = min(fd, 1.0) * backside; return lit * 0.2 + 0.8; }\r\n\r\n#else\r\n\r\nuniform float m_uShadowFine;\r\nuniform float m_uShadowSize;\r\nuniform float m_uShadowSplit;\r\n\r\nfloat bilinear(vec2 frac2, vec4 v)\r\n{\r\n vec2 cc = mix(v.xz, v.yw, frac2.x);\r\n return mix(cc.x, cc.y, frac2.y);\r\n}\r\n\r\nfloat pcf2x(float depth, vec2 coord, in float shadowMapSize, in sampler2D shadowTexture, in float isFineShadow)\r\n{\r\n coord = coord * shadowMapSize;\r\n vec2 p = floor(coord - vec2(0.5)) + vec2(0.5);\r\n vec2 f = coord - p;\r\n vec2 p0 = p / shadowMapSize;\r\n float pixel = 1.0 / shadowMapSize;\r\n \r\n vec4 c;\r\n c.x = sampleTexture2D(shadowTexture, p0).x;\r\n c.y = sampleTexture2D(shadowTexture, p0 + vec2(pixel, 0)).x;\r\n c.z = sampleTexture2D(shadowTexture, p0 + vec2(0, pixel)).x;\r\n c.w = sampleTexture2D(shadowTexture, p0 + vec2(pixel, pixel)).x;\r\n \r\n if (isFineShadow > 0.5) {\r\n c = exp(300.0 * c + vec4(-300.0 * depth));\r\n return bilinear(f, c);\r\n } \r\n \r\n float z = bilinear(f, c);\r\n return z * exp(-85.0 * depth);\r\n}\r\n\r\nfloat shadow1(vec3 P, vec3 N, vec3 L, sampler2D shadowTexture, mat4 shadowMatrix)\r\n{\r\n vec4 v = shadowMatrix * vec4(P, 1);\r\n vec3 t = (v.xyz / v.w + vec3(1.0)) * 0.5;\r\n float fd = pcf2x(t.z, t.xy, m_uShadowSize, shadowTexture, m_uShadowFine);\r\n \r\n float backside = min(1.0, max(0.0, dot(N, -L) * 10.0));\r\n float lit = min(fd, 1.0) * backside; return lit * 0.2 + 0.8; }\r\n\r\n\r\nfloat shadow(vec3 P, vec3 N, vec3 L)\r\n{\r\n if (gl_FragCoord.z < m_uShadowSplit) {\r\n return shadow1(P, N, L, m_uShadowTexture0, m_uSunLight.shadowMatrix0);\r\n } else {\r\n return shadow1(P, N, L, m_uShadowTexture1, m_uSunLight.shadowMatrix1);\r\n }\r\n}\r\n\r\n#endif\r\n\r\n#endif\r\n";
    ShaderChunks["transform_mark.inc"] = "\r\nvoid transform(inout vec4 position, inout vec4 normal, inout vec3 uv, out vec4 worldPosition)\r\n{\r\n#if MODEL_TRANSFORM\r\n position = m_uPerNode.modelMatrix * position;\r\n#endif\r\n \r\n position = m_uPerFrame.vpMatrix * position;\r\n}\r\n";
    ShaderChunks["transform_nonormal.inc"] = "\r\nvoid transform(inout vec4 position, inout vec4 normal, inout vec3 uv, out vec4 worldPosition)\r\n{\r\n#if MODEL_TRANSFORM\r\n#if INSTANCING\r\n position = m_aModelMatrix * position;\r\n#else\r\n position = m_uPerNode.modelMatrix * position;\r\n#endif\r\n#endif\r\n\r\n worldPosition = position;\r\n position = m_uPerFrame.vpMatrix * position;\r\n}\r\n";
    ShaderChunks["transform_simple.inc"] = "\r\nvoid transform(inout vec4 position, inout vec4 normal, inout vec3 uv, out vec4 worldPosition)\r\n{\r\n#if MODEL_TRANSFORM\r\n#if INSTANCING\r\n position = m_aModelMatrix * position;\r\n normal = m_aModelMatrix * normal;\r\n#else\r\n position = m_uPerNode.modelMatrix * position;\r\n normal = m_uPerNode.modelMatrix * normal;\r\n#endif\r\n#endif\r\n\r\n worldPosition = position;\r\n position = m_uPerFrame.vpMatrix * position;\r\n}\r\n";
    ShaderChunks["transform_skybox.inc"] = "\r\nvoid transform(inout vec4 position, inout vec4 normal, inout vec3 uv, out vec4 worldPosition)\r\n{\r\n#if EQUIRECTANGLE\r\n uv = vec3(1.0 - uv.x, uv.y, 1.0);\r\n#endif\r\n#if WALLPAPER\r\n uv = vec3(uv.x, 1.0 - uv.y, 1.0);\r\n#endif\r\n#if CUBEMAP\r\n#if FLIP\r\n uv = vec3(position.x, -position.z, -position.y);\r\n#else\r\n uv = vec3(position.x, position.z, -position.y);\r\n#endif\r\n#endif\r\n\r\n#if MODEL_TRANSFORM\r\n position = m_uPerNode.modelMatrix * position;\r\n#endif\r\n#if EQUIRECTANGLE || CUBEMAP\r\n position = m_uPerFrame.vpMatrix * vec4(position.xyz, 0.0);\r\n#endif\r\n\r\n position = position.xyww; \r\n}\r\n\r\n\r\n";
    ShaderChunks["uniform.inc"] = "#if WEBGL2\r\nvec4 sampleTexture2D(sampler2D tex, vec2 coord)\r\n{\r\n return texture(tex, coord);\r\n}\r\n#else\r\nvec4 sampleTexture2D(sampler2D tex, vec2 coord)\r\n{\r\n return texture2D(tex, coord);\r\n}\r\n#endif\r\n\r\n#if WEBGL2\r\nvec4 sampleTexture3D(samplerCube tex, vec3 coord)\r\n{\r\n return texture(tex, coord);\r\n}\r\n#else\r\nvec4 sampleTexture3D(samplerCube tex, vec3 coord)\r\n{\r\n return textureCube(tex, coord);\r\n}\r\n#endif\r\n\r\n";
    ShaderChunks["volume.inc"] = "uniform sampler2D m_uCubeTexture;\r\nuniform sampler2D m_uToneTexture;\r\nuniform vec2 m_uInvResolution;\r\nuniform float m_uAlphaCorrection;\r\n\r\nuniform mat4 m_uInvTransform;\r\n\r\nconst int MAX_STEPS = 888;\r\nconst float STEPS = 512.0;\r\n\r\nvec4 getColor(float intensity) {\r\n intensity = min(0.26, intensity) / 0.26;\r\n vec2 _uv = vec2(intensity, 0);\r\n vec4 color = sampleTexture2D(m_uToneTexture, _uv);\r\n float alpha = intensity;\r\n if (alpha < 0.03)\r\n {\r\n alpha = 0.02;\r\n }\r\n else\r\n {\r\n clamp(intensity, 0.5, 1.0);\r\n }\r\n\r\n return vec4(color.r, color.g, color.b, alpha); \r\n}\r\n\r\nvec4 sampleAs3DTexture(vec3 texCoord) {\r\n vec4 heightSlice1;\r\n vec4 heightSlice2;\r\n vec4 colorSlice1;\r\n vec4 colorSlice2;\r\n vec2 texCoordSlice1;\r\n vec2 texCoordSlice2;\r\n\r\n float z = clamp(texCoord.z, 0.0, 0.99);\r\n\r\n float totalHeight = 52.0;\r\n float sliceNumber = floor(z * totalHeight);\r\n\r\n float samplerNumber = 3.0;\r\n float top = min(samplerNumber + sliceNumber + 1.0, 51.0);\r\n float bottom = max(sliceNumber - samplerNumber, 0.0);\r\n\r\n float totalSamples = 0.0;\r\n\r\n texCoord.y = 1.0 - texCoord.y;\r\n texCoord.xy /= 8.0;\r\n\r\n float intensity = 0.0;\r\n for (int i = int(sliceNumber) + 1; i < int(top); i++)\r\n {\r\n vec2 texCoordSlice = texCoord.xy;\r\n texCoordSlice.x += (mod(float(i), 8.0) / 8.0);\r\n texCoordSlice.y += floor(float(i) / 8.0) / 8.0;\r\n\r\n float tempIntensity = sampleTexture2D(m_uCubeTexture, texCoordSlice).x;\r\n \r\n intensity += (samplerNumber - abs(z * totalHeight - (float(i)))) * tempIntensity;\r\n totalSamples += (samplerNumber - abs(z * totalHeight - (float(i))));\r\n }\r\n for (int i = int(sliceNumber); i > int(bottom); i--)\r\n {\r\n vec2 texCoordSlice = texCoord.xy;\r\n texCoordSlice.x += (mod(float(i), 8.0) / 8.0);\r\n texCoordSlice.y += floor(float(i) / 8.0) / 8.0;\r\n\r\n float tempIntensity = sampleTexture2D(m_uCubeTexture, texCoordSlice).x;\r\n intensity += (samplerNumber - (z * totalHeight - (float(i)))) * tempIntensity;\r\n totalSamples += (samplerNumber - (z * totalHeight - (float(i))));\r\n }\r\n\r\n if (totalSamples != 0.0)\r\n {\r\n intensity /= totalSamples; \r\n } \r\n\r\n return getColor(intensity);\r\n}\r\n\r\nvec3 shade(in vec3 diffuse, in vec3 specular, in float roughness, inout float transparent, in vec3 P, in vec3 N, in vec3 V)\r\n{\r\n vec2 texc = vec2(gl_FragCoord.x * m_uInvResolution.x,\r\n gl_FragCoord.y * m_uInvResolution.y);\r\n\r\n vec3 frontPos = (m_uInvTransform * vec4(P.x, P.y, P.z, 1.0)).xyz;\r\n\r\n vec3 dir = frontPos - (m_uInvTransform * m_uPerFrame.cameraPosition).xyz;\r\n\r\n float delta = 1.0 / STEPS;\r\n\r\n vec3 deltaDirection = normalize(dir) * delta;\r\n\r\n vec3 currentPosition = frontPos;\r\n\r\n vec4 accumulatedColor = vec4(0.0);\r\n\r\n float accumulatedAlpha = 0.0;\r\n\r\n vec4 colorSample;\r\n float alphaSample;\r\n\r\n int i;\r\n for (i = 0; i < MAX_STEPS; i++) {\r\n colorSample = sampleAs3DTexture(currentPosition);\r\n\r\n alphaSample = colorSample.a * m_uAlphaCorrection;\r\n\r\n alphaSample *= (1.0 - accumulatedAlpha);\r\n\r\n accumulatedColor += colorSample * alphaSample;\r\n\r\n accumulatedAlpha += alphaSample;\r\n\r\n currentPosition += deltaDirection;\r\n\r\n if (accumulatedAlpha >= 1.0\r\n || currentPosition.x < - 0.05 || currentPosition.y < -0.05 || currentPosition.z < -0.05\r\n || currentPosition.x > 1.05 || currentPosition.y > 1.05 || currentPosition.z > 1.05)\r\n break;\r\n }\r\n\r\n transparent = accumulatedAlpha;\r\n\r\n return accumulatedColor.xyz;\r\n}\r\n";
    return ShaderChunks;
})());


/***/ }),

/***/ "./02resource/m3d_shader_library.js":
/*!******************************************!*\
  !*** ./02resource/m3d_shader_library.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_shader_source.js */ "./02resource/m3d_shader_source.js");
//
// m3d_shader_libraries.js
// shader library
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var ShaderLibrary = {};
    ShaderLibrary["volume"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("volume", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_dummy.inc", "volume.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "uv": true
    });
    ShaderLibrary["blit"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("blit", "blit.vs", ["blit.fs", "blit_simple.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["accumulate"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("accumulate", "blit.vs", ["blit.fs", "blit_accumulate.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["normaldepth"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("normaldepth", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "normaldepth_main.fs"], {
        "highPrecision": true,
        "vpMatrix": true,
        "viewMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "depth": true,
        "uv": true
    });
    ShaderLibrary["depth"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("depth", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "depth_main.fs"], {
        "highPrecision": true,
        "vpMatrix": true,
        "viewMatrix": true,
        "modelMatrix": true,
        "position": true,
        "depth": true,
        "uv": true
    });
    ShaderLibrary["solid"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("solid", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_solid.inc", "shade_adhoc.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "uv": true
    });
    ShaderLibrary["mark"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("mark", ["main.vs", "modelo_main.vs", "transform_mark.inc"], ["main.fs", "mark_main.fs"], {
        "highPrecision": true,
        "modelMatrix": true,
        "vpMatrix": true,
        "vertexid": true
    });
    ShaderLibrary["color"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("color", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_color.inc", "shade_adhoc.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "color": true
    });
    ShaderLibrary["texture"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("texture", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_texture.inc", "shade_adhoc.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "uv": true
    });
    ShaderLibrary["glass"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("glass", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_solid.inc", "shade_glass.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true
    });
    ShaderLibrary["plain"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("plain", ["main.vs", "modelo_main.vs", "transform_nonormal.inc"], ["main.fs", "modelo_main.fs", "material_solid.inc", "shade_nolight.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true
    });
    ShaderLibrary["plain_texture"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("plain_texture", ["main.vs", "modelo_main.vs", "transform_nonormal.inc"], ["main.fs", "modelo_main.fs", "material_texture.inc", "shade_direct.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["constant"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("constant", ["main.vs", "modelo_main.vs", "transform_nonormal.inc"], ["main.fs", "modelo_main.fs", "material_solid.inc", "shade_direct.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "position": true
    });
    ShaderLibrary["constant2d"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("constant2d", "blit.vs", "blit_direct.fs", {
        "highPrecision": true,
        "position": true
    });
    ShaderLibrary["skybox"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("skybox", ["main.vs", "modelo_main.vs", "transform_skybox.inc"], ["main.fs", "modelo_main.fs", "material_skybox.inc", "shade_direct.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "modelMatrix": true,
        "uv": true
    });
    ShaderLibrary["oit_accum"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("oit_accum", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_solid.inc", "shade_oit_accum.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "viewMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "depth": true
    });
    ShaderLibrary["oit_reveal"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("oit_reveal", ["main.vs", "modelo_main.vs", "transform_simple.inc"], ["main.fs", "modelo_main.fs", "material_solid.inc", "shade_oit_reveal.inc"], {
        "highPrecision": true,
        "vpMatrix": true,
        "viewMatrix": true,
        "modelMatrix": true,
        "position": true,
        "normal": true,
        "depth": true
    });
    ShaderLibrary["ssao"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("ssao", "blit.vs", ["blit.fs", "blit_ssao2.inc"], {
        "highPrecision": true
    });
    ShaderLibrary["shadowsmooth"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("shadowsmooth", "blit.vs", ["blit.fs", "blit_shadow.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["sketch"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("sketch", "blit.vs", ["blit.fs", "blit_sketch.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["contour"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("contour", "blit.vs", ["blit.fs", "blit_contour.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["contouroverlay"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("contouroverlay", "blit.vs", ["blit.fs", "blit_contour_overlay.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["oit"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("oit", "blit.vs", ["blit.fs", "blit_oit.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["vr_wrap"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("vr_wrap", "blit.vs", ["blit.fs", "blit_vr_wrap.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["gradient"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("gradient", "blit.vs", ["blit.fs", "blit_gradient.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["glow"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("glow", "blit.vs", ["blit.fs", "blit_glow.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    ShaderLibrary["fog"] = new _m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_0__["default"]("fog", "blit.vs", ["blit.fs", "blit_fog.inc"], {
        "highPrecision": true,
        "position": true,
        "uv": true
    });
    return ShaderLibrary;
})());


/***/ }),

/***/ "./02resource/m3d_shader_source.js":
/*!*****************************************!*\
  !*** ./02resource/m3d_shader_source.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../00utility/m3d_utils.js */ "./00utility/m3d_utils.js");
/* harmony import */ var _m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_shader_chunks.js */ "./02resource/m3d_shader_chunks.js");
//
// m3d_shader_source.js
// Keep the shader sources
//
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function ShaderSource(name, vsFiles, fsFiles, options) {
        // private:
        // public:
        this.name = name;
        this.vsSource = null;
        this.fsSource = null;
        this.ready = false;
        var vsSource = "";
        var i, len;
        if (_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(vsFiles)) {
            for (i = 0, len = vsFiles.length; i < len; ++i) {
                if (_m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][vsFiles[i]]) {
                    vsSource += _m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][vsFiles[i]];
                }
                else {
                    // It is a code snippet.
                    vsSource += vsFiles[i];
                }
            }
        }
        else {
            if (_m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][vsFiles]) {
                vsSource += _m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][vsFiles];
            }
            else {
                // It is a code snippet.
                vsSource += vsFiles;
            }
        }
        var fsSource = "";
        if (_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(fsFiles)) {
            for (i = 0, len = fsFiles.length; i < len; ++i) {
                if (_m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][fsFiles[i]]) {
                    fsSource += _m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][fsFiles[i]];
                }
                else {
                    // It is a code snippet.
                    fsSource += fsFiles[i];
                }
            }
        }
        else {
            if (_m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][fsFiles]) {
                fsSource += _m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][fsFiles];
            }
            else {
                // It is a code snippet.
                fsSource += fsFiles;
            }
        }
        this._precompile(vsSource, fsSource, options);
    }
    ;
    ShaderSource.prototype.destroy = function () {
        if (this.ready) {
            this.vsSource = null;
            this.fsSource = null;
            this.ready = false;
        }
    };
    // Generate the source codes using precompiling.
    ShaderSource.prototype._precompile = function (vsSource, fsSource, options) {
        if (this.ready) {
            return;
        }
        try {
            this.vsSource = this._dissolve(vsSource, true, options);
            this.fsSource = this._dissolve(fsSource, false, options);
        }
        catch (e) {
            console.warn(e);
            return;
        }
        this.ready = true;
    };
    ShaderSource.prototype._dissolve = function (source, isVS, options) {
        var header = "";
        // add version code
        header += "#if WEBGL2 \n" +
            "#version 300 es \n" +
            "#endif \n";
        if (options.highPrecision) {
            header += "precision highp float;\n" +
                "precision highp sampler2D;\n";
        }
        else {
            header += "precision mediump float;\n" +
                "precision mediump sampler2D;\n";
        }
        // Vertex attributes
        if (isVS) {
            if (options.viewMatrix || options.vpMatrix || options.projectionMatrix || options.mvpMatrix) {
                header += "#if WEBGL2 \n" +
                    "uniform m_bPerFrame { \n" +
                    "    mat4 viewMatrix;\n" +
                    "    mat4 vpMatrix;\n" +
                    "    vec4 cameraPosition;\n" +
                    "} m_uPerFrame; \n" +
                    "#else \n" +
                    "struct PerFrameStruct {\n";
                if (options.viewMatrix) {
                    header += "    mat4 viewMatrix;\n";
                }
                if (options.vpMatrix) {
                    header += "    mat4 vpMatrix;\n";
                }
                header += "    vec4 cameraPosition;\n" +
                    "};\n" +
                    "uniform PerFrameStruct m_uPerFrame; \n" +
                    "#endif \n";
            }
            if (options.modelMatrix) {
                header += "#if WEBGL2 && MODEL_TRANSFORM\n" +
                    "uniform m_bPerNode { \n" +
                    "    mat4 modelMatrix;\n" +
                    "} m_uPerNode; \n" +
                    "#endif\n" +
                    "#if !WEBGL2 && MODEL_TRANSFORM\n" +
                    "struct PerNodeStruct {\n" +
                    "    mat4 modelMatrix;\n" +
                    "};\n" +
                    "uniform PerNodeStruct m_uPerNode;\n" +
                    "#endif\n";
            }
            if (options.vertexid) {
                header += "uniform int m_uBaseVertexOffset; \n";
            }
        }
        else {
            if (options.viewMatrix || options.vpMatrix || options.projectionMatrix || options.mvpMatrix) {
                header += "#if WEBGL2 \n" +
                    "uniform m_bPerFrame { \n" +
                    "    mat4 viewMatrix;\n" +
                    "    mat4 vpMatrix;\n" +
                    "    vec4 cameraPosition;\n" +
                    "} m_uPerFrame; \n" +
                    "#else \n" +
                    "struct PerFrameStruct {\n";
                if (options.viewMatrix) {
                    header += "    mat4 viewMatrix;\n";
                }
                if (options.vpMatrix) {
                    header += "    mat4 vpMatrix;\n";
                }
                header += "    vec4 cameraPosition;\n" +
                    "};\n" +
                    "uniform PerFrameStruct m_uPerFrame; \n" +
                    "#endif \n";
            }
        }
        var body = "";
        // Include headers
        var lines = source.split("\n");
        var pattern = /<([\w\d\.]+)>/g;
        for (var i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            if (line.match(/#include/g)) {
                var matched = line.match(pattern);
                if (matched) {
                    var included = matched[0].substring(1, matched[0].length - 1);
                    if (included === "varying.inc") {
                        if (isVS && options.normal) {
                            body += "    m_vNormal = normal.xyz; \n";
                        }
                        if (isVS && options.position) {
                            body += "    m_vVertex = worldPosition.xyz; \n";
                        }
                        if (isVS && options.uv) {
                            body += "    m_vTexCoord = uv; \n";
                        }
                        if (isVS && options.vertexid) {
                            body += "    int objectID = gl_VertexID + m_uBaseVertexOffset; \n";
                            body += "    m_vId = vec4( \n";
                            body += "    float(objectID & 0xFF) / 255.0,  \n";
                            body += "    float((objectID >> 8) & 0xFF) / 255.0,  \n";
                            body += "    float((objectID >> 16) & 0xFF) / 255.0,  \n";
                            body += "    float((objectID >> 24) & 0xFF) / 255.0); \n";
                        }
                        if (isVS && options.color) {
                            body += "    m_vColor = m_aColor; \n";
                        }
                        if (isVS && options.material) { // depth in camera space.
                            body += "    m_vMaterial = m_aMaterial;\n";
                        }
                        if (isVS && options.depth) { // depth in camera space.
                            body += "m_vDepth = (m_uPerFrame.viewMatrix * worldPosition).z;\n";
                        }
                    }
                    else {
                        body += _m3d_shader_chunks_js__WEBPACK_IMPORTED_MODULE_1__["default"][included];
                    }
                }
                else {
                    throw new Error('Can not resolve #include <' + included + '>');
                }
            }
            else {
                body += line + "\n";
            }
        }
        // Unroll loops
        pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function replace(match, start, end, snippet) {
            var unroll = '';
            for (i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/\[i\]/g, '[' + i + ']');
            }
            return unroll;
        }
        body = body.replace(pattern, replace);
        return header + body;
    };
    return ShaderSource;
})());


/***/ }),

/***/ "./02resource/m3d_staged_mesh.js":
/*!***************************************!*\
  !*** ./02resource/m3d_staged_mesh.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_mesh.js */ "./02resource/m3d_mesh.js");
//
// m3d_mesh.js
// The mesh wrapper
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function StagedMesh(name, resourceManager) {
        _m3d_mesh_js__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);
        this._vertices = null;
        this._indices = null;
        this._vertexBuffer = null;
        this._indexBuffer = null;
        this.isStaged = true;
    }
    ;
    StagedMesh.prototype = Object.create(_m3d_mesh_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);
    StagedMesh.prototype.destroy = function () {
        this._vertices = null;
        delete this._vertices;
        this._indices = null;
        delete this._indices;
        this._vertexBuffer = null;
        delete this._vertexBuffer;
        this._indexBuffer = null;
        delete this._indexBuffer;
        _m3d_mesh_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.destroy(this, arguments);
    };
    StagedMesh.prototype.createShared = function (primitive, attributes, vertices, indices, type, vertexBuffer, indexBuffer) {
        this._primitive = primitive;
        this._attributes = attributes;
        this.bytes = (vertices.byteLength + indices.byteLength);
        this._type = type || gl.UNSIGNED_SHORT;
        if (this._type === gl.UNSIGNED_BYTE) {
            this.length = indices.byteLength;
            this.indexSize = 1;
        }
        else if (this._type === gl.UNSIGNED_INT) {
            this.length = indices.byteLength / 4;
            this.indexSize = 4;
        }
        else {
            this.length = indices.byteLength / 2;
            this.indexSize = 2;
        }
        this._vertices = vertices;
        this._indices = indices;
        this._vertexBuffer = vertexBuffer;
        this._indexBuffer = indexBuffer;
        this._vbo = vertexBuffer.buffer;
        this._ibo = indexBuffer.buffer;
        if ((gl.isWebGL2 || gl.vaoExtension)) {
            this._vao = gl.createVertexArray();
            gl.bindVertexArray(this._vao);
            this._attributes.bind(this._vbo);
            gl.bindVertexArray(null);
        }
        this._shared = true;
        this.ready = (vertexBuffer.ready && indexBuffer.ready);
    };
    StagedMesh.prototype.render = function () {
        gl.drawElements(this._primitive, this.length, this._type, 0);
    };
    StagedMesh.prototype.renderSub = function (offset, count) {
        gl.drawElements(this._primitive, count, this._type, offset);
    };
    StagedMesh.prototype.use = function () {
        if (this._vao) {
            gl.bindVertexArray(this._vao);
        }
        else {
            this._attributes.bind(this._vbo);
        }
        this._vertexBuffer.update(this._vertices);
        this._indexBuffer.update(this._indices);
        this.ready = (this._vertexBuffer.ready && this._indexBuffer.ready);
        if (!this.ready) {
            console.error("mesh " + this._name + " is not ready.");
            return;
        }
    };
    StagedMesh.prototype.update = function (vertices, indices, type) {
        this._type = type || gl.UNSIGNED_SHORT;
        if (this._type === gl.UNSIGNED_BYTE) {
            this.length = indices.byteLength;
        }
        else if (this._type === gl.UNSIGNED_SHORT) {
            this.length = indices.byteLength / 2;
        }
        else if (this._type === gl.UNSIGNED_INT) {
            this.length = indices.byteLength / 4;
        }
        this.bytes = (vertices.byteLength + indices.byteLength);
    };
    // Replace the subdata in cpu memory
    StagedMesh.prototype.ibSubData = function (offset, bufferData) {
        this._indices.set(bufferData, offset);
    };
    // Replace the subdata in cpu memory
    StagedMesh.prototype.vbSubData = function (offset, bufferData) {
        this._vertices.set(bufferData, offset);
    };
    return StagedMesh;
})());


/***/ }),

/***/ "./02resource/m3d_texture.js":
/*!***********************************!*\
  !*** ./02resource/m3d_texture.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_texture.js
// The texture wrapper
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Texture(name, resourceManager) {
        // private:
        this._name = name;
        this._texture = null;
        this._internalFormat = gl.RGBA;
        this._format = gl.RGBA;
        this._type = gl.UNSIGNED_BYTE;
        this._wrap = gl.CLAMP_TO_EDGE;
        this._filter = gl.LINEAR;
        this._mipmap = false;
        this._rbo = false;
        this._target = gl.TEXTURE_2D;
        this._samples = 1;
        // public:
        this.manager = resourceManager;
        this.ready = false;
        this.width = 1;
        this.height = 1;
        this.kbytes = 0;
    }
    ;
    Texture.prototype.destroy = function () {
        if (this.ready) {
            if (this._rbo) {
                gl.deleteRenderbuffer(this._texture);
            }
            else {
                gl.deleteTexture(this._texture);
            }
            this._texture = null;
            delete this._texture;
            this.ready = false;
            var err;
            if ((err = gl.getError()) !== gl.NO_ERROR) {
                console.log("GL error in texture.destroy(): " + err);
            }
        }
        if (this.manager) {
            delete this.manager._textures[this._name];
            this.manager = null;
        }
        //modelo3d.debug("texture %s is destroyed.", this._name);
    };
    Texture.prototype._create = function (image) {
        this._texture = gl.createTexture();
        var magFilter = gl.NEAREST;
        // derive magnify filter from minimizing filter.
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR) {
            magFilter = gl.LINEAR;
        }
        // The texture unit 7 is reserved for temporary use. 
        // Do not use other units in order to avoid the unit
        // conflicts.
        gl.activeTexture(gl.TEXTURE0 + 7);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrap);
        if (image) {
            gl.texImage2D(gl.TEXTURE_2D, 0, this._format, this._format, this._type, image);
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this.width, this.height, 0, this._format, this._type, null);
        }
        if (this._mipmap) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    Texture.prototype.updateImage = function (image, format, type, filter, wrap) {
        this.ready = false;
        this.createFromImage(image, format, type, filter, wrap);
    };
    Texture.prototype.createFromImage = function (image, format, type, filter, wrap) {
        if (this.ready) {
            return;
        }
        this._format = format;
        this._type = type;
        this.width = image.width;
        this.height = image.height;
        this._filter = filter;
        this._wrap = wrap;
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.NEAREST_MIPMAP_NEAREST) {
            this._mipmap = true;
        }
        this._create(image);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
            //modelo3d.debug("texture %s is created.", this._name);
        }
        else {
            gl.deleteTexture(this._texture);
        }
    };
    Texture.prototype.createFromCanvas = function (image, format, type, filter, wrap) {
        if (this.ready) {
            return;
        }
        this._format = format;
        this._type = type;
        this.width = image.width;
        this.height = image.height;
        this._filter = filter;
        this._wrap = wrap;
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.NEAREST_MIPMAP_NEAREST) {
            this._mipmap = true;
        }
        this._texture = gl.createTexture();
        var magFilter = gl.NEAREST;
        // derive magnify filter from minimizing filter.
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR) {
            magFilter = gl.LINEAR;
        }
        // The texture unit 7 is reserved for temporary use. 
        // Do not use other units in order to avoid the unit
        // conflicts.
        gl.activeTexture(gl.TEXTURE0 + 7);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrap);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._format, this._format, this._type, image);
        if (this._mipmap) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            gl.deleteTexture(this._texture);
        }
    };
    // This method is especially used for creating a cubemap texture.
    // images is a array of 6 images. Each image has a name indicating which face this image should
    // be mapped to. If image.name contains posx, it should be mapped to right face; if it contains
    // negz, it should be mapped to bottom face. So on so forth.
    // suppose the images is an array which contains 6 images
    Texture.prototype.createFromImages = function (images, format, type, filter, wrap) {
        if (this.ready) {
            return;
        }
        this._target = gl.TEXTURE_CUBE_MAP;
        this._format = format;
        this._type = type;
        this.width = images[0].width;
        this.height = images[0].height;
        this._filter = filter;
        this._wrap = wrap;
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.NEAREST_MIPMAP_NEAREST) {
            this._mipmap = true;
        }
        this._texture = gl.createTexture();
        var magFilter = gl.NEAREST;
        // derive magnify filter from minimizing filter.
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR) {
            magFilter = gl.LINEAR;
        }
        // The texture unit 7 is reserved for temporary use. 
        // Do not use other units in order to avoid the unit
        // conflicts.
        gl.activeTexture(gl.TEXTURE0 + 7);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._texture);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this._filter);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this._wrap);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this._wrap);
        // must be 6 !
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this._format, this._format, this._type, images[0]);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this._format, this._format, this._type, images[1]);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this._format, this._format, this._type, images[2]);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, this._format, this._format, this._type, images[3]);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this._format, this._format, this._type, images[4]);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this._format, this._format, this._type, images[5]);
        if (this._mipmap) {
            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            gl.deleteTexture(this._texture);
        }
    };
    Texture.prototype.createFromFile = function (file, format, filter, wrap, onComplete) {
        if (this.ready) {
            return;
        }
        var image = new Image();
        var that = this;
        image.onload = function () {
            // FIXME: check the pixel format of the file.
            that.createFromImage(image, format, gl.UNSIGNED_BYTE, filter, wrap);
            if (onComplete !== null) {
                onComplete(that);
            }
        };
        // Trigger the loading.
        image.src = file;
    };
    Texture.prototype.create = function (width, height, format, filter, wrap, samples) {
        if (this.ready) {
            return;
        }
        format = format || gl.RGBA;
        var type = gl.UNSIGNED_BYTE;
        this.width = width;
        this.height = height;
        this._filter = filter || gl.LINEAR;
        this._wrap = wrap || gl.CLAMP_TO_EDGE;
        this._internalFormat = format;
        if (gl.isWebGL2) {
            this._samples = samples || 1;
        }
        if (format === gl.RGB32F || format === gl.RGBA32F || format === gl.R32F) {
            if (!gl.floatTextureExtension && !gl.isWebGL2) {
                console.error("Unsupported texture format for texture " + this._name);
                return;
            }
            type = gl.FLOAT;
            if (format === gl.RGB32F) {
                format = gl.RGB;
            }
            else if (format === gl.RGBA32F) {
                format = gl.RGBA;
            }
            else {
                format = gl.RED;
            }
        }
        else if (format === gl.RGBA8 || format === gl.RGBA) {
            type = gl.UNSIGNED_BYTE;
            format = gl.RGBA;
        }
        else if (format === gl.RGB8 || format === gl.RGB) {
            type = gl.UNSIGNED_BYTE;
            format = gl.RGB;
        }
        else if (format === gl.R8) {
            type = gl.UNSIGNED_BYTE;
            if (gl.isWebGL2) {
                format = gl.ALPHA;
            }
            else {
                format = gl.RED;
            }
        }
        else if (format === gl.DEPTH_COMPONENT16 || format === gl.DEPTH_COMPONENT24 || format === gl.DEPTH_COMPONENT32) {
            if (!gl.depthTextureExtension && !gl.isWebGL2) {
                console.error("Unsupported texture format for texture " + this._name);
                return;
            }
            type = gl.UNSIGNED_BYTE;
            if (format === gl.DEPTH_COMPONENT16) {
                type = gl.UNSIGNED_SHORT;
            }
            else if (format === gl.DEPTH_COMPONENT24 || format === gl.DEPTH_COMPONENT32) {
                type = gl.UNSIGNED_INT;
            }
            format = gl.DEPTH_COMPONENT;
        }
        else if (format === gl.DEPTH24_STENCIL8) {
            type = gl.isWebGL2 ? gl.UNSIGNED_INT_24_8 : gl.depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
            format = gl.DEPTH_STENCIL;
        }
        else {
            console.error("Unsupported texture format for texture " + this._name);
            return;
        }
        this._format = format;
        this._type = type;
        var magFilter = gl.NEAREST;
        if (this._filter === gl.LINEAR_MIPMAP_NEAREST ||
            this._filter === gl.NEAREST_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR_MIPMAP_LINEAR ||
            this._filter === gl.LINEAR) {
            magFilter = gl.LINEAR;
        }
        if (gl.isWebGL2) {
            if (samples > 1) {
                this._texture = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._texture);
                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._samples, this._internalFormat, this.width, this.height);
                if (gl.getError() !== gl.NO_ERROR) {
                    gl.deleteRenderbuffer(this._texture);
                    return;
                }
                this._rbo = true;
            }
            else {
                this._texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + 7);
                gl.bindTexture(gl.TEXTURE_2D, this._texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._filter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrap);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrap);
                gl.texStorage2D(gl.TEXTURE_2D, 1, this._internalFormat, this.width, this.height);
            }
        }
        else {
            if (this._format === gl.DEPTH24_STENCIL8 && !gl.depthTextureExtension) {
                // Create a render buffer instead
                this._texture = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._texture);
                gl.renderbufferStorage(gl.RENDERBUFFER, this._internalFormat, width, height);
                // It is a renderbuffer, but not a texture, so it can not be bound, (this.ready == false).
                if (gl.getError() !== gl.NO_ERROR) {
                    gl.deleteRenderbuffer(this._texture);
                    return;
                }
                this._rbo = true;
            }
            else {
                this._texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + 7);
                gl.bindTexture(gl.TEXTURE_2D, this._texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._filter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrap);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrap);
                gl.texImage2D(gl.TEXTURE_2D, 0, this._internalFormat, this.width, this.height, this._internalFormat, this._type, null);
            }
        }
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            gl.deleteTexture(this._texture);
        }
    };
    Texture.prototype.update = function (buffer) {
        gl.activeTexture(gl.TEXTURE0 + 7);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, this._format, this._type, buffer);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        else {
            gl.deleteTexture(this._texture);
        }
    };
    // Copy from the current framebuffer
    Texture.prototype.copy = function () {
        // Can't apply to renderbuffer
        if (this._rbo) {
            return;
        }
        this.ready = false;
        var w = this.width;
        var h = this.height;
        gl.activeTexture(gl.TEXTURE0 + 7);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, w, h, w, h);
        if (gl.getError() === gl.NO_ERROR) {
            this.ready = true;
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    // Resize the texture. It will destroy the old content.
    Texture.prototype.resize = function (width, height) {
        if (!this.ready) {
            return;
        }
        if (this.width === width && this.height === height) {
            return;
        }
        if (width > 4096) {
            width = 4096;
        }
        if (height > 4096) {
            height = 4096;
        }
        this.width = width;
        this.height = height;
        this.ready = false;
        if (this._rbo) {
            // Create a render buffer instead
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._texture);
            if (this._samples <= 1) {
                gl.renderbufferStorage(gl.RENDERBUFFER, this._internalFormat, width, height);
            }
            else {
                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._samples, this._internalFormat, this.width, this.height);
            }
            if (gl.getError() === gl.NO_ERROR) {
                this.ready = true;
            }
            else {
                gl.deleteRenderbuffer(this._texture);
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        else {
            gl.deleteTexture(this._texture);
            this._create(null);
            if (gl.getError() === gl.NO_ERROR) {
                this.ready = true;
            }
            else {
                gl.deleteTexture(this._texture);
            }
        }
    };
    Texture.prototype.generateMipmap = function () {
        if (!this.ready || this._rbo || this._mipmap) {
            return;
        }
        this._mipmap = true;
        gl.activeTexture(gl.TEXTURE0 + 7);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    Texture.prototype.use = function (textureUnit) {
        if (this.ready && !this._rbo) {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            gl.bindTexture(this._target, this._texture);
        }
        else {
            modelo3d.debug("texture " + this.name + " is either not ready or not bindable.");
        }
    };
    Texture.prototype.isFloating = function () {
        return this._type === gl.FLOAT ||
            this._type === gl.isWebGL2 ? gl.UNSIGNED_INT_24_8 : gl.depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
    };
    Texture.prototype.getSize = function () {
        if (!this.ready) {
            return 0;
        }
        var kbytes = this.width * this.height;
        switch (this._format) {
            case gl.RG:
                kbytes *= 2;
                break;
            case gl.RGB:
                kbytes *= 3;
                break;
            case gl.RGBA:
                kbytes *= 4;
                break;
        }
        switch (this._type) {
            case gl.FLOAT:
            case gl.isWebGL2 ? gl.UNSIGNED_INT_24_8 : gl.depthTextureExtension.UNSIGNED_INT_24_8_WEBGL:
                kbytes *= 4;
                break;
            case gl.DEPTH_COMPONENT16:
                kbytes *= 2;
                break;
        }
        this.kbytes = kbytes / 1024;
        return this.kbytes;
    };
    Texture.prototype.discard = function () {
        if (this.ready) {
            if (this._rbo) {
                gl.deleteRenderbuffer(this._texture);
            }
            else {
                gl.deleteTexture(this._texture);
            }
            this._texture = null;
            //console.log("release " + this.kbytes + "KB tex mem");
            this.ready = false;
        }
    };
    Texture.prototype.restore = function () {
        if (!this.ready) {
            this._create(null);
            if (gl.getError() === gl.NO_ERROR) {
                this.ready = true;
            }
            else {
                gl.deleteTexture(this._texture);
            }
        }
    };
    return Texture;
})());


/***/ }),

/***/ "./03scene/camera/m3d_base_camera.js":
/*!*******************************************!*\
  !*** ./03scene/camera/m3d_base_camera.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
//
// m3d_base_camera.js
// The base camera
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function BaseCamera(scene, eventEmitter) {
        // private:
        this._at = [0, 0, 0]; //vec3.fromValues(0, 0, 0);       // The position where we look at currently
        this._theta = Math.PI; // The theta in the spherical coordinate.
        this._phi = 0;
        this._distance = 15.0; // The distance from eye to lookat position.
        this._firstPerson = false; // By default, it is 3rd-person
        this._fov = 46; // Field of view. 46 is the field of view angle of single human eye.
        this._invTanFov = 1.0 / Math.tan(this._fov * 0.00872665); // Math.PI / 180 / 2 = 0.00872665
        this._znear = 0.1; // The near plane.
        this._zfar = 1000.0; // The far plane.
        this._aspect = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        this._eventEmitter = eventEmitter;
        this._perspective = true;
        this._height = 1.0; // the height of parallel frustum 
        // public:
        this.viewport = vec4.fromValues(0, 0, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        this.viewMatrix = mat4.create(); // Camera matrix.
        this.projectMatrix = mat4.create(); // Projection matrix.
        this.vpMatrix = mat4.create(); // ProjectionMatrix * CameraMatrix 
        this.eye = new Float32Array([15, 0, 0, 1.0]); // The camera position. It is a homogeneous coordinate.
        // initialization:
        mat4.perspective(this.projectMatrix, this._fov * Math.PI / 180, this._aspect, this._znear, this._zfar);
        mat4.identity(this.viewMatrix);
        if (gl.isWebGL2) {
            this.uniformBlock = new Float32Array(36);
        }
    }
    ;
    BaseCamera.prototype.destroy = function () {
        this.viewport = null;
        delete this.viewport;
        this.viewMatrix = null;
        delete this.viewMatrix;
        this.projectMatrix = null;
        delete this.projectMatrix;
        this.vpMatrix = null;
        delete this.vpMatrix;
        this._at = null;
        delete this._at;
        this.eye = null;
        delete this.eye;
    };
    BaseCamera.prototype.update = function () {
        // Rotate with x first and then with z
        var sx = Math.sin(this._phi);
        var cx = Math.cos(this._phi);
        var sz = Math.sin(this._theta);
        var cz = Math.cos(this._theta);
        var m = this.viewMatrix;
        // NOTE: The theta and phi are in the spherical coordinate whose
        // origin is at the lookat position, but no camera.
        var l;
        var invL;
        m[2] = cx * cz;
        m[6] = cx * sz;
        m[10] = sx;
        if (this._firstPerson) {
            m[2] = -m[2];
            m[6] = -m[6];
            m[10] = -m[10];
        }
        if (Math.abs(this._phi) >= 0.499999 * Math.PI) {
            // up = (-sz, cz, 0);
            m[0] = cz * m[10];
            m[4] = sz * m[10];
            m[8] = -sz * m[6] - cz * m[2];
        }
        else {
            m[0] = -m[6];
            m[4] = m[2];
            m[8] = 0;
        }
        l = BaseCamera.prototype._length.call(this, m[0], m[4], m[8]);
        if (l > 0) {
            invL = 1.0 / l;
            m[0] *= invL;
            m[4] *= invL;
            m[8] *= invL;
        }
        m[1] = -m[10] * m[4];
        m[5] = m[10] * m[0];
        m[9] = m[2] * m[4] - m[6] * m[0];
        l = BaseCamera.prototype._length.call(this, m[1], m[5], m[9]);
        if (l > 0) {
            invL = 1.0 / l;
            m[1] *= invL;
            m[5] *= invL;
            m[9] *= invL;
        }
        if (this._firstPerson) {
            // Note that (m[2], m[6], m[10]) is from at and pointing to 
            // eye.
            this._at[0] = this.eye[0] - m[2] * this._distance;
            this._at[1] = this.eye[1] - m[6] * this._distance;
            this._at[2] = this.eye[2] - m[10] * this._distance;
        }
        else {
            this.eye[0] = this._at[0] + m[2] * this._distance;
            this.eye[1] = this._at[1] + m[6] * this._distance;
            this.eye[2] = this._at[2] + m[10] * this._distance;
        }
        m[12] = -(m[0] * this.eye[0] + m[4] * this.eye[1] + m[8] * this.eye[2]);
        m[13] = -(m[1] * this.eye[0] + m[5] * this.eye[1] + m[9] * this.eye[2]);
        m[14] = -(m[2] * this.eye[0] + m[6] * this.eye[1] + m[10] * this.eye[2]);
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
    };
    BaseCamera.prototype.cull = function () {
        return false;
    };
    BaseCamera.prototype.resize = function (width, height) {
        if (width === this.viewport[2] && height === this.viewport[3]) {
            return;
        }
        if (height < 1) {
            height = 1;
        }
        this._aspect = width / height;
        if (this._perspective) {
            this.projectMatrix[0] = this._invTanFov / this._aspect;
            this.projectMatrix[5] = this._invTanFov;
        }
        else {
            var w = this._height * this._aspect;
            var h = this._height;
            this.projectMatrix[0] = 1 / w;
            this.projectMatrix[5] = 1 / h;
        }
        this.viewport[0] = 0;
        this.viewport[1] = 0;
        this.viewport[2] = width;
        this.viewport[3] = height;
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
    };
    BaseCamera.prototype.setViewport = function (viewport) {
        var width = viewport[2];
        var height = viewport[3];
        if (width > 4096 || height > 4096) {
            if (width >= height) {
                height = Math.floor(height * 4096 / width);
                width = 4096;
            }
            else {
                width = Math.floor(width * 4096 / height);
                height = 4096;
            }
        }
        this.viewport[0] = viewport[0];
        this.viewport[1] = viewport[1];
        this.viewport[2] = width;
        this.viewport[3] = height;
    };
    BaseCamera.prototype.isPerspective = function () {
        return this._perspective;
    };
    BaseCamera.prototype.setPerspective = function (perspective) {
        if (this._perspective === perspective) {
            return;
        }
        this._perspective = perspective;
        if (this._perspective) {
            this.projectMatrix[1] =
                this.projectMatrix[2] =
                    this.projectMatrix[3] =
                        this.projectMatrix[4] =
                            this.projectMatrix[6] =
                                this.projectMatrix[7] =
                                    this.projectMatrix[8] =
                                        this.projectMatrix[9] =
                                            this.projectMatrix[12] =
                                                this.projectMatrix[13] =
                                                    this.projectMatrix[15] = 0;
            this.projectMatrix[11] = -1;
            this.projectMatrix[0] = this._invTanFov / this._aspect;
            this.projectMatrix[5] = this._invTanFov;
        }
        else {
            this.projectMatrix[1] =
                this.projectMatrix[2] =
                    this.projectMatrix[3] =
                        this.projectMatrix[4] =
                            this.projectMatrix[6] =
                                this.projectMatrix[7] =
                                    this.projectMatrix[8] =
                                        this.projectMatrix[9] =
                                            this.projectMatrix[11] = 0;
            this.projectMatrix[12] = 0;
            this.projectMatrix[13] = 0;
            this.projectMatrix[15] = 1;
            var w = this._height * this._aspect;
            var h = this._height;
            this.projectMatrix[0] = 1 / w;
            this.projectMatrix[5] = 1 / h;
        }
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
        if (this._eventEmitter) {
            this._eventEmitter.emit("orthoViewChanged", !this._perspective);
        }
    };
    BaseCamera.prototype._setFov = function (fov) {
        if (this._fov !== fov) {
            this._fov = fov;
            this._invTanFov = 1.0 / Math.tan(this._fov * 0.00872665);
            if (this._perspective) {
                this.projectMatrix[0] = this._invTanFov / this._aspect;
                this.projectMatrix[5] = this._invTanFov;
            }
        }
    };
    BaseCamera.prototype._setHeight = function (height) {
        if (this._height !== height) {
            this._height = height;
            if (!this._perspective) {
                var w = this._height * this._aspect;
                var h = this._height;
                this.projectMatrix[0] = 1 / w;
                this.projectMatrix[5] = 1 / h;
            }
        }
    };
    BaseCamera.prototype._updateProjection = function (znear, zfar) {
        this._znear = znear || this._znear;
        this._zfar = zfar || this._zfar;
        // Update the project matrix.
        // Using our own code instead of glMatrix for caching tan(fov).
        var nf;
        if (this._perspective) {
            nf = 1 / (this._znear - this._zfar);
            this.projectMatrix[10] = (this._zfar + this._znear) * nf;
            this.projectMatrix[14] = 2 * this._zfar * this._znear * nf;
        }
        else {
            nf = 1 / (this._znear - this._zfar);
            this.projectMatrix[10] = 2 * nf;
            this.projectMatrix[14] = (this._znear + this._zfar) * nf;
        }
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
    };
    BaseCamera.prototype.reset = function () {
        this._firstPerson = false;
        this._theta = Math.PI; // The theta in the spherical coordinate.
        this._phi = 0;
        this._distance = 15.0; // The distance from eye to lookat position.
        this._fov = 46;
        this._invTanFov = 1.0 / Math.tan(this._fov * 0.00872665);
        this._perspective = true;
        mat4.perspective(this.projectMatrix, this._fov * Math.PI / 180, this._aspect, this._znear, this._zfar);
        this._at[0] = 0;
        this._at[1] = 0;
        this._at[2] = 0;
        this.eye[0] = -this._distance;
        this.eye[1] = 0;
        this.eye[2] = 0;
    };
    var unproject_p = [0, 0, 0];
    var unproject_ret = [0, 0, 0];
    // Find a screen point's position on the near plane in world space.
    // @param {Number} x x-coordinate obtained directly by mouse or cursor
    // @param {Number} y y-coordinate obtained directly by mouse or cursor
    // @param {Number} z the distance between this point and camera along the view direction, default value is znear
    BaseCamera.prototype.unproject = function (x, y, z) {
        x = Math.floor(x * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        y = Math.floor(y * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var width = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
        var height = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        var zPlane;
        if (z !== undefined) {
            zPlane = z;
        }
        else {
            zPlane = this._znear;
        }
        var nx = x / width * 2.0 - 1.0;
        var ny = (height - 1 - y) / height * 2.0 - 1.0;
        var nw, nh;
        var p;
        if (this._perspective) {
            nw = zPlane / this.projectMatrix[0];
            nh = zPlane / this.projectMatrix[5];
        }
        else {
            nw = 1 / this.projectMatrix[0];
            nh = 1 / this.projectMatrix[5];
        }
        unproject_p[0] = this.eye[0] - this.viewMatrix[2] * zPlane;
        unproject_p[1] = this.eye[1] - this.viewMatrix[6] * zPlane;
        unproject_p[2] = this.eye[2] - this.viewMatrix[10] * zPlane;
        unproject_ret[0] = unproject_p[0] + nx * nw * this.viewMatrix[0] + ny * nh * this.viewMatrix[1];
        unproject_ret[1] = unproject_p[1] + nx * nw * this.viewMatrix[4] + ny * nh * this.viewMatrix[5];
        unproject_ret[2] = unproject_p[2] + nx * nw * this.viewMatrix[8] + ny * nh * this.viewMatrix[9];
        return unproject_ret;
    };
    // Project a position into screen space
    BaseCamera.prototype.project = function (modelPosition, modelMatrix) {
        var worldPosition = vec4.fromValues();
        if (!(modelMatrix === null || modelMatrix === undefined)) {
            vec3.transformMat4(worldPosition, modelPosition, modelMatrix);
        }
        else {
            worldPosition[0] = modelPosition[0];
            worldPosition[1] = modelPosition[1];
            worldPosition[2] = modelPosition[2];
        }
        worldPosition[3] = 1.0;
        var windowPosition = vec4.fromValues();
        vec4.transformMat4(windowPosition, worldPosition, this.vpMatrix);
        windowPosition[0] /= windowPosition[3];
        windowPosition[1] /= windowPosition[3];
        windowPosition[2] /= windowPosition[3];
        // The comment div position 
        var x = (windowPosition[0] + 1) / 2.0 * this.viewport[2] + this.viewport[0];
        var y = (windowPosition[1] + 1) / 2.0 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        x = x / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        y = (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - y) / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        return [x, y, Math.sign(worldPosition[3])];
    };
    BaseCamera.prototype.setFirstPerson = function (enabled) {
        if (this._firstPerson !== enabled) {
            // transfer the theta and phi
            this._theta = Math.PI + this._theta;
            this._phi = -this._phi;
            this._firstPerson = enabled;
        }
    };
    BaseCamera.prototype._length = function (x, y, z) {
        return Math.sqrt(x * x + y * y + z * z);
    };
    var getViewDirection_ret = new Float32Array([0, 0, 0, 0]);
    BaseCamera.prototype.getViewDirection = function () {
        getViewDirection_ret[0] = -this.viewMatrix[2];
        getViewDirection_ret[1] = -this.viewMatrix[6];
        getViewDirection_ret[2] = -this.viewMatrix[10];
        return getViewDirection_ret;
    };
    BaseCamera.prototype.jitter = function (dx, dy) {
        if (this._perspective) {
            this.projectMatrix[8] += 2.0 * dx;
            this.projectMatrix[9] += 2.0 * dy;
        }
        else {
            this.projectMatrix[12] += 2.0 * dx;
            this.projectMatrix[13] += 2.0 * dy;
        }
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
    };
    BaseCamera.prototype.getNearPlaneSize = function () {
        if (this._perspective) {
            var tanFov = Math.tan(this._fov * 0.017453293 * 0.5);
            var nearHeight = tanFov * this._znear;
            var nearWidth = nearHeight * this._aspect;
            return [nearWidth, nearHeight, -this._znear];
        }
        else {
            return [1 / this.projectMatrix[0], 1 / this.projectMatrix[5], 1.0];
        }
    };
    BaseCamera.prototype.getFarPlaneSize = function () {
        if (this._perspective) {
            var tanFov = Math.tan(this._fov * 0.017453293 * 0.5);
            var farHeight = tanFov * this._zfar;
            var farWidth = farHeight * this._aspect;
            return [farWidth, farHeight, -this._zfar];
        }
        else {
            return [1 / this.projectMatrix[0], 1 / this.projectMatrix[5], 1.0];
        }
    };
    BaseCamera.prototype.transformPerspectiveToOrthogonal = function () {
        if (this._perspective) {
            //use far plane to cover most of the range
            var farPlane = this.getFarPlaneSize();
            this.setPerspective(false);
            this._setHeight(farPlane[1]);
            //make a shuffle to update the camera
            this._distance += 3e-4;
        }
    };
    /**
     * @description generate a ray starting from eye and hitting the point on near plane which corresponds
     * to screen coordinate (x, y)
     * @param {integer} x - the hit point coordinate in the screen space
     * @param {integer} y - ditto.
     * @param {vec3} point - the output ray's starting position
     * @param {vec3} direction - the output ray's normalized direction
     */
    BaseCamera.prototype.shootRay = function (x, y, point, direction) {
        var hit = this.unproject(x, y);
        if (this._perspective) {
            point[0] = this.eye[0];
            point[1] = this.eye[1];
            point[2] = this.eye[2];
            direction[0] = hit[0] - point[0];
            direction[1] = hit[1] - point[1];
            direction[2] = hit[2] - point[2];
        }
        else {
            point[0] = hit[0];
            point[1] = hit[1];
            point[2] = hit[2];
            direction[0] = -this.viewMatrix[2];
            direction[1] = -this.viewMatrix[6];
            direction[2] = -this.viewMatrix[10];
        }
        vec3.normalize(direction, direction);
    };
    BaseCamera.prototype.transformOrthogonalToPerspective = function () {
        if (!this._perspective) {
            this.setPerspective(true);
            //make a shuffle to update the camera
            this._distance += 1.5e-4;
        }
    };
    BaseCamera.prototype.copy = function (source) {
        this._at[0] = source._at[0];
        this._at[1] = source._at[1];
        this._at[2] = source._at[2];
        this._theta = source._theta;
        this._phi = source._phi;
        this._distance = source._distance;
        this._firstPerson = source._firstPerson;
        this._fov = source._fov;
        this._invTanFov = source._invTanFov;
        this._znear = source._znear;
        this._zfar = source._zfar;
        this._aspect = source._aspect;
        this._eventEmitter = source._eventEmitter;
        this._perspective = source._perspective;
        this._height = source._height;
        vec4.copy(this.viewport, source.viewport);
        mat4.copy(this.viewMatrix, source.viewMatrix);
        mat4.copy(this.projectMatrix, source.projectMatrix);
        mat4.copy(this.vpMatrix, source.vpMatrix);
        vec4.copy(this.eye, source.eye);
    };
    // Split the perspective camera frustum into several several partitions in the view direction.
    // FIXME: we only support 2 paritions now.
    var split_distances = new Array(5);
    BaseCamera.prototype.split = function (partitions, outCameras) {
        var znear = this._znear;
        var zfar = this._zfar;
        // Ci = (n(f / n) ^ i/m + n + (f - n)i/m) / 2+ bias; 
        // https://www.researchgate.net/publication/220805307_Parallel-split_shadow_maps_for_large-scale_virtual_environments
        var prevZ = znear;
        var bias = (zfar - znear) * 0.1;
        for (var i = 1; i < partitions; i++) {
            var p = i / partitions;
            var currZ = (znear * Math.pow(zfar / znear, p) + znear + Math.pow(zfar - znear, p)) * 0.5 + bias;
            var c = outCameras[i - 1];
            c.copy(this);
            c._updateProjection(prevZ, currZ);
            mat4.multiply(c.vpMatrix, c.projectMatrix, c.viewMatrix);
            prevZ = currZ;
            split_distances[i - 1] = currZ;
        }
        var c = outCameras[partitions - 1];
        c.copy(this);
        c._updateProjection(prevZ, zfar);
        mat4.multiply(c.vpMatrix, c.projectMatrix, c.viewMatrix);
        return split_distances;
    };
    return BaseCamera;
})());


/***/ }),

/***/ "./03scene/camera/m3d_camera_animator.js":
/*!***********************************************!*\
  !*** ./03scene/camera/m3d_camera_animator.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_camera_animator.js
// The base class for animation of camera
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function CameraAnimator() {
        this._camera = null; // The current associate camera
        this._saved = null; // The previous animator that scene camera uses
    }
    ;
    CameraAnimator.prototype.destroy = function () {
        this._camera = null;
        delete this._camera;
    };
    CameraAnimator.prototype.attach = function (sceneCamera, forceReplace) {
        this._camera = sceneCamera;
        if (this._saved == null || forceReplace) {
            this._saved = this._camera.animator;
            this._camera.animator = this;
        }
    };
    CameraAnimator.prototype.detach = function (sceneCamera) {
        this._camera.animator = this._saved;
        this._saved = null;
        this._camera = null;
    };
    CameraAnimator.prototype.update = function () {
    };
    CameraAnimator.prototype._onStart = function () {
    };
    CameraAnimator.prototype._onEnd = function () {
    };
    return CameraAnimator;
})());


/***/ }),

/***/ "./03scene/camera/m3d_camera_animator_morphing.js":
/*!********************************************************!*\
  !*** ./03scene/camera/m3d_camera_animator_morphing.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_camera_animator.js */ "./03scene/camera/m3d_camera_animator.js");
/* harmony import */ var _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
//
// m3d_camera_animator_transition.js
// The scene animation file includes all the transit and navigation functions
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var STEPS = 50;
    function CameraAnimatorMorphing() {
        _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);
        this._speed = 0;
    }
    ;
    CameraAnimatorMorphing.prototype = Object.create(_m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
    CameraAnimatorMorphing.prototype.constructor = CameraAnimatorMorphing;
    CameraAnimatorMorphing.prototype.update = function () {
        var camera = this._camera;
        if (Math.abs(camera._targetFov - camera._fov) < Math.abs(this._speed)) {
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype._setFov.apply(camera, [camera._targetFov]);
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.update.apply(camera, arguments);
            camera._cull.update();
            this.detach();
            return false;
        }
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype._setFov.apply(camera, [camera._fov + this._speed]);
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.update.apply(camera, arguments);
        camera._cull.update();
        return true;
    };
    // Move to destination camera in a smooth transition animation. Return
    // false if destination is the same as starting position.
    CameraAnimatorMorphing.prototype.start = function (phi, theta, fov, targetFOV) {
        var camera = this._camera;
        if (phi) {
            camera._phi = camera._targetPhi = phi;
        }
        if (theta) {
            camera._theta = camera._targetTheta = theta;
        }
        if (fov != null) {
            fov = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].clamp(fov, 1, 170);
            camera._fov = fov;
        }
        if (targetFOV) {
            camera._targetFov = targetFOV;
        }
        this._fovDiff = camera._targetFov - camera._fov;
        this._speed = (camera._targetFov - camera._fov) / STEPS;
    };
    CameraAnimatorMorphing.prototype.getProgress = function () {
        var camera = this._camera;
        return (camera._targetFov - camera._fov) / this._fovDiff;
    };
    return CameraAnimatorMorphing;
})());


/***/ }),

/***/ "./03scene/camera/m3d_camera_animator_navigate.js":
/*!********************************************************!*\
  !*** ./03scene/camera/m3d_camera_animator_navigate.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_camera_animator.js */ "./03scene/camera/m3d_camera_animator.js");
//
// m3d_camera_animator_navigate.js
// The camera animation used for scene navigation
//
// Copyright Modelo XX - 2017, All rights reserved.
//


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function CameraAnimatorNavigate() {
        // Inheritance:
        _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);
    }
    ;
    CameraAnimatorNavigate.prototype = Object.create(_m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
    CameraAnimatorNavigate.prototype.constructor = CameraAnimatorNavigate;
    CameraAnimatorNavigate.prototype.update = function () {
        var camera = this._camera;
        var updated = true;
        camera.eye[0] += (camera._targetEye[0] - camera.eye[0]) * 0.15;
        camera.eye[1] += (camera._targetEye[1] - camera.eye[1]) * 0.15;
        camera.eye[2] += (camera._targetEye[2] - camera.eye[2]) * 0.15;
        camera._at[0] += (camera._targetAt[0] - camera._at[0]) * 0.15;
        camera._at[1] += (camera._targetAt[1] - camera._at[1]) * 0.15;
        camera._at[2] += (camera._targetAt[2] - camera._at[2]) * 0.15;
        camera._distance = vec3.distance(camera.eye, camera._at);
        mat4.lookAt(camera.viewMatrix, camera.eye, camera._at, [0.0, 0.0, 1.0]);
        var diffFov = camera._targetFov - camera._fov;
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._setFov.apply(camera, [camera._fov + diffFov * 0.15]);
        camera._updateProjection();
        mat4.multiply(camera.vpMatrix, camera.projectMatrix, camera.viewMatrix);
        camera._cull.update();
        return updated;
    };
    CameraAnimatorNavigate.prototype.stop = function (forceStop) {
        var camera = this._camera;
        // When navigateEnd is called in transit() or outside, the navigation path
        // has not been finished as we are approaching target camera gradually. Thus
        // we delay the navigation end till camera freezes.
        if (!forceStop) {
            if (!camera) {
                return;
            }
            var changed = vec3.distance(camera.eye, camera._targetEye) > 1e-3 ||
                vec3.distance(camera._at, camera._targetAt) > 1e-3 ||
                Math.abs(camera._targetFov - camera._fov) > 1e-3;
            var that = this;
            if (changed) {
                window.setTimeout(function () {
                    that.stop();
                }, 100);
                return;
            }
        }
        camera._distance = camera._targetDistance;
        var dx = camera.eye[0] - camera._at[0];
        var dy = camera.eye[1] - camera._at[1];
        var dz = camera.eye[2] - camera._at[2];
        camera._targetPhi = camera._phi = Math.asin(Math.min(dz / camera._targetDistance, 1.0));
        if (camera._targetPhi >= 0.49999 * Math.PI) {
            camera._targetPhi = 0.49999 * Math.PI;
        }
        if (camera._targetPhi <= -0.49999 * Math.PI) {
            camera._targetPhi = -0.49999 * Math.PI;
        }
        camera._targetTheta = camera._theta = Math.atan2(dy, dx);
        if (camera._firstPerson) {
            camera._targetPhi = camera._phi = -camera._targetPhi;
            camera._targetTheta = camera._theta = camera._targetTheta + Math.PI;
        }
        this.detach();
    };
    CameraAnimatorNavigate.prototype.start = function (eye, at, theta, phi, fov) {
        var camera = this._camera;
        camera._targetAt[0] = at[0];
        camera._targetAt[1] = at[1];
        camera._targetAt[2] = at[2];
        camera._targetEye[0] = eye[0];
        camera._targetEye[1] = eye[1];
        camera._targetEye[2] = eye[2];
        if (theta) {
            camera._targetTheta = theta;
        }
        if (phi) {
            camera._targetPhi = phi;
        }
        if (fov) {
            camera.setTargetFov(fov);
        }
        var dx = camera._targetAt[0] - camera._targetEye[0];
        var dy = camera._targetAt[1] - camera._targetEye[1];
        var dz = camera._targetAt[2] - camera._targetEye[2];
        // Update the camera parameters.
        var d = Math.sqrt(dx * dx + dy * dy + dz * dz);
        camera._targetDistance = d;
        // if target distance is too small, smaller than znear distance,
        // we scale it a little up. Otherwise, the camera panning will be
        // working improperly.
        if (d < 0.001 * camera._scene.radius) {
            var scale = 0.001 * camera._scene.radius / d;
            camera._targetDistance = 0.001 * camera._scene.radius;
            camera._targetAt[0] = scale * dx + camera._targetEye[0];
            camera._targetAt[1] = scale * dy + camera._targetEye[1];
            camera._targetAt[2] = scale * dz + camera._targetEye[2];
        }
    };
    return CameraAnimatorNavigate;
})());


/***/ }),

/***/ "./03scene/camera/m3d_camera_animator_normal.js":
/*!******************************************************!*\
  !*** ./03scene/camera/m3d_camera_animator_normal.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_camera_animator.js */ "./03scene/camera/m3d_camera_animator.js");
//
// m3d_camera_animator_normal.js
// The normal camera animation
//
// Copyright Modelo XX - 2017, All rights reserved.
//


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function CameraAnimatorNormal() {
        // Inheritance:
        _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);
        this._updateThreshold = 1e-4; // We set the threshold to a fixed value for now, in the future if we
        // found wasted update canvas or too much calculation, change this value
        // based on the scene's radius
        this._acceleration = 0.15;
    }
    ;
    CameraAnimatorNormal.prototype = Object.create(_m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
    CameraAnimatorNormal.prototype.constructor = CameraAnimatorNormal;
    CameraAnimatorNormal.prototype.update = function () {
        var camera = this._camera;
        var diffDistance = camera._targetDistance - camera._distance;
        var diffTheta = camera._targetTheta - camera._theta;
        var diffPhi = camera._targetPhi - camera._phi;
        var diffFov = camera._targetFov - camera._fov;
        var updated = false;
        var diffAt = 0;
        if (!camera._firstPerson) {
            var diffAt0 = camera._targetAt[0] - camera._at[0];
            var diffAt1 = camera._targetAt[1] - camera._at[1];
            var diffAt2 = camera._targetAt[2] - camera._at[2];
            camera._at[0] += diffAt0 * this._acceleration;
            camera._at[1] += diffAt1 * this._acceleration;
            camera._at[2] += diffAt2 * this._acceleration;
            diffAt = Math.abs(diffAt0) + Math.abs(diffAt1) + Math.abs(diffAt2);
        }
        // Check if the camera has been updated in camera frame.
        var angleChanged = Math.abs(diffTheta) + Math.abs(diffPhi) > 1e-4;
        var positionChanged = (Math.abs(diffDistance) + diffAt) > this._updateThreshold;
        var fovChanged = Math.abs(diffFov) > 1e-4;
        updated = angleChanged || positionChanged || fovChanged; // either force rendering or camera updated.
        if (updated) {
            camera._distance += diffDistance * this._acceleration;
            camera._theta += diffTheta * this._acceleration;
            camera._phi += diffPhi * this._acceleration;
            if (camera._phi >= 0.499999 * Math.PI) {
                camera._phi = 0.499999 * Math.PI;
            }
            if (camera._phi <= -0.499999 * Math.PI) {
                camera._phi = -0.499999 * Math.PI;
            }
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._setFov.apply(camera, [camera._fov + diffFov * this._acceleration]);
            // Update projection every frame because we find it is needed when at is no longer at
            // the origin of the world space.
            if (camera._scene) {
                camera._updateProjection();
            }
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.update.apply(camera, arguments);
            camera._cull.update();
        }
        return updated;
    };
    return CameraAnimatorNormal;
})());


/***/ }),

/***/ "./03scene/camera/m3d_camera_animator_panorama.js":
/*!********************************************************!*\
  !*** ./03scene/camera/m3d_camera_animator_panorama.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_interpolator.js */ "./00utility/m3d_interpolator.js");
/* harmony import */ var _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_camera_animator.js */ "./03scene/camera/m3d_camera_animator.js");
//
// m3d_camera_animator_transition.js
// The scene animation file includes all the transit and navigation functions
//
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function CameraAnimatorPanorama(eventEmitter) {
        _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);
        //Suppose the eye is always at 0
        this._srcAt = vec3.create(); // source
        this._dstAt = vec3.create(); // destination
        this._srcTheta = 0;
        this._dstTheta = 0;
        this._srcPhi = 0;
        this._dstPhi = 0;
        this._curTheta = 0;
        this._curPhi = 0;
        this._eventEmitter = eventEmitter;
        this._startTime = 0;
        this._duration = 0;
        this._speed = 15;
    }
    ;
    CameraAnimatorPanorama.prototype = Object.create(_m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
    CameraAnimatorPanorama.prototype.constructor = CameraAnimatorPanorama;
    CameraAnimatorPanorama.prototype.update = function () {
        var currTime = new Date().getTime();
        var elapsedTime = currTime - this._startTime;
        if (elapsedTime >= this._duration) {
            if (elapsedTime > this._duration * 3) {
                this.stop();
                if (this._eventEmitter) {
                    this._eventEmitter.emit("Tour360-TransitionOver");
                }
            }
            else if (!this._updateCamera(this._dstTheta, this._dstPhi)) {
                this.stop();
                if (this._eventEmitter) {
                    this._eventEmitter.emit("Tour360-TransitionOver");
                }
            }
            return true;
        }
        var ratio = elapsedTime / this._duration;
        this._curPhi = _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_0__["default"].linear.scalar(this._srcPhi, this._dstPhi, ratio);
        this._curTheta = _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_0__["default"].linear.scalar(this._srcTheta, this._dstTheta, ratio);
        return this._updateCamera(this._curTheta, this._curPhi);
    };
    CameraAnimatorPanorama.prototype.stop = function () {
        var camera = this._camera;
        camera._targetDistance = camera._distance;
        var dx = camera.eye[0] - camera._at[0];
        var dy = camera.eye[1] - camera._at[1];
        var dz = camera.eye[2] - camera._at[2];
        camera._targetPhi = camera._phi = Math.asin(Math.min(dz / camera._targetDistance, 1.0));
        if (camera._targetPhi >= 0.49999 * Math.PI) {
            camera._targetPhi = 0.49999 * Math.PI;
        }
        if (camera._targetPhi <= -0.49999 * Math.PI) {
            camera._targetPhi = -0.49999 * Math.PI;
        }
        camera._targetTheta = camera._theta = Math.atan2(dy, dx);
        if (camera._firstPerson) {
            camera._targetPhi = camera._phi = -camera._targetPhi;
            camera._targetTheta = camera._theta = camera._targetTheta + Math.PI;
        }
        this.detach();
    };
    // Move to destination camera in a smooth transition animation. Return
    // false if destination is the same as starting position.
    CameraAnimatorPanorama.prototype.start = function (destination) {
        var camera = this._camera;
        var radius = 15;
        vec3.normalize(camera._at, camera._at);
        vec3.scale(camera._at, camera._at, radius);
        camera._targetTheta = camera._theta = Math.atan2(camera._at[1], camera._at[0]);
        vec3.copy(this._srcAt, camera._at);
        var position = vec3.clone(destination);
        vec3.normalize(position, position);
        vec3.scale(position, position, radius);
        vec3.copy(this._dstAt, position);
        this._srcTheta = camera._theta;
        this._srcPhi = camera._phi;
        this._dstTheta = Math.atan2(position[1], position[0]);
        var diffTheta = this._dstTheta - this._srcTheta;
        if (Math.abs(diffTheta) > Math.PI) {
            this._dstTheta -= Math.PI * 2;
        }
        this._dstPhi = Math.asin(Math.min(position[2] / radius, 1.0));
        if (this._dstPhi >= 0.49999 * Math.PI) {
            this._dstPhi = 0.49999 * Math.PI;
        }
        if (this._dstPhi <= -0.49999 * Math.PI) {
            this._dstPhi = -0.49999 * Math.PI;
        }
        var dis1, dis2;
        // angle difference between target theta and source theta
        dis1 = Math.abs(this._srcTheta - this._dstTheta);
        // angle difference between target phi and source phi
        dis2 = Math.abs(this._srcPhi - this._dstPhi);
        dis1 = Math.ceil(dis1 / Math.PI * 90);
        dis2 = Math.ceil(dis2 / Math.PI * 90);
        var steps = Math.max(dis1, dis2);
        this._duration = steps * this._speed;
        this._startTime = new Date().getTime();
        return true;
    };
    CameraAnimatorPanorama.prototype._updateCamera = function (theta, phi) {
        var camera = this._camera;
        var sx = Math.sin(phi);
        var cx = Math.cos(phi);
        var sz = Math.sin(theta);
        var cz = Math.cos(theta);
        camera._targetAt[0] = cx * cz * camera._distance;
        camera._targetAt[1] = cx * sz * camera._distance;
        camera._targetAt[2] = sx * camera._distance;
        camera._targetTheta = theta;
        camera._targetPhi = phi;
        var diffTheta = camera._targetTheta - camera._theta;
        var diffPhi = camera._targetPhi - camera._phi;
        var diffEye0 = camera._targetEye[0] - camera.eye[0];
        var diffEye1 = camera._targetEye[1] - camera.eye[1];
        var diffEye2 = camera._targetEye[2] - camera.eye[2];
        var diffAt0 = camera._targetAt[0] - camera._at[0];
        var diffAt1 = camera._targetAt[1] - camera._at[1];
        var diffAt2 = camera._targetAt[2] - camera._at[2];
        var positionChanged = (Math.abs(diffEye0) + Math.abs(diffEye1) + Math.abs(diffEye2) +
            Math.abs(diffAt0) + Math.abs(diffAt1) + Math.abs(diffAt2)) > 1e-4;
        var updated = positionChanged;
        camera.eye[0] += diffEye0 * 0.15;
        camera.eye[1] += diffEye1 * 0.15;
        camera.eye[2] += diffEye2 * 0.15;
        camera._at[0] += diffAt0 * 0.15;
        camera._at[1] += diffAt1 * 0.15;
        camera._at[2] += diffAt2 * 0.15;
        camera._distance = vec3.distance(camera.eye, camera._at);
        mat4.lookAt(camera.viewMatrix, camera.eye, camera._at, [0.0, 0.0, 1.0]);
        mat4.multiply(camera.vpMatrix, camera.projectMatrix, camera.viewMatrix);
        return updated;
    };
    CameraAnimatorPanorama.prototype.setTransitionSpeed = function (speed) {
        this._speed = speed;
    };
    return CameraAnimatorPanorama;
})());


/***/ }),

/***/ "./03scene/camera/m3d_camera_animator_transition.js":
/*!**********************************************************!*\
  !*** ./03scene/camera/m3d_camera_animator_transition.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_interpolator.js */ "./00utility/m3d_interpolator.js");
/* harmony import */ var _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_camera_animator.js */ "./03scene/camera/m3d_camera_animator.js");
/* harmony import */ var _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
//
// m3d_camera_animator_transition.js
// The scene animation file includes all the transit and navigation functions
//
// Copyright Modelo XX - 2017, All rights reserved.




/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function CameraAnimatorTransition(eventEmitter) {
        _m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_2__["default"].apply(this, arguments);
        this._srcAt = vec3.create(); // source
        this._srcEye = vec3.create();
        this._dstAt = vec3.create(); // destination
        this._dstEye = vec3.create();
        this._curAt = vec3.create(); // current
        this._curEye = vec3.create();
        this._eventEmitter = eventEmitter;
        this._srcTheta = 0;
        this._dstTheta = 0;
        this._srcPhi = 0;
        this._dstPhi = 0;
        this._curTheta = 0;
        this._curPhi = 0;
        this._srcDistance = 0;
        this._dstDistance = 0;
        this._startTime = 0;
        this._duration = 0;
        this._speed = 15;
        this._isPano = false;
    }
    ;
    CameraAnimatorTransition.prototype = Object.create(_m3d_camera_animator_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
    CameraAnimatorTransition.prototype.constructor = CameraAnimatorTransition;
    CameraAnimatorTransition.prototype.update = function () {
        var currTime = new Date().getTime();
        var elapsedTime = currTime - this._startTime;
        if (elapsedTime >= this._duration) {
            if (elapsedTime > this._duration * 3) {
                if (this._eventEmitter) {
                    this._eventEmitter.emit("Comment-TransitionOver");
                }
                this.stop();
            }
            else if (!this._updateCamera(this._dstEye, this._dstAt, this._dstTheta, this._dstPhi)) {
                if (this._eventEmitter) {
                    this._eventEmitter.emit("Comment-TransitionOver");
                }
                this.stop();
            }
            return true;
        }
        var ratio = elapsedTime / this._duration;
        //I use the sin function to make the movement slow at first and fast in the middle,
        //slow down at last. If it's not obvious, I can change to other similar function.
        ratio = Math.sin(ratio * Math.PI - Math.PI / 2) / 2 + 0.5;
        _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_1__["default"].linear.vec3(this._curAt, this._srcAt, this._dstAt, ratio);
        _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_1__["default"].linear.vec3(this._curEye, this._srcEye, this._dstEye, ratio);
        this._curPhi = _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_1__["default"].linear.scalar(this._srcPhi, this._dstPhi, ratio);
        this._curTheta = _00utility_m3d_interpolator_js__WEBPACK_IMPORTED_MODULE_1__["default"].linear.scalar(this._srcTheta, this._dstTheta, ratio);
        if (vec3.distance(this._curEye, this._curAt) > 1e-3) {
            return this._updateCamera(this._curEye, this._curAt, this._curTheta, this._curPhi);
        }
        return false;
    };
    CameraAnimatorTransition.prototype.stop = function () {
        var camera = this._camera;
        camera._targetDistance = camera._distance;
        var dx = camera.eye[0] - camera._at[0];
        var dy = camera.eye[1] - camera._at[1];
        var dz = camera.eye[2] - camera._at[2];
        camera._targetPhi = camera._phi = Math.asin(Math.min(dz / camera._targetDistance, 1.0));
        if (camera._targetPhi >= 0.49999 * Math.PI) {
            camera._targetPhi = 0.49999 * Math.PI;
        }
        if (camera._targetPhi <= -0.49999 * Math.PI) {
            camera._targetPhi = -0.49999 * Math.PI;
        }
        camera._targetTheta = camera._theta = Math.atan2(dy, dx);
        if (camera._firstPerson) {
            camera._targetPhi = camera._phi = -camera._targetPhi;
            camera._targetTheta = camera._theta = camera._targetTheta + Math.PI;
        }
        this.detach();
    };
    // Move to destination camera in a smooth transition animation. Return
    // false if destination is the same as starting position.
    CameraAnimatorTransition.prototype.start = function (destination, isVrEnabled, maxStepNum) {
        var camera = this._camera;
        if (isVrEnabled) {
            camera.restore(destination);
        }
        this._setStartPoint(camera._at, camera.eye, camera._distance, destination.at, camera._theta, camera._phi);
        if (!isVrEnabled) {
            camera.restore(destination);
        }
        this._setEndPoint(camera._targetDistance, camera._targetTheta, camera._targetPhi, camera._firstPerson, camera._scene ? camera._scene.radius : 100, maxStepNum);
        vec3.copy(camera._at, this._srcAt);
        vec3.copy(camera.eye, this._srcEye);
        if (isVrEnabled) {
            this._updateCamera(this._dstEye, this._dstAt, this._dstTheta, this._dstPhi);
            return true;
        }
        this._startTime = new Date().getTime();
        this._updateCamera(this._srcEye, this._srcAt, this._srcTheta, this._srcPhi);
        return true;
    };
    //For panorama autoplay
    CameraAnimatorTransition.prototype.startPano = function (position) {
        var camera = this._camera;
        this._isPano = true;
        vec3.normalize(position, position);
        vec3.scale(position, position, 15);
        vec3.copy(this._srcAt, camera._at);
        vec3.copy(this._srcEye, camera.eye);
        this._srcDistance = vec3.distance(camera.eye, camera._at);
        vec3.copy(this._dstAt, position);
        this._srcTheta = camera._theta;
        this._srcPhi = camera._phi;
        this._dstDistance = vec3.distance(camera.eye, position);
        this._dstTheta = camera._theta;
        this._dstPhi = camera._phi;
        vec3.copy(this._dstEye, camera.eye);
        var dis1, dis2;
        // distance between target at and source at
        dis1 = vec3.distance(this._srcAt, this._dstAt);
        // distance between target distance and source distance
        dis2 = Math.abs(this._srcDistance - this._dstDistance);
        var RATIO = 450;
        var MAX_STEPNUM = 266;
        dis1 = Math.ceil(dis1 / 100 * RATIO);
        dis2 = Math.ceil(dis2 / 100 * RATIO);
        var steps = Math.max(dis1, dis2); // we move at 20km/hour
        steps = Math.min(Math.max(steps, 1), MAX_STEPNUM);
        this._duration = steps * this._speed;
        this._startTime = new Date().getTime();
        this._updateCamera(this._srcEye, this._srcAt, this._srcTheta, this._srcPhi);
        return true;
    };
    CameraAnimatorTransition.prototype._setStartPoint = function (srcAt, srcEye, srcDis, dstAt, srcTheta, srcPhi) {
        vec3.copy(this._srcAt, srcAt);
        vec3.copy(this._srcEye, srcEye);
        this._srcDistance = srcDis;
        vec3.copy(this._dstAt, dstAt);
        this._srcTheta = srcTheta;
        this._srcPhi = srcPhi;
    };
    CameraAnimatorTransition.prototype._setEndPoint = function (dstDis, dstTheta, dstPhi, isReverse, radius, maxStepNum) {
        this._dstDistance = dstDis;
        this._dstTheta = dstTheta;
        this._dstPhi = dstPhi;
        var dx;
        var dy;
        var dz;
        var sx = Math.sin(this._dstPhi);
        var cx = Math.cos(this._dstPhi);
        var sz = Math.sin(this._dstTheta);
        var cz = Math.cos(this._dstTheta);
        dx = cx * cz;
        dy = cx * sz;
        dz = sx;
        if (isReverse) {
            dx = -dx;
            dy = -dy;
            dz = -dz;
        }
        this._dstEye[0] = this._dstAt[0] + dx * this._dstDistance;
        this._dstEye[1] = this._dstAt[1] + dy * this._dstDistance;
        this._dstEye[2] = this._dstAt[2] + dz * this._dstDistance;
        // For the transition from one comment to another, we call the transition traversal function every 15ms.
        // For example if we take 100 steps to finish entire transition, then whole time is 1500ms.
        // 
        // The number of steps is calculated by 5 factors as follows: dis1,
        // dis2, dis3, dis4 and dis5 Suppose the whole scene's radius is 100
        // feet and the distance between source eye and target eye is 5 feet,
        // then the dis2 is 5 / 100 * RATIO where RATIO is a pre-defined value.
        //
        // We choose the largest among dis1 to dis5 to the value of steps.
        // Sometimes the steps can be big if the scene is a whole city. The
        // transition might take a very long time That's why we defined a value
        // called MAX_STEPNUM, which will set a limit to the steps. 
        // FIXME: it is not easy to find proper steps values for different
        // scenes as scenes are varying in their size varying in their sizes.
        // another. At many times the transition may fail to have a pleasant
        // speed on certain models we have not found a perfect solution yet.
        var dis1, dis2, dis3, dis4, dis5;
        // distance between target at and source at
        dis1 = vec3.distance(this._srcAt, this._dstAt);
        // distance between target eye and source eye
        dis2 = vec3.distance(this._srcEye, this._dstEye);
        // distance between target distance and source distance
        dis3 = Math.abs(this._srcDistance - this._dstDistance);
        // angle difference between target theta and source theta
        dis4 = Math.abs(this._srcTheta - this._dstTheta);
        // angle difference between target phi and source phi
        dis5 = Math.abs(this._srcPhi - this._dstPhi);
        var RATIO = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile ? 300 : 450;
        var MAX_STEPNUM = maxStepNum || 266;
        dis1 = Math.ceil(dis1 / radius * RATIO);
        dis2 = Math.ceil(dis2 / radius * RATIO);
        dis3 = Math.ceil(dis3 / radius * RATIO);
        dis4 = Math.ceil(dis4 / Math.PI * 90);
        dis5 = Math.ceil(dis5 / Math.PI * 90);
        var steps = Math.max(dis3, Math.max(dis1, dis2)); // we move at 20km/hour
        steps = Math.max(steps, Math.max(dis4, dis5));
        steps = Math.min(Math.max(steps, 1), MAX_STEPNUM);
        this._duration = steps * this._speed;
    };
    CameraAnimatorTransition.prototype._updateCamera = function (eye, at, theta, phi) {
        var camera = this._camera;
        camera._targetAt[0] = at[0];
        camera._targetAt[1] = at[1];
        camera._targetAt[2] = at[2];
        camera._targetEye[0] = eye[0];
        camera._targetEye[1] = eye[1];
        camera._targetEye[2] = eye[2];
        if (theta) {
            camera._targetTheta = theta;
        }
        if (phi) {
            camera._targetPhi = phi;
        }
        var dx = camera._targetAt[0] - camera._targetEye[0];
        var dy = camera._targetAt[1] - camera._targetEye[1];
        var dz = camera._targetAt[2] - camera._targetEye[2];
        // Update the camera parameters.
        var d = Math.sqrt(dx * dx + dy * dy + dz * dz);
        camera._targetDistance = d;
        // if target distance is too small, smaller than znear distance,
        // we scale it a little up. Otherwise, the camera panning will be
        // working improperly.
        var radius = camera._scene ? camera._scene.radius : 100;
        if (d < 0.001 * radius) {
            var scale = 0.001 * radius / d;
            camera._targetDistance = 0.001 * radius;
            camera._targetAt[0] = scale * dx + camera._targetEye[0];
            camera._targetAt[1] = scale * dy + camera._targetEye[1];
            camera._targetAt[2] = scale * dz + camera._targetEye[2];
        }
        var diffFov = camera._targetFov - camera._fov;
        var diffTheta = camera._targetTheta - camera._theta;
        var diffPhi = camera._targetPhi - camera._phi;
        var diffEye0 = camera._targetEye[0] - camera.eye[0];
        var diffEye1 = camera._targetEye[1] - camera.eye[1];
        var diffEye2 = camera._targetEye[2] - camera.eye[2];
        var diffAt0 = camera._targetAt[0] - camera._at[0];
        var diffAt1 = camera._targetAt[1] - camera._at[1];
        var diffAt2 = camera._targetAt[2] - camera._at[2];
        //MOD-6554, if the phi is 0.5*PI or -0.5*PI, then the transition camera
        //needs more iteration to get to the right eye and at position. So change
        //the threshold from 1e-4 to 1e-7
        var isVertical = false;
        if (Math.abs(1 - Math.abs(camera._targetPhi / (Math.PI * 0.49999))) < 1e-4) {
            isVertical = true;
        }
        var angleChanged = Math.abs(diffTheta) + Math.abs(diffPhi) > 1e-4;
        var positionChanged = (Math.abs(diffEye0) + Math.abs(diffEye1) + Math.abs(diffEye2) +
            Math.abs(diffAt0) + Math.abs(diffAt1) + Math.abs(diffAt2)) > (isVertical ? 6e-7 : 1e-4);
        var fovChanged = Math.abs(diffFov) > 1e-4;
        var updated = angleChanged || positionChanged || fovChanged;
        camera.eye[0] += diffEye0 * 0.15;
        camera.eye[1] += diffEye1 * 0.15;
        camera.eye[2] += diffEye2 * 0.15;
        camera._at[0] += diffAt0 * 0.15;
        camera._at[1] += diffAt1 * 0.15;
        camera._at[2] += diffAt2 * 0.15;
        camera._distance = vec3.distance(camera.eye, camera._at);
        mat4.lookAt(camera.viewMatrix, camera.eye, camera._at, [0.0, 0.0, 1.0]);
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype._setFov.apply(camera, [camera._fov + diffFov * 0.15]);
        if (camera._scene) {
            camera._updateProjection();
        }
        mat4.multiply(camera.vpMatrix, camera.projectMatrix, camera.viewMatrix);
        camera._cull.update();
        return updated;
    };
    CameraAnimatorTransition.prototype.setTransitionSpeed = function (speed) {
        this._speed = speed;
    };
    return CameraAnimatorTransition;
})());


/***/ }),

/***/ "./03scene/camera/m3d_scene_camera.js":
/*!********************************************!*\
  !*** ./03scene/camera/m3d_scene_camera.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _culling_m3d_cull_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../culling/m3d_cull.js */ "./03scene/culling/m3d_cull.js");
/* harmony import */ var _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _m3d_camera_animator_normal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./m3d_camera_animator_normal.js */ "./03scene/camera/m3d_camera_animator_normal.js");
//
// m3d_scene_camera.js
// The scene camera
//
// Copyright Modelo XX - 2017, All rights reserved.




/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var DISTANCERATIO = 1.05; // The distance to model is based on the model's radius
    var ZOOM_RATIO = 0.35;
    var offProj = vec3.create(); // Only used in update projection for saving GC
    var centerProj = vec3.create(); // Only used in update projection for saving GC
    var targetEyeProj = [0, 0, 0]; // Only used in update projection for saving GC
    function SceneCamera(scene) {
        // Inheritance:
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].apply(this, arguments);
        // public:
        this._scene = scene;
        // private:
        // The targetXXX is updated by UI input event and while xxx is updated in
        // UI mainloop so that when xxx approaches xxxTarget, it generates an
        // animation/inertia effect.
        this._targetAt = [0, 0, 0]; // The position where we look at finally
        // We change this value from vec3.fromValues to [0,0,0]
        // because of the precision issue
        this._targetEye = [0, 0, 0]; // Only used in navigation
        this._targetFov = 46;
        this._targetTheta = -Math.PI / 4.0;
        this._targetPhi = Math.PI / 18.0;
        this._targetDistance = 15.0;
        this._initDistance = 15.0; // Only used to save the view distance at init time
        this._maxZoomOffset = 0.6;
        this._minZoomOffset = 0.15;
        this.animator = new _m3d_camera_animator_normal_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
        this.animator.attach(this);
        this._cull = new _culling_m3d_cull_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        this.updated = true;
        this._prevUpdated = this.updated;
        this._updateStopListeners = [];
    }
    ;
    SceneCamera.prototype = Object.create(_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
    SceneCamera.prototype.constructor = SceneCamera;
    SceneCamera.prototype.destroy = function () {
        this._cull.destroy();
        this._cull = null;
        delete this._cull;
        this.animator.destroy();
        this.animator = null;
        delete this.animator;
        this._targetAt = null;
        delete this._targetAt;
        this._targetEye = null;
        delete this._targetEye;
        this._updateStopListeners = null;
        delete this._updateStopListeners;
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.destroy(this, arguments);
    };
    SceneCamera.prototype.resize = function (width, height) {
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.resize.call(this, width, height);
        for (var i = 0; i < this._updateStopListeners.length; i++) {
            this._updateStopListeners[i](this);
        }
    };
    SceneCamera.prototype.update = function () {
        this._prevUpdated = this.updated;
        this.updated = this.animator.update();
        if (this._prevUpdated && !this.updated) {
            for (var i = 0; i < this._updateStopListeners.length; i++) {
                this._updateStopListeners[i](this);
            }
        }
        return this.updated;
    };
    SceneCamera.prototype.addUpdateStopListener = function (listener) {
        this._updateStopListeners.push(listener);
    };
    SceneCamera.prototype.removeUpdateStopListener = function (listener) {
        var idx = this._updateStopListeners.indexOf(listener);
        if (idx >= 0) {
            this._updateStopListeners.splice(idx, 1);
        }
    };
    SceneCamera.prototype.rotate = function (x, y) {
        if (this._firstPerson) {
            y = -y;
        }
        this._targetTheta -= x * 0.006;
        this._targetPhi += y * 0.006;
        if (this._targetPhi >= 0.499999 * Math.PI) {
            this._targetPhi = 0.499999 * Math.PI;
        }
        if (this._targetPhi <= -0.499999 * Math.PI) {
            this._targetPhi = -0.499999 * Math.PI;
        }
    };
    SceneCamera.prototype.setCullingEnabled = function (enabled) {
        this._cull.setEnabled(enabled);
        if (enabled) {
            this._cull.update();
        }
    };
    SceneCamera.prototype.setBimCullingEnabled = function (enabled) {
        this._cull.setBimCullingEnabled(this._scene.isBimCullingNeeded && enabled);
        if (this.isBimCullingEnabled()) {
            this._cull.update();
        }
    };
    SceneCamera.prototype.isBimCullingEnabled = function () {
        return this._scene.isBimCullingNeeded && this._cull.isBimCullingEnabled();
    };
    SceneCamera.prototype.setTargetFov = function (fov) {
        this._targetFov = fov;
        if (this._targetFov >= 179.9) {
            this._targetFov = 179.9;
        }
        if (this._targetFov <= 0.1) {
            this._targetFov = 0.1;
        }
    };
    SceneCamera.prototype.getTargetFov = function () {
        return this._targetFov;
    };
    SceneCamera.prototype.zoom = function (delta, x, y) {
        if (this._perspective) {
            var zoomOffset = Math.abs(delta * this._targetDistance * ZOOM_RATIO);
            zoomOffset = (delta > 0 ? 1 : -1) * Math.min(Math.max(zoomOffset, this._minZoomOffset), this._maxZoomOffset);
            // We are approach the current pivot and we should now move the pivot too.
            if (this._targetDistance < zoomOffset) {
                var dir = this.getViewDirection();
                this._targetAt[0] += dir[0] * zoomOffset;
                this._targetAt[1] += dir[1] * zoomOffset;
                this._targetAt[2] += dir[2] * zoomOffset;
            }
            else {
                this._targetDistance -= zoomOffset;
            }
        }
        else {
            // In ortho view, we use scaling to zoom in/out the view
            var height = this._height * Math.max(1.0 - delta * 0.1 * ZOOM_RATIO, 0.00001);
            if (x !== undefined && y !== undefined) {
                var xRatio = x / this.viewport[2];
                var yRatio = (this.viewport[3] - 1 - y) / this.viewport[3];
                var left = (this.projectMatrix[12] / (-2 / this.projectMatrix[0])
                    + (-2 / this.projectMatrix[0])) / 2;
                var bottom = (this.projectMatrix[13] / (-2 / this.projectMatrix[5])
                    + (-2 / this.projectMatrix[5])) / 2;
                var xPoint = left + this._height * 2 * this._aspect * xRatio;
                var yPoint = bottom + this._height * 2 * yRatio;
                left = xPoint - xRatio * height * 2 * this._aspect;
                bottom = yPoint - yRatio * 2 * height;
                var right = left + height * 2 * this._aspect;
                var top = bottom + height * 2;
                this._height = height;
                mat4.ortho(this.projectMatrix, left, right, bottom, top, this._znear, this._zfar);
            }
            else {
                _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype._setHeight.call(this, height);
            }
            // Trigger camera.update
            this._targetDistance -= delta > 0 ? 1.5e-4 : -1.5e-4;
        }
    };
    SceneCamera.prototype.pan = function (dx, dy) {
        var offset = 0.001 * this._targetDistance;
        this._targetAt[0] += -dx * this.viewMatrix[0] * offset + dy * this.viewMatrix[1] * offset;
        this._targetAt[1] += -dx * this.viewMatrix[4] * offset + dy * this.viewMatrix[5] * offset;
        this._targetAt[2] += -dx * this.viewMatrix[8] * offset + dy * this.viewMatrix[9] * offset;
    };
    SceneCamera.prototype.forward = function (ratio, dir) {
        if (!dir) {
            dir = this.getViewDirection();
            // Forward movement is only used for in house movement, 
            // so move parallel to the floor, which means no effect on
            // z direction is correct. Also after 5.0.1, there will be no
            // flipyz difference, so only set the dir[2] to 0 should be enough
            dir[2] = 0;
        }
        var x = dir[0] * ratio * this._scene.radius;
        var y = dir[1] * ratio * this._scene.radius;
        var z = dir[2] * ratio * this._scene.radius;
        this._targetAt[0] += x;
        this._targetAt[1] += y;
        this._targetAt[2] += z;
        this.eye[0] += x;
        this.eye[1] += y;
        this.eye[2] += z;
    };
    SceneCamera.prototype._updateProjection = function () {
        // FIXME: The following piece of code needs validation, especially when
        // eye is in the bbox of the scene.
        centerProj = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.center(this._scene.bbox);
        targetEyeProj[0] = this._at[0] + this.viewMatrix[2] * this._targetDistance;
        targetEyeProj[1] = this._at[1] + this.viewMatrix[6] * this._targetDistance;
        targetEyeProj[2] = this._at[2] + this.viewMatrix[10] * this._targetDistance;
        vec3.subtract(offProj, this.eye, centerProj);
        var projDis = this.viewMatrix[2] * offProj[0] +
            this.viewMatrix[6] * offProj[1] +
            this.viewMatrix[10] * offProj[2];
        vec3.subtract(offProj, targetEyeProj, centerProj);
        var projDis2 = this.viewMatrix[2] * offProj[0] +
            this.viewMatrix[6] * offProj[1] +
            this.viewMatrix[10] * offProj[2];
        // FIXME: the near plan is too close that will cut the model part off
        // when scrolling fast. See MOD-2664.
        var znear = Math.min(projDis, projDis2) - this._scene.radius * 1.1;
        var zfar = Math.max(projDis, projDis2) + this._scene.radius * 1.03;
        if (this._perspective && znear < 0.001 * this._scene.radius) {
            znear = 0.001 * this._scene.radius;
        }
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype._updateProjection.call(this, znear, zfar);
    };
    // if changeCurrent is true, the current camera status will also be changed.
    SceneCamera.prototype.reset = function (changeCurrent) {
        // Reset the camera animator
        if (this.animator.stop) {
            this.animator.stop();
        }
        this.animator = new _m3d_camera_animator_normal_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
        this.animator.attach(this);
        if (this._scene.clipping.isEnabled()) {
            vec3.copy(this._targetAt, this._scene.clipping.getCenter());
        }
        else {
            this._targetAt = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.center(this._scene.bbox);
        }
        //FOV should only change by the setting panel
        this._targetDistance = this._getViewDistance();
        this._initDistance = this._targetDistance;
        this._maxZoomOffset = this._targetDistance * 0.025;
        this._minZoomOffset = this._targetDistance * 0.0025;
        this.rotateTo(Math.PI / 18.0, -Math.PI / 4.0);
        if (changeCurrent) {
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.reset.apply(this, arguments);
            vec3.copy(this._at, this._targetAt);
        }
    };
    // here we find the smallest rotate angle of CCW and CW
    SceneCamera.prototype.rotateTo = function (phi, theta) {
        var diff = theta - this._theta;
        diff %= 2 * Math.PI;
        if (diff > Math.PI) {
            diff -= 2 * Math.PI;
        }
        else if (diff < -Math.PI) {
            diff += 2 * Math.PI;
        }
        this._targetTheta = this._theta + diff;
        this._targetPhi = phi;
    };
    SceneCamera.prototype.lookTo = function (position, range) {
        this._targetAt[0] = position[0];
        this._targetAt[1] = position[1];
        this._targetAt[2] = position[2];
        //MOD-bimloader, range is the bbox's radius of the selected drawable in bim mode.
        //According to this range/radius value, we need to move the camera to focus on
        //on the drawable with a proper distance.  Camera needs to see the whole drawable.
        if (range) {
            this._targetDistance = range / Math.sin(this._fov * Math.PI / 360);
        }
        else {
            var dx = this._targetAt[0] - this.eye[0];
            var dy = this._targetAt[1] - this.eye[1];
            var dz = this._targetAt[2] - this.eye[2];
            this._distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            // this._targetDistance = this._distance;
            this._targetDistance = Math.min(ZOOM_RATIO * this._scene.radius, this._distance);
        }
    };
    SceneCamera.prototype.zoomTo = function (distance, targetDistance, targetAt) {
        this._distance = distance;
        if (targetDistance) {
            this._targetDistance = targetDistance;
        }
        else {
            this._targetDistance = distance;
        }
        if (targetAt) {
            vec3.copy(this._targetAt, targetAt);
        }
    };
    SceneCamera.prototype.zoomBy = function (ratio) {
        if (this._perspective) {
            return;
        }
        var height = this._height * ratio;
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype._setHeight.call(this, height);
        // Trigger camera.update
        this._targetDistance -= ratio < 1 ? 1.5e-4 : -1.5e-4;
    };
    SceneCamera.prototype.dump = function () {
        var targetPhi;
        var targetTheta;
        // Note that we don't save/restore a first-person camera, so
        // a first-person camera is converted into a 3rd-person one
        // at saving.
        if (this._firstPerson) {
            targetPhi = -this._targetPhi;
            targetTheta = this._targetTheta - Math.PI;
        }
        else {
            targetPhi = this._targetPhi;
            targetTheta = this._targetTheta;
        }
        var ret;
        if (this._perspective) {
            ret = {
                fov: this._fov,
                distance: this._targetDistance,
                phi: targetPhi,
                theta: targetTheta,
                at: [this._at[0], this._at[1], this._at[2]]
            };
        }
        else {
            ret = {
                height: this._height,
                distance: this._targetDistance,
                phi: targetPhi,
                theta: targetTheta,
                at: [this._at[0], this._at[1], this._at[2]]
            };
        }
        return ret;
    };
    SceneCamera.prototype.restore = function (dumped) {
        // Reset targetDistance if it is a ortho view.
        var targetDistance = dumped.height ? this._scene.radius * 1.2 : dumped.distance;
        var diffDistance = 0.15 * Math.abs(targetDistance - this._targetDistance) / Math.max(targetDistance, this._targetDistance);
        var diffPhi = 0;
        var diffTheta = 0;
        this._distance = this._targetDistance = targetDistance;
        if (dumped.phi >= 0.49999 * Math.PI) {
            dumped.phi = 0.49999 * Math.PI;
        }
        if (dumped.phi <= -0.49999 * Math.PI) {
            dumped.phi = -0.49999 * Math.PI;
        }
        if (this._firstPerson) {
            diffPhi = Math.abs(-dumped.phi - this._targetPhi);
            this._phi = this._targetPhi = -dumped.phi;
            // wrapping the theta
            var diff = dumped.theta + Math.PI - this._theta;
            diff %= 2 * Math.PI;
            if (diff > Math.PI) {
                diff -= 2 * Math.PI;
            }
            else if (diff < -Math.PI) {
                diff += 2 * Math.PI;
            }
            diffTheta = Math.abs(this._theta + diff - this._targetTheta);
            this._targetTheta = this._theta + diff;
            this._theta = this._targetTheta;
            var dx;
            var dy;
            var dz;
            var sx = Math.sin(this._targetPhi);
            var cx = Math.cos(this._targetPhi);
            var sz = Math.sin(this._targetTheta);
            var cz = Math.cos(this._targetTheta);
            dx = cx * cz;
            dy = cx * sz;
            dz = sx;
            // The origin of the coordinate is at eye
            this.eye[0] = dumped.at[0] - dx * this._targetDistance;
            this.eye[1] = dumped.at[1] - dy * this._targetDistance;
            this.eye[2] = dumped.at[2] - dz * this._targetDistance;
        }
        else {
            diffPhi = Math.abs(dumped.phi - this._targetPhi);
            this._phi = this._targetPhi = dumped.phi;
            // wrapping the theta
            var diff = dumped.theta - this._theta;
            diff %= 2 * Math.PI;
            if (diff > Math.PI) {
                diff -= 2 * Math.PI;
            }
            else if (diff < -Math.PI) {
                diff += 2 * Math.PI;
            }
            diffTheta = Math.abs(this._theta + diff - this._targetTheta);
            this._targetTheta = this._theta + diff;
            this._theta = this._targetTheta;
        }
        this._at[0] = this._targetAt[0] = dumped.at[0];
        this._at[1] = this._targetAt[1] = dumped.at[1];
        this._at[2] = this._targetAt[2] = dumped.at[2];
        if (dumped.height) {
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype._setHeight.call(this, dumped.height);
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.setPerspective.call(this, false);
        }
        else {
            // The following line is removed for MOD-4798 since at the eye of frontend,
            // fov is part of rendering setting but not camera. When switching comments,
            // the fov should not change with different camera.
            // This.setTargetFov(dumped.fov);
            _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.setPerspective.call(this, true);
        }
        if (this._scene) {
            this._updateProjection();
        }
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.update.apply(this, arguments);
        this._cull.update();
    };
    SceneCamera.prototype.cull = function (drawable, indices) {
        return this._cull.isCulled(drawable, indices);
    };
    SceneCamera.prototype.setFirstPerson = function (enabled) {
        if (this._firstPerson !== enabled) {
            this._targetTheta = Math.PI + this._targetTheta;
            this._targetPhi = -this._targetPhi;
        }
        // When switched back from 1st-person view, we need to fix
        // the camera's at position.
        if (!enabled) {
            this._targetAt[0] = this._at[0];
            this._targetAt[1] = this._at[1];
            this._targetAt[2] = this._at[2];
            // FIXME: this is a temp solution for avoiding the projection matrix go wrong
            // Since the diffAt of at and target at is always bigger than the threshold of 1e-8
            // once the model is panned, but directly copy the value to targetAt makes the projection matrix
            // not updated anymore. Current solution makes a small delta value from the at and the targetAt.
            // This bug will be fix better in the next version.
            this._at[0] -= 0.000001;
            this._at[1] -= 0.000001;
            this._at[2] -= 0.000001;
        }
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.setFirstPerson.apply(this, arguments);
    };
    SceneCamera.prototype.isFirstPerson = function () {
        return this._firstPerson;
    };
    SceneCamera.prototype.isPerspective = function () {
        return this._perspective;
    };
    // Get an appropriate view distance to have a good screen size of visible
    // objects.
    SceneCamera.prototype._getViewDistance = function () {
        var distance = -Number.MAX_VALUE;
        var scale1 = 1.0 / Math.sin(this._fov * 0.00872665); //Math.PI / 180 / 2 = 0.00872665
        var scale2 = scale1 / Math.cos(this._fov * 0.00872665); //Math.PI / 180 / 2 = 0.00872665
        var scale3 = Math.tan(this._fov * 0.00872665); //Math.PI / 180 / 2 = 0.00872665
        var viewDirection = this.getTargetViewDirection();
        var off = vec3.create();
        var p = vec3.create();
        if (this._scene.layers.length !== 0) {
            for (var i = 0, len1 = this._scene.layers.length; i < len1; i++) {
                if (this._scene.layers[i].visible) {
                    for (var j = 0, len2 = this._scene.layers[i].drawables.length; j < len2; j++) {
                        var drawableData = this._scene.layers[i].drawables[j];
                        // The description of the math below can be found in MOD-2557
                        vec3.subtract(off, drawableData.bsphere, this._targetAt);
                        var at2p = vec3.dot(off, viewDirection);
                        vec3.scaleAndAdd(p, this._targetAt, viewDirection, at2p);
                        var d = vec3.distance(p, drawableData.bsphere);
                        var r = drawableData.bsphere[3];
                        var o2eye = d * scale2 + r * scale1;
                        var o2p = d * scale3;
                        var at2eye = at2p + (o2eye - o2p);
                        var thisDistance = Math.max(r, at2eye) * DISTANCERATIO;
                        distance = Math.max(distance, thisDistance);
                    }
                }
            }
        }
        if (this._scene.clipping.isEnabled()) {
            var r = this._scene.clipping.getRadius();
            var o2eye = r * scale1;
            thisDistance = Math.max(r, o2eye) * DISTANCERATIO;
            distance = Math.min(distance, thisDistance);
        }
        // FIXME: at initialization, the layers don't contain any drawables and
        // we can't compute a valid distance value using layer information.
        // We simply take the entire scene into computation.
        if (distance < 0) {
            var r = this._scene.radius;
            var o2eye = r * scale1;
            distance = Math.max(r, o2eye) * DISTANCERATIO;
        }
        return distance;
    };
    // Get the target view direction.
    SceneCamera.prototype.getTargetViewDirection = function () {
        var sx = Math.sin(this._targetPhi);
        var cx = Math.cos(this._targetPhi);
        var sz = Math.sin(this._targetTheta);
        var cz = Math.cos(this._targetTheta);
        var ret = vec3.create();
        // NOTE: The theta and phi are in the spherical coordinate whose
        // origin is at the lookat position, but no camera.
        ret[0] = -cx * cz;
        ret[1] = -cx * sz;
        ret[2] = -sx;
        // In first-person view, the origin is eye.
        if (this._firstPerson) {
            ret[0] = -ret[0];
            ret[1] = -ret[1];
            ret[2] = -ret[2];
        }
        return ret;
    };
    SceneCamera.prototype.setZoomMinMax = function (scale) {
        this._maxZoomOffset = this._initDistance * 0.025 * scale;
    };
    return SceneCamera;
})());


/***/ }),

/***/ "./03scene/camera/m3d_shadow_camera.js":
/*!*********************************************!*\
  !*** ./03scene/camera/m3d_shadow_camera.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _culling_m3d_cull_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../culling/m3d_cull.js */ "./03scene/culling/m3d_cull.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
//
// m3d_shadow_camera.js
// The shadow/light camera.
//
// Copyright Modelo XX - 2018, All rights reserved.
//



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function ShadowCamera(scene) {
        _m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].apply(this, arguments);
        this._scene = scene;
        this._cull = new _culling_m3d_cull_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
    }
    ShadowCamera.prototype = Object.create(_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
    ShadowCamera.prototype.constructor = ShadowCamera;
    // Create an orthogonal matrix used for shadow map; seeing from light.
    ShadowCamera.prototype.createFromLight = function (lightDirection, bbox, upDir) {
        this._at = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.center(bbox);
        this._distance = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.length(bbox);
        this.eye = [];
        this.eye[0] = -lightDirection[0] * this._distance + this._at[0];
        this.eye[1] = -lightDirection[1] * this._distance + this._at[1];
        this.eye[2] = -lightDirection[2] * this._distance + this._at[2];
        if (!upDir) {
            mat4.lookAt(this.viewMatrix, this.eye, this._at, [0, 0, 1]);
        }
        else {
            mat4.lookAt(this.viewMatrix, this.eye, this._at, upDir);
        }
        var radius = this._distance * 0.505; // bbox'radius * 1.01
        var w = radius;
        var h = radius;
        this._znear = this._distance - radius * 1.02;
        this._zfar = this._distance + radius * 1.02;
        this._height = h;
        this._aspect = 1.0;
        this._perspective = false;
        mat4.ortho(this.projectMatrix, -w, w, -h, h, this._znear, this._zfar);
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
    };
    ShadowCamera.prototype.createFromLightTight = function (lightDirection, bbox, intersections) {
        var _min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
        var _max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
        var _tmp = vec3.create();
        var i;
        for (i = 0; i < intersections.length; i++) {
            vec3.min(_min, _min, intersections[i]);
            vec3.max(_max, _max, intersections[i]);
        }
        var xbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.create(_min, _max);
        var points = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.points(xbox);
        vec3.lerp(this._at, _min, _max, 0.5);
        this._distance = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.length(bbox);
        var radius = this._distance * 0.505; // bbox'radius * 1.01
        this.eye = [];
        this.eye[0] = -lightDirection[0] * this._distance + this._at[0];
        this.eye[1] = -lightDirection[1] * this._distance + this._at[1];
        this.eye[2] = -lightDirection[2] * this._distance + this._at[2];
        mat4.lookAt(this.viewMatrix, this.eye, this._at, [0, 0, 1]);
        _min = [Number.MAX_VALUE, Number.MAX_VALUE];
        _max = [-Number.MAX_VALUE, -Number.MAX_VALUE];
        for (i = 0; i < points.length; i++) {
            if (points[i] !== null) {
                //1. change space to light camera
                _tmp[0] = this.viewMatrix[0] * points[i][0] + this.viewMatrix[4] * points[i][1] +
                    this.viewMatrix[8] * points[i][2] + this.viewMatrix[12];
                _tmp[1] = this.viewMatrix[1] * points[i][0] + this.viewMatrix[5] * points[i][1] +
                    this.viewMatrix[9] * points[i][2] + this.viewMatrix[13];
                vec2.min(_min, _min, _tmp);
                vec2.max(_max, _max, _tmp);
            }
        }
        this._znear = this._distance - radius * 1.02;
        this._zfar = this._distance + radius * 1.02;
        //this._height = h;
        this._aspect = 1.0;
        this._perspective = false;
        mat4.ortho(this.projectMatrix, _min[0], _max[0], _min[1], _max[1], this._znear, this._zfar);
        mat4.multiply(this.vpMatrix, this.projectMatrix, this.viewMatrix);
    };
    // TODO: These culling functions are duplicated with ShadowCamera. 
    ShadowCamera.prototype.setCullingEnabled = function (enabled) {
        this._cull.setEnabled(enabled);
        if (enabled) {
            this._cull.update();
        }
    };
    ShadowCamera.prototype.setBimCullingEnabled = function (enabled) {
        this._cull.setBimCullingEnabled(this._scene.isBimCullingNeeded && enabled);
        if (this.isBimCullingEnabled()) {
            this._cull.update();
        }
    };
    ShadowCamera.prototype.isBimCullingEnabled = function () {
        return this._scene.isBimCullingNeeded && this._cull.isBimCullingEnabled();
    };
    ShadowCamera.prototype.cull = function (drawable, indices) {
        return this._cull.isCulled(drawable, indices);
    };
    return ShadowCamera;
})());


/***/ }),

/***/ "./03scene/culling/m3d_bim_cull.js":
/*!*****************************************!*\
  !*** ./03scene/culling/m3d_bim_cull.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_bim_cull.js
// The bim culling will cull off elements inside drawable drawable based
// on BIM.
// 
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function BimCull(camera) {
        this._camera = camera;
        this.enabled = false;
    }
    ;
    BimCull.prototype.update = function () {
    };
    // The output indices is the index offset and range of draw call.
    BimCull.prototype.isCulled = function (drawable, indices) {
        if (!this.enabled) {
            return false;
        }
        // Bim culling is to skip the rendering of hidable elements inside
        // this drawable drawable. The hidability of each element is given by their regions.
        // In most cases, the element of interior will be thrown away, together with less important
        // regions than interior, e.g., landscape, mep.
        if (drawable.hidables > 0) {
            indices[1] = drawable.nodes[drawable.hidables].indicesOffset / drawable.mesh.indexSize;
        }
        return drawable.hidables === 0 || drawable.mesh.isStaged; // If entire drawable can be culled.
    };
    return BimCull;
})());


/***/ }),

/***/ "./03scene/culling/m3d_clip_cull.js":
/*!******************************************!*\
  !*** ./03scene/culling/m3d_clip_cull.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
//
// m3d_clipping_cull.js
// Cull objects if they are not in clipping range
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function ClippingCull(camera) {
        this._camera = camera;
        this._scene = camera._scene;
    }
    ;
    ClippingCull.prototype.isCulled = function (drawable) {
        if (!this._scene.clipping.isEnabled()) {
            return false;
        }
        var aabb = this._scene.clipping.get();
        // If the drawable's bbox is inside the clipping range, we don't cull it.
        if (_00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].outside.aabb_aabb(drawable.bbox, aabb)) {
            return true;
        }
        return false;
    };
    return ClippingCull;
})());


/***/ }),

/***/ "./03scene/culling/m3d_cull.js":
/*!*************************************!*\
  !*** ./03scene/culling/m3d_cull.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_clip_cull_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_clip_cull.js */ "./03scene/culling/m3d_clip_cull.js");
/* harmony import */ var _m3d_zeroarea_cull_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_zeroarea_cull.js */ "./03scene/culling/m3d_zeroarea_cull.js");
/* harmony import */ var _m3d_frustum_cull_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_frustum_cull.js */ "./03scene/culling/m3d_frustum_cull.js");
/* harmony import */ var _m3d_bim_cull_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./m3d_bim_cull.js */ "./03scene/culling/m3d_bim_cull.js");
//
// m3d_cull.js
// Tailor the drawables so that only visible part of it will be rendered.
// 
// Copyright Modelo XX - 2017, All rights reserved.




/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Cull(camera) {
        this._clippingCull = new _m3d_clip_cull_js__WEBPACK_IMPORTED_MODULE_0__["default"](camera);
        this._frustumCull = new _m3d_frustum_cull_js__WEBPACK_IMPORTED_MODULE_2__["default"](camera);
        this._zeroAreaCull = new _m3d_zeroarea_cull_js__WEBPACK_IMPORTED_MODULE_1__["default"](camera, this._frustumCull);
        this._bimCull = new _m3d_bim_cull_js__WEBPACK_IMPORTED_MODULE_3__["default"](camera);
        this._enabled = false;
    }
    ;
    Cull.prototype.destroy = function () {
        this._clippingCull = null;
        delete this._clippingCull;
        this._frustumCull = null;
        delete this._frustumCull;
        this._bimCull = null;
        delete this._bimCull;
        this._zeroAreaCull = null;
        delete this._zeroAreaCull;
    };
    Cull.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
    };
    Cull.prototype.isCulled = function (drawable, indices) {
        if (!this._enabled) {
            return false;
        }
        if (this._clippingCull.isCulled(drawable) ||
            this._frustumCull.isCulled(drawable) ||
            this._bimCull.isCulled(drawable, indices) ||
            this._zeroAreaCull.isCulled(drawable) ||
            false) {
            return true;
        }
        return false;
    };
    Cull.prototype.update = function () {
        if (this._enabled) {
            this._frustumCull.update();
            this._zeroAreaCull.update();
            this._bimCull.update();
        }
    };
    Cull.prototype.setBimCullingEnabled = function (enabled) {
        this._bimCull.enabled = enabled;
    };
    Cull.prototype.isBimCullingEnabled = function () {
        return this._bimCull.enabled;
    };
    return Cull;
})());


/***/ }),

/***/ "./03scene/culling/m3d_frustum_cull.js":
/*!*********************************************!*\
  !*** ./03scene/culling/m3d_frustum_cull.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
//
// m3d_frustum_cull.js
// Frustum culling and small objects culling
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function FrustumCull(camera) {
        this._camera = camera;
        this._scene = camera._scene;
        //this._cone    = Math.cone.create();
        this._frustum = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].frustum.createFromMatrix(camera.vpMatrix);
        this._contain = false; // contain the entire scene.
        this._p = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ];
        this._t = [0, 0, 0, 0, 0, 0];
    }
    ;
    FrustumCull.prototype.isCulled = function (drawable) {
        // When the (clipped) scene is contained by the frustum entirely, 
        // we don't need to do the culling.
        // According to test, computing aabb_frustum only takes only 30% of
        // CPU time of the combination of the three functions (see above)
        // together. That is why we disable the first two tests and use only
        // the last one.
        //return !modelo3d.intersect.sphere_cone(drawable.bsphere, this._cone) ||
        //        modelo3d.outside.sphere_frustum(drawable.bsphere, this._frustum) ||
        //        modelo3d.outside.aabb_frustum(drawable.bbox, this._frustum);
        if (this._contain) {
            return false;
        }
        var f = this._frustum;
        var b = drawable.bbox;
        // A simplified version of outside.aabb_frustum
        return (b[this._p[0][0]] * f[0][0] + b[this._p[0][1]] * f[0][1] + b[this._p[0][2]] * f[0][2] > this._t[0]) ||
            (b[this._p[1][0]] * f[1][0] + b[this._p[1][1]] * f[1][1] + b[this._p[1][2]] * f[1][2] > this._t[1]) ||
            (b[this._p[2][0]] * f[2][0] + b[this._p[2][1]] * f[2][1] + b[this._p[2][2]] * f[2][2] > this._t[2]) ||
            (b[this._p[3][0]] * f[3][0] + b[this._p[3][1]] * f[3][1] + b[this._p[3][2]] * f[3][2] > this._t[3]) ||
            (b[this._p[4][0]] * f[4][0] + b[this._p[4][1]] * f[4][1] + b[this._p[4][2]] * f[4][2] > this._t[4]) ||
            (b[this._p[5][0]] * f[5][0] + b[this._p[5][1]] * f[5][1] + b[this._p[5][2]] * f[5][2] > this._t[5]);
    };
    // Update the frustum shape
    FrustumCull.prototype.update = function () {
        // Update the cone shape by first finding 
        // the max spanning angle of the frustum.
        //if (this._camera.isPerspective()) {
        //    Math.cone.updateShape(this._cone, this._camera._fov, this._camera._aspect);
        //    // Cone
        //    vec3.copy(this._cone.tip, this._camera.eye);
        //    this._cone.direction = this._camera.getViewDirection();
        //}
        this._frustum = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].frustum.createFromMatrix(this._camera.vpMatrix);
        // Pre-compute some parts of the outside.aabb_frustum 
        for (var i = 0; i < 6; i++) {
            this._p[i][0] = (this._frustum[i][0] > 0 ? 0 : 3);
            this._p[i][1] = (this._frustum[i][1] > 0 ? 1 : 4);
            this._p[i][2] = (this._frustum[i][2] > 0 ? 2 : 5);
            this._t[i] = -this._frustum[i][3];
        }
        this._contain = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].inside.aabb_frustum(this._scene.bbox, this._frustum);
    };
    return FrustumCull;
})());


/***/ }),

/***/ "./03scene/culling/m3d_zeroarea_cull.js":
/*!**********************************************!*\
  !*** ./03scene/culling/m3d_zeroarea_cull.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
//
// m3d_zeroarea_cull.js
// When a drawable's projection area is less than 2x2 pixels, we don't render (cull) it. 
// 
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function ZeroAreaCull(camera) {
        this._camera = camera;
        this._scene = camera._scene;
        this._threshold = new Float32Array(1);
    }
    ;
    ZeroAreaCull.prototype.update = function () {
        var invx = 2.0 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
        var invy = 2.0 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        // 2x2 pixel size
        this._threshold = Math.min(invx, invy) * 4.0;
    };
    // precise bounding box projection
    // https://data.icg.tugraz.at/~dieter/publications/Schmalstieg_031.pdf
    var VERTICES_LUT = [
        0, 0, 0, 0, 0, 0, 0,
        4, 0, 4, 7, 3, 0, 0,
        4, 1, 2, 6, 5, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        4, 0, 1, 5, 4, 0, 0,
        6, 0, 1, 2, 6, 5, 4,
        6, 0, 1, 2, 6, 5, 4,
        0, 0, 0, 0, 0, 0, 0,
        4, 2, 3, 7, 6, 0, 0,
        6, 4, 7, 6, 2, 3, 0,
        6, 2, 3, 7, 6, 5, 1,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        4, 0, 3, 2, 1, 0, 0,
        6, 0, 4, 7, 3, 2, 1,
        6, 0, 3, 2, 6, 5, 1,
        0, 0, 0, 0, 0, 0, 0,
        6, 0, 3, 2, 1, 5, 4,
        6, 1, 5, 4, 7, 3, 2,
        6, 0, 3, 2, 6, 5, 4,
        0, 0, 0, 0, 0, 0, 0,
        6, 0, 3, 7, 6, 2, 1,
        6, 0, 4, 7, 6, 2, 1,
        6, 0, 3, 7, 6, 5, 1,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        4, 4, 5, 6, 7, 0, 0,
        6, 4, 5, 6, 7, 3, 0,
        6, 1, 2, 6, 7, 4, 5,
        0, 0, 0, 0, 0, 0, 0,
        6, 0, 1, 5, 6, 7, 4,
        6, 0, 1, 5, 6, 7, 3,
        6, 0, 1, 2, 6, 7, 4,
        0, 0, 0, 0, 0, 0, 0,
        6, 2, 3, 7, 4, 5, 6,
        6, 0, 4, 5, 6, 2, 3,
        6, 1, 2, 3, 7, 4, 5,
    ];
    var vertices2D = [];
    vertices2D[0] = [0, 0, 0, 0];
    vertices2D[1] = [0, 0, 0, 0];
    vertices2D[2] = [0, 0, 0, 0];
    vertices2D[3] = [0, 0, 0, 0];
    vertices2D[4] = [0, 0, 0, 0];
    vertices2D[5] = [0, 0, 0, 0];
    var points = [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
    ];
    function CalculateBoxAreaPrecisely(bbox, camera) {
        var eye = camera.eye;
        var pos = ((eye[0] < bbox[0])) + // 1 = left | compute 6-bit
            ((eye[0] > bbox[3]) << 1) + // 2 = right | code to
            ((eye[2] < bbox[2]) << 2) + // 4 = bottom | classify eye
            ((eye[2] > bbox[5]) << 3) + // 8 = top |with respect to
            ((eye[1] < bbox[1]) << 4) + // 16 = front | the 6 defining
            ((eye[1] > bbox[4]) << 5); // 32 = back | planes
        var numVertices = VERTICES_LUT[pos * 7];
        if (numVertices === 0) {
            //return a large value if inside
            return 1000000000.0; // look up number of vertices
        }
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.points3(bbox, points);
        for (var i = 0; i < numVertices; i++) {
            var index = VERTICES_LUT[pos * 7 + 1 + i];
            vec4.transformMat4(vertices2D[i], points[index], camera.vpMatrix);
            vertices2D[i][0] /= vertices2D[i][3];
            vertices2D[i][1] /= vertices2D[i][3];
        }
        var sum = (vertices2D[0][0] - vertices2D[numVertices - 1][0]) * (vertices2D[numVertices - 1][1] + vertices2D[0][1]);
        for (var i = 0; i < numVertices - 1; i++) {
            sum += (vertices2D[i + 1][0] - vertices2D[i][0]) * (vertices2D[i][1] + vertices2D[i + 1][1]);
        }
        //console.log(sum);
        return sum; // return double of area of projected bbox.
    }
    ;
    var v0 = new Float32Array(3); // the vector from camera position to center of drawable.
    function CalculateBoxAreaApproximately(bsphere, camera) {
        var r = bsphere[3];
        var f = camera.projectMatrix[5]; // ctan(fov/2)
        vec3.subtract(v0, bsphere, camera.eye);
        // the distance from center of sphere to the eye in view direction.
        var d = -(v0[0] * camera.viewMatrix[2] +
            v0[1] * camera.viewMatrix[6] +
            v0[2] * camera.viewMatrix[10]);
        // The ratio of projected radius on the near over near plane size.
        return r * f / d;
    }
    ;
    ZeroAreaCull.prototype.isCulled = function (drawable) {
        // TODO: consider ortho view
        if (!this._camera.isPerspective()) {
            return false;
        }
        // The projection area computation about bbox is only valid when it is 
        // fully inside the frustum. If any corner of it is behind near plane,
        // it does not generate right answer.
        // On the other hand, when scene is intersecting the frustum, it means
        // camera is close. In this case, most of objects look large on the screen
        // and no need to do zero area culling.
        //if (//CalculateBoxAreaPrecisely(drawable.bbox, this._camera) < this._threshold) {
        //    CalculateBoxAreaApproximately(drawable.bsphere, this._camera)  < this._threshold) {
        //    return true;
        //}
        var ratio = CalculateBoxAreaApproximately(drawable.bsphere, this._camera);
        if (ratio > 0 && ratio < this._threshold) {
            return true;
        }
        // For instanced drawables, we see if their mesh bbox is too small to visible
        if (drawable.meshRadius) {
            var f = this._camera.projectMatrix[5]; // ctan(fov/2)
            if (drawable.meshRadius * f / this._camera._distance < this._threshold) {
                return true;
            }
        }
        return false;
    };
    return ZeroAreaCull;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_drawable.js":
/*!*******************************************!*\
  !*** ./03scene/drawables/m3d_drawable.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _m3d_transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_transform.js */ "./03scene/drawables/m3d_transform.js");
//
// m3d_drawable.js
// The drawable drawable. It is generated by merging lots of origianl scene elements
// with same rendering attributes.
//
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Drawable(name, mesh, layer, shader, material, transform, bbox) {
        // public:
        // Scene data
        this.name = name; // The name of the model
        this.layer = layer;
        // Rendering data
        this.mesh = mesh; // The solid mesh
        this.material = material;
        this.shader = shader;
        this.transform = new _m3d_transform_js__WEBPACK_IMPORTED_MODULE_1__["default"](transform);
        // Visibility data
        this.visible = (layer ? layer.visible : true);
        this.bbox = null;
        this.bsphere = null;
        // Intermediate data
        this.distance = 0; // The distance of drawable to eye.
        this.nodes = []; // A drawable is composed of several nodes of scene graph
        this.hidables = -1; // the index of starting element that can be hidable during camera rotation.
        this.originalMaterial = null;
        // Initialization:
        if (this.material) {
            var shader1 = this.material.attachShader(this.shader, this.mesh.manager);
            this.shader = this.shader || shader1;
        }
        if (bbox) {
            this.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox);
            this.bsphere = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].sphere.createFromAABB(this.bbox);
        }
        this.isShadowReceiver = true;
    }
    ;
    Drawable.prototype.destroy = function () {
        this.transform.destroy();
        this.transform = null;
        delete this.transform;
        this.bbox = null;
        delete this.bbox;
        this.bsphere = null;
        delete this.bsphere;
        this.mesh = null;
        delete this.mesh;
        this.material = null;
        delete this.material;
        this.layer = null;
        delete this.layer;
        this.originalMaterial = null;
        delete this.originalMaterial;
        this.nodes = null;
        delete this.nodes;
    };
    Drawable.prototype.isShadowCaster = function () {
        // Don't draw solid transparent objects in shadow generation. It can most
        // likely be the glass.
        return (!this.material.transparent ||
            this.material.parameters.hasOwnProperty("uMaterialDiffuseTexture")) &&
            this.mesh.isTriangle();
    };
    Drawable.prototype.isInstancing = function () {
        return false;
    };
    Drawable.prototype.setShader = function (shader) {
        if (this.shader !== shader) {
            this.shader = shader;
            this.material.attachShader(shader);
        }
    };
    // Translate the drawable.
    Drawable.prototype.translate = function (dx, dy, dz) {
        this.transform.translate(dx, dy, dz);
        this.bbox[0] += dx;
        this.bbox[1] += dy;
        this.bbox[2] += dz;
        this.bbox[3] += dx;
        this.bbox[4] += dy;
        this.bbox[5] += dz;
        this.bsphere[0] += dz;
        this.bsphere[1] += dy;
        this.bsphere[2] += dz;
        this.recompileShader("MODEL_TRANSFORM", !this.transform.identity);
    };
    // Multiply the transform matrix to the current one.
    Drawable.prototype.multiply = function (matrix) {
        vec3.transformMat4(this.bsphere, this.bsphere, matrix);
        this.transform.multiply(matrix);
        // Since it is very hard to precisely compute the new bbox of the
        // transformed drawable, we simply use the bbox of the bsphere of
        // the drawable. As the model transformation is only avaiable in
        // particular view, the performance and precision is not the first
        // consideration.
        this.bbox[0] = this.bsphere[0] - this.bsphere[3];
        this.bbox[1] = this.bsphere[1] - this.bsphere[3];
        this.bbox[2] = this.bsphere[2] - this.bsphere[3];
        this.bbox[3] = this.bsphere[0] + this.bsphere[3];
        this.bbox[4] = this.bsphere[1] + this.bsphere[3];
        this.bbox[5] = this.bsphere[2] + this.bsphere[3];
        this.recompileShader("MODEL_TRANSFORM", !this.transform.identity);
    };
    // Pick an element inside this drawable that intersects with pick ray. We can
    // assume the ray has already intersected with this drawable.
    Drawable.prototype.pickNode = function (point, direction, position, graph) {
        if (this.nodes.length === 0) {
            console.log("Error! The drawable has no scene information.");
            return null;
        }
        if (this.nodes.length === 1) {
            return this.nodes[0];
        }
        var minDistance = Number.MAX_VALUE;
        var closestNode = null;
        var bbox = [0, 0, 0, 0, 0, 0];
        for (var i = 0, len = this.nodes.length; i < len; ++i) {
            var node = this.nodes[i];
            graph.getNodeBBox(node.id, bbox);
            var intersect = null;
            if (_00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].inside.point_aabb(position, bbox)) {
                intersect = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].intersect.ray_aabb(point, direction, bbox);
            }
            if (intersect) {
                var dx = intersect[0] - point[0];
                var dy = intersect[1] - point[1];
                var dz = intersect[2] - point[2];
                var d = dx * direction[0] + dy * direction[1] + dz * direction[2];
                if (d < minDistance) {
                    minDistance = d;
                    closestNode = this.nodes[i];
                }
            }
        }
        return closestNode;
    };
    // Add or remove a flag from the shader compiling flags, and recompile shader.
    Drawable.prototype.recompileShader = function (flag, enabled) {
        var pos = this.shader.flags.lastIndexOf(flag);
        var flags;
        var needUpdate = false;
        if (enabled) {
            // Add the flag to the drawable's shader compiling flags.
            if (pos === -1) {
                flags = this.shader.flags.concat(flag);
                needUpdate = true;
            }
        }
        else {
            // Remove the flag from the drawable's shader compiling flag.
            if (pos !== -1) {
                flags = this.shader.flags.slice(0);
                flags.splice(pos, 1);
                needUpdate = true;
            }
        }
        if (needUpdate) {
            var shaderType = this.shader.shaderSource.name;
            var newShader = this.shader.manager.getShader(shaderType, flags);
            if (!newShader.ready) {
                newShader.createFromShaderSource(this.shader.shaderSource, flags);
                if (!newShader.ready) {
                    throw new Error("Failed to create shader '" + shaderType + "'!");
                }
            }
            this.shader = newShader;
            this.material.attachShader(this.shader);
        }
    };
    Drawable.prototype.updateVisibility = function () {
        // This drawable is single-noded. The visibility of node
        // equals the visibility of this drawable.
        if (this.nodes.length === 1) {
            this.visible = this.nodes[0].visible;
            return;
        }
        // Change the visibility attribute of the each vertex to reflect
        // the visibility change.
        // TODO: bufferOffset and verticesCount of a drawable do not change, we can pre-compute.
        var vertexSize = this.mesh._attributes.values[0].stride;
        var verticesCount = 0;
        var bufferOffset = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            var node = this.nodes[i];
            bufferOffset += node.verticesCount * vertexSize;
            verticesCount += node.verticesCount;
        }
        // TODO: the verticesCount can be pre-allocated as the Uint8Array(largetsDrawable)
        var verticesOffset = 0;
        var visibility = new Uint8Array(verticesCount);
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            var node = this.nodes[i];
            if (!node.visible) {
                node.platteIndex |= 0x80;
            }
            else {
                node.platteIndex &= 0x7F;
            }
            visibility.fill(node.platteIndex, verticesOffset, verticesOffset + node.verticesCount);
            verticesOffset += node.verticesCount;
        }
        this.mesh.vbSubData(bufferOffset, visibility);
        var visibles = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            if (this.nodes[i].visible) {
                visibles++;
            }
        }
        // If all nodes are either invisible or visible, we simply mark
        // the drawable's visility and simplify the shader.
        if (visibles === 0 || this.nodes.length === visibles) {
            this.visible = (visibles === this.nodes.length);
            // Remove the visilibity check in the shader.
            this.recompileShader('VISIBILITY', false);
            return;
        }
        this.visible = true;
        // Only some of nodes in drawable are visible.
        var vi = this.shader.flags.lastIndexOf('VISIBILITY'); // We have to enable visiblity part inshader.
        if (vi == -1) {
            this.recompileShader('VISIBILITY', true);
        }
    };
    Drawable.prototype.updateColor = function () {
        var usePlatte = false;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            if ((this.nodes[i].platteIndex & 0x7F) != 127) {
                usePlatte = true;
                break;
            }
        }
        var index = this.shader.flags.lastIndexOf('USE_PLATTE');
        if (index == -1 && usePlatte) {
            this.recompileShader('USE_PLATTE', true);
        }
        else if (index != -1 && !usePlatte) {
            this.recompileShader('USE_PLATTE', false);
            return;
        }
        // Change the attribute of the each vertex to reflect
        // the color change.
        var vertexSize = this.mesh._attributes.values[0].stride;
        var verticesCount = 0;
        var bufferOffset = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            var node = this.nodes[i];
            bufferOffset += node.verticesCount * vertexSize;
            verticesCount += node.verticesCount;
        }
        var verticesOffset = 0;
        var platteIndices = new Uint8Array(verticesCount);
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            var node = this.nodes[i];
            platteIndices.fill(node.platteIndex, verticesOffset, verticesOffset + node.verticesCount);
            verticesOffset += node.verticesCount;
        }
        this.mesh.vbSubData(bufferOffset, platteIndices);
    };
    Drawable.prototype.setNodeMaterial = function (node, material) {
        if (this.material.index === material.index) {
            return;
        }
        node.visible = visible;
        var verticesOffset = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            if (this.nodes[i] === node) {
                break;
            }
            verticesOffset += node.verticesBytes;
        }
        // Find the starting position of material IDs in the buffer.
        var vertexSize = this.mesh.attributes.values[0].stride + 1;
        var bufferOffset = verticesBytes + node.verticesBytes / vertexSize * this.mesh.attributes.values[0].stride;
        var materialIds = new Uint8Array(vertexSize);
        for (var i = 0; i < vertexSize; i++) {
            materialIds[i] = material.index;
        }
        this.mesh.update(bufferOffset, materialIds);
    };
    Drawable.prototype.render = function (camera, shader, indices) {
        this.transform.use(camera, shader);
        this.mesh.renderSub(indices[0], indices[1]);
    };
    return Drawable;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_drawable_instanced.js":
/*!*****************************************************!*\
  !*** ./03scene/drawables/m3d_drawable_instanced.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/m3d_node.js */ "./03scene/graph/m3d_node.js");
/* harmony import */ var _m3d_transform_instanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_transform_instanced.js */ "./03scene/drawables/m3d_transform_instanced.js");
/* harmony import */ var _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
//
// m3d_drawable_instanced.js
// The drawable drawable with many instances.
//
// Copyright Modelo XX - 2017, All rights reserved.




/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function DrawableInstanced(name, mesh, layer, shader, material, transform, bbox, meshBBox) {
        // Inheritance:
        _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, [name, mesh, layer, shader, material, null, bbox]);
        // Self:
        this.transform = new _m3d_transform_instanced_js__WEBPACK_IMPORTED_MODULE_2__["default"](transform);
        var s = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.size(meshBBox);
        this.meshRadius = Math.sqrt(s.width * s.width + s.height * s.height + s.depth * s.depth) * 0.5;
    }
    ;
    DrawableInstanced.prototype.destroy = function () {
        this.transform.destroy();
        this.transform = null;
        delete this.transform;
        this.mesh = null;
        this.material = null;
        this.layer = null;
    };
    DrawableInstanced.prototype = Object.create(_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype);
    DrawableInstanced.prototype.constructor = DrawableInstanced;
    DrawableInstanced.prototype.isInstancing = function () {
        return true;
    };
    // Since this drawable are identical in term of BIM region, they are neither kept or culled away
    // by bim culling. Thus indicies are not used in this draw.
    DrawableInstanced.prototype.render = function (camera, shader, indices) {
        this.transform.use(camera, shader, 0);
        this.mesh.renderInstanced(this.transform.count);
        // FIXME: since we don't have other instanced attributes, we
        // can skip the divisor disable here.
        //gl.vertexAttribDivisor(4, 0);
        //gl.vertexAttribDivisor(5, 0);
        //gl.vertexAttribDivisor(6, 0);
        //gl.vertexAttribDivisor(7, 0);
    };
    // Render the base to base + count instances.
    DrawableInstanced.prototype.renderBaseInstance = function (camera, shader, indices) {
        this.transform.use(camera, shader, indices[0]);
        this.mesh.renderInstanced(indices[1]);
    };
    DrawableInstanced.prototype.removeElements = function (elements) {
        // Delete the entire drawable
        if (elements.length === this.elements.length) {
            console.warn("drawable " + this.name + " is to be deleted.");
            this.destroy();
            return;
        }
        // Find the element in the drawable
        var deleteElementsIndices = new Array(this.elements.length);
        for (var i = 0, len = this.elements.length; i < len; ++i) {
            deleteElementsIndices[i] = -1;
            for (var j = 0, len1 = elements.length; j < len1; ++j) {
                if (this.elements[i].id === elements[j].id) {
                    deleteElementsIndices[i] = j;
                    break;
                }
            }
        }
        // Upgrade the transformation buffer and elements
        var leftElementsIndices = [];
        var leftElements = [];
        for (var i = 0, len = deleteElementsIndices.length; i < len; i++) {
            if (deleteElementsIndices[i] < 0) {
                leftElementsIndices.push(i);
                var element = this.elements[i];
                element.indicesOffset = leftElements.length;
                leftElements.push(element);
            }
        }
        var transform = this.transform.slice(leftElementsIndices);
        this.transform.destroy();
        this.transform = transform;
        this.elements = leftElements;
    };
    DrawableInstanced.prototype.addElements = function (scene, drawablesInfo) {
        for (var i = 0, len = drawablesInfo.length; i < len; i++) {
            var element = scene.graph.nodes[drawablesInfo[i].id];
            element.indicesOffset = this.elements.length;
            this.elements.push(element);
            this.transform.append(drawablesInfo[i].transform);
        }
        this.hidables = -1;
        if (this.elements[0].region >= _graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_1__["default"].STRUCTURE_INTERIOR) {
            this.hidables = 0;
        }
    };
    function DrawableInfo() {
        this.id = 0; // element's node index
        this.layer = -1;
        this.primitive = 0;
        this.instanced = false;
        this.transform = null;
        this.attributes = null;
        this.verticesOffset = 0;
        this.verticesBytes = 0;
        this.indicesOffset = 0;
        this.indicesBytes = 0;
        this.indexSize = 0;
        this.verticesBinary = null;
        this.indicesBinary = null;
        this.mesh = "";
    }
    ;
    DrawableInstanced.prototype.getElementInfo = function (element, outDrawablesInfo) {
        var drawableInfo = new DrawableInfo();
        drawableInfo.id = element.id;
        drawableInfo.instanced = true;
        drawableInfo.layer = this.layer.index;
        drawableInfo.primitive = this.mesh._primitive;
        drawableInfo.attributes = this.mesh._attributes;
        drawableInfo.mesh = this.mesh._name;
        for (var i = 0, len = this.elements.length; i < len; i++) {
            if (this.elements[i].id === element.id) {
                drawableInfo.transform = this.transform.getTransformData(i);
                break;
            }
        }
        outDrawablesInfo.push(drawableInfo);
    };
    return DrawableInstanced;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_drawable_library.js":
/*!***************************************************!*\
  !*** ./03scene/drawables/m3d_drawable_library.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
/* harmony import */ var _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/m3d_material_adhoc.js */ "./03scene/materials/m3d_material_adhoc.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_materials_m3d_material_volume_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/materials/m3d_material_volume.js */ "./03scene/materials/m3d_material_volume.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
//
// m3d_drawable_library.js
// Generate a handful of drawables
//
// Copyright Modelo XX - 2017, All rights reserved.





/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var DrawableLibrary = {
        "createHeatmapVolume": function (resourceManager, matrix, cubeTexture, toneTexture) {
            var mesh = resourceManager.getMesh("heat-map-volume");
            mesh.createHeatmapCube();
            var shaderType = "volume";
            var shader = resourceManager.getShader(shaderType, ["MODEL_TRANSFORM"]);
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource, ["MODEL_TRANSFORM"]);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _03scene_materials_m3d_material_volume_js__WEBPACK_IMPORTED_MODULE_3__["default"]("heat-map-volume");
            material.attachShader(shader);
            material.setToneTexture(toneTexture);
            material.setCubeTexture(cubeTexture);
            material.setAlphaCorrection(0.03);
            var bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_4__["default"].aabb.create();
            var _bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_4__["default"].aabb.createFromArray(0, 0, 0, 1, 1, 1);
            _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_4__["default"].aabb.transform(bbox, _bbox, matrix);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"]("heat-map-volume", mesh, null, shader, material, matrix, bbox);
            var invTransform = mat4.create();
            mat4.invert(invTransform, drawable.transform.matrix);
            material.setInvTransform(invTransform);
            return drawable;
        },
        "createSolidSphere": function (resourceManager, color, radius, position) {
            color = color || [1, 0, 0];
            radius = radius || 1.0;
            position = position || [0, 0, 0];
            var mesh = resourceManager.getMesh("sphere");
            mesh.createSphere(32, 16);
            var shaderType = "constant";
            var shader = resourceManager.getShader(shaderType, ["MODEL_TRANSFORM"]);
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource, ["MODEL_TRANSFORM"]);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"]("solid-sphere-material");
            material.attachShader(shader);
            material.setDiffuse(color);
            material.setTransparent(1);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"]("solid-sphere", mesh, null, shader, material, null, [position[0] - radius, position[1] - radius, position[2] - radius,
                position[0] + radius, position[1] + radius, position[2] + radius]);
            drawable.transform.setTranslation(position[0], position[1], position[2]);
            drawable.transform.setScaling(radius, radius, radius);
            return drawable;
        },
        "createWiredCube": function (resourceManager, color, size, position) {
            color = color || [1, 0, 0];
            size = size || 1.0;
            position = position || [0, 0, 0];
            var mesh = resourceManager.getMesh("wired-cube");
            mesh.createWiredCube();
            var shaderType = "constant";
            var shader = resourceManager.getShader(shaderType, ["MODEL_TRANSFORM"]);
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource, ["MODEL_TRANSFORM"]);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"]("wired-cube-material");
            material.attachShader(shader);
            material.setDiffuse(color);
            material.setTransparent(1);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"]("wired-cube", mesh, null, shader, material, null, [position[0] - size, position[1] - size, position[2] - size,
                position[0] + size, position[1] + size, position[2] + size]);
            drawable.transform.setTranslation(position[0], position[1], position[2]);
            drawable.transform.setScaling(size, size, size);
            return drawable;
        },
        "createSolidCube": function (resourceManager, color, size, position) {
            color = color || [1, 0, 0];
            size = size || 1.0;
            position = position || [0, 0, 0];
            var mesh = resourceManager.getMesh("cube");
            mesh.createSolidCube();
            var shaderType = "constant";
            var shader = resourceManager.getShader(shaderType, ["MODEL_TRANSFORM"]);
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"]("solid-cube-material");
            material.attachShader(shader);
            material.setDiffuse(color);
            material.setTransparent(1);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"]("solid-cube", mesh, null, shader, material, null, [position[0] - size, position[1] - size, position[2] - size,
                position[0] + size, position[1] + size, position[2] + size]);
            drawable.transform.setTranslation(position[0], position[1], position[2]);
            drawable.transform.setScaling(size, size, size);
            return drawable;
        },
        "createShadedSphere": function (resourceManager, color) {
            color = color || [1, 0, 0];
            var mesh = resourceManager.getMesh("sphere");
            mesh.createSphere(32, 16);
            var shaderType = "solid";
            var shader = resourceManager.getShader();
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"]("shaded-sphere-material");
            material.attachShader(shader);
            material.setDiffuse(color);
            material.setTransparent(1);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"]("shaded-sphere", mesh, null, shader, material, null, [-1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);
            return drawable;
        },
        "createShadedCube": function (resourceManager, color) {
            color = color || [1, 0, 0];
            var mesh = resourceManager.getMesh("sphere");
            mesh.createSolidCube();
            var shaderType = "constant";
            var shader = resourceManager.getShader();
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"]("shaded-cube-material");
            material.attachShader(shader);
            material.setDiffuse(color);
            material.setTransparent(1);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"]("shaded-cube", mesh, null, shader, material, null, [-1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);
            return drawable;
        },
        "createDrawable": function (resourceManager, mesh, color) {
            color = color || [1, 0, 0];
            var shaderType = "constant";
            var shader = resourceManager.getShader();
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"][shaderType];
                shader.createFromShaderSource(shaderSource);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
            var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"]("wired-drawable-material");
            material.attachShader(shader);
            material.setDiffuse(color);
            material.setTransparent(1);
            var drawable = new _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"](mesh.name, mesh, null, shader, material, null, [-1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);
            return drawable;
        }
    };
    return DrawableLibrary;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_gizmo.js":
/*!****************************************!*\
  !*** ./03scene/drawables/m3d_gizmo.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/m3d_material_adhoc.js */ "./03scene/materials/m3d_material_adhoc.js");
/* harmony import */ var _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
//
// m3d_gizmo.js
// A drawable used for 3D UI controller which uses simple material and doesn't
// associate to scene and layers.
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Gizmo(name, mesh, resourceManager) {
        var flag = [];
        flag.push("MODEL_TRANSFORM");
        var shader = resourceManager.getShader("gizmo", flag);
        if (!shader.ready) {
            shader.createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"]["constant"], flag);
        }
        var material = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_1__["default"](name);
        // Inheritance:
        _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__["default"].apply(this, [name, mesh, null, shader, material, null, null]);
    }
    ;
    // Gizmo inherits Drawable
    Gizmo.prototype = Object.create(_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
    Gizmo.prototype.constructor = Gizmo;
    Gizmo.prototype.destroy = function () {
        _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.destroy.apply(this);
    };
    Gizmo.prototype.setColor = function (color) {
        this.material.setDiffuse(color);
    };
    Gizmo.prototype.setTransparent = function (alpha) {
        this.material.setTransparent(alpha);
    };
    return Gizmo;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_gizmo2d.js":
/*!******************************************!*\
  !*** ./03scene/drawables/m3d_gizmo2d.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _materials_m3d_material_blit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/m3d_material_blit.js */ "./03scene/materials/m3d_material_blit.js");
/* harmony import */ var _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
//
// m3d_gizmo.js
// A drawable used for 3D UI controller which uses simple material and doesn't
// associate to scene and layers.
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Gizmo2D(name, mesh, resourceManager) {
        // private:
        this._resourceManager = resourceManager;
        // initialization
        var shader = resourceManager.getShader("gizmo2d");
        if (!shader.ready) {
            shader.createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"]["constant2d"]);
        }
        var material = new _materials_m3d_material_blit_js__WEBPACK_IMPORTED_MODULE_1__["default"](name);
        material.attachShader(shader);
        // Inheritance:
        _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__["default"].apply(this, [name, mesh, null, shader, material, null, null]);
        this._textured = false; // using texture or not. 
    }
    ;
    // Gizmo2D inherits Drawable
    Gizmo2D.prototype = Object.create(_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
    Gizmo2D.prototype.constructor = Gizmo2D;
    Gizmo2D.prototype.setColor = function (color) {
        if (this._textured) {
            this.shader = this._resourceManager.getShader("gizmo2d");
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"]["constant2d"]);
            }
            this.material.attachShader(this.shader);
            this._textured = false;
        }
        this.material.parameters["uColor"].value = color;
    };
    Gizmo2D.prototype.setTransparent = function (alpha) {
        if (this._textured) {
            this.shader = this._resourceManager.getShader("gizmo2d");
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"]["constant2d"]);
            }
            this.material.attachShader(this.shader);
            this._textured = false;
        }
        // TODO: transparency is not supported yet.
        //this.material.setTransparent(alpha);
    };
    Gizmo2D.prototype.setTexture = function (texture) {
        if (!this._textured) {
            this.shader = this._resourceManager.getShader("blit");
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"]["blit"]);
            }
            this.material.attachShader(this.shader);
            this._textured = true;
        }
        this.material.setTexture(texture);
    };
    return Gizmo2D;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_skybox.js":
/*!*****************************************!*\
  !*** ./03scene/drawables/m3d_skybox.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_utils.js */ "./00utility/m3d_utils.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _materials_m3d_material_skybox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../materials/m3d_material_skybox.js */ "./03scene/materials/m3d_material_skybox.js");
/* harmony import */ var _camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../camera/m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
//
// m3d_skybox.js
// The sky dome or planar background
//
// Copyright Modelo XX - 2017, All rights reserved.






/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function SkyBox(resourceManager, name) {
        this._name = name || "skybox";
        // Inheritance:
        _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_5__["default"].apply(this, [this._name, null, null, null, null, null, null]);
        // public:
        this.enabled = false;
        // private:
        this._texture = null;
        this._resourceManager = resourceManager;
        this._mode = -1;
        this._flipY = false;
        this.camera = new _camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
        // Initialization:
        this.material = new _materials_m3d_material_skybox_js__WEBPACK_IMPORTED_MODULE_3__["default"](this._name);
        this.setMode(SkyBox.SKYBOX_EQUIRECTANGLE);
    }
    ;
    SkyBox.SKYBOX_SOLIDCOLOR = 0;
    SkyBox.SKYBOX_WALLPAPER = 1;
    SkyBox.SKYBOX_EQUIRECTANGLE = 2; // Equirectangle panorama
    SkyBox.SKYBOX_CUBEMAP = 3; // Cubemap panorama
    SkyBox.SKYBOX_WALLPAPER_TILED = 4;
    // Skybox inherits Drawable
    SkyBox.prototype = Object.create(_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype);
    SkyBox.prototype.constructor = SkyBox;
    SkyBox.prototype.destroy = function () {
        _m3d_drawable_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype.destroy.apply(this);
        if (this._texture) {
            this._texture.destroy();
        }
    };
    SkyBox.prototype.update = function (viewMatrix) {
        if (this._mode === SkyBox.SKYBOX_WALLPAPER_TILED && this.enabled) {
            // Stretch the bg image to the window left/right border
            // and move the bg image to the top.
            var aspect = (this._texture.height / this._texture.width) * (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
            this.transform.setScaling(1.0, aspect, 1.0);
            this.transform.setTranslation(0.0, 1.0 - aspect, 1.0);
        }
        else {
            mat4.copy(this.camera.viewMatrix, viewMatrix);
            this.camera.viewMatrix[12] = 0;
            this.camera.viewMatrix[13] = 0;
            this.camera.viewMatrix[14] = 0;
            mat4.multiply(this.camera.vpMatrix, this.camera.projectMatrix, viewMatrix);
        }
    };
    SkyBox.prototype.resize = function (width, height) {
        this.camera.resize(width, height);
    };
    SkyBox.prototype.setImage = function (images) {
        if (!images) {
            this.enabled = false;
            return;
        }
        if (this._texture && this._texture.ready) {
            this._texture.destroy();
        }
        this._texture = this._resourceManager.getTexture(this._name);
        if (images && _00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArray(images)) { // cubemap
            this._texture.createFromImages(images, gl.RGB, gl.UNSIGNED_BYTE, gl.LINEAR, gl.CLAMP_TO_EDGE);
        }
        else { // single image, e.g., equirectangle
            this._texture.createFromImage(images, gl.RGB, gl.UNSIGNED_BYTE, gl.LINEAR, gl.CLAMP_TO_EDGE);
        }
        this.enabled = this._texture.ready;
        if (!this.enabled) {
            console.warn("skybox sees a corrupted image.");
        }
        else {
            this.material.setTexture(this._texture);
        }
    };
    var SPHERE_RINGS = 64;
    var SPHERE_SEGMENTS = 128;
    SkyBox.prototype.setMode = function (mode) {
        if (this._mode === mode) {
            return;
        }
        this._mode = mode;
        var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"]["skybox"];
        if (this._mode === SkyBox.SKYBOX_WALLPAPER) {
            this.mesh = this._resourceManager.getMesh("quad");
            if (!this.mesh.ready) {
                this.mesh.createQuad();
            }
            this.shader = this._resourceManager.getShader("skybox", ["WALLPAPER"]);
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(shaderSource, ["WALLPAPER"]);
            }
            this.transform.reset();
        }
        else if (this._mode === SkyBox.SKYBOX_WALLPAPER_TILED) {
            this.mesh = this._resourceManager.getMesh("quad");
            if (!this.mesh.ready) {
                this.mesh.createQuad();
            }
            this.shader = this._resourceManager.getShader("skybox", ["WALLPAPER", "MODEL_TRANSFORM"]);
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(shaderSource, ["WALLPAPER", "MODEL_TRANSFORM"]);
            }
            this.transform.reset();
        }
        else if (this._mode === SkyBox.SKYBOX_EQUIRECTANGLE) {
            this.mesh = this._resourceManager.getMesh("sphere-" + SPHERE_RINGS + "-" + SPHERE_SEGMENTS);
            if (!this.mesh.ready) {
                this.mesh.createSphere(SPHERE_RINGS, SPHERE_SEGMENTS);
            }
            this.shader = this._resourceManager.getShader("skybox", ["EQUIRECTANGLE"]);
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(shaderSource, ["EQUIRECTANGLE"]);
            }
        }
        else if (this._mode === SkyBox.SKYBOX_CUBEMAP) {
            this.mesh = this._resourceManager.getMesh("sphere-" + SPHERE_RINGS + "-" + SPHERE_SEGMENTS);
            if (!this.mesh.ready) {
                this.mesh.createSphere(SPHERE_RINGS, SKYBOX_CUBEMAP);
            }
            var flags = ["CUBEMAP"];
            if (this._flipY) {
                flags.push("FLIP");
            }
            this.shader = this._resourceManager.getShader("skybox", flags);
            if (!this.shader.ready) {
                this.shader.createFromShaderSource(shaderSource, flags);
            }
        }
        this.material.attachShader(this.shader);
        this.material.setTexture(this._texture);
        this.material.setTransparency(1.0);
    };
    SkyBox.prototype.setTransparency = function (value) {
        this.material.setTransparency(value);
    };
    //Flip Y axis, only works for panorama, which means the cubemap
    SkyBox.prototype.setFlipYEnabled = function (enabled) {
        this._flipY = enabled;
        this._mode = -1;
        this.setMode(SkyBox.SKYBOX_CUBEMAP);
    };
    return SkyBox;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_transform.js":
/*!********************************************!*\
  !*** ./03scene/drawables/m3d_transform.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_transform.js
// The transform of drawable
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Transform(matrix) {
        // private:
        this._default = null; // The initialized transform.
        this._buffer = null;
        // public:
        this.identity = true;
        this.matrix = null; // The current transform.
        // initialization:
        if (matrix) {
            this.identity = false;
            this.matrix = mat4.clone(matrix);
        }
        else {
            this.matrix = mat4.create();
        }
        this._default = this.matrix;
        this._buffer = this.matrix;
    }
    ;
    Transform.prototype.destroy = function () {
        this._buffer = null;
        delete this._buffer;
        this._default = null;
        delete this._default;
        this.matrix = null;
        delete this.matrix;
        this.identity = null;
        delete this.identity;
    };
    Transform.prototype.use = function (camera, shader) {
        var uniform = null;
        var parameter = gl.isWebGL2 ? "m_uPerNode" : "m_uPerNode.modelMatrix";
        uniform = shader.reservedUniforms[parameter];
        if (uniform) {
            uniform.upload(this._buffer);
        }
    };
    Transform.prototype.translate = function (dx, dy, dz) {
        if (this._default === this.matrix) {
            this._default = mat4.clone(this.matrix);
        }
        this.identity = false;
        this.matrix[12] += dx;
        this.matrix[13] += dy;
        this.matrix[14] += dz;
    };
    Transform.prototype.setTranslation = function (x, y, z) {
        if (this._default === this.matrix) {
            this._default = mat4.clone(this.matrix);
        }
        this.identity = false;
        this.matrix[12] = this._default[12] + x;
        this.matrix[13] = this._default[13] + y;
        this.matrix[14] = this._default[14] + z;
    };
    Transform.prototype.setScaling = function (x, y, z) {
        this.identity = false;
        var c0 = [this.matrix[0], this.matrix[1], this.matrix[2]];
        var c1 = [this.matrix[4], this.matrix[5], this.matrix[6]];
        var c2 = [this.matrix[8], this.matrix[9], this.matrix[10]];
        var oldx = Math.sqrt(vec3.dot(c0, c0));
        var oldy = Math.sqrt(vec3.dot(c1, c1));
        var oldz = Math.sqrt(vec3.dot(c2, c2));
        // Compute the current scaling factor.
        var ratiox = x / oldx;
        var ratioy = y / oldy;
        var ratioz = z / oldz;
        this.matrix[0] *= ratiox;
        this.matrix[1] *= ratiox;
        this.matrix[2] *= ratiox;
        this.matrix[4] *= ratioy;
        this.matrix[5] *= ratioy;
        this.matrix[6] *= ratioy;
        this.matrix[8] *= ratioz;
        this.matrix[9] *= ratioz;
        this.matrix[10] *= ratioz;
    };
    // Set the current transformation matrix directly, i.e., 4x4 matrix in column major.
    Transform.prototype.set = function (matrix) {
        if (this._default === this.matrix) {
            this._default = mat4.clone(this.matrix);
        }
        if (matrix) {
            this.identity = false;
            mat4.copy(this.matrix, matrix);
        }
        else {
            mat4.identity(this.matrix);
        }
    };
    // Reset the current transform to the initial state.
    Transform.prototype.reset = function () {
        mat4.copy(this.matrix, this._default);
        this.identity = (Math.abs(this.matrix[0] - 1) < 1e-5 &&
            Math.abs(this.matrix[5] - 1) < 1e-5 &&
            Math.abs(this.matrix[10] - 1) < 1e-5 &&
            Math.abs(this.matrix[12]) < 1e-5 &&
            Math.abs(this.matrix[13]) < 1e-5 &&
            Math.abs(this.matrix[14]) < 1e-5);
    };
    Transform.prototype.getInverted = function (output) {
        mat4.invert(output, this.matrix);
    };
    Transform.prototype.multiply = function (matrix) {
        if (this._default === this.matrix) {
            this._default = mat4.clone(this.matrix);
        }
        if (this.identity) {
            mat4.copy(this.matrix, matrix);
        }
        else {
            mat4.multiply(this.matrix, matrix, this.matrix);
        }
        this.identity = (Math.abs(this.matrix[0] - 1) < 1e-5 &&
            Math.abs(this.matrix[5] - 1) < 1e-5 &&
            Math.abs(this.matrix[10] - 1) < 1e-5 &&
            Math.abs(this.matrix[12]) < 1e-5 &&
            Math.abs(this.matrix[13]) < 1e-5 &&
            Math.abs(this.matrix[14]) < 1e-5);
    };
    //var inverse_ret = [0, 0, 0];
    //Transform.prototype.inverse = function(vec) {
    //    if (!this.identity) {
    //        mat4.invert(inv, this.matrix);
    //        mat4.multiplyVector3(inverse_ret, inv, vec);
    //        return inverse_ret;
    //    }
    //    return vec;
    //};
    return Transform;
})());


/***/ }),

/***/ "./03scene/drawables/m3d_transform_instanced.js":
/*!******************************************************!*\
  !*** ./03scene/drawables/m3d_transform_instanced.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_transform_instanced.js
// The transform of instancing drawable
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    // The model matrices length must be smaller than 32
    function TransformInstanced(matrices) {
        //matrices = new Float32Array(
        //    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 11.636218070983887, 3.897318124771118, 0, 1, 
        //     1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 11.36070442199707, 6.775900840759277, 0, 1, 
        //     1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 14.993080139160156, 3.6942176818847656, 0, 1]);
        // public:
        this.count = matrices.byteLength / 64;
        this.identity = false;
        // private
        this._matricesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._matricesBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, matrices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    ;
    TransformInstanced.prototype.destroy = function () {
        gl.deleteBuffer(this._matricesBuffer);
    };
    TransformInstanced.prototype.use = function (camera, shader, base) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this._matricesBuffer);
        // matrices will be used as a per-instance transformation
        // matrix. Note that a mat4 consumes 4 consecutive locations, so
        // this will actually sit in locations, 6, 7, 8 and 9. 
        // Loop over each column of the matrix.
        var offset = base * 64;
        gl.enableVertexAttribArray(6);
        gl.enableVertexAttribArray(7);
        gl.enableVertexAttribArray(8);
        gl.enableVertexAttribArray(9);
        gl.vertexAttribPointer(6, 4, gl.FLOAT, false, 64, offset + 0);
        gl.vertexAttribPointer(7, 4, gl.FLOAT, false, 64, offset + 16);
        gl.vertexAttribPointer(8, 4, gl.FLOAT, false, 64, offset + 32);
        gl.vertexAttribPointer(9, 4, gl.FLOAT, false, 64, offset + 48);
        gl.vertexAttribDivisor(6, 1);
        gl.vertexAttribDivisor(7, 1);
        gl.vertexAttribDivisor(8, 1);
        gl.vertexAttribDivisor(9, 1);
    };
    // Create a new tranform of transform data at indices of this one.
    TransformInstanced.prototype.slice = function (indices) {
        var newModelMatrices = new Float32Array(indices.length * 16);
        var bufferOffset = 0;
        // TODO: optimize the copy to reduce the copy times. Consecutive transform can be copied once.
        gl.bindBuffer(gl.ARRAY_BUFFER, this._matricesBuffer);
        for (var i = 0, len = indices.length; i < len; i++) {
            gl.getBufferSubData(gl.ARRAY_BUFFER, indices[i] * 64, newModelMatrices, bufferOffset, 16);
            bufferOffset += 16;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return new TransformInstanced(newModelMatrices);
    };
    TransformInstanced.prototype.append = function (transform) {
        this.count += 1;
        var newBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, newBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.count * 16), gl.STATIC_DRAW);
        // Copy the old buffer to the new one
        var offset = (this.count - 1) * 64;
        gl.bindBuffer(gl.COPY_READ_BUFFER, this._matricesBuffer);
        gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.ARRAY_BUFFER, 0, 0, offset);
        // Add the new transform to the tail of new buffer.
        gl.bufferSubData(gl.ARRAY_BUFFER, offset, transform);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.COPY_READ_BUFFER, null);
        // Replace the buffer object.
        gl.deleteBuffer(this._matricesBuffer);
        this._matricesBuffer = newBuffer;
    };
    TransformInstanced.prototype.getTransformData = function (index) {
        var retBuffer = new Float32Array(16);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._matricesBuffer);
        gl.getBufferSubData(gl.ARRAY_BUFFER, index * 64, retBuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return retBuffer;
    };
    return TransformInstanced;
})());


/***/ }),

/***/ "./03scene/graph/m3d_element.js":
/*!**************************************!*\
  !*** ./03scene/graph/m3d_element.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
// m3d_element.js
// The scene drawable, which is one-to-one corresponding to the 
// original model scene graph drawable.
//
// Copyright Modelo XX - 2017, All rights reserved.
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Element(type, name) {
        this.type = type;
        this.name = name;
        this.father = null;
        this.children = [];
        this.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.create();
    }
    ;
    // Return all nodes that are descedants of this element.
    Element.prototype.getNodes = function () {
        var ret = [];
        var queue = [];
        for (var i = 0, len = this.children.length; i < len; ++i) {
            var child = this.children[i];
            if (child.children === undefined) { // element leaf/node
                ret.push(child);
            }
            else {
                queue.push(child);
            }
        }
        while (queue.length > 0) {
            var element = queue.pop();
            for (var i = 0, len = element.children.length; i < len; ++i) {
                var child = element.children[i];
                if (child.children === undefined) { // element leaf/node
                    ret.push(child);
                }
                else {
                    queue.push(child);
                }
            }
        }
        return ret;
    };
    // Find the doc element that has this element as desendent
    Element.prototype.getDocument = function () {
        var father = this.father;
        while (father !== null && father.type !== Element.LINK) {
            father = father.father;
        }
        if (father.type === Element.LINK) {
            return father;
        }
        return null;
    };
    Element.ROOT = 0;
    Element.INSTANCE = 1;
    Element.GROUP = 2;
    Element.ELEMENT = 3; // Correspond to semantic node in the model defined by modelling.
    Element.NODE = 4; // Correspond to drawable node (mesh + material) in the model
    Element.LINK = 5; // Correspond to drawable node (mesh + material) in the model
    return Element;
})());


/***/ }),

/***/ "./03scene/graph/m3d_node.js":
/*!***********************************!*\
  !*** ./03scene/graph/m3d_node.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_element.js */ "./03scene/graph/m3d_element.js");
// The scene drawable, which is one-to-one corresponding to the 
// original model scene graph drawable.
//
// Copyright Modelo XX - 2017, All rights reserved.
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Node(id) {
        this.id = id;
        // The location of this element 
        this.region = Node.STRUCTURE;
        // Refer to its parent
        this.father = null;
        // The indices section of this element in this drawable.
        this.indicesOffset = 0;
        this.indicesCount = 0;
        this.verticesCount = 0; // number of vertices
        // The drawable that contained this element. Only useful in BIM.
        this.drawable = null;
        // The visibility
        this.visible = true;
        // custom color
        // Since the visibility and custom color share the same attribute in shader
        // in order to remember the custom color after setting the visibility
        // we use 0-126 to represent the custom color, 127 to represent the original color
        // 0-127 to represent visible nodes and 128-255 to represent invisible nodes   
        this.platteIndex = 127;
    }
    ;
    Node.STRUCTURE = 0;
    Node.STRUCTURE_INTERIOR = 4;
    Node.INTERIOR = 8;
    Node.MEP = 12;
    Node.LANDSCAPE = 15;
    // Get the nearest instance that contains this element.
    Node.prototype.getInstance = function () {
        var element = this.father;
        while (element.type !== _m3d_element_js__WEBPACK_IMPORTED_MODULE_0__["default"].INSTNACE) {
            element = element.father;
            if (element === null) {
                break;
            }
        }
        return element;
    };
    // Get the nearest group that contains this element.
    Node.prototype.getGroup = function () {
        var element = this.father;
        while (element.type !== _m3d_element_js__WEBPACK_IMPORTED_MODULE_0__["default"].GROUP) {
            element = element.father;
            if (element === null) {
                break;
            }
        }
        return element;
    };
    // Get the nearest element
    Node.prototype.getElement = function () {
        var element = this.father;
        while (element.type !== _m3d_element_js__WEBPACK_IMPORTED_MODULE_0__["default"].ELEMENT) {
            element = element.father;
            if (element === null) {
                break;
            }
        }
        return element;
    };
    // Get the nearest component (either instance or group)
    Node.prototype.getComponent = function () {
        var element = this.father;
        while (element.type !== _m3d_element_js__WEBPACK_IMPORTED_MODULE_0__["default"].GROUP && element.type !== _m3d_element_js__WEBPACK_IMPORTED_MODULE_0__["default"].INSTANCE) {
            element = element.father;
            if (element === null) {
                break;
            }
        }
        return element;
    };
    return Node;
})());


/***/ }),

/***/ "./03scene/graph/m3d_scene_graph.js":
/*!******************************************!*\
  !*** ./03scene/graph/m3d_scene_graph.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// The scene tree.
//
// Copyright Modelo XX - 2017, All rights reserved.
//
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function SceneGraph(model) {
        this.nodes = []; // All scene nodes 
        this.nodeBBoxes = null; // The node bounding boxes
        this.root = null; // The root element of scene tree
        this.elements = {}; // ELEMENT elements indexed by name
        this.elementsNum = 0; // The number of element of type ELEMENT.
        this.model = model;
    }
    ;
    SceneGraph.prototype.destroy = function () {
        this.nodes = null;
        delete this.nodes;
        this.elements = null;
        delete this.elements;
        this.nodeBBoxes = null;
        delete this.nodeBBoxes;
        this.root = null;
        delete this.root;
    };
    SceneGraph.prototype.createNodes = function (number) {
        this.nodes = new Array(number);
        this.nodeBBoxes = new Float32Array(number * 6);
    };
    SceneGraph.prototype.getNodeBBox = function (elementIndex, bbox) {
        var j = elementIndex * 6;
        bbox[0] = this.nodeBBoxes[j];
        bbox[1] = this.nodeBBoxes[j + 1];
        bbox[2] = this.nodeBBoxes[j + 2];
        bbox[3] = this.nodeBBoxes[j + 3];
        bbox[4] = this.nodeBBoxes[j + 4];
        bbox[5] = this.nodeBBoxes[j + 5];
    };
    /**
     * @description Find the doc id of each element
     * @constructor
     * @param {array} elements - the array of element objects
     * @return {array} - [{modelId: integer, docId: integer, element: integer}, {...}, ...}]
     */
    function ElementPath() {
        this.element = 0;
        this.docId = 0;
        this.modelId = 0;
    }
    ;
    SceneGraph.prototype.getElementPaths = function (elements) {
        var ret = [];
        for (var e in elements) {
            var p = this.getElementPath(elements[e]);
            if (p) {
                ret.push(p);
            }
        }
        return ret;
    };
    SceneGraph.prototype.getElementPath = function (element) {
        var r = new ElementPath();
        r.element = element.name;
        var doc = element.getDocument();
        if (!doc) {
            console.warn("element '" + r.element + "' doesn't belong to any doc");
            return null;
        }
        r.docId = doc.name;
        r.modelId = this.model.id;
        return r;
    };
    SceneGraph.prototype.getElementPathString = function (element) {
        var doc = element.getDocument();
        if (!doc) {
            console.warn("element '" + r.element + "' doesn't belong to any doc");
            return "";
        }
        return this.model.id + "+" + doc.name + "/" + element.name;
    };
    SceneGraph.prototype.getElementPathStringss = function (elements) {
        var ret = [];
        for (var e in elements) {
            var s = this.getElementPathString(elements[e]);
            if (s !== "") {
                ret.push(s);
            }
        }
        return ret;
    };
    return SceneGraph;
})());


/***/ }),

/***/ "./03scene/m3d_background.js":
/*!***********************************!*\
  !*** ./03scene/m3d_background.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawables/m3d_skybox.js */ "./03scene/drawables/m3d_skybox.js");
//
// m3d_background.js
// The backgroun of the scene.
//
// Copyright Modelo XX - 2018, All rights reserved.
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Background(resourceManager) {
        this._resourceManager = resourceManager;
        this.color = new Float32Array([1, 1, 1, 0]);
        this.mode = _drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__["default"].SKYBOX_SOLIDCOLOR;
        this.skybox = null;
    }
    ;
    Background.prototype.destroy = function () {
        if (this.skybox !== null) {
            this.skybox.destroy();
        }
        this.skybox = null;
        delete this.skybox;
        this.color = null;
        delete this.color;
    };
    Background.prototype.setColor = function (color) {
        this.color[0] = color[0];
        this.color[1] = color[1];
        this.color[2] = color[2];
        this.color[3] = 0.0;
    };
    var background_getcolor = [0, 0, 0, 0];
    Background.prototype.getColor = function () {
        background_getcolor[0] = this.color[0];
        background_getcolor[1] = this.color[1];
        background_getcolor[2] = this.color[2];
        background_getcolor[3] = this.color[3];
        return background_getcolor;
    };
    Background.prototype.setImages = function (images) {
        if (!this.skybox) {
            this.skybox = new _drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._resourceManager);
        }
        this.skybox.setImage(images);
    };
    Background.prototype.setMode = function (mode) {
        if (mode !== _drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__["default"].SKYBOX_SOLIDCOLOR) {
            if (!this.skybox) {
                this.skybox = new _drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._resourceManager);
            }
            this.skybox.setMode(mode);
            this.skybox.enabled = true;
        }
        else {
            this.skybox && (this.skybox.enabled = false);
        }
        this.mode = mode;
    };
    return Background;
})());


/***/ }),

/***/ "./03scene/m3d_layer.js":
/*!******************************!*\
  !*** ./03scene/m3d_layer.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_layer.js
// The layer in the scene
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Layer(name, index, color, visible) {
        this.index = index; // the index of layer in the scene
        this.name = name;
        this.color = vec3.clone(color);
        this.visible = visible;
        this.drawables = [];
    }
    ;
    Layer.prototype.destroy = function () {
        this.drawables = null;
        delete this.drawables;
        this.color = null;
        delete this.color;
        this.name = null;
        delete this.name;
    };
    Layer.prototype.setVisible = function (visible) {
        for (var i = 0, len = this.drawables.length; i < len; i++) {
            this.drawables[i].visible = visible;
        }
        this.visible = visible;
        return true;
    };
    return Layer;
})());


/***/ }),

/***/ "./03scene/m3d_light.js":
/*!******************************!*\
  !*** ./03scene/m3d_light.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_light.js
// Lights
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Light() {
        // private:
        this._initialDirection = vec3.clone([0.81961, -0.28627, -0.49804]); // The position of the sun
        this._latitude = Math.asin(-this._initialDirection[2]);
        this._longitude = Math.atan2(-this._initialDirection[1], -this._initialDirection[0]);
        this._constantEnvmapMatrix = null;
        this._initialEnvmapMatrix = null;
        // public:
        this.direction = vec3.clone(this._initialDirection);
        this.intensity = 1.05;
        this.shinness = 100.0;
        this.envmapMatrix = mat4.create();
        // initializatoin.
        // http://www.cs.berkeley.edu/~ravir/papers/envmap/envmap.pdf
        // The diffuse light matrix (Y is up)
        var matrixR = mat4.clone([
            1.586253, -0.725169, 0.704410, -2.300680,
            -0.725169, -1.586253, -0.359456, 1.623691,
            0.704410, -0.359456, -0.237555, -0.893975,
            -2.300680, 1.623691, -0.893975, 6.141995
        ]);
        var matrixG = mat4.clone([
            1.329145, -0.730669, 0.591031, -2.126058,
            -0.730669, -1.329145, -0.403495, 1.890295,
            0.591031, -0.403495, -0.159067, -0.888839,
            -2.126058, 1.890295, -0.888839, 6.193693
        ]);
        var matrixB = mat4.clone([
            0.870924, -0.654664, 0.433506, -1.748137,
            -0.654664, -0.870924, -0.440849, 2.254821,
            0.433506, -0.440849, -0.109753, -0.848042,
            -1.748137, 2.254821, -0.848042, 6.301804
        ]);
        // Merge three RGB matrices into a luminance matrix.
        var SCALING = 0.1;
        mat4.multiplyScalar(matrixR, matrixR, 0.299 * SCALING);
        mat4.multiplyScalar(matrixG, matrixG, 0.587 * SCALING);
        mat4.multiplyScalar(matrixB, matrixB, 0.114 * SCALING);
        mat4.add(this.envmapMatrix, matrixR, matrixG);
        mat4.add(this.envmapMatrix, this.envmapMatrix, matrixB);
        this._constantEnvmapMatrix = mat4.clone(this.envmapMatrix);
        this._initialEnvmapMatrix = mat4.clone(this.envmapMatrix);
        this._initialDirection = vec3.clone([0.81961, -0.49804, 0.28627]);
        this._initialEnvmapMatrix = mat4.clone(this._constantEnvmapMatrix);
        this._setFlipYZ(false);
        // FIXME: the numbers are from initial values of the lighting sliders
        // in model-effects-services.js
        this.setLatitude(0.17 * Math.PI);
        this.setLongitude(0.89 * 2 * Math.PI);
    }
    ; // end of Light
    Light.prototype._setFlipYZ = function (enabled) {
        // By default z is up
        this._flipYZ = enabled;
        if (!enabled) {
            this._initialDirection = vec3.clone([0.81961, -0.28627, -0.49804]);
            var zUpMatrix = mat4.clone([
                1, 0, 0, 0,
                0, 0, -1, 0,
                0, 1, 0, 0,
                0, 0, 0, 1
            ]);
            var zUpMatrixT = mat4.create();
            mat4.transpose(zUpMatrixT, zUpMatrix);
            var tempMatrix = mat4.create();
            mat4.multiply(this._initialEnvmapMatrix, mat4.multiply(tempMatrix, zUpMatrixT, this._constantEnvmapMatrix), zUpMatrix);
        }
        else {
            this._initialDirection = vec3.clone([0.81961, -0.49804, 0.28627]);
            this._initialEnvmapMatrix = mat4.clone(this._constantEnvmapMatrix);
        }
    };
    Light.prototype.setIntensity = function (intensity) {
        this.intensity = intensity;
    };
    Light.prototype.getIntensity = function () {
        return this.intensity;
    };
    Light.prototype.setSpecularShinness = function (intensity) {
        this.shinness = intensity;
    };
    Light.prototype.getIntensity = function () {
        return this.intensity;
    };
    Light.prototype.setLatitude = function (angle) {
        this._latitude = angle;
        // Update the light direction.
        var c = Math.cos(this._latitude);
        this.direction[0] = -(c * Math.cos(this._longitude));
        this.direction[1] = -(c * Math.sin(this._longitude));
        this.direction[2] = -(Math.sin(this._latitude));
        this._updateEnvmapMatrix();
    };
    Light.prototype.setLongitude = function (angle) {
        this._longitude = angle;
        // Update the light direction.
        var c = Math.cos(this._latitude);
        this.direction[0] = -(c * Math.cos(this._longitude));
        this.direction[1] = -(c * Math.sin(this._longitude));
        this.direction[2] = -Math.sin(this._latitude);
        this._updateEnvmapMatrix();
    };
    Light.prototype.getLongitude = function () {
        return this._longitude;
    };
    Light.prototype.getLatitude = function () {
        return this._latitude;
    };
    Light.prototype._updateEnvmapMatrix = function () {
        // Quaternion to vector from one to another
        // http://stackoverflow.com/questions/1171849/finding-quaternion-representing-the-rotation-from-one-vector-to-another
        var q = quat.create();
        var a = vec3.create();
        // The rotation matrix of the environmap is inverted to the rotation of the light.
        vec3.cross(a, this.direction, this._initialDirection);
        q[0] = a[0];
        q[1] = a[1];
        q[2] = a[2];
        q[3] = 1.0 + vec3.dot(this.direction, this._initialDirection);
        quat.normalize(q, q);
        var rotMat = mat4.create();
        mat4.fromQuat(rotMat, q);
        var rotMatT = mat4.create();
        mat4.transpose(rotMatT, rotMat);
        var tempMat = mat4.create();
        mat4.multiply(this.envmapMatrix, mat4.multiply(tempMat, rotMatT, this._initialEnvmapMatrix), rotMat);
    };
    return Light;
})());


/***/ }),

/***/ "./03scene/m3d_material_manager.js":
/*!*****************************************!*\
  !*** ./03scene/m3d_material_manager.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./materials/m3d_material_adhoc.js */ "./03scene/materials/m3d_material_adhoc.js");
//
// m3d_material_manager.js
// The material manager which manages the model materials
// that comes from model file.
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialManager(resourceManager) {
        this._materials = {};
        this._count = 0;
        this._customColors = {};
        this._customColorCount = 0;
        this._buffer = new Uint8Array(256 * 4); // 4 for current valid material parameters (diffuse, transparency)
        this.texture = resourceManager.getTexture("texturemanager");
        this.texture.create(256, 1, gl.RGBA8, gl.NEAREST, gl.CLAMP_TO_EDGE);
        this.texture.use(10);
    }
    ;
    MaterialManager.prototype.destroy = function () {
        for (var name in this._materials) {
            this._materials[name].destroy();
        }
        this._materials = null;
        delete this._materials;
        this.texture = null;
        delete this.texture;
        this._buffer = null;
        delete this._buffer;
    };
    // name can be optional
    MaterialManager.prototype.createMaterialAdhoc = function (name) {
        if (typeof (name) === "string") {
            if (this._materials[name]) {
                return this._materials[name];
            }
            this._materials[name] = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_0__["default"](name);
            this._materials[name].index = this._count;
            this._count++;
            return this._materials[name];
        }
        else {
            var hashkey = _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_0__["default"].hash(name);
            if (this._materials[hashkey]) {
                if (this._materials[hashkey].equal(name)) {
                    return this._materials[hashkey];
                }
                else {
                    var newHashKey = this._materials[hashKey].hash();
                    this._materials[newHashKey] = this._materials[hashKey];
                }
            }
            this._materials[hashkey] = new _materials_m3d_material_adhoc_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
            this._materials[hashkey].index = this._count;
            this._count++;
            return this._materials[hashkey];
        }
    };
    MaterialManager.prototype.addCustomColor = function (color) {
        var name = color.toString();
        if (!this._customColors[name]) {
            this._customColors[name] = {
                index: this._customColorCount,
                color: color
            };
            this._customColorCount++;
        }
        return this._customColors[name].index;
    };
    MaterialManager.prototype.createMaterialPbs = function (name) {
    };
    MaterialManager.prototype.getMaterial = function (name) {
        return this._materials[name];
    };
    // upload material data to GPU.
    MaterialManager.prototype.upload = function () {
        for (var m in this._customColors) {
            var index = this._customColors[m].index * 4;
            this._buffer[index] = Math.floor(this._customColors[m].color[0] * 255.0);
            this._buffer[index + 1] = Math.floor(this._customColors[m].color[1] * 255.0);
            this._buffer[index + 2] = Math.floor(this._customColors[m].color[2] * 255.0);
            this._buffer[index + 3] = 255;
        }
        this.texture.update(this._buffer);
    };
    MaterialManager.prototype.getAllMaterials = function () {
        return this._materials;
    };
    return MaterialManager;
})());


/***/ }),

/***/ "./03scene/m3d_model.js":
/*!******************************!*\
  !*** ./03scene/m3d_model.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _graph_m3d_scene_graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph/m3d_scene_graph.js */ "./03scene/graph/m3d_scene_graph.js");
// m3d_model.js
// A model is loaded from .mx file.
//
// Copyright Modelo XX - 2018, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    function Model() {
        // private:
        this._transform = new Float32Array(16);
        // public:
        this.graph = new _graph_m3d_scene_graph_js__WEBPACK_IMPORTED_MODULE_1__["default"](this); // The model structure
        this.drawables = [];
        this.source = "";
        this.id = "";
        this.bbox = null;
    }
    ;
    Model.prototype.destroy = function () {
        for (var i = 0, len = this.drawables.length; i < len; i++) {
            this.drawables[i].destroy();
        }
        this.drawables = null;
        delete this.drawables;
        this.graph.destroy();
        this.graph = null;
        delete this.graph;
        this._transform = null;
        delete this._transform;
        this._rotation = null;
        delete this._rotation;
    };
    // Compute the bbox of model about visible drawables.
    Model.prototype.updateBBox = function () {
        var bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray([
            Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE,
            -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE
        ]);
        var visibles = 0;
        for (var i = 0, len = this.drawables.length; i < len; i++) {
            var drawable = this.drawables[i];
            if (drawable.visible) {
                visibles++;
                _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.union(bbox, drawable.bbox, bbox);
            }
        }
        this.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox);
    };
    // Does this model file has any BIM data or related to BIM.
    Model.prototype.hasBIM = function () {
        var suffix = this.source.split('.');
        return suffix === ".rvt" || suffix === "ifc";
    };
    Model.prototype.getTransform = function () {
        return this._transform;
    };
    Model.prototype.translate = function (dx, dy, dz) {
        this._transform[12] += dx;
        this._transform[13] += dy;
        this._transform[14] += dz;
        for (var i = 0, len = this.drawables.length; i < len; i++) {
            this.drawables[i].translate(dx, dy, dz);
        }
        this.updateBBox();
    };
    var rotate_matrix = new Float32Array(16);
    var rotate_point = new Float32Array(3);
    Model.prototype.rotate = function (angle, axis, point) {
        mat4.fromRotation(rotate_matrix, angle, axis);
        vec3.transformMat4(rotate_point, point, rotate_matrix);
        rotate_matrix[12] = point[0] - rotate_point[0];
        rotate_matrix[13] = point[1] - rotate_point[1];
        rotate_matrix[14] = point[2] - rotate_point[2];
        mat4.multiply(this._transform, rotate_matrix, this._transform);
        for (var i = 0, len = this.drawables.length; i < len; i++) {
            this.drawables[i].multiply(rotate_matrix);
        }
        this.updateBBox();
    };
    return Model;
})());


/***/ }),

/***/ "./03scene/m3d_scene.js":
/*!******************************!*\
  !*** ./03scene/m3d_scene.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _m3d_light_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_light.js */ "./03scene/m3d_light.js");
/* harmony import */ var _m3d_scene_clip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_scene_clip.js */ "./03scene/m3d_scene_clip.js");
/* harmony import */ var _m3d_material_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./m3d_material_manager.js */ "./03scene/m3d_material_manager.js");
/* harmony import */ var _m3d_background_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./m3d_background.js */ "./03scene/m3d_background.js");
// m3d_scene.js
// The scene object/drawable
//
// Copyright Modelo XX - 2017, All rights reserved.





/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Scene(resourceManager) {
        // private:
        this._lights = [];
        // public:
        this.models = [];
        this.terrain = null;
        this.background = new _m3d_background_js__WEBPACK_IMPORTED_MODULE_4__["default"](resourceManager);
        // FIXME: make most of them private
        //
        this.layers = []; // Layers of drawables.
        this.views = {}; // The user defined views
        this.defaultView = null; // The default view
        this.materialManager = new _m3d_material_manager_js__WEBPACK_IMPORTED_MODULE_3__["default"](resourceManager); // The matetial manager
        this.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.create(); // The current bbox of visible drawables
        this.scale = 1.0; // Half of the length of the largest bbox edge
        this.radius = 0; // The radius of bounding sphere of the scene
        this.faces = 1; // 0: this model is created in a bad way, it has broken faces (inconsistent wind order).
        // 1: each object in this model has only one face.
        // 2: each object in this model has two faces, e.g., skp models.
        // FIXME: use lights from model data.
        this._lights[0] = new _m3d_light_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.clipping = new _m3d_scene_clip_js__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        this.hasCurveOrLine = false; //Is there line info extracted from model, for rhino model
        this.hasProfileLines = false; //Is there line info extracted from model, for revit model
        this.compressed = false; // whether the scene geometry is compressed; check out comments in 
        // m3d_mesh_attributes.js.
    }
    ;
    // Do a clean exit when the scene is about to reload.
    Scene.prototype.destroy = function () {
        if (this.background) {
            this.background.destroy();
        }
        this.background = null;
        delete this.background;
        if (this.terrain) {
            this.terrain.destroy();
        }
        this.terrain = null;
        delete this.terrain;
        var i, len;
        for (i = 0, len = this.layers.length; i < len; i++) {
            this.layers[i].destroy();
        }
        this.layers = null;
        delete this.layers;
        for (i = 0, len = this.models.length; i < len; i++) {
            this.models[i].destroy();
        }
        this.models = null;
        delete this.models;
        this.materialManager.destroy();
        this.materialManager = null;
        delete this.materialManager;
        this.bbox = null;
        this._lights = null;
        this.clipping = null;
    };
    Scene.prototype.setLayerVisible = function (layerIndex, visible) {
        // Update the visibility of each drawable.
        var layer = this.layers[layerIndex];
        return layer.setVisible(visible);
    };
    Scene.prototype.setLayersVisible = function (layerIndexes, visible) {
        for (var i = 0; i < layerIndexes.length; i++) {
            var layerIndex = parseInt(layerIndexes[i]);
            var layer = this.layers[layerIndex];
            layer.setVisible(visible);
        }
        if (!this.clipping.isEnabled()) {
            // Update the bbox of the scene
            this.updateBBox();
        }
        return true;
    };
    Scene.prototype.updateBBox = function () {
        var bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray([
            Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE,
            -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE
        ]);
        // FIXME: the bbox will be infinite when neither model and terrain is
        // visible, the following camera computation will be wrong but as the
        // canvas is empty, we're good.
        if (this.models.length > 0) {
            // FIXME: on BIM product, we don't have either layer or view control so
            // that the bbox of the model never changes.
            this.models.forEach(function (model) {
                model.updateBBox();
                _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.union(bbox, bbox, model.bbox);
            });
        }
        if (this.terrain) {
            _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.union(bbox, bbox, this.terrain.bbox);
        }
        this.setBBox(bbox);
    };
    Scene.prototype.setActiveView = function (viewName) {
        if (this.views[viewName].drawables.length === 0 && this.views[viewName].layers.length === 0) {
            return;
        }
        var view = this.views[viewName];
        view.visible = true;
        var i = 0;
        var len = 0;
        if (view.drawables.length) {
            for (i = 0, len = view.drawables.length; i < len; i++) {
                view.drawables[i].visible = false;
            }
            for (i = 0, len = view.drawables.length; i < len; i++) {
                view.drawables[i].visible = true;
            }
        }
        if (!this.clipping.isEnabled()) {
            this.updateBBox();
        }
    };
    Scene.prototype.getDefaultView = function () {
        return this.defaultView.name;
    };
    // Get the layer with same name
    Scene.prototype.getLayerByName = function (layerName) {
        for (var i = 0, len = this.layers.length; i < len; i++) {
            if (this.layers[i].name === layerName) {
                return this.layers[i];
            }
        }
        return null;
    };
    Scene.prototype.setLightingIntensity = function (intensity) {
        this._lights[0].setIntensity(intensity);
    };
    Scene.prototype.setSpecularShinness = function (intensity) {
        this._lights[0].setSpecularShinness(intensity);
    };
    Scene.prototype.setLightingLatitude = function (angle) {
        this._lights[0].setLatitude(angle);
    };
    Scene.prototype.setLightingLongitude = function (angle) {
        this._lights[0].setLongitude(angle);
    };
    Scene.prototype.setMainLight = function (light) {
        this._lights[0] = light;
    };
    Scene.prototype.getMainLight = function () {
        return this._lights[0];
    };
    // Set the bbox of the scene directly
    Scene.prototype.setBBox = function (bbox) {
        this.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox);
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.expand(this.bbox);
        var size = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.size(this.bbox);
        this.scale = Math.max(size.width, Math.max(size.height, size.depth)) * 0.5;
        this.radius = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.length(this.bbox) * 0.5;
        this.clipping.initialize(this.bbox);
    };
    // Whether we need to render one face twice, for front and back faces. 
    Scene.prototype.needRenderDoubleSided = function () {
        return (this.faces < 1 || (this.faces <= 1 && this.clipping.isEnabled()));
    };
    Scene.prototype.setElementsVisibility = function (elementNames, visibility) {
        var nodes = [];
        for (var i = 0, len = elementNames.length; i < len; i++) {
            var elementName = elementNames[i];
            var element = null;
            for (var j = 0, len2 = this.models.length; j < len2; j++) {
                element = this.models[j].graph.elements[elementName];
                if (element) {
                    break;
                }
            }
            var nodes1 = element.getNodes();
            for (var j = 0, len2 = nodes1.length; j < len2; j++) {
                nodes.push(nodes1[j]);
            }
        }
        var drawables = {};
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.visible = visibility;
            if (!drawables[node.drawable.name]) {
                drawables[node.drawable.name] = node.drawable;
            }
        }
        for (var name in drawables) {
            drawables[name].updateVisibility();
        }
    };
    Scene.prototype.isElementVisible = function (elementName) {
        for (var i = 0, len = elementNames.length; i < len; i++) {
            var elementName = elementNames[i];
            var element = null;
            for (var j = 0, len2 = this.models.length; j < len2; j++) {
                element = this.models[j].graph.elements[elementName];
                if (element) {
                    var nodes1 = element.getNodes();
                    return nodes[0].visible;
                }
            }
        }
        return false;
    };
    var getElementBbox_bbox = [1e10, 1e10, 1e10, -1e10, -1e10, -1e10];
    Scene.prototype.getElementBBox = function (elementName) {
        var element = null;
        for (var j = 0, len2 = this.models.length; j < len2; j++) {
            element = this.models[j].graph.elements[elementName];
            if (element) {
                return element.bbox;
            }
        }
        return getElementBbox_bbox;
    };
    Scene.prototype.setElementsColor = function (elementNames, color) {
        // create custom material, max material count: 255
        var customMaterial = null;
        var nodes = [];
        for (var i = 0, len = elementNames.length; i < len; i++) {
            var elementName = elementNames[i];
            var element = null;
            for (var j = 0, len2 = this.models.length; j < len2; j++) {
                element = this.models[j].graph.elements[elementName];
                if (element) {
                    break;
                }
            }
            var nodes1 = element.getNodes();
            for (var j = 0, len2 = nodes1.length; j < len2; j++) {
                nodes.push(nodes1[j]);
            }
        }
        var drawables = {};
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (!drawables[node.drawable.name]) {
                drawables[node.drawable.name] = node.drawable;
            }
        }
        for (var name in drawables) {
            var drawable = drawables[name];
            // if all node has the same material, just replace the drawable's material
            if (drawable.nodes.length === 1) {
                var adhocMaterial = drawable.material.clone();
                adhocMaterial.setDiffuse(color);
                adhocMaterial.setTransparent(1.0);
                (!drawable.originalMaterial) && (drawable.originalMaterial = drawable.material);
                drawable.material = adhocMaterial;
                continue;
            }
            if (customMaterial === null) {
                var index = this.materialManager.addCustomColor(color);
                if (index > 126) {
                    console.warn("color count out of index");
                    continue;
                }
                // upload the new material texture
                this.materialManager.upload();
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    node.platteIndex = (node.platteIndex & 0x80) + index;
                }
            }
            drawable.updateColor();
        }
    };
    Scene.prototype.restoreElementsColor = function (elementNames) {
        var nodes = [];
        for (var i = 0, len = elementNames.length; i < len; i++) {
            var elementName = elementNames[i];
            var element = null;
            for (var j = 0, len2 = this.models.length; j < len2; j++) {
                element = this.models[j].graph.elements[elementName];
                if (element) {
                    break;
                }
            }
            var nodes1 = element.getNodes();
            for (var j = 0, len2 = nodes1.length; j < len2; j++) {
                nodes.push(nodes1[j]);
            }
        }
        var drawables = {};
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            node.platteIndex = (node.platteIndex & 0x80) + 127;
            if (!drawables[node.drawable.name]) {
                drawables[node.drawable.name] = node.drawable;
            }
        }
        for (var name in drawables) {
            var drawable = drawables[name];
            if (drawable.nodes.length === 1) {
                drawable.originalMaterial && (drawable.material = drawable.originalMaterial);
                continue;
            }
            drawable.updateColor();
        }
    };
    Scene.prototype.setTerrainVisibility = function (visible) {
        this.terrain.setVisibility(visible);
    };
    Scene.prototype.setElementsMaterial = function (elements, material) {
        if (material.hasTexture) {
            console.warn("can't change element material to material with textures");
            return;
        }
        // Get the material ID 
        // var materialId = this.
        // Change node's material one by one.
        var nodes = [];
        for (var i = 0, len = elements.length; i < len; i++) {
            var l = elements[i].getNodes();
            for (var j = 0, len1 = l.length; j < len1; j++) {
                var node = l[j];
                node.drawable.setNodeMaterial(node, materialId);
            }
        }
    };
    return Scene;
})());


/***/ }),

/***/ "./03scene/m3d_scene_clip.js":
/*!***********************************!*\
  !*** ./03scene/m3d_scene_clip.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../00utility/m3d_math.js */ "./00utility/m3d_math.js");
//
// m3d_scene_clip.js
// Do clipping over the scene
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function SceneClipping(scene) {
        // private:
        this._enabled = false;
        // The scene bounding box, [-x, -y, -z, +x, +y, +z] 
        this._bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray([-1, -1, -1, 1, 1, 1]);
        // The actual cliping bbox, which is aabb
        this._clip = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray([0, 0, 0, 0, 0, 0]);
        this._points = []; // 8 points of bounding in world space, which may be not axis aligned
        this._planes = []; // 6 planes of bounding in world space, which may be not axis aligned
    }
    ;
    SceneClipping.prototype.initialize = function (bbox) {
        this._bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox);
        this._bbox[0] -= 2e-5;
        this._bbox[1] -= 2e-5;
        this._bbox[2] -= 2e-5;
        this._bbox[3] += 2e-5;
        this._bbox[4] += 2e-5;
        this._bbox[5] += 2e-5;
        this.reset();
    };
    SceneClipping.prototype.reset = function () {
        this._enabled = false;
        var minClip = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.min(this._bbox);
        var maxClip = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.max(this._bbox);
        this._clip = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.create(minClip, maxClip);
        this._points = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.points(this._clip);
        this._planes = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.planes(this._clip);
    };
    // Get the center of clipping scene in the world space
    SceneClipping.prototype.getCenter = function () {
        return _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.center(this._clip);
    };
    SceneClipping.prototype.getRadius = function () {
        return _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.length(this._clip) * 0.5;
    };
    SceneClipping.prototype.get = function () {
        return this._clip;
    };
    SceneClipping.prototype.getBBox = function () {
        return this._bbox;
    };
    SceneClipping.prototype.getClippingPlanes = function (copy) {
        if (copy) {
            var planes = [];
            planes.push(vec4.clone(this._planes[0]));
            planes.push(vec4.clone(this._planes[1]));
            planes.push(vec4.clone(this._planes[2]));
            planes.push(vec4.clone(this._planes[3]));
            planes.push(vec4.clone(this._planes[4]));
            planes.push(vec4.clone(this._planes[5]));
            return planes;
        }
        else {
            return this._planes;
        }
    };
    SceneClipping.prototype.getClippingPoints = function (copy) {
        if (copy) {
            var points = [];
            points.push(vec3.clone(this._points[0]));
            points.push(vec3.clone(this._points[1]));
            points.push(vec3.clone(this._points[2]));
            points.push(vec3.clone(this._points[3]));
            points.push(vec3.clone(this._points[4]));
            points.push(vec3.clone(this._points[5]));
            points.push(vec3.clone(this._points[6]));
            points.push(vec3.clone(this._points[7]));
            return points;
        }
        else {
            return this._points;
        }
    };
    SceneClipping.prototype.getMin = function () {
        return _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.min(this._clip);
    };
    SceneClipping.prototype.getMax = function () {
        return _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.max(this._clip);
    };
    // update through 8 points 
    SceneClipping.prototype.update = function (points) {
        //copy the points to local
        for (var i = 0; i < points.length; i++) {
            vec3.copy(this._points[i], points[i]);
        }
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromPoints(this._clip, points);
        vec4.copy(this._planes[0], _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].plane.create(points[0], points[4], points[7])); // -x
        vec4.copy(this._planes[1], _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].plane.create(points[1], points[2], points[6])); //  x
        vec4.copy(this._planes[2], _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].plane.create(points[0], points[1], points[5])); // -y
        vec4.copy(this._planes[3], _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].plane.create(points[2], points[3], points[7])); //  y
        vec4.copy(this._planes[4], _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].plane.create(points[0], points[3], points[2])); // -z
        vec4.copy(this._planes[5], _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].plane.create(points[4], points[5], points[6])); //  z
    };
    SceneClipping.prototype.set = function (minClip, maxClip) {
        this._enabled = true;
        if (typeof maxClip[0] === 'number') {
            this._clip = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.create(minClip, maxClip);
            this._points = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.points(this._clip);
            this._planes = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.planes(this._clip);
        }
        else {
            this.update(maxClip);
        }
    };
    SceneClipping.prototype.isEnabled = function () {
        return this._enabled;
    };
    SceneClipping.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
    };
    return SceneClipping;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material.js":
/*!*******************************************!*\
  !*** ./03scene/materials/m3d_material.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_material_parameter.js */ "./03scene/materials/m3d_material_parameter.js");
//
// m3d_material.js
// The material base class
//
// Copyright Modelo XX - 2017, All rights reserved.
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Material(name) {
        // public:
        this.name = name; // The name of this material.
        this.transparent = false;
        this.hasMask = false; // Is this material having a alpha mask
        this.drawables = []; // The drawables that use this material
        this.hasTexture = false; // If the material contains a texture
        this.parameters = {}; // The material parameters, like ambient.
        this.reservedParameters = {}; // Reserved material
    }
    ;
    // Attach this material to the shader and associate parameters to the uniforms. 
    // If shader doesn't exist, we should pick one from the resource manager properly.
    Material.prototype.attachShader = function (shader) {
        if (!shader || !shader.ready) {
            return;
        }
        // For each uniform in the shader, connect it to its value source.
        for (var uniform in shader.userUniforms) {
            // If it is not the first time for material to attach a shader.
            // If so, just update the associated uniform.
            if (this.parameters.hasOwnProperty(uniform)) {
                continue;
            }
            this.parameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
            if (uniform.match(/uTexture\d/)) {
                this.hasTexture = true;
                var texId = parseInt(uniform.substr(8));
                if (texId > 2) {
                    console.error("can't support >3 user textures. See shader '" + shader.name + "'");
                    continue;
                }
                this.parameters[uniform].texUnit = texId;
                this.parameters[uniform].upload = this.parameters[uniform].uploadTexture;
            }
            else {
                this.parameters[uniform].upload = this.parameters[uniform].uploadValue;
            }
        }
        // Remove parameters that are no more in shader uniforms.
        var parameter;
        for (parameter in this.parameters) {
            if (!shader.userUniforms[parameter]) {
                delete this.parameters[parameter];
            }
        }
        for (parameter in this.reservedParameters) {
            if (!shader.reservedUniforms[parameter]) {
                delete this.reservedParameters[parameter];
            }
        }
        return shader;
    };
    Material.prototype.destroy = function () {
        this.parameters = null;
        this.reservedParameters = null;
        delete this.parameters;
        delete this.reservedParameters;
    };
    Material.prototype.use = function (shader) {
        var parameter;
        for (parameter in this.reservedParameters) {
            this.reservedParameters[parameter].upload(shader.reservedUniforms[parameter]);
        }
        for (parameter in this.parameters) {
            this.parameters[parameter].upload(shader.userUniforms[parameter]);
        }
    };
    // Use the value from another material
    Material.prototype.absorb = function (other) {
        // TODO: absorb all information is not needed for now
        // only masked textures is needed for alpha test
        // use materialadhoc absorb
        var parameter;
        for (parameter in this.reservedParameters) {
            this.reservedParameters[parameter].value = other.reservedParameters[parameter].value;
            this.reservedParameters[parameter].texUnit = other.reservedParameters[parameter].texUnit;
        }
        for (parameter in this.parameters) {
            this.parameters[parameter].value = other.parameters[parameter].value;
            this.parameters[parameter].texUnit = other.parameters[parameter].texUnit;
        }
    };
    return Material;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material_adhoc.js":
/*!*************************************************!*\
  !*** ./03scene/materials/m3d_material_adhoc.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_material_parameter.js */ "./03scene/materials/m3d_material_parameter.js");
//
// m3d_material_adhoc.js
// The material of adhoc one <= 0.5.6 modelo3d
//
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialAdhoc(name) {
        // Inheritance
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);
        // Private
        this._reservedParameters2 = {};
        this._materialParameters = null;
    }
    ;
    // MaterialAdhoc inherits Material
    MaterialAdhoc.prototype = Object.create(_m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);
    MaterialAdhoc.prototype.constructor = MaterialAdhoc;
    var defaultMaterialValues = [1.0, 0.0, 1.0, 0.5, 100.0, 0.0, 0, 0]; // The last two 0s are for 4-alignment.
    MaterialAdhoc.prototype.attachShader = function (shader, resourceManager) {
        if (!shader && !resourceManager) {
            return;
        }
        if (!shader) {
            var shaderType = "solid";
            shader = resourceManager.getShader(shaderType);
            if (!shader.ready) {
                var shaderSource = ShaderLibrary[shaderType];
                shader.createFromShaderSource(shaderSource, ["MODEL_TRANSFORM"]);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
        }
        if (!shader || !shader.ready) {
            return;
        }
        // Apply the base class method
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.attachShader.apply(this, arguments);
        // Default values:
        // diffuse: 255, 255, 255
        // transparent: 0.0
        // roughness: 100.0
        // metallic: 0.0 
        for (var uniform in shader.reservedUniforms) { // If it is not the first time for material to attach a shader.
            // If so, just update the associated uniform.
            if (this.reservedParameters.hasOwnProperty(uniform)) {
                continue;
            }
            if (uniform === "m_uDiffuseTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.hasTexture = true;
                this.reservedParameters[uniform].texUnit = 5;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform.indexOf("m_uMaterial") >= 0) {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
                this._materialParameters = new Float32Array(defaultMaterialValues);
                this.reservedParameters[uniform].value = this._materialParameters;
            }
        }
        return shader;
    };
    MaterialAdhoc.prototype.equal = function (parameters) {
        return (this._materialParameters[0] === parameters[0]) && (this._materialParameters[0] === parameters[0]) &&
            (this._materialParameters[2] === parameters[2]) && (this._materialParameters[3] === parameters[3]);
    };
    MaterialAdhoc.prototype.hash = function () {
        var s = "";
        var dst = this._materialParameters;
        s = s + dst[0].toString() + dst[1].toString() + dst[2].toString() + dst[3].toString();
        return s;
    };
    MaterialAdhoc.prototype.setDiffuse = function (color) {
        var dst = this._materialParameters;
        dst[0] = color[0];
        dst[1] = color[1];
        dst[2] = color[2];
    };
    MaterialAdhoc.prototype.setTransparent = function (alpha) {
        this._materialParameters[3] = alpha;
        this.transparent = (alpha < 0.99);
    };
    MaterialAdhoc.prototype.setDiffuseTexture = function (texture) {
        this.reservedParameters["m_uDiffuseTexture"].value = texture;
    };
    MaterialAdhoc.prototype.setShininess = function (shininess) {
        this._materialParameters[4] = shininess;
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.reservedParameters["m_uMaterial"].value);
        gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this._materialParameters);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    };
    MaterialAdhoc.prototype.getDiffuse = function () {
        return this._materialParameters;
    };
    MaterialAdhoc.prototype.getTransparent = function () {
        return this._materialParameters[3];
    };
    MaterialAdhoc.prototype.getShininess = function () {
        return this._materialParameters[4];
    };
    MaterialAdhoc.prototype.getDiffuseTexture = function () {
        return this.reservedParameters["m_uDiffuseTexture"].value;
    };
    // Copy special parameters from other material.
    MaterialAdhoc.prototype.absorb = function (other) {
        if (other.hasMask) {
            var dst = this.reservedParameters["m_uDiffuseTexture"];
            var src = other.reservedParameters["m_uDiffuseTexture"];
            if (dst && src) {
                dst.value = src.value;
            }
        }
        // Only when this material is transparent but transparent value is invalid,
        // we take the transparent value from others.
        if (other.transparent && (this.transparent && this.getTransparent() < 0)) {
            this.setTransparent(other.getTransparent());
        }
    };
    MaterialAdhoc.prototype.clone = function (name) {
        var ret = new MaterialAdhoc(name);
        if (this.reservedParameters) {
            for (var key in this.reservedParameters) {
                if (key.indexOf("m_uMaterial") >= 0) {
                    ret.reservedParameters[key] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    ret.reservedParameters[key].upload = this.reservedParameters[key].upload;
                    ret._materialParameters = new Float32Array(this.reservedParameters[key].value);
                    ret.reservedParameters[key].value = ret._materialParameters;
                }
                else {
                    ret[key] = this.reservedParameters[key];
                }
            }
        }
        return ret;
    };
    return MaterialAdhoc;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material_basic.js":
/*!*************************************************!*\
  !*** ./03scene/materials/m3d_material_basic.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _m3d_material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_material_parameter.js */ "./03scene/materials/m3d_material_parameter.js");
//
// m3d_material_basic.js
// The very basic material which only contains color
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialBasic(name) {
        // Inheritance
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);
        // Private
        this._reservedParameters2 = {};
        this._materialParameters = null;
    }
    ;
    // MaterialBasic inherits Material
    MaterialBasic.prototype = Object.create(_m3d_material_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
    MaterialBasic.prototype.constructor = MaterialBasic;
    var defaultMaterialValues = [1.0, 0.0, 1.0, 0.5]; // The last two 0s are for 4-alignment.
    MaterialBasic.prototype.attachShader = function (shader, resourceManager) {
        if (!shader && !resourceManager) {
            return;
        }
        if (!shader) {
            var shaderType = "constant";
            shader = resourceManager.getShader(shaderType);
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][shaderType];
                shader.createFromShaderSource(shaderSource, ["MODEL_TRANSFORM"]);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
        }
        if (!shader || !shader.ready) {
            return;
        }
        // Apply the base class method
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.attachShader.apply(this, arguments);
        // Default values:
        // diffuse: 255, 255, 255
        // transparent: 0.0
        for (var uniform in shader.reservedUniforms) { // If it is not the first time for material to attach a shader.
            // If so, just update the associated uniform.
            if (this.reservedParameters.hasOwnProperty(uniform)) {
                continue;
            }
            if (uniform.indexOf("m_uMaterial") >= 0) {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
                this._materialParameters = new Float32Array(defaultMaterialValues);
                this.reservedParameters[uniform].value = this._materialParameters;
            }
        }
        return shader;
    };
    MaterialBasic.prototype.equal = function (parameters) {
        return (this._materialParameters[0] === parameters[0]) && (this._materialParameters[0] === parameters[0]) &&
            (this._materialParameters[2] === parameters[2]) && (this._materialParameters[3] === parameters[3]);
    };
    MaterialBasic.prototype.hash = function () {
        var s = "";
        var dst = this._materialParameters;
        s = s + dst[0].toString() + dst[1].toString() + dst[2].toString() + dst[3].toString();
        return s;
    };
    MaterialBasic.prototype.setColor = function (color) {
        var dst = this._materialParameters;
        dst[0] = color[0];
        dst[1] = color[1];
        dst[2] = color[2];
    };
    MaterialBasic.prototype.setTransparent = function (alpha) {
        this._materialParameters[3] = alpha;
        this.transparent = (alpha < 0.99);
    };
    MaterialBasic.prototype.getColor = function () {
        return this._materialParameters;
    };
    MaterialBasic.prototype.getTransparent = function () {
        return this._materialParameters[3];
    };
    // Copy special parameters from other material.
    MaterialBasic.prototype.absorb = function (other) {
        if (other.transparent) {
            this.setTransparent(other.getTransparent());
        }
    };
    return MaterialBasic;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material_blit.js":
/*!************************************************!*\
  !*** ./03scene/materials/m3d_material_blit.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_material_parameter.js */ "./03scene/materials/m3d_material_parameter.js");
/* harmony import */ var _m3d_material_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m3d_material.js */ "./03scene/materials/m3d_material.js");
//
// m3d_material_blit.js
// The material of blit
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialBlit(name) {
        // Inheritance
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_2__["default"].apply(this, arguments);
    }
    ;
    // MaterialAdhoc inherits Material
    MaterialBlit.prototype = Object.create(_m3d_material_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
    MaterialBlit.prototype.constructor = MaterialBlit;
    MaterialBlit.prototype.attachShader = function (shader) {
        if (!shader || !shader.ready) {
            return;
        }
        // Apply the base class method
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.attachShader.apply(this, arguments);
        for (var uniform in shader.reservedUniforms) {
            // If it is not the first time for material to attach a shader.
            // If so, just update the associated uniform.
            if (this.reservedParameters.hasOwnProperty(uniform)) {
                continue;
            }
            if (uniform === "m_uBlitTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.hasTexture = true;
                this.reservedParameters[uniform].texUnit = 4;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform === "m_uBlitDepthTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.hasTexture = true;
                this.reservedParameters[uniform].texUnit = 6;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform === "m_uInvResolution") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
                this.reservedParameters[uniform].value = [1.0 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, 1.0 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height];
            }
        }
    };
    MaterialBlit.prototype.setTexture = function (texture) {
        this.reservedParameters["m_uBlitTexture"].value = texture;
    };
    MaterialBlit.prototype.setDepthTexture = function (texture) {
        this.reservedParameters["m_uBlitDepthTexture"].value = texture;
    };
    MaterialBlit.prototype.setInvResolution = function (value) {
        if (this.reservedParameters["m_uInvResolution"]) {
            this.reservedParameters["m_uInvResolution"].value = value;
        }
    };
    return MaterialBlit;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material_parameter.js":
/*!*****************************************************!*\
  !*** ./03scene/materials/m3d_material_parameter.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_material.js
// The material base class
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialParameter() {
        this.upload = null;
        this.value = null;
        this.texUnit = -1; // only valid when value is a texture
    }
    ;
    MaterialParameter.prototype.uploadTexture = function (uniform) {
        // FIXME: this is a hotfix for value undefined
        if (this.value) {
            this.value.use(this.texUnit);
        }
        uniform && uniform.upload(this.texUnit);
    };
    MaterialParameter.prototype.uploadValue = function (uniform) {
        uniform.upload(this.value);
    };
    return MaterialParameter;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material_skybox.js":
/*!**************************************************!*\
  !*** ./03scene/materials/m3d_material_skybox.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_material_parameter.js */ "./03scene/materials/m3d_material_parameter.js");
//
// m3d_material_skybox.js
// The material of skybox
//
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialSkybox(name) {
        // Inheritance
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);
    }
    ;
    // MaterialSkybox inherits Material
    MaterialSkybox.prototype = Object.create(_m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);
    MaterialSkybox.prototype.constructor = MaterialSkybox;
    MaterialSkybox.prototype.attachShader = function (shader) {
        if (!shader || !shader.ready) {
            return;
        }
        // For each uniform in the shader, connect it to its value source.
        for (var uniform in shader.reservedUniforms) {
            // If it is not the first time for material to attach a shader.
            // If so, just update the associated uniform.
            if (this.reservedParameters.hasOwnProperty(uniform)) {
                continue;
            }
            if (uniform === "m_uSkyTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.hasTexture = true;
                this.reservedParameters[uniform].texUnit = 4;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            if (uniform === "m_uTransparency") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].value = 1.0;
                this.reservedParameters[uniform].upload = function UploadScalars(uniform) {
                    if (uniform) {
                        uniform.upload(this.value);
                    }
                };
            }
        }
        // Remove parameters that are no more in shader uniforms.
        for (var parameter in this.reservedParameters) {
            if (!shader.reservedUniforms[parameter]) {
                delete this.reservedParameters[parameter];
            }
        }
    };
    MaterialSkybox.prototype.setTexture = function (texture) {
        this.reservedParameters["m_uSkyTexture"].value = texture;
    };
    MaterialSkybox.prototype.texture = function () {
        return this.reservedParameters["m_uSkyTexture"].value;
    };
    MaterialSkybox.prototype.setTransparency = function (value) {
        this.reservedParameters["m_uTransparency"].value = value;
    };
    return MaterialSkybox;
})());


/***/ }),

/***/ "./03scene/materials/m3d_material_volume.js":
/*!**************************************************!*\
  !*** ./03scene/materials/m3d_material_volume.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_material_parameter.js */ "./03scene/materials/m3d_material_parameter.js");
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
//
// m3d_material_adhoc.js
// The material of adhoc one <= 0.5.6 modelo3d
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MaterialVolume(name) {
        // Inheritance
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);
        // Private
        this._reservedParameters2 = {};
        this._materialParameters = null;
    }
    ;
    // MaterialVolume inherits Material
    MaterialVolume.prototype = Object.create(_m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);
    MaterialVolume.prototype.constructor = MaterialVolume;
    var defaultMaterialValues = [1.0, 0.0, 1.0, 0.5, 100.0, 0.0, 0, 0]; // The last two 0s are for 4-alignment.
    MaterialVolume.prototype.attachShader = function (shader, resourceManager) {
        if (!shader && !resourceManager) {
            return;
        }
        if (!shader) {
            var shaderType = "solid";
            shader = resourceManager.getShader(shaderType);
            if (!shader.ready) {
                var shaderSource = ShaderLibrary[shaderType];
                shader.createFromShaderSource(shaderSource, ["MODEL_TRANSFORM"]);
                if (!shader.ready) {
                    throw ("modelo3d error at creating shader '" + shaderType + "'!");
                }
            }
        }
        if (!shader || !shader.ready) {
            return;
        }
        // Apply the base class method
        _m3d_material_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.attachShader.apply(this, arguments);
        // Default values:
        // diffuse: 255, 255, 255
        // transparent: 0.0
        // roughness: 100.0
        // metallic: 0.0 
        for (var uniform in shader.reservedUniforms) { // If it is not the first time for material to attach a shader.
            // If so, just update the associated uniform.
            if (this.reservedParameters.hasOwnProperty(uniform)) {
                continue;
            }
            if (uniform === "m_uDiffuseTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.hasTexture = true;
                this.reservedParameters[uniform].texUnit = 5;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform.indexOf("m_uMaterial") >= 0) {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
                this._materialParameters = new Float32Array(defaultMaterialValues);
                this.reservedParameters[uniform].value = this._materialParameters;
            }
            else if (uniform.indexOf("m_uScale") >= 0) {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
                this._scaleParameters = new Float32Array([1.0, 1.0, 1.0]);
                this.reservedParameters[uniform].value = this._scaleParameters;
            }
            else if (uniform === "m_uToneTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].texUnit = 6;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform === "m_uCubeTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].texUnit = 8;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform === "m_uPositionTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].texUnit = 9;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
            else if (uniform === "m_uInvResolution") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
                this.reservedParameters[uniform].value = [1.0 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_2__["default"].width, 1.0 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_2__["default"].height];
            }
            else if (uniform === "m_uAlphaCorrection") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
            }
            else if (uniform === "m_uIntensityAsAlpha") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
            }
            else if (uniform === "m_uBlendWithBackground") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
            }
            else if (uniform === "m_uInvTransform") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadValue;
            }
            else if (uniform === "m_uBackgroundTexture") {
                this.reservedParameters[uniform] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                this.reservedParameters[uniform].texUnit = 10;
                this.reservedParameters[uniform].upload = this.reservedParameters[uniform].uploadTexture;
            }
        }
        return shader;
    };
    MaterialVolume.prototype.equal = function (parameters) {
        return (this._materialParameters[0] === parameters[0]) && (this._materialParameters[0] === parameters[0]) &&
            (this._materialParameters[2] === parameters[2]) && (this._materialParameters[3] === parameters[3]);
    };
    MaterialVolume.prototype.hash = function () {
        var s = "";
        var dst = this._materialParameters;
        s = s + dst[0].toString() + dst[1].toString() + dst[2].toString() + dst[3].toString();
        return s;
    };
    MaterialVolume.prototype.setDiffuse = function (color) {
        var dst = this._materialParameters;
        dst[0] = color[0];
        dst[1] = color[1];
        dst[2] = color[2];
    };
    MaterialVolume.prototype.setScale = function (scale) {
        this._scaleParameters[0] = scale[0];
        this._scaleParameters[1] = scale[1];
        this._scaleParameters[2] = scale[2];
    };
    MaterialVolume.prototype.setTransparent = function (alpha) {
        this._materialParameters[3] = alpha;
        this.transparent = (alpha < 0.99);
    };
    MaterialVolume.prototype.setDiffuseTexture = function (texture) {
        this.reservedParameters["m_uDiffuseTexture"].value = texture;
    };
    MaterialVolume.prototype.setToneTexture = function (texture) {
        if (this.reservedParameters["m_uToneTexture"]) {
            this.reservedParameters["m_uToneTexture"].value = texture;
        }
    };
    MaterialVolume.prototype.setCubeTexture = function (texture) {
        if (this.reservedParameters["m_uCubeTexture"]) {
            this.reservedParameters["m_uCubeTexture"].value = texture;
        }
    };
    MaterialVolume.prototype.setPositionTexture = function (texture) {
        if (this.reservedParameters["m_uPositionTexture"]) {
            this.reservedParameters["m_uPositionTexture"].value = texture;
        }
    };
    MaterialVolume.prototype.setBackgroundImage = function (texture) {
        if (this.reservedParameters["m_uBackgroundTexture"]) {
            this.reservedParameters["m_uBackgroundTexture"].value = texture;
        }
    };
    MaterialVolume.prototype.setAlphaCorrection = function (value) {
        if (this.reservedParameters["m_uAlphaCorrection"]) {
            this.reservedParameters["m_uAlphaCorrection"].value = value;
        }
    };
    MaterialVolume.prototype.setIntensityAsAlpha = function (value) {
        if (this.reservedParameters["m_uIntensityAsAlpha"]) {
            this.reservedParameters["m_uIntensityAsAlpha"].value = value;
        }
    };
    MaterialVolume.prototype.setBlendWithBackground = function (enable) {
        if (this.reservedParameters["m_uBlendWithBackground"]) {
            this.reservedParameters["m_uBlendWithBackground"].value = enable;
        }
    };
    MaterialVolume.prototype.setInvTransform = function (value) {
        if (this.reservedParameters["m_uInvTransform"]) {
            this.reservedParameters["m_uInvTransform"].value = value;
        }
    };
    MaterialVolume.prototype.setShininess = function (shininess) {
        this._materialParameters[4] = shininess;
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.reservedParameters["m_uMaterial"].value);
        gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this._materialParameters);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    };
    MaterialVolume.prototype.getDiffuse = function () {
        return this._materialParameters;
    };
    MaterialVolume.prototype.getTransparent = function () {
        return this._materialParameters[3];
    };
    MaterialVolume.prototype.getShininess = function () {
        return this._materialParameters[4];
    };
    MaterialVolume.prototype.getDiffuseTexture = function () {
        return this.reservedParameters["m_uDiffuseTexture"].value;
    };
    // Copy special parameters from other material.
    MaterialVolume.prototype.absorb = function (other) {
        if (other.hasMask) {
            var dst = this.reservedParameters["m_uDiffuseTexture"];
            var src = other.reservedParameters["m_uDiffuseTexture"];
            if (dst && src) {
                dst.value = src.value;
            }
        }
        // Only when this material is transparent but transparent value is invalid,
        // we take the transparent value from others.
        if (other.transparent && (this.transparent && this.getTransparent() < 0)) {
            this.setTransparent(other.getTransparent());
        }
    };
    MaterialVolume.prototype.clone = function (name) {
        var ret = new MaterialVolume(name);
        if (this.reservedParameters) {
            for (var key in this.reservedParameters) {
                if (key.indexOf("m_uMaterial") >= 0) {
                    ret.reservedParameters[key] = new _m3d_material_parameter_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    ret.reservedParameters[key].upload = this.reservedParameters[key].upload;
                    ret._materialParameters = new Float32Array(this.reservedParameters[key].value);
                    ret.reservedParameters[key].value = ret._materialParameters;
                }
                else {
                    ret[key] = this.reservedParameters[key];
                }
            }
        }
        return ret;
    };
    return MaterialVolume;
})());


/***/ }),

/***/ "./03scene/terrain/m3d_terrain.js":
/*!****************************************!*\
  !*** ./03scene/terrain/m3d_terrain.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
// m3d_terrain.js
// The terrain object, loaded from .mt file.
//
// Copyright Modelo XX - 2018, All rights reserved.
//
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Terrain(levels, bbox) {
        // private:
        this._levels = new Array(levels);
        this._rotation = 0.0; // The transform angle
        this._scaling = 1.0; // Ditto
        this._translation = [0, 0, 0]; // Ditto.
        this._matrix = mat4.create(); // The transform matrix.
        this._originalBBox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox); // The original bbox of the terrain model.
        this._visible = true;
        // public:
        this.tiles = []; // The current visible tiles
        this.drawables = []; // The aggregation of drawables of tiles.
        this.source = "";
        this.id = "";
        this.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox); // The current bbox of the terrain (after transformed)
    }
    ;
    Terrain.prototype.destroy = function () {
        for (var i = 0, len = this._levels.length; i < len; ++i) {
            if (this._levels[i]) {
                this._levels[i].destroy();
            }
        }
        this._levels = null;
        delete this._levels;
        this._matrix = null;
        delete this._matrix;
        this._translation = null;
        delete this._translation;
        this._scaling = null;
        delete this._scaling;
        this._rotation = null;
        delete this._rotation;
        this.bbox = null;
        delete this.bbox;
        this._originalBBox = null;
        delete this._originalBBox;
        this.tiles = null;
        delete this.tiles;
        this.drawables = null;
        delete this.drawables;
        this._visible = null;
        delete this._visible;
    };
    // Add level of tiles to this terrain object.
    Terrain.prototype.setLevel = function (level) {
        if (level.index < this._levels.length) {
            this._levels[level.index] = level;
        }
    };
    Terrain.prototype._applyTransform = function () {
        var cx = (this._originalBBox[3] + this._originalBBox[0]) * 0.5;
        var cy = (this._originalBBox[4] + this._originalBBox[1]) * 0.5;
        var cz = (this._originalBBox[5] + this._originalBBox[2]) * 0.5;
        // Accumulate the scaling and rotation at the center of bbox of the terrain.
        this._matrix[12] = -cx * this._scaling;
        this._matrix[13] = -cy * this._scaling;
        this._matrix[14] = -cz * this._scaling;
        this._matrix[0] = this._scaling;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[4] = 0;
        this._matrix[5] = this._scaling;
        this._matrix[6] = 0;
        this._matrix[8] = 0;
        this._matrix[9] = 0;
        this._matrix[10] = this._scaling;
        mat4.rotateZ(this._matrix, this._matrix, this._rotation);
        this._matrix[12] += cx + this._translation[0];
        this._matrix[13] += cy + this._translation[1];
        this._matrix[14] += cz + this._translation[2];
    };
    Terrain.prototype.translate = function (x, y, z) {
        this._translation[0] += x;
        this._translation[1] += y;
        this._translation[2] += z;
        this._applyTransform();
        for (var i = 0, count = this.tiles.length; i < count; i++) {
            this.tiles[i].setTransform(this._matrix);
        }
        // Update the terrain bbox
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.transform(this.bbox, this._originalBBox, this._matrix);
    };
    Terrain.prototype.setTranslation = function (x, y, z) {
        this._translation[0] = x;
        this._translation[1] = y;
        this._translation[2] = z;
        this._applyTransform();
        for (var i = 0, count = this.tiles.length; i < count; i++) {
            this.tiles[i].setTransform(this._matrix);
        }
        // Update the terrain bbox
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.transform(this.bbox, this._originalBBox, this._matrix);
        console.log([x, y, z]);
    };
    Terrain.prototype.setRotation = function (angle) {
        // Avoid overflow
        if (angle < -1e7) {
            angle = -1e7;
        }
        if (angle > 1e7) {
            angle = 1e7;
        }
        angle = angle * 0.0174532925199432957; // PI / 180
        this._rotation = angle;
        this._applyTransform();
        for (var i = 0, count = this.tiles.length; i < count; i++) {
            this.tiles[i].setTransform(this._matrix);
        }
        // Update the terrain bbox
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.transform(this.bbox, this._originalBBox, this._matrix);
    };
    Terrain.prototype.setScaling = function (s) {
        if (s < 0) {
            s = 1e-5;
        }
        this._scaling = s;
        this._applyTransform();
        for (var i = 0, count = this.tiles.length; i < count; i++) {
            this.tiles[i].setTransform(this._matrix);
        }
        // Update the terrain bbox
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.transform(this.bbox, this._originalBBox, this._matrix);
    };
    Terrain.prototype.getScaling = function () {
        return this._scaling;
    };
    Terrain.prototype.getRotation = function () {
        return this._rotation * 57.29577951308232087;
    };
    Terrain.prototype.getTranslation = function () {
        return this._translation;
    };
    // Prepare to render this level. 
    // FIXME: for the first iteration of modelo3d terrain rendering, we only support
    // render one and only one entire level. There is no dynamic LOD support.
    Terrain.prototype.useLevel = function (levelIndex) {
        this._currentLevel = levelIndex;
        this.tiles = [];
        this.drawables = [];
        var level = this._levels[levelIndex];
        var size = (1 << levelIndex);
        var count = size * size;
        for (var i = 0; i < count; i++) {
            var tile = level.tiles[i];
            if (tile) {
                tile.setTransform(this._matrix);
                this.tiles.push(tile);
                this.drawables.push(tile.drawable);
            }
        }
    };
    Terrain.prototype.levels = function () {
        return this._levels.length;
    };
    Terrain.prototype.setVisibility = function (visible) {
        if (this._visible === visible) {
            return;
        }
        this._visible = visible;
        for (var i = 0, len = this.tiles.length; i < len; i++) {
            this.tiles[i].drawable.visible = visible;
        }
    };
    return Terrain;
})());


/***/ }),

/***/ "./03scene/terrain/m3d_terrain_level.js":
/*!**********************************************!*\
  !*** ./03scene/terrain/m3d_terrain_level.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// m3d_terrain_level.js
// The terrain object, loaded from .mt file.
//
// Copyright Modelo XX - 2018, All rights reserved.
//
//
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function TerrainLevel(level) {
        this.index = level;
        this.size = (1 << level);
        this.tiles = Array(this.size * this.size);
    }
    ;
    TerrainLevel.prototype.destroy = function () {
        var count = this.size * this.size;
        for (var i = 0; i < this.size * this.size; ++i) {
            if (this.tiles[i]) {
                this.tiles[i].destroy();
            }
        }
        this.tiles = null;
        delete this.tiles;
        this.index = null;
        delete this.index;
        this.size = null;
        delete this.size;
    };
    TerrainLevel.prototype.addTile = function (tile) {
        var index = tile.y * this.size + tile.x;
        this.tiles[index] = tile;
    };
    return TerrainLevel;
})());


/***/ }),

/***/ "./03scene/terrain/m3d_terrain_tile.js":
/*!*********************************************!*\
  !*** ./03scene/terrain/m3d_terrain_tile.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
// m3d_terrain_tile.js
// The terrain tile.
//
// Copyright Modelo XX - 2018, All rights reserved.
//
//

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function TerrainTile(x, y, drawable, bbox) {
        this.x = x;
        this.y = y;
        this.level = null;
        this.drawable = drawable;
        this.originalBBox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.createFromArray(bbox); // The original bbox of this tile.
    }
    ;
    TerrainTile.prototype.destroy = function () {
        this.x = null;
        delete this.x;
        this.y = null;
        delete this.y;
        this.level = null;
        delete this.level;
        this.drawable.destroy();
        this.drawable = null;
        delete this.drawable;
        this.originalBBox = null;
        delete this.originalBBox;
    };
    TerrainTile.prototype.setTransform = function (matrix) {
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.transform(this.drawable.bbox, this.originalBBox, matrix);
        this.drawable.bsphere = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].sphere.createFromAABB(this.drawable.bbox);
        this.drawable.transform.set(matrix);
    };
    return TerrainTile;
})());


/***/ }),

/***/ "./04renderer/m3d_blit.js":
/*!********************************!*\
  !*** ./04renderer/m3d_blit.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_materials_m3d_material_blit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../03scene/materials/m3d_material_blit.js */ "./03scene/materials/m3d_material_blit.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
//
// m3d_blit.js
// A 2D image processing pass
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Blit(resourceManager, shaderSource, mobile) {
        // private
        this._material = null;
        this._shader = null;
        // initialization:
        if (!shaderSource) {
            shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["blit"];
        }
        this._shader = resourceManager.getShader(shaderSource.name);
        if (!this._shader.ready) {
            this._shader.createFromShaderSource(shaderSource, mobile ? ["MOBILE"] : []);
        }
        this.ready = this._shader.ready;
        if (this.ready) {
            this._material = new _03scene_materials_m3d_material_blit_js__WEBPACK_IMPORTED_MODULE_0__["default"](shaderSource.name);
            this._material.attachShader(this._shader);
        }
    }
    ;
    Blit.prototype.destroy = function () {
        if (this.ready) {
            this._material.destroy();
            this._shader.destroy();
            this.ready = false;
        }
    };
    Blit.prototype.setTexture = function (texture) {
        this._material.setTexture(texture);
    };
    Blit.prototype.setDepthTexture = function (texture) {
        this._material.setDepthTexture(texture);
    };
    Blit.prototype.setParameter = function (parameter, value) {
        this._material.parameters[parameter].value = value;
    };
    /**
     * @param {object} renderer - render class.
     * @param {object} renderTarget - render target.
     * @param {boolean} blend - is blend.
     * @param {boolean} onlyValidPixels - is only render to valid pixels.
     * @return {null} -return nothing
     */
    Blit.prototype.render = function (renderer, renderTarget, blend, onlyValidPixels) {
        // FIXME: we touch many render state's private members.
        if (this.ready && renderTarget.ready) {
            var oldDepthMask = renderTarget._options.depthMask;
            renderTarget._options.depthMask = false;
            var depthFunc = onlyValidPixels ? gl.GREATER : gl.ALWAYS;
            var oldDepthFunc = renderTarget._options.depthFunc;
            renderTarget._options.depthFunc = depthFunc;
            var oldBlend = renderTarget._options.blend;
            renderTarget._options.blend = blend || false;
            var invResolution = [
                1.0 / renderTarget.getWidth(),
                1.0 / renderTarget.getHeight()
            ];
            this._material.setInvResolution(invResolution);
            // Render a screen quad
            renderer.drawScreen(renderTarget, this._shader, this._material);
            renderTarget._options.depthMask = oldDepthMask;
            renderTarget._options.depthFunc = oldDepthFunc;
            renderTarget._options.blend = oldBlend;
            renderer.renderState.blend(renderTarget._options.blend);
            renderer.renderState.depthTest(renderTarget._options.depthTest, renderTarget._options.clearDepth, renderTarget._options.depthFunc);
            renderer.renderState.depthMask(renderTarget._options.depthMask);
            // FIXME: unbind textures otherwise it will cause later rendering collides with the binding
            // here, i.e., rendering the texture to the same texture.
            var parameters = this._material.parameters;
            for (var parameter in parameters) {
                if (parameters[parameter].texUnit >= 0) {
                    gl.activeTexture(gl.TEXTURE0 + parameters[parameter].texUnit);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
            }
        }
    };
    return Blit;
})());


/***/ }),

/***/ "./04renderer/m3d_samples.js":
/*!***********************************!*\
  !*** ./04renderer/m3d_samples.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// m3d_samples.js
// Poisson disk sampling pattern (normalized to [-1, 1])
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var SAMPLES = {};
    SAMPLES._2X2 = [
        6 / 16, 2 / 16,
        14 / 16, 6 / 16,
        2 / 16, 10 / 16,
        10 / 16, 14 / 16
    ];
    SAMPLES._4X2 = [
        9 / 16, 5 / 16,
        7 / 16, 11 / 16,
        13 / 16, 9 / 16,
        5 / 16, 3 / 16,
        3 / 16, 13 / 16,
        1 / 16, 7 / 16,
        11 / 16, 15 / 16,
        15 / 16, 1 / 16
    ];
    SAMPLES._4X4 = [
        9 / 16, 9 / 16,
        2 / 16, 12 / 16,
        12 / 16, 7 / 16,
        8 / 16, 1 / 16,
        13 / 16, 11 / 16,
        1 / 16, 0 / 16,
        11 / 16, 3 / 16,
        5 / 16, 10 / 16,
        6 / 16, 14 / 16,
        4 / 16, 2 / 16,
        0 / 16, 8 / 16,
        14 / 16, 15 / 16,
        3 / 16, 6 / 16,
        15 / 16, 4 / 16,
        7 / 16, 5 / 16,
        10 / 16, 13 / 16
    ];
    SAMPLES._4x4_2D = [
        0.524814, 0.56488,
        0.74661, 0.664308,
        0.694092, 0.462367,
        0.623577, 0.267783,
        0.340815, 0.790118,
        0.247202, 0.532242,
        0.36916, 0.311385,
        0.825046, 0.312099,
        0.72246, 0.905,
        0.27684, 0.092381,
        0.72246, 0.905,
        0.943712, 0.7082,
        0.019365, 0.400172,
        0.03138, 0.65182,
        0.995488, 0.433175,
        0.637063, 0.021535,
        0.412268, 0.984494,
    ];
    //poisson disk pattern from center to edge
    SAMPLES._8x8_2D = [
        0.501506, 0.536596,
        0.479138, 0.43034,
        0.397053, 0.487056,
        0.591406, 0.449082,
        0.497369, 0.644404,
        0.381063, 0.588818,
        0.636382, 0.583616,
        0.52319, 0.33336,
        0.37642, 0.379573,
        0.713274, 0.461703,
        0.283159, 0.497054,
        0.590899, 0.697271,
        0.670374, 0.344963,
        0.385952, 0.705203,
        0.424452, 0.277044,
        0.764748, 0.543555,
        0.603993, 0.250593,
        0.494041, 0.772178,
        0.258782, 0.641709,
        0.246434, 0.369532,
        0.755129, 0.628899,
        0.309775, 0.274196,
        0.706395, 0.722131,
        0.512554, 0.195892,
        0.790205, 0.3784,
        0.61636, 0.797562,
        0.29905, 0.751101,
        0.174923, 0.45043,
        0.698505, 0.236127,
        0.381569, 0.18237,
        0.161473, 0.556691,
        0.848478, 0.467565,
        0.555191, 0.851308,
        0.378558, 0.839659,
        0.791231, 0.280491,
        0.8164, 0.702177,
        0.875051, 0.595993,
        0.645256, 0.140087,
        0.187367, 0.259117,
        0.48844, 0.895837,
        0.7087, 0.838936,
        0.194892, 0.757962,
        0.126029, 0.354896,
        0.25983, 0.168335,
        0.447763, 0.0934675,
        0.266928, 0.837262,
        0.551968, 0.0880472,
        0.118845, 0.673752,
        0.76843, 0.163361,
        0.062746, 0.469565,
        0.62316, 0.924319,
        0.916225, 0.344364,
        0.330463, 0.0834606,
        0.819568, 0.817768,
        0.050363, 0.590149,
        0.912991, 0.727568,
        0.87403, 0.207755,
        0.97926, 0.489109,
        0.400768, 0.969595,
        0.289428, 0.936614,
        0.030082, 0.356932,
        0.514659, 0.992979,
        0.177672, 0.877666,
        0.632581, 0.0178981
    ];
    // 64 samples evenly distributed on a unit sphere
    SAMPLES._8x8_3D = [
        0.936780, 0.207818, -0.281522,
        0.155734, -0.528496, -0.834529,
        0.318403, 0.287368, 0.903349,
        0.217197, -0.610563, 0.761602,
        0.439011, 0.210822, 0.873397,
        0.977207, 0.053257, 0.205501,
        0.641795, 0.546048, 0.538453,
        0.348168, -0.458926, -0.817414,
        0.170284, -0.774256, -0.609534,
        0.160135, 0.980561, 0.113387,
        0.106271, 0.295349, 0.949461,
        -0.914237, -0.074791, 0.398217,
        -0.779510, -0.543208, -0.311912,
        0.027064, -0.908468, 0.417077,
        -0.101380, -0.994828, 0.006289,
        -0.883905, -0.028965, -0.466769,
        0.895093, -0.435134, 0.097299,
        0.188100, 0.388757, -0.901935,
        0.865264, 0.331237, 0.376298,
        -0.208541, 0.948524, -0.238356,
        0.061496, 0.888755, 0.454239,
        -0.572418, 0.589289, 0.570154,
        -0.605071, -0.187697, -0.773731,
        -0.888205, 0.306047, 0.342678,
        0.772958, -0.048692, 0.632586,
        -0.119578, 0.653396, 0.747513,
        -0.669006, 0.120272, 0.733461,
        -0.299117, -0.139439, 0.943973,
        0.435083, 0.612268, -0.660175,
        -0.646608, -0.352291, 0.676601,
        0.823632, -0.163268, -0.543115,
        -0.443489, -0.863253, 0.241063,
        0.514024, -0.264126, 0.816098,
        -0.909153, 0.333005, -0.250099,
        0.960448, -0.226223, -0.162368,
        0.805614, 0.592417, 0.005408,
        0.082866, -0.252741, 0.963979,
        -0.979375, -0.166776, -0.114065,
        0.405677, -0.833005, 0.376204,
        -0.832468, 0.551533, 0.052997,
        -0.066544, -0.159122, -0.985014,
        0.658670, -0.609037, -0.441846,
        -0.099674, -0.912569, -0.396589,
        -0.603554, 0.671968, -0.429164,
        0.323987, 0.045308, -0.944976,
        -0.315941, 0.138344, -0.938638,
        0.554968, 0.829633, -0.060986,
        -0.244659, 0.560061, -0.791501,
        0.379228, 0.719356, 0.581991,
        0.699318, -0.522353, 0.487956,
        -0.879993, -0.450901, 0.149331,
        0.621998, -0.062407, -0.780528,
        -0.513325, 0.858183, -0.004391,
        -0.612452, -0.645248, 0.456681,
        0.350088, -0.913147, -0.208811,
        -0.494057, -0.596705, -0.632338,
        -0.238260, -0.632492, 0.737011,
        0.729728, 0.460782, -0.505151,
        0.625231, -0.779835, 0.030709,
        -0.377751, 0.867056, 0.324836,
        -0.035872, 0.799911, -0.599045,
        0.263772, 0.905962, -0.331144,
        -0.517616, -0.829878, -0.208271,
        -0.640118, 0.321235, -0.697894
    ];
    /*
    SAMPLES_8x8_2D_LIST[0] = [
            0.493002,0.486801,
            0.517631,0.49452,
            0.497573,0.519301,
            0.47017,0.490718,
            0.511466,0.4697,
            0.526276,0.520274,
            0.471387,0.530187,
            0.542578,0.50116,
            0.487701,0.456834,
            0.540647,0.471123,
            0.523813,0.548331,
            0.444787,0.505885,
            0.461328,0.459459,
            0.497033,0.556115,
            0.520243,0.445633,
            0.554511,0.529321
    ];

    SAMPLES_8x8_2D_LIST[1] = [
            0.440597,0.474633,
            0.443318,0.532877,
            0.566766,0.49582,
            0.477209,0.56345,
            0.549282,0.553361,
            0.453171,0.557524,
            0.468181,0.432018,
            0.499088,0.424571,
            0.56906,0.462608,
            0.552033,0.435232,
            0.417077,0.491924,
            0.438394,0.442296,
            0.514164,0.583738,
            0.417382,0.524049,
            0.528412,0.418238,
            0.582878,0.526221
    ];
    
    SAMPLES_8x8_2D_LIST[2] = [
            0.541444,0.576698,
            0.588513,0.478049,
            0.462541,0.583936,
            0.423962,0.554538,
            0.487695,0.59293,
            0.594247,0.50027,
            0.414221,0.459072,
            0.573266,0.564402,
            0.477741,0.403847,
            0.581069,0.437238,
            0.437362,0.584065,
            0.443534,0.411584,
            0.513325,0.393123,
            0.392311,0.511699,
            0.598893,0.453631,
            0.533052,0.604971
    ];
    
    SAMPLES_8x8_2D_LIST[3] = [
            0.391593,0.47875,
            0.603223,0.544705,
            0.613862,0.514299,
            0.550603,0.396992,
            0.558118,0.599456,
            0.577322,0.412749,
            0.615316,0.47971,
            0.409486,0.424231,
            0.455824,0.612518,
            0.511037,0.620712,
            0.389734,0.550991,
            0.485582,0.378429,
            0.409218,0.582198,
            0.387134,0.448654,
            0.482433,0.622848,
            0.454253,0.381341
    ];
    
    SAMPLES_8x8_2D_LIST[4] = [
            0.602417,0.578125,
            0.367012,0.494274,
            0.607932,0.421473,
            0.622268,0.557984,
            0.366414,0.52638,
            0.423299,0.612849,
            0.588241,0.604784,
            0.625988,0.445897,
            0.366742,0.467507,
            0.567014,0.620135,
            0.416165,0.390893,
            0.538328,0.367547,
            0.578662,0.386221,
            0.507664,0.361429,
            0.637588,0.532581,
            0.546172,0.634001
    ];
    
    SAMPLES_8x8_2D_LIST[5] = [
            0.638081,0.467756,
            0.642136,0.498921,
            0.377421,0.42447,
            0.38405,0.585397,
            0.599298,0.395209,
            0.493348,0.647948,
            0.465372,0.644731,
            0.567722,0.365646,
            0.429045,0.366967,
            0.476757,0.350707,
            0.628903,0.581293,
            0.394156,0.6111,
            0.357094,0.443951,
            0.382438,0.400671,
            0.345792,0.506603,
            0.520097,0.653526
    ];
    
    SAMPLES_8x8_2D_LIST[6] = [
            0.44882,0.353719,
            0.437084,0.641879,
            0.364159,0.576683,
            0.354188,0.555578,
            0.657622,0.473652,
            0.528709,0.342622,
            0.580491,0.638351,
            0.647397,0.562943,
            0.640331,0.416711,
            0.624401,0.606969,
            0.622597,0.390465,
            0.337522,0.474707,
            0.336486,0.532838,
            0.386071,0.377335,
            0.600914,0.365808,
            0.504087,0.331666
    ];
    
    SAMPLES_8x8_2D_LIST[7] = [
            0.659112,0.44476,
            0.54189,0.663288,
            0.403648,0.360701,
            0.669866,0.492255,
            0.664566,0.544444,
            0.405,0.642657,
            0.671948,0.517534,
            0.609283,0.63404,
            0.503145,0.673026,
            0.557222,0.336199,
            0.478761,0.67282,
            0.349421,0.412028,
            0.360544,0.607739,
            0.332783,0.440933,
            0.451845,0.67084,
            0.453736,0.328177
    ];
    
    SAMPLES_8x8_2D_LIST[8] = [
            0.585568,0.342818,
            0.653955,0.591478,
            0.569593,0.665038,
            0.320989,0.5083,
            0.423388,0.337956,
            0.376412,0.632496,
            0.326422,0.557978,
            0.480042,0.316523,
            0.683006,0.4676,
            0.423931,0.669785,
            0.334108,0.584909,
            0.64996,0.387168,
            0.532383,0.314804,
            0.355285,0.377955,
            0.676104,0.569736,
            0.525011,0.687942
    ];
    
    SAMPLES_8x8_2D_LIST[9] = [
            0.630597,0.360715,
            0.600653,0.662873,
            0.308846,0.484612,
            0.551176,0.685044,
            0.637153,0.634604,
            0.374814,0.352677,
            0.673364,0.413197,
            0.393926,0.33597,
            0.695986,0.491705,
            0.691524,0.542835,
            0.504377,0.301997,
            0.496853,0.698433,
            0.305147,0.538327,
            0.659276,0.619164,
            0.305873,0.454,
            0.397663,0.671537
    ];
    
    SAMPLES_8x8_2D_LIST[10] = [
            0.31662,0.41976,
            0.692691,0.442336,
            0.375842,0.65839,
            0.467191,0.698789,
            0.43162,0.309398,
            0.585988,0.316368,
            0.614387,0.332212,
            0.704992,0.515086,
            0.56233,0.304051,
            0.459011,0.297898,
            0.628815,0.661383,
            0.438369,0.697227,
            0.324687,0.389574,
            0.328127,0.616852,
            0.34764,0.641768,
            0.591669,0.687124
    ];
    
    SAMPLES_8x8_2D_LIST[11] = [
            0.291791,0.509104,
            0.685101,0.597556,
            0.302885,0.571442,
            0.656992,0.3608,
            0.571913,0.697725,
            0.401942,0.312944,
            0.524385,0.288245,
            0.676221,0.379144,
            0.350045,0.346621,
            0.544422,0.289153,
            0.408408,0.695221,
            0.546651,0.711447,
            0.482961,0.282773,
            0.282667,0.481633,
            0.708345,0.569404,
            0.716877,0.465044
    ];
    
    SAMPLES_8x8_2D_LIST[12] = [
            0.647757,0.336342,
            0.3022,0.598612,
            0.695526,0.395646,
            0.660453,0.653386,
            0.706796,0.418337,
            0.368004,0.320321,
            0.720536,0.538062,
            0.326018,0.359122,
            0.519535,0.723139,
            0.288058,0.427136,
            0.439477,0.283956,
            0.484636,0.724215,
            0.353635,0.671127,
            0.276447,0.531407,
            0.617361,0.693701,
            0.726515,0.49183
    ];
    
    SAMPLES_8x8_2D_LIST[13] = [
            0.375434,0.690199,
            0.27953,0.556232,
            0.295699,0.399071,
            0.507631,0.271419,
            0.689145,0.629563,
            0.61127,0.29889,
            0.721874,0.439958,
            0.413033,0.285971,
            0.58721,0.285722,
            0.452515,0.726796,
            0.272784,0.454346,
            0.733201,0.512943,
            0.570054,0.724189,
            0.300552,0.624104,
            0.562927,0.273328,
            0.421356,0.721754
    ];
    
    SAMPLES_8x8_2D_LIST[14] = [
            0.639322,0.309216,
            0.647077,0.685241,
            0.680762,0.347395,
            0.59554,0.718471,
            0.298769,0.371559,
            0.715452,0.603145,
            0.329308,0.667431,
            0.31247,0.648561,
            0.460041,0.263547,
            0.383813,0.289921,
            0.536302,0.262209,
            0.259259,0.50971,
            0.704131,0.36953,
            0.33141,0.325248,
            0.272367,0.585768,
            0.391673,0.718085
    ];
    
    SAMPLES_8x8_2D_LIST[15] = [
            0.256644,0.478791,
            0.50012,0.745114,
            0.686111,0.65981,
            0.732712,0.580175,
            0.722162,0.392877,
            0.740357,0.556476,
            0.745871,0.472954,
            0.428806,0.261886,
            0.260205,0.565767,
            0.66884,0.317224,
            0.260294,0.432371,
            0.550919,0.74382,
            0.266726,0.406224,
            0.737961,0.417903,
            0.750071,0.529848,
            0.716358,0.629058
    ];
    
    SAMPLES_8x8_2D_LIST[16] = [
            0.33928,0.695229,
            0.638112,0.712018,
            0.488806,0.246868,
            0.674339,0.684024,
            0.250413,0.544403,
            0.274134,0.615524,
            0.299969,0.343713,
            0.274191,0.383022,
            0.634276,0.283516,
            0.51588,0.245712,
            0.74948,0.445643,
            0.363215,0.716361,
            0.472688,0.754675,
            0.52377,0.755562,
            0.350918,0.29107,
            0.450363,0.752485
    ];
    
    SAMPLES_8x8_2D_LIST[17] = [
            0.584329,0.256387,
            0.70954,0.65356,
            0.429073,0.750638,
            0.282384,0.643708,
            0.61328,0.264978,
            0.621544,0.730935,
            0.58151,0.748324,
            0.761845,0.497807,
            0.398313,0.258283,
            0.695564,0.325224,
            0.558301,0.243221,
            0.745064,0.60029,
            0.402402,0.746931,
            0.371053,0.267369,
            0.442703,0.239853,
            0.233476,0.493687
    ];
    
    SAMPLES_8x8_2D_LIST[18] = [
            0.71525,0.342489,
            0.236612,0.45581,
            0.663291,0.712391,
            0.323342,0.298266,
            0.271044,0.359731,
            0.241715,0.575356,
            0.303346,0.683958,
            0.664113,0.286057,
            0.605904,0.748974,
            0.758572,0.580232,
            0.741367,0.622748,
            0.300283,0.315309,
            0.498255,0.772275,
            0.463024,0.230151,
            0.285508,0.668188,
            0.735861,0.362923
    ];
    
    SAMPLES_8x8_2D_LIST[19] = [
            0.704184,0.681136,
            0.751007,0.392113,
            0.535716,0.229081,
            0.239342,0.417493,
            0.374986,0.743259,
            0.227731,0.526242,
            0.732377,0.645819,
            0.418962,0.237728,
            0.773289,0.467479,
            0.774102,0.524898,
            0.544226,0.771948,
            0.244555,0.603759,
            0.772006,0.553198,
            0.692866,0.299961,
            0.355175,0.738888,
            0.337744,0.727623
    ];
    
    SAMPLES_8x8_2D_LIST[20] = [
            0.245365,0.3836,
            0.315807,0.711326,
            0.509239,0.219738,
            0.646543,0.739104,
            0.577364,0.230104,
            0.646103,0.260159,
            0.568025,0.774109,
            0.272694,0.331655,
            0.6921,0.70802,
            0.771168,0.416035,
            0.602336,0.234717,
            0.7784,0.442128,
            0.446117,0.779436,
            0.220878,0.555604,
            0.249042,0.635562,
            0.262732,0.660185
    ];
    
    SAMPLES_8x8_2D_LIST[21] = [
            0.52159,0.785571,
            0.47376,0.78558,
            0.485403,0.213472,
            0.348271,0.255744,
            0.3266,0.269582,
            0.720459,0.312928,
            0.733364,0.670722,
            0.373663,0.239235,
            0.209213,0.509333,
            0.20941,0.480873,
            0.217048,0.431084,
            0.79151,0.508772,
            0.596423,0.775838,
            0.780758,0.582345,
            0.762692,0.37028,
            0.300964,0.284937
    ];
    
    SAMPLES_8x8_2D_LIST[22] = [
            0.411423,0.780135,
            0.629486,0.23614,
            0.77143,0.613525,
            0.398064,0.223771,
            0.380678,0.76959,
            0.7559,0.647383,
            0.245192,0.350135,
            0.557616,0.209085,
            0.432278,0.210636,
            0.693016,0.273914,
            0.215251,0.588435,
            0.79799,0.485433,
            0.460651,0.203994,
            0.678213,0.74011,
            0.628159,0.770872,
            0.275469,0.301408
    ];
    
    SAMPLES_8x8_2D_LIST[23] = [
            0.266956,0.689506,
            0.79901,0.535262,
            0.677257,0.255747,
            0.748091,0.327474,
            0.528207,0.199031,
            0.289355,0.717441,
            0.762002,0.347863,
            0.200527,0.453596,
            0.345832,0.76156,
            0.316214,0.741888,
            0.727601,0.701242,
            0.78235,0.386604,
            0.5871,0.207718,
            0.548598,0.80116,
            0.495155,0.805089,
            0.211769,0.399047
    ];
    
    SAMPLES_8x8_2D_LIST[24] = [
            0.218503,0.619349,
            0.802886,0.458129,
            0.657606,0.762749,
            0.706549,0.726332,
            0.717353,0.283256,
            0.241555,0.666734,
            0.221496,0.3687,
            0.80106,0.564994,
            0.198714,0.564718,
            0.800919,0.430101,
            0.65757,0.234243,
            0.247871,0.320305,
            0.192153,0.535676,
            0.501696,0.189693,
            0.349533,0.228184,
            0.30416,0.257253
    ];
    
    SAMPLES_8x8_2D_LIST[25] = [
            0.521778,0.81141,
            0.579278,0.802274,
            0.615562,0.209009,
            0.477699,0.186828,
            0.18505,0.5011,
            0.779898,0.6477,
            0.801501,0.596407,
            0.46069,0.814627,
            0.219073,0.647427,
            0.429593,0.809659,
            0.762105,0.679813,
            0.803721,0.403292,
            0.321911,0.235358,
            0.745214,0.295757,
            0.189593,0.425557,
            0.181232,0.474341
    ];
    
    SAMPLES_8x8_2D_LIST[26] = [
            0.359761,0.787986,
            0.39962,0.195662,
            0.278286,0.268112,
            0.787964,0.358517,
            0.82126,0.510058,
            0.368259,0.206617,
            0.383036,0.799967,
            0.609241,0.802958,
            0.545002,0.181037,
            0.188256,0.584556,
            0.252781,0.290328,
            0.704267,0.75222,
            0.641798,0.207892,
            0.452704,0.177806,
            0.293694,0.752608,
            0.216153,0.339211
    ];
    
    SAMPLES_8x8_2D_LIST[27] = [
            0.40307,0.811568,
            0.423379,0.1828,
            0.653647,0.788287,
            0.255304,0.71773,
            0.802555,0.625475,
            0.190464,0.607655,
            0.685934,0.229353,
            0.60036,0.186585,
            0.825932,0.546393,
            0.234784,0.695064,
            0.571946,0.178489,
            0.272132,0.73828,
            0.713511,0.248087,
            0.518274,0.169491,
            0.783755,0.32954,
            0.733449,0.734711
    ];
    
    SAMPLES_8x8_2D_LIST[28] = [
            0.217984,0.673376,
            0.314698,0.775173,
            0.68246,0.777299,
            0.737578,0.268132,
            0.168228,0.517101,
            0.173555,0.563864,
            0.757954,0.710064,
            0.483733,0.83277,
            0.666227,0.210449,
            0.19326,0.368023,
            0.829349,0.444458,
            0.833366,0.476055,
            0.226339,0.30748,
            0.825019,0.420478,
            0.5628,0.82869,
            0.535595,0.832763
    ];
    
    SAMPLES_8x8_2D_LIST[29] = [
            0.825297,0.579186,
            0.508898,0.835732,
            0.191722,0.634666,
            0.334202,0.206074,
            0.29008,0.235269,
            0.790609,0.672866,
            0.775506,0.302999,
            0.177645,0.395444,
            0.164333,0.449937,
            0.485432,0.160707,
            0.815554,0.374131,
            0.334102,0.796813,
            0.806047,0.651859,
            0.589989,0.829597,
            0.638048,0.812594,
            0.25099,0.263361
    ];
    
    SAMPLES_8x8_2D_LIST[30] = [
            0.376569,0.179232,
            0.844723,0.525474,
            0.437283,0.840719,
            0.162882,0.419591,
            0.829028,0.609033,
            0.356614,0.815721,
            0.627003,0.177287,
            0.266884,0.243224,
            0.728107,0.761458,
            0.19386,0.663474,
            0.165299,0.592106,
            0.431819,0.158926,
            0.709417,0.777983,
            0.543792,0.154583,
            0.154409,0.543982,
            0.764472,0.273159
    ];
    
    SAMPLES_8x8_2D_LIST[31] = [
            0.15175,0.486199,
            0.270031,0.762613,
            0.410111,0.8374,
            0.614824,0.830192,
            0.228409,0.279665,
            0.834994,0.398576,
            0.708348,0.217873,
            0.19997,0.317554,
            0.400318,0.162786,
            0.814374,0.341994,
            0.760052,0.737035,
            0.464603,0.850867,
            0.846469,0.566524,
            0.147241,0.516898,
            0.686755,0.199882,
            0.597925,0.160265
    ];
    
    SAMPLES_8x8_2D_LIST[32] = [
            0.203573,0.693157,
            0.247356,0.748088,
            0.286838,0.782884,
            0.379829,0.833338,
            0.854486,0.50195,
            0.672079,0.809989,
            0.792459,0.700755,
            0.222653,0.72327,
            0.748273,0.244531,
            0.660309,0.181712,
            0.164132,0.61955,
            0.298891,0.205627,
            0.572366,0.15078,
            0.458816,0.14514,
            0.854198,0.546879,
            0.347871,0.176678
    ];
    
    SAMPLES_8x8_2D_LIST[33] = [
            0.549839,0.854457,
            0.510305,0.141934,
            0.179936,0.338459,
            0.148184,0.571932,
            0.781512,0.724994,
            0.832224,0.640334,
            0.492347,0.860736,
            0.858655,0.451848,
            0.20373,0.291993,
            0.818411,0.675262,
            0.855236,0.421851,
            0.852784,0.590099,
            0.319608,0.183568,
            0.574987,0.856693,
            0.811726,0.309172,
            0.228105,0.255324
    ];
    
    SAMPLES_8x8_2D_LIST[34] = [
            0.166351,0.650264,
            0.524704,0.865321,
            0.754473,0.763823,
            0.157961,0.367941,
            0.304938,0.811133,
            0.242918,0.237065,
            0.794675,0.279606,
            0.847091,0.376458,
            0.705337,0.805944,
            0.414656,0.141069,
            0.735297,0.214444,
            0.371658,0.152826,
            0.144641,0.396417,
            0.263793,0.214777,
            0.603038,0.855858,
            0.136573,0.426333
    ];
    
    SAMPLES_8x8_2D_LIST[35] = [
            0.733998,0.788127,
            0.437436,0.134098,
            0.870619,0.478128,
            0.530301,0.129312,
            0.631308,0.848043,
            0.128026,0.504936,
            0.328656,0.830198,
            0.445004,0.868011,
            0.129922,0.456351,
            0.352571,0.842344,
            0.843416,0.354344,
            0.87254,0.53039,
            0.481956,0.126451,
            0.127383,0.533368,
            0.712068,0.191707,
            0.779222,0.250648
    ];
    
    SAMPLES_8x8_2D_LIST[36] = [
            0.659361,0.838968,
            0.390207,0.858358,
            0.172028,0.682199,
            0.557061,0.128736,
            0.253243,0.783657,
            0.617913,0.142526,
            0.13652,0.598129,
            0.206059,0.263924,
            0.18708,0.71215,
            0.859135,0.61817,
            0.64711,0.151473,
            0.415272,0.86902,
            0.689668,0.172085,
            0.783624,0.751483,
            0.275295,0.805747,
            0.202972,0.736851
    ];
    
    SAMPLES_8x8_2D_LIST[37] = [
            0.22426,0.761555,
            0.174683,0.302933,
            0.874952,0.565841,
            0.84468,0.662586,
            0.8663,0.392602,
            0.587847,0.127828,
            0.151841,0.341499,
            0.122606,0.564507,
            0.140098,0.632624,
            0.842202,0.326028,
            0.346866,0.147963,
            0.82511,0.706411,
            0.766765,0.222206,
            0.503231,0.885703,
            0.184926,0.276941,
            0.886271,0.502536
    ];
       
    SAMPLES_8x8_2D_LIST[38] = [
            0.690875,0.836077,
            0.295507,0.171867,
            0.672524,0.153507,
            0.809012,0.734013,
            0.392126,0.127525,
            0.555872,0.88375,
            0.472133,0.887247,
            0.1561,0.319503,
            0.886809,0.45874,
            0.269415,0.186374,
            0.363594,0.864605,
            0.110424,0.483041,
            0.842809,0.685928,
            0.320015,0.153918,
            0.884582,0.434182,
            0.232926,0.214793
    ];
    
    SAMPLES_8x8_2D_LIST[39] = [
            0.879265,0.596079,
            0.506614,0.10878,
            0.212594,0.234069,
            0.452837,0.111228,
            0.421383,0.116245,
            0.589046,0.882777,
            0.866245,0.643849,
            0.826764,0.280202,
            0.808866,0.255668,
            0.780716,0.777086,
            0.537226,0.106874,
            0.894879,0.524272,
            0.736813,0.817456,
            0.104142,0.514964,
            0.280981,0.830352,
            0.132137,0.352
    ];
    
    SAMPLES_8x8_2D_LIST[40] = [
            0.713209,0.165463,
            0.436777,0.891701,
            0.13956,0.666753,
            0.762634,0.79812,
            0.735634,0.179981,
            0.619285,0.879811,
            0.648005,0.869602,
            0.104036,0.542591,
            0.196379,0.757723,
            0.122297,0.373247,
            0.887789,0.408365,
            0.844908,0.299004,
            0.33286,0.862829,
            0.362392,0.124664,
            0.106383,0.429246,
            0.112633,0.400134
    ];
    
    SAMPLES_8x8_2D_LIST[41] = [
            0.117059,0.615759,
            0.528794,0.899049,
            0.639013,0.124742,
            0.876102,0.362938,
            0.718392,0.835477,
            0.867037,0.339115,
            0.563804,0.103546,
            0.898843,0.547472,
            0.3834,0.884443,
            0.796886,0.228821,
            0.760409,0.193127,
            0.0998801,0.454679,
            0.300941,0.850968,
            0.172819,0.737439,
            0.151243,0.704664,
            0.678751,0.862926
    ];
    
    SAMPLES_8x8_2D_LIST[42] = [
            0.182132,0.24921,
            0.226343,0.798666,
            0.238643,0.18999,
            0.161824,0.274694,
            0.250345,0.821149,
            0.103256,0.589981,
            0.477937,0.0935999,
            0.61158,0.107717,
            0.907925,0.480511,
            0.334782,0.126026,
            0.869519,0.675222,
            0.272559,0.159927,
            0.129593,0.325423,
            0.698449,0.140616,
            0.407997,0.900178,
            0.586444,0.0985024
    ];
    
    SAMPLES_8x8_2D_LIST[43] = [
            0.502027,0.910935,
            0.856601,0.705112,
            0.808904,0.771767,
            0.201443,0.783477,
            0.894019,0.620575,
            0.841916,0.730374,
            0.455161,0.909893,
            0.671157,0.124361,
            0.57593,0.906511,
            0.905331,0.582491,
            0.520116,0.0867869,
            0.139503,0.296852,
            0.111432,0.642527,
            0.787765,0.201764,
            0.430813,0.0912759,
            0.911784,0.449799
    ];
    
    SAMPLES_8x8_2D_LIST[44] = [
            0.897583,0.38155,
            0.836801,0.257114,
            0.190868,0.221274,
            0.404969,0.0947297,
            0.0883849,0.562076,
            0.830257,0.754337,
            0.873378,0.314149,
            0.91696,0.515985,
            0.759679,0.827539,
            0.289452,0.137792,
            0.912041,0.423606,
            0.208029,0.198103,
            0.30958,0.125339,
            0.375901,0.0979476,
            0.246575,0.163998,
            0.79498,0.80039
    ];
    
    SAMPLES_8x8_2D_LIST[45] = [
            0.730763,0.147829,
            0.866252,0.292254,
            0.664477,0.88767,
            0.0788692,0.497779,
            0.552597,0.91787,
            0.0796058,0.53012,
            0.479254,0.921094,
            0.826613,0.233361,
            0.543639,0.0804713,
            0.634661,0.100051,
            0.176064,0.770668,
            0.122243,0.68908,
            0.893917,0.653124,
            0.106811,0.344191,
            0.756886,0.163867,
            0.713485,0.865393
    ];
    
    SAMPLES_8x8_2D_LIST[46] = [
            0.348028,0.895502,
            0.26573,0.853283,
            0.0771156,0.466818,
            0.603563,0.911785,
            0.657238,0.104924,
            0.922476,0.552329,
            0.430751,0.920223,
            0.452191,0.0766352,
            0.781052,0.82047,
            0.498151,0.07361,
            0.0896271,0.617331,
            0.894504,0.336168,
            0.638779,0.904022,
            0.106699,0.66736,
            0.311134,0.883928,
            0.380049,0.911382
    ];
    
    SAMPLES_8x8_2D_LIST[47] = [
            0.152499,0.248326,
            0.139926,0.73385,
            0.0813911,0.404371,
            0.347233,0.0986426,
            0.746517,0.851909,
            0.862961,0.269982,
            0.137376,0.268915,
            0.0749707,0.433983,
            0.918067,0.398295,
            0.569769,0.075096,
            0.154414,0.757662,
            0.527953,0.93033,
            0.0885764,0.370085,
            0.816686,0.206572,
            0.199453,0.810781,
            0.782749,0.172711
    ];
    
    SAMPLES_8x8_2D_LIST[48] = [
            0.165945,0.224188,
            0.895693,0.678851,
            0.884546,0.701821,
            0.321542,0.104029,
            0.910528,0.356532,
            0.691544,0.890581,
            0.597643,0.0753978,
            0.258226,0.137521,
            0.718473,0.122302,
            0.238353,0.849421,
            0.117715,0.712578,
            0.872795,0.729283,
            0.21493,0.83209,
            0.455032,0.935548,
            0.475946,0.0625291,
            0.405674,0.928659
    ];
    
    SAMPLES_8x8_2D_LIST[49] = [
            0.104461,0.309384,
            0.925587,0.60948,
            0.503489,0.939506,
            0.938565,0.532281,
            0.0686215,0.585615,
            0.519611,0.060501,
            0.27852,0.880143,
            0.857928,0.755999,
            0.938825,0.465037,
            0.839038,0.781055,
            0.624581,0.0767404,
            0.389868,0.072713,
            0.754398,0.138956,
            0.806366,0.181491,
            0.937516,0.437563,
            0.941841,0.48989
    ];
    
    SAMPLES_8x8_2D_LIST[50] = [
            0.888588,0.289405,
            0.214556,0.162526,
            0.699995,0.105707,
            0.57717,0.935345,
            0.175489,0.800865,
            0.0601722,0.549563,
            0.858102,0.239296,
            0.175839,0.197864,
            0.92055,0.640798,
            0.937124,0.579388,
            0.822206,0.805953,
            0.936789,0.414562,
            0.778886,0.846988,
            0.113366,0.278236,
            0.422742,0.0607227,
            0.651227,0.0801234
    ];
    
    SAMPLES_8x8_2D_LIST[51] = [
            0.319786,0.908476,
            0.946468,0.511178,
            0.622866,0.929595,
            0.90564,0.311004,
            0.669286,0.914595,
            0.269757,0.115749,
            0.93067,0.374732,
            0.359033,0.926101,
            0.804486,0.830417,
            0.0508575,0.51398,
            0.548562,0.053175,
            0.231698,0.13938,
            0.845312,0.211983,
            0.479402,0.949391,
            0.0504708,0.479114,
            0.681691,0.0882069
    ];
    
    SAMPLES_8x8_2D_LIST[52] = [
            0.0758992,0.651118,
            0.777536,0.144804,
            0.141149,0.226638,
            0.294839,0.0980907,
            0.0641588,0.617033,
            0.918107,0.669858,
            0.741996,0.119065,
            0.0802298,0.334007,
            0.0897778,0.690234,
            0.14958,0.786994,
            0.950801,0.553186,
            0.0492097,0.446053,
            0.551795,0.951046,
            0.0611621,0.380825,
            0.127948,0.761662,
            0.356784,0.0675809
    ];
    
    SAMPLES_8x8_2D_LIST[53] = [
            0.183772,0.172068,
            0.121628,0.246028,
            0.721014,0.899229,
            0.324671,0.078506,
            0.380282,0.940579,
            0.747116,0.884046,
            0.42959,0.95177,
            0.925332,0.33157,
            0.599945,0.946854,
            0.455578,0.0442123,
            0.913091,0.698236,
            0.400491,0.0522961,
            0.108648,0.739875,
            0.243211,0.880814,
            0.336418,0.929797,
            0.897121,0.267985
    ];
    
    SAMPLES_8x8_2D_LIST[54] = [
            0.948665,0.39396,
            0.578792,0.0456171,
            0.147028,0.202336,
            0.903451,0.724546,
            0.524736,0.961459,
            0.525056,0.0383165,
            0.456663,0.96047,
            0.612306,0.0513213,
            0.832972,0.178549,
            0.289285,0.912536,
            0.216002,0.866309,
            0.960781,0.449629,
            0.402875,0.953413,
            0.177768,0.833843,
            0.0907663,0.719001,
            0.0451626,0.406845
    ];
    
    SAMPLES_8x8_2D_LIST[55] = [
            0.867722,0.783935,
            0.807066,0.151291,
            0.648716,0.940221,
            0.729155,0.0956793,
            0.499827,0.964973,
            0.698621,0.920646,
            0.940785,0.350871,
            0.0357627,0.538427,
            0.965006,0.528496,
            0.889532,0.755852,
            0.776994,0.874907,
            0.891021,0.245359,
            0.0577259,0.350734,
            0.492728,0.0332514,
            0.947811,0.632497,
            0.955766,0.602609
    ];
    
    SAMPLES_8x8_2D_LIST[56] = [
            0.76855,0.11743,
            0.669255,0.0642839,
            0.850032,0.810325,
            0.0370044,0.567673,
            0.0736649,0.305746,
            0.193578,0.854566,
            0.260819,0.903394,
            0.917923,0.28605,
            0.237576,0.110257,
            0.0830186,0.28319,
            0.963672,0.421902,
            0.377144,0.045692,
            0.0388548,0.598486,
            0.858887,0.193646,
            0.187792,0.145963,
            0.624404,0.955398
    ];
    
    SAMPLES_8x8_2D_LIST[57] = [
            0.309916,0.932266,
            0.94341,0.66275,
            0.262643,0.0913742,
            0.805185,0.861032,
            0.0271026,0.491944,
            0.967515,0.574379,
            0.973545,0.502711,
            0.0933674,0.257088,
            0.973469,0.474941,
            0.933845,0.30829,
            0.151342,0.821732,
            0.880419,0.21616,
            0.0435109,0.630238,
            0.152275,0.176029,
            0.120344,0.213909,
            0.936367,0.688654
    ];
    
    SAMPLES_8x8_2D_LIST[58] = [
            0.646156,0.0474278,
            0.832514,0.840292,
            0.791604,0.123722,
            0.119668,0.787216,
            0.57785,0.970733,
            0.0587975,0.681724,
            0.20635,0.12334,
            0.477246,0.977215,
            0.680009,0.943833,
            0.281045,0.073872,
            0.330998,0.0512246,
            0.976994,0.549539,
            0.0251224,0.431386,
            0.549932,0.0227185,
            0.353837,0.957134,
            0.433189,0.0246682
    ];
    
    SAMPLES_8x8_2D_LIST[59] = [
            0.715908,0.0712645,
            0.758766,0.0944816,
            0.404016,0.028234,
            0.13196,0.811293,
            0.0194563,0.461488,
            0.017938,0.517654,
            0.520253,0.0179154,
            0.303561,0.058558,
            0.0348199,0.368986,
            0.965185,0.366369,
            0.38264,0.969614,
            0.750493,0.914637,
            0.0507064,0.318795,
            0.695359,0.0563879,
            0.0946243,0.766308,
            0.892495,0.785347
    ];
    
    SAMPLES_8x8_2D_LIST[60] = [
            0.0404536,0.657443,
            0.726507,0.930168,
            0.0968447,0.228196,
            0.974983,0.395716,
            0.0631134,0.713652,
            0.411595,0.978238,
            0.443981,0.983123,
            0.600664,0.0241162,
            0.545022,0.984765,
            0.921677,0.743496,
            0.0778177,0.742741,
            0.626913,0.0295149,
            0.461681,0.0129651,
            0.985681,0.445422,
            0.938483,0.715936,
            0.776824,0.903945
    ];
    
    SAMPLES_8x8_2D_LIST[61] = [
            0.157626,0.149564,
            0.508517,0.990252,
            0.926317,0.257643,
            0.674537,0.0417185,
            0.837425,0.144103,
            0.608024,0.97857,
            0.575266,0.015071,
            0.214012,0.899351,
            0.122915,0.185015,
            0.010992,0.548131,
            0.959571,0.325759,
            0.320927,0.957758,
            0.262437,0.930833,
            0.860349,0.835046,
            0.6645,0.963758,
            0.235957,0.915562
    ];
    
    SAMPLES_8x8_2D_LIST[62] = [
            0.861876,0.166085,
            0.88094,0.187951,
            0.191329,0.883969,
            0.976557,0.625425,
            0.968341,0.655452,
            0.169757,0.866751,
            0.984558,0.594919,
            0.88213,0.812711,
            0.349114,0.0296754,
            0.0142217,0.408466,
            0.814601,0.118461,
            0.237709,0.0805622,
            0.748192,0.0706716,
            0.948102,0.2873,
            0.376645,0.0195097,
            0.70779,0.950671
    ];
    
    SAMPLES_8x8_2D_LIST[63] = [
            0.915978,0.771631,
            0.829924,0.871475,
            0.996125,0.528919,
            0.0158802,0.614086,
            0.640164,0.977304,
            0.0632511,0.260507,
            0.288586,0.951228,
            0.569351,0.993794,
            0.0967406,0.793309,
            0.0147537,0.383559,
            0.0075025,0.580886,
            0.961553,0.690164,
            0.0281882,0.336457,
            0.0741242,0.239106,
            0.146788,0.853595,
            0.791192,0.093543
    ];
    */
    // It provides 64 groups of 2D samples. 
    // Each group has 8 sample evenly randomly 
    // distributed on a normalized vector. 
    // Furthermore, the 64 vectors are uniformly 
    // randomly placed in a normalized semi-disc. 
    // To make programming easy, 
    // we regroup 4 groups into 1 large group, 
    // but in total we still have 16x4x8 samples.
    // TODO: a more sophisticated implementation would be
    // to use parameter to control sample generation
    // SAMPLES._16x4x8_2D_LIST = [];
    // (function() {
    //     function halton(base, idx)
    //     {
    //         var val = 0;
    //         var step = 1.0 / base;
    //         for ( var j = idx; j > 0; j = Math.floor(j / base) ) {
    //             val += step * (j % base);
    //             step /= base;
    //         }
    //         return val;
    //     }
    //     for (var i = 0; i < 16; ++i) {
    //         SAMPLES._16x4x8_2D_LIST[i] = [];
    //         for(var m = 0; m < 4; m++) {   
    //             // halton sequence value
    //             var a = halton(2, i*4+m ) * Math.PI;
    //             var offset = halton(3, i*4+m);
    //             var baseX = Math.cos(a);
    //             var baseY = Math.sin(a);
    //             for (var j = 0; j < 8; ++j) {
    //                 var randScale = Math.random() * 0.125;
    //                 var scaler = (j + offset + randScale) / 8.0; // with random jitter
    //                 SAMPLES._16x4x8_2D_LIST[i][(j + m * 8) * 2] = baseX * scaler;
    //                 SAMPLES._16x4x8_2D_LIST[i][(j + m * 8) * 2 + 1] = baseY * scaler;
    //             }
    //         }
    //     }
    // })();
    SAMPLES._8x8_2D_LIST = [];
    (function () {
        function halton(base, idx) {
            var val = 0;
            var step = 1.0 / base;
            for (var j = idx; j > 0; j = Math.floor(j / base)) {
                val += step * (j % base);
                step /= base;
            }
            return val;
        }
        for (var i = 0; i < 64; ++i) {
            // halton sequence value
            var a = halton(2, i) * Math.PI;
            var offset = halton(3, i);
            SAMPLES._8x8_2D_LIST[i] = [];
            var baseX = Math.cos(a);
            var baseY = Math.sin(a);
            for (var j = 0; j < 8; ++j) {
                var randScale = Math.random() * 0.125;
                var scaler = (j + offset + randScale) / 8.0; // with random jitter
                SAMPLES._8x8_2D_LIST[i][j * 2] = baseX * scaler;
                SAMPLES._8x8_2D_LIST[i][j * 2 + 1] = baseY * scaler;
            }
        }
    })();
    return SAMPLES;
})());


/***/ }),

/***/ "./04renderer/pipeline/RenderPass.ts":
/*!*******************************************!*\
  !*** ./04renderer/pipeline/RenderPass.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RenderQueueManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderQueueManager */ "./04renderer/pipeline/RenderQueueManager.ts");
// RenderPass.js
// A render pass contains a render target, a render queue 
// and a few overrided parameters, e.g., material
//
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.

var RenderPass = /** @class */ (function () {
    function RenderPass(resourceManager, needSort, selector) {
        this.queue = _RenderQueueManager__WEBPACK_IMPORTED_MODULE_0__["default"].getQueue(selector);
        this._resourceManager = resourceManager;
        this._overridedMaterial = null;
        this._overridedShaders = [null, null, null];
        this._needSort = needSort;
        this._cullFace = gl.CCW;
    }
    ;
    RenderPass.prototype.destroy = function () {
        this._overridedShaders = null;
        delete this._overridedShaders;
        this._overridedMaterial = null;
        delete this._overridedMaterial;
    };
    RenderPass.prototype.setCullFace = function (cullFace) {
        this._cullFace = cullFace;
    };
    RenderPass.prototype.getCullFace = function () {
        return this._cullFace;
    };
    RenderPass.prototype.render = function (renderTarget, renderer, camera, shadow, clipping, lights) {
        if (this.queue.isValid()) {
            if (this._needSort) {
                this.queue.sort(camera);
            }
            var blend = false;
            // FIXME: temporary change the blending state of the render target when
            // the override material is transparent. However, we don't do the sorting.
            if (this._overridedMaterial !== null && this._overridedMaterial.transparent) {
                var originalBlend = renderTarget.getOption("blend");
                renderTarget.setOption("blend", true);
                renderTarget.always = true;
            }
            renderer.drawDrawables(renderTarget, this.queue.drawables, camera, this._overridedShaders, this._overridedMaterial, clipping, lights, shadow, null, this._cullFace);
            if (this._overridedMaterial !== null && this._overridedMaterial.transparent) {
                renderTarget.setOption("blend", originalBlend);
                renderTarget.always = false;
            }
        }
    };
    RenderPass.prototype.setOverridedMaterial = function (material) {
        this._overridedMaterial = material;
        if (this._overridedMaterial) {
            if (this._overridedShaders[0]) {
                this._overridedMaterial.attachShader(this._overridedShaders[0]);
            }
        }
    };
    RenderPass.prototype.setOverridedShader = function (shader) {
        this._overridedShaders[0] = shader;
        if (this._overridedMaterial && this._overridedShaders[0]) {
            this._overridedMaterial.attachShader(this._overridedShaders[0]);
        }
        if (shader) {
            var flags1 = shader.flags.concat("MODEL_TRANSFORM");
            var shader1 = this._resourceManager.getShader(shader.shaderSource.name, flags1);
            if (!shader1.ready) {
                shader1.createFromShaderSource(shader.shaderSource, flags1);
            }
            this._overridedShaders[1] = shader1;
            var flags2 = flags1.concat("INSTANCING");
            var shader2 = this._resourceManager.getShader(shader.shaderSource.name, flags2);
            if (!shader2.ready) {
                shader2.createFromShaderSource(shader.shaderSource, flags2);
            }
            this._overridedShaders[2] = shader2;
        }
    };
    RenderPass.prototype.recompileOverridedShader = function (flag, enabled) {
        // Update overrided shaders with new flags.
        for (var i = 0; i < this._overridedShaders.length; i++) {
            var shader = this._overridedShaders[i];
            var pos = shader.flags.lastIndexOf(flag);
            var flags = void 0;
            var needUpdate = false;
            if (enabled) {
                if (pos === -1) {
                    flags = shader.flags.concat(flag);
                    needUpdate = true;
                }
            }
            else {
                if (pos !== -1) {
                    flags = shader.flags.slice(0);
                    flags.splice(pos, 1);
                    needUpdate = true;
                }
            }
            if (needUpdate) {
                var shaderType = shader.shaderSource.name;
                var newShader = this._resourceManager.getShader(shaderType, flags);
                if (!newShader.ready) {
                    newShader.createFromShaderSource(shader.shaderSource, flags);
                    if (!newShader.ready) {
                        throw new Error("Failed to create shader '" + shaderType + "'!");
                    }
                }
                this._overridedShaders[i] = newShader;
            }
        }
        // No need to compile the shaders of drawables as they 
        // are managed by scene.
    };
    return RenderPass;
}());
/* harmony default export */ __webpack_exports__["default"] = (RenderPass);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderPassEdgeMap.ts":
/*!**************************************************!*\
  !*** ./04renderer/pipeline/RenderPassEdgeMap.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RenderPass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderPass */ "./04renderer/pipeline/RenderPass.ts");
// RenderPassTransparent.js
// A render pass contains a render target, a render queue 
// and a few overrided parameters, e.g., material
//
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var RenderPassEdgeMap = /** @class */ (function (_super) {
    __extends(RenderPassEdgeMap, _super);
    function RenderPassEdgeMap(resourceManager) {
        return _super.call(this, resourceManager, false, { line: true }) || this;
    }
    RenderPassEdgeMap.prototype.render = function (renderTarget, renderer, camera, shadow, clipping, lights) {
        if (this.queue.isValid()) {
            // FIXME: temporary change the blending state of the render target when
            // the override material is transparent. However, we don't do the sorting.
            if (this._overridedMaterial !== null && this._overridedMaterial.transparent) {
                var originalBlend = renderTarget.getOption("blend");
                renderTarget.setOption("blend", true);
                renderTarget.always = true;
            }
            renderer.drawLinesWithVertexIds(renderTarget, this.queue.drawables, camera, this._overridedShaders, this._overridedMaterial, clipping);
            if (this._overridedMaterial !== null && this._overridedMaterial.transparent) {
                renderTarget.setOption("blend", originalBlend);
                renderTarget.always = false;
            }
        }
    };
    return RenderPassEdgeMap;
}(_RenderPass__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (RenderPassEdgeMap);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderPassNode.ts":
/*!***********************************************!*\
  !*** ./04renderer/pipeline/RenderPassNode.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RenderPass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderPass */ "./04renderer/pipeline/RenderPass.ts");
// RenderPassNodes.js
//
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var Node = /** @class */ (function () {
    function Node(node) {
        this.drawable = node.drawable;
        this.indexSize = this.drawable.mesh.indexSize;
        this.indicesOffset = node.indicesOffset;
        this.indicesCount = node.indicesCount;
    }
    Node.prototype.destroy = function () {
        this.drawable = null;
        delete this.drawable;
    };
    return Node;
}());
;
var RenderPassNodes = /** @class */ (function (_super) {
    __extends(RenderPassNodes, _super);
    function RenderPassNodes(resourceManager) {
        var _this = _super.call(this, resourceManager, false, {}) || this;
        _this._queue = [];
        return _this;
    }
    RenderPassNodes.prototype.destroy = function () {
        for (var i = 0; i < this._queue.length; ++i) {
            this._queue[i].destroy();
        }
        this._queue = null;
        delete this._queue;
        _super.prototype.destroy.call(this);
    };
    RenderPassNodes.prototype.render = function (renderTarget, renderer, camera, shadow, clipping, lights) {
        if (this._queue.length === 0) {
            return;
        }
        var blend = false;
        if (this._overridedMaterial !== null && this._overridedMaterial.transparent) {
            var originalBlend = renderTarget.getOption("blend");
            renderTarget.setOption("blend", true);
            renderTarget.always = true;
        }
        renderer.drawElements(renderTarget, this._queue, camera, clipping, lights, shadow, this._cullFace, this._overridedShaders, this._overridedMaterial);
        if (this._overridedMaterial !== null && this._overridedMaterial.transparent) {
            renderTarget.setOption("blend", originalBlend);
            renderTarget.always = false;
        }
    };
    // Add nodes to the rendering queue sort nodes with materials and drawables.
    // Merge nodes if possible.
    RenderPassNodes.prototype.setNodes = function (nodes) {
        var name = "";
        for (var i = 0; i < this._queue.length; ++i) {
            var drawable = this._queue[i].drawable;
            // Restore the unselected element profile lines to black.
            if (name !== drawable.name && drawable.mesh.isLine()) {
                drawable.material.setDiffuse([0, 0, 0]);
                name = drawable.name;
            }
            this._queue[i].destroy();
        }
        this._queue = [];
        if (!nodes) {
            return;
        }
        nodes.sort(function (a, b) {
            var ret = 0;
            ret = a.drawable.name.localeCompare(b.drawable.name);
            if (ret !== 0) {
                return ret;
            }
            return a.indicesOffset - b.indicesOffset;
        });
        name = "";
        for (var i = 0, len = nodes.length; i < len; i++) {
            var node = nodes[i];
            var drawable = nodes[i].drawable;
            if (name !== drawable.name) {
                // Highlight the selected element profile lines.
                if (drawable.mesh.isLine()) {
                    drawable.material.setDiffuse([0.96, 0.32, 0.14]);
                }
                this._queue.push(new Node(node));
                name = drawable.name;
            }
            else {
                var d = this._queue[this._queue.length - 1];
                if (drawable.transform.count > 1) { // instanced
                    if (d.indicesOffset + 1 === node.indicesOffset) {
                        d.indicesCount += 1;
                    }
                    else {
                        this._queue.push(new Node(node));
                    }
                }
                else {
                    if (d.indicesOffset + d.indicesCount * d.indexSize === node.indicesOffset) {
                        d.indicesCount += node.indicesCount;
                    }
                    else {
                        this._queue.push(new Node(node));
                    }
                }
            }
        }
    };
    return RenderPassNodes;
}(_RenderPass__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (RenderPassNodes);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderPassTransparent.ts":
/*!******************************************************!*\
  !*** ./04renderer/pipeline/RenderPassTransparent.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RenderPass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _RenderTarget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
// RenderPassTransparent.js
// A render pass contains a render target, a render queue 
// and a few overrided parameters, e.g., material
//
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var RenderPassTransparent = /** @class */ (function (_super) {
    __extends(RenderPassTransparent, _super);
    function RenderPassTransparent(resourceManager, width, height, selector) {
        var _this = _super.call(this, resourceManager, true, selector) || this;
        if (gl.isWebGL2) {
            // Reuse the framebuffer of current pipeline.
            _this._renderTarget = new _RenderTarget__WEBPACK_IMPORTED_MODULE_1__["default"]("pipeline", _this._resourceManager, width, height, {
                blend: true,
                samples: gl.wbSamples,
                colorFilter: gl.NEAREST,
                colorFormat: gl.wbFormat,
                colorBuffer: 0,
                depthBuffer: 0
            });
        }
        else {
            _this._renderTarget = new _RenderTarget__WEBPACK_IMPORTED_MODULE_1__["default"]("default", _this._resourceManager, width, height);
        }
        _this._oit = false;
        return _this;
    }
    RenderPassTransparent.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
    };
    RenderPassTransparent.prototype.setOITEnabled = function (enabled) {
        this._oit = enabled;
        // TODO: initialize the OIT.
        if (this._oit) {
        }
    };
    RenderPassTransparent.prototype.resize = function (width, height) {
    };
    RenderPassTransparent.prototype.render = function (renderTarget, renderer, camera, shadow, clipping, lights) {
        if (this._oit) {
            //this._oit.render(renderer, camera, renderTarget);
        }
        else {
            renderTarget.setOption("blend", true);
            renderTarget.always = true;
            _super.prototype.render.call(this, renderTarget, renderer, camera, shadow, clipping, lights);
            renderTarget.setOption("blend", false);
            renderTarget.always = false;
        }
    };
    return RenderPassTransparent;
}(_RenderPass__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (RenderPassTransparent);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderQueue.ts":
/*!********************************************!*\
  !*** ./04renderer/pipeline/RenderQueue.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
//
// RenderQueue.ts
// The render queue that consists many drawables.
//
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.

var RenderQueue = /** @class */ (function () {
    function RenderQueue(name, selector) {
        this.name = name;
        this.drawables = [];
        this._lastUpdated = 0;
        this._setSelector(selector);
    }
    RenderQueue.prototype.destroy = function () {
        this.drawables = null;
        delete this.drawables;
    };
    RenderQueue.prototype.removeDrawables = function () {
        this.drawables = [];
    };
    RenderQueue.prototype.removeDrawable = function (drawable) {
        for (var i = this.drawables.length - 1; i >= 0; i--) {
            if (this.drawables[i] === drawable) {
                this.drawables.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    RenderQueue.prototype.addDrawable = function (drawable) {
        if (drawable.visible && this._selector(drawable)) {
            this.drawables.push(drawable);
            return true;
        }
        return false;
    };
    // Create the queue.
    // Note: It is a very expensive function, only called when needed.
    RenderQueue.prototype.create = function (scene) {
        // Since queues are shared by different render passes and they will be 
        // updated in the same frame. It should be detected and avoided.
        if (this._lastUpdated === _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame) {
            return;
        }
        this.drawables = [];
        for (var i = 0, len1 = scene.models.length; i < len1; i++) {
            var model = scene.models[i];
            for (var j = 0, len2 = model.drawables.length; j < len2; j++) {
                this.addDrawable(model.drawables[j]);
            }
        }
        if (scene.terrain != null) {
            var t = scene.terrain;
            for (var i = 0, len = t.tiles.length; i < len; i++) {
                this.addDrawable(t.tiles[i].drawable);
            }
        }
        this._lastUpdated = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame;
        this.optimize();
    };
    RenderQueue.prototype.isValid = function () {
        return this.drawables.length > 0;
    };
    RenderQueue.prototype.optimize = function () {
        if (this.drawables.length === 0) {
            return;
        }
        this.drawables.sort(function (a, b) {
            return a.shader.name.localeCompare(b.shader.name);
        });
        //// Sort drawables in the renderqueue with mesh first. 
        //this.drawables.sort(function(a, b){ return a.mesh._name.localeCompare(b.mesh._name); });
        //// Then with material.
        //var currentMesh = this.drawables[0].mesh;
        //var currentIndex = 0;
        //var subarray;
        //for (var i = 1, len = this.drawables.length; i < len; ++i) {
        //    if (currentMesh !== this.drawables[i].mesh) {
        //        // Sort by material for this subarray
        //        if (i - currentIndex > 1) {
        //            subarray = this.drawables.slice(currentIndex, i);
        //            subarray.sort(function(a, b){ return a.material.name.localeCompare(b.material.name); });
        //            for (var j = currentIndex; j < i; ++j) {
        //                this.drawables[j] = subarray[j - currentIndex];
        //            }
        //        }
        //        
        //        currentMesh = this.drawables[i].mesh;
        //        currentIndex = i;
        //    }
        //}
        //if (this.drawables.length - currentIndex > 1) {
        //    subarray = this.drawables.slice(currentIndex, this.drawables.length);
        //    subarray.sort(function(a, b){ return a.material.name.localeCompare(b.material.name); });
        //    for (var j = currentIndex, len = this.drawables.length; j < len; ++j) {
        //        this.drawables[j] = subarray[j - currentIndex];
        //    }
        //}
    };
    RenderQueue.prototype.update = function (camera) {
        for (var i = 0, len = this.drawables.length; i < len; ++i) {
            this.drawables[i].update(camera);
        }
    };
    // A select will decide if a drawable is accepted by this queue.
    RenderQueue.prototype._setSelector = function (selector) {
        this._selector = function (drawable) {
            if (!selector) {
                return true;
            }
            if (selector.line !== undefined && (selector.line !== drawable.mesh.isLine())) {
                return false;
            }
            if (selector.texture !== undefined && (selector.texture !== drawable.material.hasTexture)) {
                return false;
            }
            if (selector.mask !== undefined && (selector.mask !== drawable.material.hasMask)) {
                return false;
            }
            if (selector.transparent !== undefined && (selector.transparent !== drawable.material.transparent)) {
                return false;
            }
            if (selector.shadowCaster !== undefined && (selector.shadowCaster !== drawable.isShadowCaster())) {
                return false;
            }
            return true;
        };
    };
    RenderQueue.prototype.sort = function (camera) {
        // Sort the drawables in this queue with respect to the distance of the drawable
        // to the camera.
        if (!this.isValid()) {
            return;
        }
        var eyeDir = camera.getViewDirection();
        var dir = vec3.fromValues();
        var sortArray = [];
        for (var i = 0, len = this.drawables.length; i < len; ++i) {
            var drawable = this.drawables[i];
            vec3.subtract(dir, drawable.bsphere, camera.eye);
            drawable.distance = vec3.dot(dir, eyeDir);
            //TODO: merge transparent could cause bbox and visible calculation error.
            //drawable.visible = (drawable.distance > 0); 
        }
        this.drawables.sort(function (a, b) { return b.distance - a.distance; });
    };
    // Copy other queues into this one.
    RenderQueue.prototype.copy = function (other) {
        if (this.name === other.name) {
            return;
        }
        if (this._lastUpdated === _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame) {
            return;
        }
        this.drawables = [];
        for (var i = 0; i < other.drawables.length; i++) {
            var drawable = other.drawables[i];
            if (this._selector(drawable)) {
                this.drawables.push(drawable);
            }
        }
        this._lastUpdated = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame;
    };
    return RenderQueue;
}());
/* harmony default export */ __webpack_exports__["default"] = (RenderQueue);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderQueueManager.ts":
/*!***************************************************!*\
  !*** ./04renderer/pipeline/RenderQueueManager.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RenderQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderQueue */ "./04renderer/pipeline/RenderQueue.ts");
//
// RenderQueueManager.js
// Manages all render queues.
//
// Hongwei Li (lihongwei@modeloapp.com)
// Copyright Modelo XX - 2018, All rights reserved.
//

var RenderQueueManager = {
    queues: {}
};
RenderQueueManager.getQueue = function (selector) {
    var name = "";
    if (!selector) {
        name = "default";
    }
    else {
        name += selector.line === undefined ? "" : selector.line ? "_Line_" : "_Not_Line_";
        name += selector.texture === undefined ? "" : selector.texture ? "_Texture_" : "_Not_Texture_";
        name += selector.mask === undefined ? "" : selector.mask ? "_Mask_" : "_Not_Mask_";
        name += selector.transparent === undefined ? "" : selector.transparent ? "_Transparent_" : "_Not_Transparent_";
        name += selector.shadowCaster === undefined ? "" : selector.shadowCaster ? "_ShadowCaster_" : "_Not_ShadowCaster_";
    }
    if (!RenderQueueManager.queues[name]) {
        RenderQueueManager.queues[name] = new _RenderQueue__WEBPACK_IMPORTED_MODULE_0__["default"](name, selector);
    }
    return RenderQueueManager.queues[name];
};
/* harmony default export */ __webpack_exports__["default"] = (RenderQueueManager);


/***/ }),

/***/ "./04renderer/pipeline/RenderScene.ts":
/*!********************************************!*\
  !*** ./04renderer/pipeline/RenderScene.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _rendereffects_RenderEffectLibrary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendereffects/RenderEffectLibrary */ "./04renderer/rendereffects/RenderEffectLibrary.ts");
/* harmony import */ var _RenderQueueManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderQueueManager */ "./04renderer/pipeline/RenderQueueManager.ts");
/* harmony import */ var _RenderTarget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _RenderPassTransparent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RenderPassTransparent */ "./04renderer/pipeline/RenderPassTransparent.ts");
/* harmony import */ var _RenderPassNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RenderPassNode */ "./04renderer/pipeline/RenderPassNode.ts");
// RenderScene.ts
// The base class of scene rendering pipeline
//
// Copyright Modelo XX - 2018, All rights reserved.








var RenderScene = /** @class */ (function () {
    function RenderScene(scene, camera, resourceManager, renderer) {
        this._scene = scene;
        this._camera = camera;
        this._resourceManager = resourceManager;
        this._renderer = renderer;
        this._effects = {};
        this._sortedEffects = [];
        _RenderQueueManager__WEBPACK_IMPORTED_MODULE_3__["default"].queues = _RenderQueueManager__WEBPACK_IMPORTED_MODULE_3__["default"].queues || {};
        this._opaques = new _RenderPass__WEBPACK_IMPORTED_MODULE_5__["default"](resourceManager, false, { line: false, transparent: false, mask: false });
        this._maskeds = new _RenderPass__WEBPACK_IMPORTED_MODULE_5__["default"](resourceManager, false, { line: false, transparent: false, mask: true });
        this._transparents = new _RenderPassTransparent__WEBPACK_IMPORTED_MODULE_6__["default"](resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, { line: false, transparent: true });
        this._lines = new _RenderPass__WEBPACK_IMPORTED_MODULE_5__["default"](resourceManager, false, { line: true });
        this._nodes = new _RenderPassNode__WEBPACK_IMPORTED_MODULE_7__["default"](resourceManager);
        this._flags = {
            doubleSided: false,
            clipping: false,
            line: false // rendering line flag
        };
        if (gl.isWebGL2) {
            this._renderTarget = new _RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("pipeline", this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                samples: gl.wbSamples,
                depthFunc: gl.LEQUAL,
                colorFilter: gl.NEAREST,
                colorFormat: gl.wbFormat,
                colorBuffer: 0,
                depthBuffer: 0
            });
        }
        else {
            this._renderTarget = new _RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("default", this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: false,
            });
        }
    }
    RenderScene.prototype.destroy = function () {
        this._scene = null;
        delete this._scene;
        this._camera = null;
        delete this._camera;
        this._resourceManager = null;
        delete this._resourceManager;
        this._renderer = null;
        delete this._renderer;
        for (var effect in this._effects) {
            this._effects[effect].destroy();
        }
        this._effects = null;
        delete this._effects;
        this._sortedEffects = null;
        delete this._sortedEffects;
        this._renderTarget.destroy();
        this._renderTarget = null;
        ;
        delete this._renderTarget;
        this._opaques.destroy();
        this._opaques = null;
        delete this._opaques;
        this._maskeds.destroy();
        this._maskeds = null;
        delete this._maskeds;
        this._transparents.destroy();
        this._transparents = null;
        delete this._transparents;
        this._lines.destroy();
        this._lines = null;
        delete this._lines;
        this._nodes.destroy();
        this._nodes = null;
        delete this._nodes;
        this._flags = null;
        delete this._flags;
        // Delete all render queues.
        _RenderQueueManager__WEBPACK_IMPORTED_MODULE_3__["default"].queues = null;
        delete _RenderQueueManager__WEBPACK_IMPORTED_MODULE_3__["default"].queues;
    };
    // Override this function to render the scene to the pipeline's render
    // target. Don't forget to call present() to blit the pipeline's render
    // target to the screen.
    RenderScene.prototype.draw = function (forceRende) {
        if (forceRende === void 0) { forceRende = false; }
        return false;
    };
    // Render the scene in high quality.
    RenderScene.prototype.drawHD = function () {
    };
    RenderScene.prototype.resize = function (width, height) {
        for (var effect in this._effects) {
            this._effects[effect].resize(width, height);
        }
        if (this._scene.background.skybox) {
            this._scene.background.skybox.resize(width, height);
        }
    };
    RenderScene.prototype.addEffect = function (name) {
        if (this._effects.hasOwnProperty(name)) {
            return;
        }
        var effect = new _rendereffects_RenderEffectLibrary__WEBPACK_IMPORTED_MODULE_2__["default"][name](this);
        if (!effect.doesSupportMobile(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile)) {
            effect.destroy();
            console.warn("Effect " + name + " is not supported on mobile!");
            return;
        }
        this._effects[effect.name] = effect;
        var position = this._sortedEffects.length;
        for (var i = 0, len = this._sortedEffects.length; i < len; i++) {
            if (this._sortedEffects[i].priority < effect.priority) {
                position = i;
                break;
            }
        }
        if (this._sortedEffects.length === position) {
            this._sortedEffects.push(effect);
        }
        else {
            this._sortedEffects.splice(position, 0, effect);
        }
        effect.onSceneChanged();
    };
    RenderScene.prototype.removeEffect = function (name) {
        if (!this._effects.hasOwnProperty(name)) {
            return;
        }
        var effect = this._effects[name];
        var idx = this._sortedEffects.indexOf(effect);
        this._sortedEffects.splice(idx, 1);
        effect.destroy();
        delete this._effects[name];
    };
    RenderScene.prototype.getEffect = function (name) {
        if (!this._effects.hasOwnProperty(name)) {
            console.warn("Effect '" + name + "' does not exist!");
            return null;
        }
        return this._effects[name];
    };
    RenderScene.prototype.setEffectEnabled = function (name, enabled) {
        if (!this._effects.hasOwnProperty(name)) {
            this.addEffect(name);
        }
        this._effects[name].setEnabled(enabled);
    };
    RenderScene.prototype.isEffectEnabled = function (name) {
        if (!this._effects.hasOwnProperty(name)) {
            return false;
        }
        return this._effects[name].isEnabled();
    };
    // Override the drawables' own materials with a global one. Different types of drawable
    // will have different drawable shaders.
    RenderScene.prototype.setOverridedRenderingAppearance = function (materials) {
        if (!materials) {
            this._lines.setOverridedMaterial(null);
            this._opaques.setOverridedMaterial(null);
            this._transparents.setOverridedMaterial(null);
            this._maskeds.setOverridedMaterial(null);
        }
        else {
            // We should create a material with white texture to render textured drawable.
            var dummyTexture = this._resourceManager.getTexture("white");
            if (!dummyTexture.ready) {
                dummyTexture.create(1, 1, gl.RGBA8, gl.NEAREST, gl.CLAMP_TO_EDGE);
                dummyTexture.update(new Uint8Array([255, 255, 255, 255]));
            }
            var shader = this._resourceManager.getShader("texture");
            if (!shader.ready) {
                var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["texture"];
                shader.createFromShaderSource(shaderSource, []);
            }
            if (Object.keys(materials).length <= 4) {
                this._lines.setOverridedMaterial(materials["lines"]);
                var material = materials["opaques"];
                if (material && !material.hasTexture) {
                    material.attachShader(shader);
                    material.setDiffuseTexture(dummyTexture);
                    this._opaques.setOverridedMaterial(material);
                }
                else {
                    this._opaques.setOverridedMaterial(material);
                }
                material = materials["transparents"];
                if (material && !material.hasTexture) {
                    material.attachShader(shader);
                    material.setDiffuseTexture(dummyTexture);
                    this._transparents.setOverridedMaterial(material);
                }
                else {
                    this._transparents.setOverridedMaterial(materials["transparents"]);
                }
                this._maskeds.setOverridedMaterial(materials["maskeds"]);
            }
            else {
                if (!materials.hasTexture) {
                    materials.attachShader(shader);
                    materials.setDiffuseTexture(dummyTexture);
                }
                this._lines.setOverridedMaterial(materials);
                this._opaques.setOverridedMaterial(materials);
                this._transparents.setOverridedMaterial(materials);
                this._maskeds.setOverridedMaterial(materials);
            }
        }
    };
    // Add elements/nodes to the render queue.
    RenderScene.prototype.renderNodes = function (nodes) {
        this._nodes.setNodes(nodes);
    };
    RenderScene.prototype.onSceneChanged = function () {
        for (var effect in this._effects) {
            this._effects[effect].onSceneChanged();
        }
        this._lines.queue.create(this._scene);
        this._opaques.queue.create(this._scene);
        this._maskeds.queue.create(this._scene);
        this._transparents.queue.create(this._scene);
        // FIXME: how can we change scene data here.
        this._scene.hasCurveOrLine = this._scene.hasCurveOrLine && this._lines.queue.isValid();
    };
    RenderScene.prototype.optimize = function () {
        this._lines.queue.optimize();
        this._opaques.queue.optimize();
        this._maskeds.queue.optimize();
        this._transparents.queue.optimize();
    };
    // Recompile the shaders in the render scene pipeline when asked
    RenderScene.prototype._recompileShaders = function (flag, enabled) {
        for (var effect in this._effects) {
            this._effects[effect].recompileShader(flag, enabled);
        }
        // FIXME: here we recompile shaders in the entire scene. Maybe 
        // it is faster only to recompile only visibles ones.
        for (var i_1 = 0; i_1 < this._scene.models.length; i_1++) {
            var drawables = this._scene.models[i_1].drawables;
            for (var j = 0; j < drawables.length; j++) {
                if (drawables[j].visible) {
                    drawables[j].recompileShader(flag, enabled);
                }
            }
        }
        if (this._scene.terrain) {
            var tiles = this._scene.terrain.tiles;
            for (var i = 0; i < tiles.length; i++) {
                if (tiles[i].visible) {
                    tiles[i].drawable.recompileShader(flag, enabled);
                }
            }
        }
        this._renderer.invalidate();
    };
    RenderScene.prototype.refreshRendering = function (refreshes) {
        if (refreshes === void 0) { refreshes = 1; }
    };
    RenderScene.prototype.getScene = function () {
        return this._scene;
    };
    RenderScene.prototype.getResourceManager = function () {
        return this._resourceManager;
    };
    RenderScene.prototype.getCamera = function () {
        return this._camera;
    };
    RenderScene.prototype.getRenderer = function () {
        return this._renderer;
    };
    RenderScene.prototype.getRenderTarget = function () {
        return this._renderTarget;
    };
    RenderScene.prototype.isLineRendering = function (enabled) {
        return this._flags.line;
    };
    RenderScene.prototype.setLineRendering = function (enabled) {
        this._flags.line = enabled;
    };
    RenderScene.prototype.addDrawable = function (drawable) {
        this._opaques.queue.addDrawable(drawable) ||
            this._maskeds.queue.addDrawable(drawable) ||
            this._lines.queue.addDrawable(drawable) ||
            this._transparents.queue.addDrawable(drawable);
    };
    RenderScene.prototype.removeDrawable = function (drawable) {
        this._opaques.queue.removeDrawable(drawable) ||
            this._maskeds.queue.removeDrawable(drawable) ||
            this._lines.queue.removeDrawable(drawable) ||
            this._transparents.queue.removeDrawable(drawable);
    };
    RenderScene.prototype.getOpaques = function () {
        return this._opaques;
    };
    RenderScene.prototype.getMaskeds = function () {
        return this._maskeds;
    };
    RenderScene.prototype.getLines = function () {
        return this._lines;
    };
    RenderScene.prototype.getTransparents = function () {
        return this._transparents;
    };
    return RenderScene;
}());
/* harmony default export */ __webpack_exports__["default"] = (RenderScene);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderSceneForward.ts":
/*!***************************************************!*\
  !*** ./04renderer/pipeline/RenderSceneForward.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/drawables/m3d_skybox.js */ "./03scene/drawables/m3d_skybox.js");
/* harmony import */ var _shadow_ShadowController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shadow/ShadowController */ "./04renderer/shadow/ShadowController.ts");
/* harmony import */ var _RenderScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RenderScene */ "./04renderer/pipeline/RenderScene.ts");
// RenderSceneForward.ts
// Forward rendering of scene.
//
// Copyright Modelo XX - 2018, All rights reserved.
//
// Hongwei Li (lihongwei@modeloapp.com)
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var RenderSceneForward = /** @class */ (function (_super) {
    __extends(RenderSceneForward, _super);
    function RenderSceneForward(scene, camera, resourceManager, renderer, volumeRenderer) {
        var _this = _super.call(this, scene, camera, resourceManager, renderer) || this;
        _this._volumeRenderer = volumeRenderer;
        _this._flags = {
            doubleSided: false,
            clipping: false,
            shadow: false,
            specular: false,
            line: false // rendering line flag
        };
        _this._shadow = null;
        return _this;
    }
    RenderSceneForward.prototype.destroy = function () {
        if (this._shadow) {
            this._shadow.destroy();
            this._shadow = null;
            delete this._shadow;
        }
        _super.prototype.destroy.call(this);
    };
    RenderSceneForward.prototype.draw = function (forceRender) {
        if (forceRender === void 0) { forceRender = false; }
        if (this._scene.background.mode === _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_0__["default"].SKYBOX_SOLIDCOLOR) {
            this._renderTarget.setClearColor(this._scene.background.color);
        }
        this._drawFrame(this._renderTarget);
        return true;
    };
    // Render the scene in high quality.
    RenderSceneForward.prototype.drawHD = function () {
        this.draw(true);
    };
    RenderSceneForward.prototype._drawFrame = function (renderTarget) {
        this._renderer.clear(renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        var clipping = this._scene.clipping;
        var lights = this._scene.getMainLight();
        this._opaques.render(renderTarget, this._renderer, this._camera, this._shadow, clipping, lights);
        this._maskeds.render(renderTarget, this._renderer, this._camera, this._shadow, clipping, lights);
        if (this._flags.line) {
            this._lines.render(renderTarget, this._renderer, this._camera, this._shadow, clipping, lights);
        }
        this._nodes.render(renderTarget, this._renderer, this._camera, this._shadow, clipping, lights);
        this._transparents.render(renderTarget, this._renderer, this._camera, this._shadow, clipping, lights);
        this._volumeRenderer.render(renderTarget, this._renderer, this._camera, clipping, lights);
        this._drawEffects(renderTarget);
        // Draw the skybox after opaques because most of its pixels will be occluded by others.
        if (this._scene.background.skybox && this._scene.background.skybox.enabled) {
            this._scene.background.skybox.update(this._camera.viewMatrix);
            this._renderer.drawSkybox(renderTarget, this._scene.background.skybox, this._camera);
        }
    };
    RenderSceneForward.prototype._drawEffects = function (renderTarget) {
        for (var i = 0; i < this._sortedEffects.length; i++) {
            this._sortedEffects[i].draw(renderTarget, -1);
        }
    };
    RenderSceneForward.prototype.resize = function (width, height) {
        _super.prototype.resize.call(this, width, height);
        this._renderTarget.resize(width, height);
    };
    RenderSceneForward.prototype.isLineRendering = function (enabled) {
        return this._flags.line;
    };
    RenderSceneForward.prototype.setLineRendering = function (enabled) {
        this._flags.line = enabled;
    };
    RenderSceneForward.prototype.setShadowEnabled = function (enabled) {
        if (this._flags.shadow === enabled) {
            return;
        }
        this._flags.shadow = enabled;
        if (this._flags.shadow && this._shadow === null) {
            this._shadow = new _shadow_ShadowController__WEBPACK_IMPORTED_MODULE_1__["default"](this);
            this._shadow.onSceneChanged();
        }
        this._shadow.setEnabled(enabled);
        this.updateShadow();
        this._recompileShaders("SHADOW", enabled);
        // FIXME: only when CSM is enabled
        this._recompileShaders("SHADOW_PARTITION", enabled);
    };
    RenderSceneForward.prototype.updateShadow = function (forceUpdate) {
        if (forceUpdate === void 0) { forceUpdate = false; }
        if (this._shadow && (this._flags.shadow || forceUpdate)) {
            this._shadow.draw(null);
            this._renderer.renderState.invalidateShadow();
        }
    };
    RenderSceneForward.prototype.isShadowEnabled = function () {
        return this._flags.shadow;
    };
    RenderSceneForward.prototype.setClippingEnabled = function (enabled) {
        if (this._flags.clipping === enabled) {
            return;
        }
        this._flags.clipping = enabled;
        this._recompileShaders("CLIPPING", enabled);
        if (this._shadow) {
            this._shadow.recompileShader("CLIPPING", enabled);
            this._shadow.draw(null);
        }
        for (var effect in this._effects) {
            this._effects[effect].recompileShader("CLIPPING", enabled);
        }
    };
    RenderSceneForward.prototype.isClippingEnabled = function () {
        return this._flags.clipping;
    };
    RenderSceneForward.prototype.optimize = function () {
        this._lines.queue.optimize();
        this._opaques.queue.optimize();
        this._maskeds.queue.optimize();
        this._transparents.queue.optimize();
    };
    // TODO: fine control the add/remove drawables from the queues.
    RenderSceneForward.prototype.onSceneChanged = function () {
        _super.prototype.onSceneChanged.call(this);
        this._shadow.onSceneChanged();
        this._flags.doubleSided = this._scene.needRenderDoubleSided();
    };
    // When the rendering setting has changed, we need to update the shaders
    // of materials to minimize the shader instructions.
    // Add flag to the shader building flags if enabled is true or remove the flag from the shader building flags otherwise.
    RenderSceneForward.prototype.recompileShaders = function (flag, enabled) {
        //flags.push("VISIBILITY");
        //flags.push("MODEL_TRANSFORM");
        //if (this._scene.needRenderDoubleSided()) {
        //    flags.push("DOUBLESIDED");
        //}
        //if (this._flags.shadow) {
        //    flags.push("SHADOW");
        //}
        //if (this._flags.clipping) {
        //    flags.push("CLIPPING");
        //}
        //if (this._flags.specular) {
        //    flags.push("SPECULAR");
        //}
        //if (this._flags.manySpecular) {
        //    flags.push("MANY_SPECULAR");
        //}
        //if (Globals.isMobile) {
        //    flags.push("MOBILE");
        //}
        //if (this._scene.compressed) {
        //    flags.push("COMPRESSION");
        //}
        this._opaques.recompileOverridedShader(flag, enabled);
        this._maskeds.recompileOverridedShader(flag, enabled);
        this._lines.recompileOverridedShader(flag, enabled);
        this._transparents.recompileOverridedShader(flag, enabled);
        for (var effect in this._effects) {
            this._effects[effect].recompileShader(flag, enabled);
        }
        if (this._shadow) {
            this._shadow.recompileShader(flag, enabled);
        }
        //flags.push("ALPHATEST");
        //this._maskeds.recompileOverridedShader(this._resourceManager, flags);
        this._renderer.invalidate();
    };
    RenderSceneForward.prototype.refreshRendering = function (refreshes) {
        if (refreshes === void 0) { refreshes = 1; }
    };
    return RenderSceneForward;
}(_RenderScene__WEBPACK_IMPORTED_MODULE_2__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (RenderSceneForward);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderScenePR.ts":
/*!**********************************************!*\
  !*** ./04renderer/pipeline/RenderScenePR.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/drawables/m3d_skybox.js */ "./03scene/drawables/m3d_skybox.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _RenderTarget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../m3d_samples.js */ "./04renderer/m3d_samples.js");
/* harmony import */ var _m3d_blit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../m3d_blit.js */ "./04renderer/m3d_blit.js");
/* harmony import */ var _RenderSceneForward__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RenderSceneForward */ "./04renderer/pipeline/RenderSceneForward.ts");
// RenderScenePR.ts
// The scene rendering with progressive rendering.
//
// Copyright Modelo XX - 2018, All rights reserved.
//
// Hongwei Li (lihongwei@modeloapp.com)
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var RenderScenePR = /** @class */ (function (_super) {
    __extends(RenderScenePR, _super);
    function RenderScenePR(scene, camera, resourceManager, renderer, volumeRenderer) {
        var _this = _super.call(this, scene, camera, resourceManager, renderer, volumeRenderer) || this;
        _this._prFrame = -1; // Current progressive rendering frame
        _this._prSkipFrames = 4; // Now only use skip frames in screenshot process
        _this._PR_MAX_FRAMES = 16;
        _this._prEnabled = true; // Enabled PR rendering. By default, it is true.
        _this._needUpdate = 0;
        _this._flags = {
            progressive: false,
            doubleSided: false,
            clipping: false,
            shadow: false,
            specular: false,
            line: false,
            smartCulling: false,
        };
        _this._prRenderTargets = [
            new _RenderTarget__WEBPACK_IMPORTED_MODULE_3__["default"]("pipeline-pr", _this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthFunc: gl.LEQUAL,
                colorFilter: gl.NEAREST,
                colorFormat: gl.RGBA8,
                depthBuffer: 0,
            }),
            new _RenderTarget__WEBPACK_IMPORTED_MODULE_3__["default"]("pipeline-pr1", _this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: false,
                colorFilter: gl.NEAREST,
                colorFormat: gl.RGBA8,
                depthBuffer: 0
            }),
            new _RenderTarget__WEBPACK_IMPORTED_MODULE_3__["default"]("pipeline-pr2", _this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: false,
                colorFilter: gl.NEAREST,
                colorFormat: gl.RGBA8,
                depthBuffer: 0
            })
        ];
        _this._prBlit = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_5__["default"](_this._resourceManager, _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_2__["default"]["accumulate"]);
        return _this;
    }
    RenderScenePR.prototype.destroy = function () {
        this._prRenderTargets[0].destroy();
        this._prRenderTargets[1].destroy();
        this._prRenderTargets[2].destroy();
        this._prRenderTargets = null;
        ;
        delete this._prRenderTargets;
        this._prBlit.destroy();
        this._prBlit = null;
        delete this._prBlit;
        _super.prototype.destroy.call(this);
    };
    RenderScenePR.prototype.draw = function (forceRender) {
        if (forceRender === void 0) { forceRender = false; }
        forceRender = (forceRender || !this._prEnabled);
        // No need to render when progressive rendering stops and forceRendering is not needed.
        if (!forceRender && this._flags.progressive && this._needUpdate === 0) {
            return false;
        }
        if (this._scene.background.mode === _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__["default"].SKYBOX_SOLIDCOLOR) {
            this._renderTarget.setClearColor(this._scene.background.color);
            this._prRenderTargets[0].setClearColor(this._scene.background.color);
        }
        // In the progressive rendering mode.
        if (!forceRender && this._flags.progressive) {
            while (this._prFrame <= this._prSkipFrames) {
                this._drawFrameProgressively();
                this._prFrame++;
            }
            // Do progressive frame for this pass
            this._drawFrameProgressively();
            // FIXME: why do we need to flush GPU pipeline here?
            //gl.syncGPU();
            this._prFrame++;
            if (this._prFrame <= this._PR_MAX_FRAMES) {
                // We should keep rendering still all PR frames are finished.
                this._needUpdate += 1;
            }
        }
        else {
            // In non-PR mode, we simply render one frame.
            this._drawFrame(this._renderTarget);
        }
        // Each rendering will consume one refresh requests if it is not a forced one.
        if (!forceRender) {
            this._needUpdate -= 1;
            // When refresh requests, we should decide if we should enter or get out of PR mode.
            if (this._needUpdate < 0) {
                this._onAnimationEnd();
            }
        }
        return true;
    };
    // Render the scene in high quality.
    RenderScenePR.prototype.drawHD = function () {
        if (this._scene.background.mode === _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__["default"].SKYBOX_SOLIDCOLOR) {
            this._prRenderTargets[0].setClearColor(this._scene.background.color);
        }
        // Render in PR mode by default.
        this._prFrame = 1;
        while (this._prFrame <= this._PR_MAX_FRAMES) {
            this._drawFrameProgressively();
            this._prFrame++;
        }
        this._renderer.present(this._prRenderTargets[1 + this._prFrame % 2].getFramebuffer());
        this._prFrame = -1; // Restore to un-initialize frame.
    };
    RenderScenePR.prototype._drawEffects = function (renderTarget) {
        for (var i = 0; i < this._sortedEffects.length; i++) {
            this._sortedEffects[i].draw(renderTarget, this._prFrame);
        }
    };
    RenderScenePR.prototype.resize = function (width, height) {
        _super.prototype.resize.call(this, width, height);
        this._prRenderTargets[0].resize(width, height);
        this._prRenderTargets[1].resize(width, height);
        this._prRenderTargets[2].resize(width, height);
    };
    RenderScenePR.prototype._drawFrameProgressively = function () {
        //console.log("pr frame " + this._prFrame);
        var camera = this._camera;
        // AA: jitter the projection matrix to do AA stuff.
        var dx = _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__["default"]._4X4[(this._prFrame - 1) * 2] - 0.5;
        var dy = _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__["default"]._4X4[(this._prFrame - 1) * 2 + 1] - 0.5;
        if (this._flags.shadow) {
            this._shadow.draw(this._prFrame);
            this._renderer.renderState.invalidateShadow();
        }
        // Jitter the camera a few subpixels
        camera.jitter(dx / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, dy / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        mat4.multiply(camera.vpMatrix, camera.projectMatrix, camera.viewMatrix);
        //gl.activeTexture(gl.TEXTURE0 + 0); 
        //gl.bindTexture(gl.TEXTURE_2D, null);
        gl.activeTexture(gl.TEXTURE0 + 1);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.activeTexture(gl.TEXTURE0 + 2);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.activeTexture(gl.TEXTURE0 + 3);
        gl.bindTexture(gl.TEXTURE_2D, null);
        this._drawFrame(this._prRenderTargets[0]);
        // Restore the camera
        camera.jitter(-dx / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, -dy / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        // Accumulate with previous frame.
        this._renderer.renderState.viewport(camera.viewport); // Set the blit viewport the same size of pr viewport.
        this._prBlit.setTexture(this._prRenderTargets[1 + this._prFrame % 2].getColorBuffer());
        this._prBlit.setParameter("uTexture0", this._prRenderTargets[0].getColorBuffer());
        this._prBlit.setParameter("uFrameCount", this._prFrame);
        this._prBlit.render(this._renderer, this._prRenderTargets[2 - this._prFrame % 2]);
    };
    RenderScenePR.prototype.isProgressiveRenderingEnabled = function () {
        return this._prEnabled;
    };
    RenderScenePR.prototype.setProgressiveRenderingEnabled = function (enabled) {
        this._prEnabled = enabled;
    };
    RenderScenePR.prototype.setProgressiveRenderingLatency = function (latency) {
        if (this._prSkipFrames >= this._PR_MAX_FRAMES) {
            this._prSkipFrames = 15;
        }
        if (this._prSkipFrames < 0) {
            this._prSkipFrames = 4;
        }
    };
    RenderScenePR.prototype._onAnimationStart = function () {
        this._camera.setBimCullingEnabled(this._flags.smartCulling);
        if (this._flags.shadow) {
            this._shadow.draw();
            this._renderer.renderState.invalidateShadow();
        }
        //this.setEffectEnabled("OIT", false);
    };
    RenderScenePR.prototype._onAnimationEnd = function () {
        // We finish all frames in progressive mode.
        if (this._flags.progressive) {
            // We will do no more frames until next refresh request.
            this._needUpdate = 0;
        }
        else {
            //console.log("enter pr 1");
            // We are going to enter progressive mode now.
            // We need to refresh rendering for starting PR. Adding 1.01 to
            // make 0 < this._needUpdate < 1.
            // it would cause error when this._needUpdate > 1.0
            this._needUpdate += 1.01;
            if (this._needUpdate > 1) {
                this._needUpdate = 0.9999;
            }
            // Render another frame with BIM culling off before entering PR mode.
            if (this._prFrame <= 0 && this._camera.isBimCullingEnabled()) {
                this._camera.setBimCullingEnabled(false);
                // We need to invalidate the rendering states for instancing shaders here
                // as it may be the first time of using them and they haven't acquired the
                // global rendering states.
                this._renderer.invalidate();
                return;
            }
            this._prFrame = 1;
            //console.log("enter pr 2");
            this._flags.progressive = true;
            this._renderer.clear(this._prRenderTargets[1], gl.COLOR_BUFFER_BIT);
            this._renderer.clear(this._prRenderTargets[2], gl.COLOR_BUFFER_BIT);
            if (this._flags.shadow) {
                this._renderer.renderState.invalidateShadow();
            }
        }
    };
    RenderScenePR.prototype.setSmartCullingEnabled = function (enabled) {
        this._flags.smartCulling = enabled;
    };
    RenderScenePR.prototype.isSmartCullingEnabled = function () {
        return this._flags.smartCulling;
    };
    RenderScenePR.prototype.getRenderTarget = function () {
        // Only present final rendering result to the render target.
        if (this._prFrame > this._PR_MAX_FRAMES) {
            return this._prRenderTargets[1 + this._prFrame % 2];
        }
        else {
            return this._renderTarget;
        }
    };
    RenderScenePR.prototype.refreshRendering = function (refreshes) {
        if (refreshes === void 0) { refreshes = 1; }
        // Quit the PR mode whenever a refresh rendering event is issued.
        if (this._flags.progressive) {
            // Quit PR mode.
            this._flags.progressive = false;
            //console.log("quit pr " + this._needUpdate);
            this._onAnimationStart();
            this._prFrame = -1;
        }
        // Using 1.01 ensure this._needUpdate never equlas to 0.
        this._needUpdate += refreshes * 1.01;
        if (this._needUpdate > 20.01) {
            this._needUpdate = 20.01;
        }
    };
    return RenderScenePR;
}(_RenderSceneForward__WEBPACK_IMPORTED_MODULE_6__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (RenderScenePR);
;


/***/ }),

/***/ "./04renderer/pipeline/RenderTarget.ts":
/*!*********************************************!*\
  !*** ./04renderer/pipeline/RenderTarget.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// RenderTarget.js
// A render target is the 
//
// Copyright Modelo XX - 2017, All rights reserved.
var RenderTarget = /** @class */ (function () {
    //
    // options: { 
    //   clearColor:  [R, G, B, A], # a vec4, the background of the color buffer
    //   colorMask:   [true, true, true, true], # a boolean vec4, whether color buffer is writable 
    //   depthTest: true, # enable depth testing
    //   depthMask: true, # enable depth writing
    //   depthFunc: gl.LESS, # the default depth testing function
    //   clearDepth: 1.0, # the depth buffer background value
    //   stencilTest: true, # enable stencil testing
    //   samples: the MSAA target. The max samples are 8.
    //
    //   colorFormat: the color format 
    //   colorBuffer: an integer. It gives the id of this color buffer. When another color with 
    //   same id and same resolution+format is found in current resource pool, it will be reused
    //   for this render target. By default, it is -1, and this color buffer will not be shared with
    //   others. The common practice is when a color buffer should be resident in the memory, e.g.,
    //   used in next frame or valid during the entire frame, it should be set to -1. If it is only
    //   a temporary rendertarget, set to an incremental ID series in one rendering effect.
    //   colorFilter: the texture filtering of the buffer. Linear by default.
    //   colorWrap: the texture filtering of the buffer. Using clamp to edge by default.
    //
    //   depthXXXX: ditto for the depth buffer
    //   }
    //
    //   By default if options is empty. We can will create an
    //   RGBA color buffer with wrapping mode of clamp-to-edge and filtering mode of linear, and 
    //   DEPTH24 depth buffer with wrapping mode of clamp-to-edge and filtering mode of linear.
    function RenderTarget(name, resourceManager, width, height, options) {
        // public:
        this.ready = false;
        this.always = false; // always applied
        // private:
        this._name = name;
        this._options = options || {};
        this._framebuffer = null;
        if (!this._options.hasOwnProperty("clearColor")) {
            this._options.clearColor = new Float32Array([1.0, 1.0, 1.0, 0.0]);
        }
        if (!this._options.hasOwnProperty("colorMask")) {
            this._options.colorMask = new Int32Array([1, 1, 1, 1]);
        }
        if (!this._options.hasOwnProperty("depthTest")) {
            this._options.depthTest = true;
        }
        if (!this._options.hasOwnProperty("depthMask")) {
            this._options.depthMask = true;
        }
        if (!this._options.hasOwnProperty("clearDepth")) {
            this._options.clearDepth = true;
        }
        if (!this._options.hasOwnProperty("depthFunc")) {
            this._options.depthFunc = gl.LESS;
        }
        if (!this._options.hasOwnProperty("blend")) {
            this._options.blend = false;
        }
        if (!this._options.hasOwnProperty("stencilTest")) {
            this._options.stencilTest = false;
        }
        if (!this._options.hasOwnProperty("stencilOp")) {
            this._options.stencilOp = [gl.KEEP, gl.KEEP, gl.REPLACE];
        }
        if (!this._options.hasOwnProperty("stencilFunc")) {
            this._options.stencilFunc = [gl.ALWAYS, 0, -1];
        }
        if (!this._options.hasOwnProperty("samples")) {
            this._options.samples = 1;
        }
        this._framebuffer = resourceManager.getFramebuffer(this._name);
        // Only create the framebuffer object when it does not exist.
        if (!this._framebuffer.ready) {
            var colorBuffer = -1;
            if (options.hasOwnProperty("colorBuffer")) {
                colorBuffer = options.colorBuffer;
            }
            var depthBuffer = -1;
            if (options.hasOwnProperty("depthBuffer")) {
                depthBuffer = options.depthBuffer;
            }
            var colorFormat = options.colorFormat || gl.RGBA8;
            var depthFormat = options.depthFormat || (gl.isWebGL2 ? gl.DEPTH_COMPONENT24 : gl.DEPTH_COMPONENT);
            if (this._options.stencilTest) {
                if (gl.isWebGL2) {
                    depthFormat = gl.DEPTH24_STENCIL8;
                }
                else {
                    depthFormat = gl.DEPTH_STENCIL;
                }
            }
            var bufferName;
            // Convert color buffer ID to a string.
            if (colorBuffer === -1) {
                bufferName = name + "-cbuf";
            }
            else {
                // NOTE: All shared framebuffer textures will resize at the same time, so it is safe to use their resolution to 
                // identify them.
                bufferName = "c" + colorBuffer.toString() + "-" + width.toString() + "x" + height.toString() +
                    "-" + colorFormat + "x" + this._options.samples;
            }
            var colorBufferObject = resourceManager.getTexture(bufferName);
            if (!colorBufferObject.ready) {
                colorBufferObject.create(width, height, colorFormat, this._options.colorFilter, this._options.colorWrap, this._options.samples);
                if (!colorBufferObject.ready) {
                    colorBufferObject.destroy();
                    this.ready = false;
                    return;
                }
            }
            if (depthBuffer === -1) {
                bufferName = name + "-dbuf";
            }
            else {
                bufferName = "d" + depthBuffer.toString() + "-" + width.toString() + "x" + height.toString() +
                    "-" + depthFormat + "x" + this._options.samples;
            }
            var depthBufferObject = resourceManager.getTexture(bufferName);
            if (!depthBufferObject.ready) {
                depthBufferObject.create(width, height, depthFormat, this._options.depthFilter, this._options.depthWrap, this._options.samples);
                if (!depthBufferObject.ready) {
                    depthBufferObject.destroy();
                    this.ready = false;
                    return;
                }
            }
            this._framebuffer.create(colorBufferObject, depthBufferObject);
        }
        this.ready = this._framebuffer.ready;
    }
    ;
    RenderTarget.prototype.destroy = function () {
        if (this._name !== "default") {
            this._framebuffer.destroy();
            this._framebuffer = null;
            delete this._framebuffer;
        }
        this._options = null;
        delete this._options;
    };
    RenderTarget.prototype.render = function (renderState) {
        if (!this.ready) {
            console.log("render target '" + this._name + "' is not ready.");
            return;
        }
        renderState.useFramebuffer(this._framebuffer);
        renderState.blend(this._options.blend);
        renderState.clearColor(this._options.clearColor);
        renderState.colorMask(this._options.colorMask);
        renderState.depthTest(this._options.depthTest, this._options.clearDepth, this._options.depthFunc);
        renderState.depthMask(this._options.depthMask);
        renderState.stencilTest(this._options.stencilTest, this._options.stencilFunc, this._options.stencilOp);
    };
    ;
    RenderTarget.prototype.resize = function (width, height) {
        if (!this.ready) {
            console.log("render target '" + this._name + "' is not ready.");
            return;
        }
        this.ready = false;
        this._framebuffer.resize(width, height);
        this.ready = this._framebuffer.ready;
    };
    RenderTarget.prototype.setClearColor = function (color) {
        if (!this.ready) {
            console.log("render target " + this._name + " is not ready.");
            return;
        }
        this._options.clearColor[0] = color[0];
        this._options.clearColor[1] = color[1];
        this._options.clearColor[2] = color[2];
        this._options.clearColor[3] = color[3];
    };
    RenderTarget.prototype.getOption = function (name) {
        return this._options[name];
    };
    RenderTarget.prototype.setOption = function (name, value) {
        this._options[name] = value;
    };
    RenderTarget.prototype.getColorBuffer = function () {
        return this._framebuffer.getColorBuffer();
    };
    RenderTarget.prototype.getDepthBuffer = function () {
        return this._framebuffer.getDepthBuffer();
    };
    RenderTarget.prototype.getWidth = function () {
        return this._framebuffer.getWidth();
    };
    RenderTarget.prototype.getHeight = function () {
        return this._framebuffer.getHeight();
    };
    RenderTarget.prototype.getFramebuffer = function () {
        return this._framebuffer;
    };
    RenderTarget.prototype.getName = function () {
        return this._name;
    };
    return RenderTarget;
}());
/* harmony default export */ __webpack_exports__["default"] = (RenderTarget);
;


/***/ }),

/***/ "./04renderer/pipeline/m3d_renderer.js":
/*!*********************************************!*\
  !*** ./04renderer/pipeline/m3d_renderer.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_renderstate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_renderstate.js */ "./04renderer/pipeline/m3d_renderstate.js");
// m3d_renderer.js
// Renderer which does not related to scene.
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function Renderer(resourceManager) {
        // public:
        this.renderState = new _m3d_renderstate_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
        // private:
        this._resourceManager = resourceManager;
        this._renderTarget = null;
        this._quadMesh = null;
        this._quadMesh = resourceManager.getMesh("quad");
        this._quadMesh.createQuad();
    }
    ;
    Renderer.prototype.destroy = function () {
        this.renderState = null;
    };
    var indices = [0, 0];
    Renderer.prototype.drawDrawables = function (target, drawables, camera, overridedShaders, overridedMaterial, clipping, light, shadow, materials, cullFace) {
        if (drawables.length === 0) {
            return 0;
        }
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        if (!cullFace) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
            gl.frontFace(cullFace);
        }
        this.renderState.viewport(camera.viewport);
        if (overridedShaders[0] !== null) {
            // If the the scene is not contained by the camera frustum, we can skip
            // culling testing of each individual drawable.
            for (var i = 0, len = drawables.length; i < len; i++) {
                var drawable = drawables[i];
                if (!drawable.visible) {
                    continue;
                }
                indices[0] = 0;
                indices[1] = drawable.mesh.length;
                if (camera.cull(drawable, indices)) {
                    continue;
                }
                if (drawable.billboard) {
                    drawable.update(camera);
                }
                var shader = null;
                // Choose shader base on drawable type
                if (drawable.transform.identity) {
                    shader = overridedShaders[0];
                }
                else if (drawable.isInstancing()) {
                    shader = overridedShaders[2];
                }
                else {
                    shader = overridedShaders[1];
                }
                // Bind the shader to the pipeline and update global uniforms.
                this.renderState.useShader(shader, camera, clipping, light, shadow, null, null);
                // Update uniforms in the materials.
                if (overridedMaterial) {
                    overridedMaterial.absorb(drawable.material);
                    overridedMaterial.use(shader);
                }
                else {
                    drawable.material.use(shader);
                }
                // Render mesh
                this.renderState.useMesh(drawable.mesh);
                drawable.render(camera, shader, indices);
            }
        }
        else {
            for (var i = 0, len = drawables.length; i < len; i++) {
                var drawable = drawables[i];
                if (!drawable.visible) {
                    continue;
                }
                indices[0] = 0;
                indices[1] = drawable.mesh.length;
                if (camera.cull(drawable, indices)) {
                    continue;
                }
                if (drawable.billboard) {
                    drawable.update(camera);
                }
                // Bind the shader to the pipeline and update global uniforms.
                this.renderState.useShader(drawable.shader, camera, clipping, light, shadow, materials);
                if (overridedMaterial) {
                    overridedMaterial.absorb(drawable.material);
                    overridedMaterial.use(drawable.shader);
                }
                else {
                    drawable.material.use(drawable.shader);
                }
                // Render mesh
                this.renderState.useMesh(drawable.mesh);
                drawable.render(camera, drawable.shader, indices);
            }
        }
    };
    Renderer.prototype.drawLinesWithVertexIds = function (target, drawables, camera, overridedShaders, overridedMaterial, clipping) {
        if (drawables.length === 0) {
            return 0;
        }
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        this.renderState.viewport(camera.viewport);
        var vertexBaseId = 0;
        // If the the scene is not contained by the camera frustum, we can skip
        // culling testing of each individual drawable.
        for (var i = 0, len = drawables.length; i < len; i++) {
            var drawable = drawables[i];
            indices[0] = 0;
            indices[1] = drawable.mesh.length;
            var shader = null;
            // Choose shader base on drawable type
            if (drawable.transform.identity) {
                shader = overridedShaders[0];
            }
            else {
                shader = overridedShaders[1];
            }
            // Bind the shader to the pipeline and update global uniforms.
            this.renderState.useShader(shader, camera, clipping, null, null, null, vertexBaseId);
            // Update uniforms in the materials.
            overridedMaterial.absorb(drawable.material);
            overridedMaterial.use(shader);
            // Render mesh
            this.renderState.useMesh(drawable.mesh);
            drawable.render(camera, shader, indices);
            // The gl_vertexID is reset at each drawable, so we have to manually offset it.
            // es 3.0 doesn't provide baseVertex built-in var.
            vertexBaseId += drawable.mesh.length;
        }
    };
    // Draw a single drawable
    Renderer.prototype.drawDrawable = function (target, drawable, camera, clipping, light, shadow, cullFace) {
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        if (!cullFace) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
            gl.frontFace(cullFace);
        }
        this.renderState.viewport(camera.viewport);
        this.renderState.useShader(drawable.shader, camera, clipping, light, shadow);
        drawable.material.use(drawable.shader);
        drawable.transform.use(camera, drawable.shader);
        this.renderState.useMesh(drawable.mesh);
        drawable.mesh.render();
    };
    // Draw an element
    Renderer.prototype.drawElements = function (target, elements, camera, clipping, light, shadow, cullFace, overridedShaders, overridedMaterial) {
        if (elements.length === 0) {
            return;
        }
        if (overridedMaterial !== null && overridedMaterial.transparent) {
            var originalBlend = target._options.blend;
            target._options.blend = true;
            target.always = true;
        }
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        if (!cullFace) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
            gl.frontFace(cullFace);
        }
        this.renderState.viewport(camera.viewport);
        if (overridedShaders && overridedShaders[0] !== null) {
            for (var i = 0, len = elements.length; i < len; i++) {
                var element = elements[i];
                var drawable = element.drawable;
                // We need to check visibility of drawable of node. If drawable
                // is hidden, the node should be off too.
                if (!drawable.visible) {
                    continue;
                }
                if (drawable.billboard) {
                    drawable.update(camera);
                }
                var shader = null;
                // Choose shader base on drawable type
                if (drawable.transform.identity) {
                    shader = overridedShaders[0];
                }
                else if (drawable.isInstancing()) {
                    shader = overridedShaders[2];
                }
                else {
                    shader = overridedShaders[1];
                }
                // Bind the shader to the pipeline and update global uniforms.
                this.renderState.useShader(shader, camera, clipping, light, shadow);
                // Update uniforms in the materials.
                overridedMaterial.absorb(drawable.material);
                overridedMaterial.use(shader);
                this.renderState.useMesh(drawable.mesh);
                indices[0] = element.indicesOffset;
                indices[1] = element.indicesCount;
                if (drawable.isInstancing()) { // instanced
                    drawable.renderBaseInstance(camera, shader, indices);
                }
                else {
                    drawable.render(camera, shader, indices);
                }
            }
        }
        else {
            for (var i = 0, len = elements.length; i < len; i++) {
                var element = elements[i];
                var drawable = element.drawable;
                // We need to check visibility of drawable of node. If drawable
                // is hidden, the node should be off too.
                if (!drawable.visible) {
                    continue;
                }
                if (drawable.billboard) {
                    drawable.update(camera);
                }
                // Bind the shader to the pipeline and update global uniforms.
                this.renderState.useShader(drawable.shader, camera, clipping, light, shadow);
                // Update uniforms in the materials.
                drawable.material.use(drawable.shader);
                this.renderState.useMesh(drawable.mesh);
                indices[0] = element.indicesOffset;
                indices[1] = element.indicesCount;
                if (drawable.isInstancing()) { // instanced
                    drawable.renderBaseInstance(camera, drawable.shader, indices);
                }
                else {
                    drawable.render(camera, drawable.shader, indices);
                }
            }
        }
        if (overridedMaterial !== null && overridedMaterial.transparent) {
            target._options.blend = originalBlend;
            target.always = false;
        }
    };
    Renderer.prototype.drawGizmo = function (target, drawable, camera, cullFace) {
        this.drawDrawable(target, drawable, camera, null, null, null, cullFace);
    };
    // Draw a screen quad but constrained by current viewport.
    Renderer.prototype.drawScreen = function (target, shader, material) {
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        gl.disable(gl.CULL_FACE);
        this.renderState.useShader(shader);
        material.use(shader);
        this.renderState.useMesh(this._quadMesh);
        this._quadMesh.render();
    };
    // A custom callback function will be called before draw each drawable.
    Renderer.prototype.drawDrawablesCustom = function (target, drawables, camera, overridedShaders, overridedMaterial, clipping, cullFace, onMaterialCallback) {
        if (drawables.length === 0) {
            return;
        }
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        if (cullFace) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
            gl.frontFace(gl.CCW);
        }
        this.renderState.viewport(camera.viewport);
        // If the the scene is not contained by the camera frustum, we can skip
        // culling testing of each individual drawable.
        for (var i = 0, len = drawables.length; i < len; i++) {
            var drawable = drawables[i];
            if (!drawable.visible || camera.cull(drawable, indices)) {
                continue;
            }
            indices[0] = 0;
            indices[1] = drawable.mesh.length;
            var shader = null;
            // Choose shader base on drawable type
            if (drawable.transform.identity) {
                shader = overridedShaders[0];
            }
            else if (drawable.isInstancing()) {
                shader = overridedShaders[2];
            }
            else {
                shader = overridedShaders[1];
            }
            // Bind the material's shader to the pipeline and update
            // uniforms in the materials.
            this.renderState.useShader(shader, camera, clipping);
            onMaterialCallback(i, overridedMaterial);
            overridedMaterial.use(shader);
            this.renderState.useMesh(drawable.mesh);
            drawable.render(camera, shader, indices);
        }
    };
    // A custom callback function will be called before draw each drawable
    Renderer.prototype.drawNodesCustom = function (target, nodes, camera, overridedShaders, overridedMaterial, clipping, cullFace, onMaterialCallback) {
        if (nodes.length === 0) {
            return;
        }
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        if (cullFace) {
            gl.disable(gl.CULL_FACE);
        }
        else {
            gl.enable(gl.CULL_FACE);
            gl.frontFace(gl.CCW);
        }
        this.renderState.viewport(camera.viewport);
        // Sort the nodes before rendering to reduce the mesh switches.
        nodes.sort(function (a, b) {
            return a.drawable.name < b.drawable.name;
        });
        for (var i = 0, len = nodes.length; i < len; i++) {
            var node = nodes[i];
            var drawable = node.drawable;
            if (drawable.billboard) {
                drawable.update(camera);
            }
            var shader = null;
            // Choose shader base on drawable type
            if (drawable.transform.identity) {
                shader = overridedShaders[0];
            }
            else if (drawable.isInstancing()) {
                shader = overridedShaders[2];
            }
            else {
                shader = overridedShaders[1];
            }
            // Bind the shader to the pipeline;
            this.renderState.useShader(shader, camera, clipping);
            onMaterialCallback(i, overridedMaterial);
            overridedMaterial.use(shader);
            this.renderState.useMesh(drawable.mesh);
            indices[0] = node.indicesOffset;
            indices[1] = node.indicesCount;
            if (drawable.isInstancing()) { // instanced
                drawable.renderBaseInstance(camera, shader, indices);
            }
            else {
                drawable.render(camera, shader, indices);
            }
        }
    };
    Renderer.prototype.drawSkybox = function (target, drawable, camera) {
        if (this._renderTarget !== target || this._renderTarget.always) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        gl.disable(gl.CULL_FACE);
        this.renderState.viewport(camera.viewport);
        this.renderState.useShader(drawable.shader, camera);
        drawable.material.use(drawable.shader);
        drawable.transform.use(camera, drawable.shader);
        this.renderState.useMesh(drawable.mesh);
        drawable.mesh.render();
    };
    Renderer.prototype.beginFrame = function () {
        this.renderState.invalidateStates();
    };
    Renderer.prototype.endFrame = function () {
        // The shader's uniform should have been cleaned.
        this.renderState.dirtyBits = 0;
    };
    // Draw a full screen quad
    Renderer.prototype.invalidate = function () {
        this._renderTarget = null;
        this.renderState.dirtyBits = _m3d_renderstate_js__WEBPACK_IMPORTED_MODULE_0__["default"].ALL_DIRTY_BIT;
    };
    // clear the defualt framebuffer's depth and color buffer.
    Renderer.prototype.clear = function (target, clearBits) {
        if (this._renderTarget !== target) {
            this._renderTarget = target;
            this._renderTarget.render(this.renderState);
        }
        gl.clear(clearBits);
    };
    Renderer.prototype.restore = function () {
    };
    Renderer.prototype.discard = function () {
    };
    // Render framebuffer to window buffer
    Renderer.prototype.present = function (framebuffer) {
        if (gl.isWebGL2) {
            this._resourceManager.getFramebuffer("default").copy(framebuffer, gl.COLOR_BUFFER_BIT);
        }
    };
    return Renderer;
})());


/***/ }),

/***/ "./04renderer/pipeline/m3d_renderstate.js":
/*!************************************************!*\
  !*** ./04renderer/pipeline/m3d_renderstate.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
//
// m3d_renderstate.js
// The render states
//
// Copyright Modelo XX - 2018, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var perFrameData = new Float32Array(36);
    function RenderState() {
        // public:
        this.dirtyBits = (0xffffffff | 0); // Set dirty initially
        // private:
        // Rendering state 
        this._framebuffer = null; // The current framebuffer
        this._mesh = null; // The current mesh
        this._shader = null; // The current shader
        // More rendering states
        this._clearColor = new Float32Array([1.0, 1.0, 1.0, 0.0]);
        this._colorMask = new Int32Array([1, 1, 1, 1]);
        this._depthTest = true;
        this._clearDepth = 1.0;
        this._depthFunc = gl.LESS;
        this._viewport = new Int32Array([0, 0, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height]);
        this._planesArray = new Float32Array(24);
        this._blend = false;
        this._stencilTest = false;
        this._stencilOp = [gl.KEEP, gl.KEEP, gl.REPLACE];
        this._stencilFunc = [gl.ALWAYS, 0, -1];
        // Initialize OpenGL states
        gl.enable(gl.CULL_FACE);
        gl.frontFace(gl.CCW);
        // FIXME: line width does not work in Chrome using ANGLE.
        gl.lineWidth(1);
        gl.clearColor(this._clearColor[0], this._clearColor[1], this._clearColor[2], this._clearColor[3]);
        gl.colorMask(this._colorMask[0], this._colorMask[1], this._colorMask[2], this._colorMask[3]);
        gl.clearStencil(0);
        if (this._depthTest) {
            gl.enable(gl.DEPTH_TEST);
        }
        else {
            gl.disable(gl.DEPTH_TEST);
        }
        gl.clearDepth(this._clearDepth);
        gl.depthFunc(this._depthFunc);
        if (this._blend) {
            gl.enable(gl.BLEND);
        }
        else {
            gl.disable(gl.BLEND);
        }
        // TODO: save the state of blend func
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        if (this._stencilTest) {
            gl.enable(gl.STENCIL_TEST);
        }
        else {
            gl.disable(gl.STENCIL_TEST);
        }
        gl.viewport(this._viewport[0], this._viewport[1], this._viewport[2], this._viewport[3]);
    }
    ;
    RenderState.CLIP_DIRTY_BIT = (1 | 0);
    RenderState.LIGHT_DIRTY_BIT = (2 | 0);
    RenderState.SHADOW_DIRTY_BIT = (4 | 0);
    RenderState.MATERIAL_DIRTY_BIT = (8 | 0);
    RenderState.PLATTE_DIRTY_BIT = (16 | 0);
    RenderState.OTHER_DIRTY_BIT = (32 | 0);
    RenderState.ALL_DIRTY_BIT =
        (RenderState.CLIP_DIRTY_BIT |
            RenderState.LIGHT_DIRTY_BIT |
            RenderState.SHADOW_DIRTY_BIT |
            RenderState.MATERIAL_DIRTY_BIT |
            RenderState.PLATTE_DIRTY_BIT |
            RenderState.OTHER_DIRTY_BIT);
    RenderState.prototype.useShader = function (shader, camera, clipping, light, shadow, materials, vertexBaseId) {
        if (shader !== this._shader || this.dirtyBits) {
            if (shader !== null) {
                if (shader !== this._shader) {
                    shader.use();
                }
                //update the shadow when render each drawable but we don't need to do this.
                //checking if the shadow is not null and if two drawables' shader is same then
                //update the shadow
                if ((shader !== this._shader) && shadow && !(this.dirtyBits & RenderState.SHADOW_DIRTY_BIT)) {
                    this.dirtyBits |= RenderState.SHADOW_DIRTY_BIT;
                }
                // Update some uniforms only when their CPU values are changed.
                if (this.dirtyBits) {
                    if (this.dirtyBits & RenderState.CLIP_DIRTY_BIT) {
                        this._syncGlobalUniforms(shader.reservedUniforms, clipping);
                    }
                    if (this.dirtyBits & RenderState.LIGHT_DIRTY_BIT) {
                        this._syncLightUniforms(shader.reservedUniforms, light, shadow);
                    }
                    if (this.dirtyBits & RenderState.MATERIAL_DIRTY_BIT) {
                        this._syncMaterialsUniforms(shader.reservedUniforms, materials);
                    }
                    if (this.dirtyBits & RenderState.SHADOW_DIRTY_BIT) {
                        this._syncShadowUniforms(shader.reservedUniforms, shadow);
                        this.dirtyBits &= ~(RenderState.SHADOW_DIRTY_BIT);
                    }
                    if (this.dirtyBits & RenderState.PLATTE_DIRTY_BIT) {
                        this._syncPlatteUniforms(shader.reservedUniforms);
                    }
                }
                // Update some other every frame.
                var uniform;
                if (gl.isWebGL2) {
                    uniform = shader.reservedUniforms["m_uPerFrame"];
                    if (uniform) {
                        camera.uniformBlock.set(camera.viewMatrix, 0);
                        camera.uniformBlock.set(camera.vpMatrix, 16);
                        if (camera.isPerspective()) {
                            camera.uniformBlock[32] = camera.eye[0];
                            camera.uniformBlock[33] = camera.eye[1];
                            camera.uniformBlock[34] = camera.eye[2];
                            camera.uniformBlock[35] = 1;
                        }
                        else {
                            var d = camera.getViewDirection();
                            camera.uniformBlock[32] = -d[0];
                            camera.uniformBlock[33] = -d[1];
                            camera.uniformBlock[34] = -d[2];
                            camera.uniformBlock[35] = 0;
                        }
                        uniform.upload(camera.uniformBlock);
                    }
                    uniform = shader.reservedUniforms["m_uBaseVertexOffset"];
                    if (uniform) {
                        uniform.upload(vertexBaseId);
                    }
                }
                else {
                    uniform = shader.reservedUniforms["m_uPerFrame.vpMatrix"];
                    if (uniform) {
                        uniform.upload(camera.vpMatrix);
                    }
                    uniform = shader.reservedUniforms["m_uPerFrame.viewMatrix"];
                    if (uniform) {
                        uniform.upload(camera.viewMatrix);
                    }
                    uniform = shader.reservedUniforms["m_uPerFrame.cameraPosition"];
                    if (uniform) {
                        var v;
                        if (camera.isPerspective()) {
                            v = camera.eye;
                        }
                        else {
                            var d = camera.getViewDirection();
                            d[0] = -d[0];
                            d[1] = -d[1];
                            d[2] = -d[2];
                            v = d;
                        }
                        uniform.upload(v);
                    }
                }
            }
            this._shader = shader;
        }
    };
    RenderState.prototype.useFramebuffer = function (framebuffer) {
        if (this._framebuffer !== framebuffer) {
            this._framebuffer = framebuffer;
            this._framebuffer.use();
        }
    };
    RenderState.prototype.useMesh = function (mesh) {
        if (this._mesh !== mesh) {
            this._mesh = mesh;
            this._mesh.use();
        }
    };
    RenderState.prototype.clearColor = function (clearColor) {
        if (clearColor[0] !== this._clearColor[0] ||
            clearColor[1] !== this._clearColor[1] ||
            clearColor[2] !== this._clearColor[2] ||
            clearColor[3] !== this._clearColor[3]) {
            this._clearColor[0] = clearColor[0];
            this._clearColor[1] = clearColor[1];
            this._clearColor[2] = clearColor[2];
            this._clearColor[3] = clearColor[3];
            gl.clearColor(this._clearColor[0], this._clearColor[1], this._clearColor[2], this._clearColor[3]);
        }
    };
    RenderState.prototype.colorMask = function (mask) {
        if (mask[0] !== this._colorMask[0] ||
            mask[1] !== this._colorMask[1] ||
            mask[2] !== this._colorMask[2] ||
            mask[3] !== this._colorMask[3]) {
            this._colorMask[0] = mask[0];
            this._colorMask[1] = mask[1];
            this._colorMask[2] = mask[2];
            this._colorMask[3] = mask[3];
            gl.colorMask(this._colorMask[0], this._colorMask[1], this._colorMask[2], this._colorMask[3]);
        }
    };
    RenderState.prototype.depthTest = function (depthTest, clearDepth, depthFunc) {
        if (this._depthTest !== depthTest) {
            this._depthTest = depthTest;
            if (this._depthTest) {
                gl.enable(gl.DEPTH_TEST);
            }
            else {
                gl.disable(gl.DEPTH_TEST);
            }
        }
        if (this._clearDepth !== clearDepth) {
            this._clearDepth = clearDepth;
            gl.clearDepth(this._clearDepth);
        }
        if (this._depthFunc !== depthFunc) {
            this._depthFunc = depthFunc;
            gl.depthFunc(this._depthFunc);
        }
    };
    RenderState.prototype.depthMask = function (depthMask) {
        if (this._depthMask !== depthMask) {
            this._depthMask = depthMask;
            gl.depthMask(this._depthMask);
        }
    };
    RenderState.prototype.viewport = function (viewport) {
        if (viewport[0] !== this._viewport[0] ||
            viewport[1] !== this._viewport[1] ||
            viewport[2] !== this._viewport[2] ||
            viewport[3] !== this._viewport[3]) {
            this._viewport[0] = viewport[0];
            this._viewport[1] = viewport[1];
            this._viewport[2] = viewport[2];
            this._viewport[3] = viewport[3];
            gl.viewport(this._viewport[0], this._viewport[1], this._viewport[2], this._viewport[3]);
        }
    };
    RenderState.prototype.blend = function (blend) {
        if (this._blend !== blend) {
            this._blend = blend;
            if (this._blend) {
                gl.enable(gl.BLEND);
            }
            else {
                gl.disable(gl.BLEND);
            }
        }
    };
    RenderState.prototype.stencilTest = function (stencil, func, op) {
        if (this._stencil !== stencil) {
            this._stencil = stencil;
            if (this._stencil) {
                gl.enable(gl.STENCIL_TEST);
            }
            else {
                gl.disable(gl.STENCIL_TEST);
            }
        }
        if (this._stencilFunc[0] !== func[0] ||
            this._stencilFunc[1] !== func[1] ||
            this._stencilFunc[2] !== func[2]) {
            this._stencilFunc[0] = func[0];
            this._stencilFunc[1] = func[1];
            this._stencilFunc[2] = func[2];
            gl.stencilFunc(func[0], func[1], func[2]);
        }
        if (this._stencilOp[0] !== op[0] ||
            this._stencilOp[1] !== op[1] ||
            this._stencilOp[2] !== op[2]) {
            this._stencilOp[0] = op[0];
            this._stencilOp[1] = op[1];
            this._stencilOp[2] = op[2];
            gl.stencilOp(op[0], op[1], op[2]);
        }
    };
    // Invalidate the current GPU states 
    RenderState.prototype.invalidateStates = function () {
        this._mesh = null;
        this._framebuffer = null;
        this._shader = null;
    };
    RenderState.prototype.invalidateShadow = function () {
        this.dirtyBits |= RenderState.SHADOW_DIRTY_BIT;
    };
    RenderState.prototype.invalidateLight = function () {
        this.dirtyBits |= RenderState.LIGHT_DIRTY_BIT;
    };
    RenderState.prototype.invalidateClip = function () {
        this.dirtyBits |= RenderState.CLIP_DIRTY_BIT;
    };
    RenderState.prototype.invalidateManager = function () {
        this.dirtyBits |= RenderState.MATERIAL_DIRTY_BIT;
    };
    RenderState.prototype.invalidatePlatte = function () {
        this.dirtyBits |= RenderState.PLATTE_DIRTY_BIT;
    };
    RenderState.prototype.invalidateOther = function () {
        this.dirtyBits |= RenderState.OTHER_DIRTY_BIT;
    };
    RenderState.prototype._syncGlobalUniforms = function (uniforms, clipping) {
        if (!clipping) {
            return;
        }
        var uniform;
        uniform = uniforms["m_uGlobal.clipPlanes[0]"];
        if (uniform) {
            var planes = clipping.getClippingPlanes();
            this._planesArray[0] = planes[0][0];
            this._planesArray[1] = planes[0][1];
            this._planesArray[2] = planes[0][2];
            this._planesArray[3] = -planes[0][3];
            this._planesArray[4] = planes[1][0];
            this._planesArray[5] = planes[1][1];
            this._planesArray[6] = planes[1][2];
            this._planesArray[7] = -planes[1][3];
            this._planesArray[8] = planes[2][0];
            this._planesArray[9] = planes[2][1];
            this._planesArray[10] = planes[2][2];
            this._planesArray[11] = -planes[2][3];
            this._planesArray[12] = planes[3][0];
            this._planesArray[13] = planes[3][1];
            this._planesArray[14] = planes[3][2];
            this._planesArray[15] = -planes[3][3];
            this._planesArray[16] = planes[4][0];
            this._planesArray[17] = planes[4][1];
            this._planesArray[18] = planes[4][2];
            this._planesArray[19] = -planes[4][3];
            this._planesArray[20] = planes[5][0];
            this._planesArray[21] = planes[5][1];
            this._planesArray[22] = planes[5][2];
            this._planesArray[23] = -planes[5][3];
            uniform.upload(this._planesArray);
        }
    };
    RenderState.prototype._syncLightUniforms = function (uniforms, light) {
        if (!light) {
            return;
        }
        var uniform;
        // sun light
        uniform = uniforms["m_uSunLight.intensity"];
        if (uniform) {
            uniform.upload(light.intensity);
            // uniform = uniforms["m_uSunLight.diffuseMatrix[0]"];
            // uniform.upload(light.envmapMatrix);
            // TODO: in PBS, we will need GB channels of diffuse matrix.
            //uniform = uniforms["m_uSunLight.diffuseMatrix[1]"];
            //uniform.upload(light.envmapMatrix);
            //uniform = uniforms["m_uSunLight.diffuseMatrix[2]"];
            //uniform.upload(light.envmapMatrix);
            // uniform = uniforms["m_uSunLight.direction"];
            // uniform.upload(light.direction);
        }
        uniform = uniforms["m_uSunLight.diffuseMatrix[0]"];
        if (uniform) {
            uniform.upload(light.envmapMatrix);
        }
        uniform = uniforms["m_uSunLight.direction"];
        if (uniform) {
            uniform.upload(light.direction);
        }
    };
    RenderState.prototype._syncShadowUniforms = function (uniforms, shadow) {
        if (!shadow) {
            return;
        }
        var uniform = uniforms["m_uShadowSize"];
        if (uniform) {
            uniform.upload(shadow.size);
            if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
                uniform = uniforms["m_uShadowFine"];
                uniform.upload(shadow.fine ? 1.0 : 0.0);
                uniform = uniforms["m_uShadowSplit"];
                uniform.upload(shadow.shadowSplit);
            }
            for (var i = 0, len = shadow.shadowMaps.length; i < len; i++) {
                uniform = uniforms["m_uShadowTexture" + i];
                if (uniform) {
                    uniform.upload(6 + i);
                    shadow.shadowMaps[i].use(6 + i);
                }
                uniform = uniforms["m_uSunLight.shadowMatrix" + i];
                if (uniform) {
                    uniform.upload(shadow.shadowMatrices[i]);
                }
            }
        }
    };
    // Sync global material uniforms.
    RenderState.prototype._syncMaterialsUniforms = function (uniforms, materials) {
        if (!materials) {
            return;
        }
        var uniform = uniforms["m_uMaterialTexture"];
        if (uniform) {
            uniform.upload(4);
            materials.texture.use(4);
        }
    };
    RenderState.prototype._syncPlatteUniforms = function (uniforms) {
        var uniform = uniforms["m_uPlatteTexture"];
        if (uniform) {
            uniform.upload(10);
        }
    };
    return RenderState;
})());


/***/ }),

/***/ "./04renderer/rendereffects/Blur.ts":
/*!******************************************!*\
  !*** ./04renderer/rendereffects/Blur.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _02resource_m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_source.js */ "./02resource/m3d_shader_source.js");
/* harmony import */ var _m3d_blit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../m3d_blit.js */ "./04renderer/m3d_blit.js");
// Blur.ts
// smooth a floating texture, used in SSAO and HBAO (not avaiable on mobile)
//
// Copyright Modelo XX - 2017, All rights reserved.



var Blur = /** @class */ (function () {
    function Blur(resourceManager, radius, sigma) {
        this.ready = false;
        this.result = null;
        var xBlurShaderName = "blurx-" + radius;
        var yBlurShaderName = "blury-" + radius;
        if (!_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][xBlurShaderName] ||
            !_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][yBlurShaderName]) {
            var kernel = [];
            var sum = 0;
            var i;
            for (i = -radius; i <= radius; ++i) {
                var t = i / radius * 1.5;
                var v = Math.exp(-t * t * sigma);
                kernel.push(v);
                sum += v;
            }
            for (i = 0; i < radius * 2 + 1; ++i) {
                kernel[i] /= sum;
            }
        }
        if (!_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][xBlurShaderName]) {
            var XFSSOURCE = "vec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\n" +
                "{\n" +
                "    vec4 value = vec4(0);\n" +
                "    float kernel[" + (2 * radius + 1) + "];\n";
            for (var i_1 = 0; i_1 < radius * 2 + 1; ++i_1) {
                XFSSOURCE += "   kernel[" + i_1 + "] = " + kernel[i_1] + ";\n";
            }
            XFSSOURCE += "    for (int i = -" + radius + "; i <= " + radius + "; i++)\n";
            if (gl.isWebGL2) {
                XFSSOURCE += "        value += texture(tex, (gl_FragCoord.xy + vec2(float(i), 0.0)) * invResolution) * kernel[i + " + radius + "];\n";
            }
            else {
                XFSSOURCE += "        value += texture2D(tex, (gl_FragCoord.xy + vec2(float(i), 0.0)) * invResolution) * kernel[i + " + radius + "];\n";
            }
            XFSSOURCE += "    return value;\n" +
                "}\n";
            _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][xBlurShaderName] = new _02resource_m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_1__["default"](xBlurShaderName, "blit.vs", ["blit.fs", XFSSOURCE], {
                "highPrecision": true,
                "position": true,
                "uv": true
            });
        }
        if (!_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][yBlurShaderName]) {
            var YFSSOURCE = "vec4 shade(in sampler2D tex, in vec2 uv, in vec2 invResolution)\n" +
                "{\n" +
                "    vec4 value = vec4(0);\n" +
                "    float kernel[" + (2 * radius + 1) + "];\n";
            for (var i_2 = 0; i_2 < radius * 2 + 1; ++i_2) {
                YFSSOURCE += "   kernel[" + i_2 + "] = " + kernel[i_2] + ";\n";
            }
            YFSSOURCE += "    for (int i = -" + radius + "; i <= " + radius + "; i++)\n";
            if (gl.isWebGL2) {
                YFSSOURCE += "        value += texture(tex, (gl_FragCoord.xy + vec2(0.0, float(i))) * invResolution) * kernel[i + " + radius + "];\n";
            }
            else {
                YFSSOURCE += "        value += texture2D(tex, (gl_FragCoord.xy + vec2(0.0, float(i))) * invResolution) * kernel[i + " + radius + "];\n";
            }
            YFSSOURCE += "    return value;\n" +
                "} ";
            _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][yBlurShaderName] = new _02resource_m3d_shader_source_js__WEBPACK_IMPORTED_MODULE_1__["default"](yBlurShaderName, "blit.vs", ["blit.fs", YFSSOURCE], {
                "highPrecision": true,
                "position": true,
                "uv": true
            });
        }
        this._blitx = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_2__["default"](resourceManager, _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][xBlurShaderName]);
        this._blity = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_2__["default"](resourceManager, _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_0__["default"][yBlurShaderName]);
        this.ready = this._blitx.ready && this._blity.ready;
    }
    Blur.prototype.destroy = function () {
        if (this.ready) {
            this._blitx.destroy();
            this._blitx = null;
            delete this._blitx;
            this._blity.destroy();
            this._blity = null;
            delete this._blity;
            this.ready = false;
        }
    };
    /**
     * @param renderTarget1 {object} - the input render target to be smoothed
     * @param renderTarget1 {object} - used as the ping-pong framebuffer.
     */
    Blur.prototype.smooth = function (renderTarget1, renderTarget2, renderer, iterations) {
        if (!this.ready) {
            console.error("'blur' is not ready.");
            return null;
        }
        if (renderTarget1.getWidth() != renderTarget2.getWidth() ||
            renderTarget1.getHeight() != renderTarget2.getHeight()) {
            console.error("'blur' requires two render targets in the same size.");
        }
        var renderTargets = [
            renderTarget1,
            renderTarget2,
        ];
        var index = 0;
        var i;
        for (i = 0; i < iterations; ++i) {
            // Smooth in X direction
            this._blitx.setTexture(renderTargets[index].getColorBuffer());
            this._blitx.render(renderer, renderTargets[1 - index]);
            index = 1 - index;
            // Smooth in Y direction
            this._blity.setTexture(renderTargets[index].getColorBuffer());
            this._blity.render(renderer, renderTargets[1 - index]);
            index = 1 - index;
        }
        this.result = renderTargets[index].getColorBuffer();
        return this.result;
    };
    return Blur;
}());
/* harmony default export */ __webpack_exports__["default"] = (Blur);
;


/***/ }),

/***/ "./04renderer/rendereffects/RenderEffect.ts":
/*!**************************************************!*\
  !*** ./04renderer/rendereffects/RenderEffect.ts ***!
  \**************************************************/
/*! exports provided: RenderEffectPriorityEnum, RenderEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderEffectPriorityEnum", function() { return RenderEffectPriorityEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderEffect", function() { return RenderEffect; });
// RenderEffect.ts
// The base class of render effects
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.
//
var RenderEffectPriorityEnum;
(function (RenderEffectPriorityEnum) {
    RenderEffectPriorityEnum[RenderEffectPriorityEnum["LOW"] = 0] = "LOW";
    RenderEffectPriorityEnum[RenderEffectPriorityEnum["NORMAL"] = 1] = "NORMAL";
    RenderEffectPriorityEnum[RenderEffectPriorityEnum["HIGH"] = 2] = "HIGH";
    RenderEffectPriorityEnum[RenderEffectPriorityEnum["VERY_HIGH"] = 3] = "VERY_HIGH";
})(RenderEffectPriorityEnum || (RenderEffectPriorityEnum = {}));
var RenderEffect = /** @class */ (function () {
    function RenderEffect(name, priority, renderScene) {
        this.name = name;
        this.priority = priority;
        this._renderScene = renderScene;
        this._enabled = false;
        this._ready = false;
        this._ready = this._initialize();
        if (!this._ready) {
            console.warn("RenderEffect " + name + " initialized failed!");
        }
    }
    RenderEffect.prototype.destroy = function () {
        this._renderScene = null;
        delete this._renderScene;
        this._ready = false;
    };
    RenderEffect.prototype.setEnabled = function (enabled) {
        if (this._ready) {
            this._enabled = enabled;
        }
    };
    RenderEffect.prototype.doesSupportMobile = function (isMobile) {
        return false;
    };
    RenderEffect.prototype.isEnabled = function () {
        return this._enabled;
    };
    RenderEffect.prototype.resize = function (width, height) {
    };
    /**
     * @param renderTarget {object} - The render target that this effect applies to.
     * @param prFrame {number} - The current progressive rendering frame if used in PR pipeline.
     */
    RenderEffect.prototype.draw = function (renderTarget, prFrame) {
        if (prFrame === void 0) { prFrame = -1; }
    };
    RenderEffect.prototype._initialize = function () {
        return true;
    };
    RenderEffect.prototype.setParameter = function (parameter, value) {
    };
    RenderEffect.prototype.getParameter = function (parameter) {
    };
    RenderEffect.prototype.onSceneChanged = function () {
    };
    RenderEffect.prototype.recompileShader = function (flag, enabled) {
    };
    return RenderEffect;
}());

;


/***/ }),

/***/ "./04renderer/rendereffects/RenderEffectLibrary.ts":
/*!*********************************************************!*\
  !*** ./04renderer/rendereffects/RenderEffectLibrary.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Sketch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sketch */ "./04renderer/rendereffects/Sketch.ts");
/* harmony import */ var _SSAO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SSAO */ "./04renderer/rendereffects/SSAO.ts");
// RenderEffectLibrary.ts
// Library of all effects
// Hongwei Li (lihongwei@modeloapp.com)
//
// Copyright Modelo XX - 2018, All rights reserved.
//


var RenderEffectLibrary = {
    "Sketch": _Sketch__WEBPACK_IMPORTED_MODULE_0__["default"],
    "SSAO": _SSAO__WEBPACK_IMPORTED_MODULE_1__["default"],
};
/* harmony default export */ __webpack_exports__["default"] = (RenderEffectLibrary);


/***/ }),

/***/ "./04renderer/rendereffects/SSAO.ts":
/*!******************************************!*\
  !*** ./04renderer/rendereffects/SSAO.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _m3d_blit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../m3d_blit.js */ "./04renderer/m3d_blit.js");
/* harmony import */ var _Blur__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Blur */ "./04renderer/rendereffects/Blur.ts");
/* harmony import */ var _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../m3d_samples.js */ "./04renderer/m3d_samples.js");
/* harmony import */ var _RenderEffect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RenderEffect */ "./04renderer/rendereffects/RenderEffect.ts");
/* harmony import */ var _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../pipeline/RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
//
// SSAO.ts
// Screen-screen AO (not supported on Mobile)
//
// Copyright Modelo XX - 2017, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var SSAO = /** @class */ (function (_super) {
    __extends(SSAO, _super);
    function SSAO(renderScene) {
        return _super.call(this, "SSAO", _RenderEffect__WEBPACK_IMPORTED_MODULE_5__["RenderEffectPriorityEnum"].HIGH, renderScene) || this;
    }
    SSAO.prototype._initialize = function () {
        _super.prototype._initialize.call(this);
        var resourceManager = this._renderScene.getResourceManager();
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._rt0 = new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_7__["default"]("ssao-rt0", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: true,
                colorFormat: gl.RGBA8,
                clearColor: [0, 0, 1, -1e10],
                colorBuffer: 0,
                colorFilter: gl.NEAREST,
                depthFormat: gl.DEPTH24_STENCIL8,
                depthBuffer: 1
            });
        }
        else {
            this._rt0 = new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_7__["default"]("ssao-rt0", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: true,
                colorFormat: gl.RGBA32F,
                clearColor: [0.0, 0.0, 1.0, 0.0],
                colorFilter: gl.NEAREST,
                depthBuffer: 0
            });
        }
        this._rt1 = new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_7__["default"]("ssao-rt1", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            colorFormat: gl.RGBA8,
            colorFilter: gl.LINEAR,
            colorBuffer: 0,
            depthBuffer: 0,
            depthTest: false
        });
        this._rt2 = new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_7__["default"]("ssao-rt2", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            colorFormat: gl.RGBA8,
            colorFilter: gl.LINEAR,
            colorBuffer: 1,
            depthBuffer: 0,
            depthTest: false
        });
        if (!this._rt0.ready || !this._rt1.ready || !this._rt2.ready) {
            return false;
        }
        // Create shaders.
        this._opaques = new _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_6__["default"](resourceManager, false, { mask: false, transparent: false, line: false });
        this._maskeds = new _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_6__["default"](resourceManager, false, { mask: true });
        var flags = ["VISIBILITY"];
        var scene = this._renderScene.getScene();
        if (scene.clipping.isEnabled()) {
            flags.push("CLIPPING");
        }
        if (scene.needRenderDoubleSided()) {
            flags.push("DOUBLESIDED");
        }
        if (scene.compressed) {
            flags.push("COMPRESSION");
        }
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            flags.push("ENCODE_NORMAL");
        }
        var shader1 = resourceManager.getShader("normaldepth", flags);
        if (!shader1.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["normaldepth"];
            shader1.createFromShaderSource(shaderSource, flags);
        }
        this._opaques.setOverridedShader(shader1);
        flags.push("ALPHATEST");
        var shader2 = resourceManager.getShader("normaldepth", flags);
        if (!shader2.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["normaldepth"];
            shader2.createFromShaderSource(shaderSource, flags);
        }
        this._maskeds.setOverridedShader(shader2);
        this._opaques.setOverridedMaterial(scene.materialManager.createMaterialAdhoc("ssao"));
        this._maskeds.setOverridedMaterial(scene.materialManager.createMaterialAdhoc("ssao"));
        // Other utilities
        this._blur = new _Blur__WEBPACK_IMPORTED_MODULE_3__["default"](resourceManager, 1, 0.8);
        this._blit = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_2__["default"](resourceManager, _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["ssao"], _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile);
        this._blit.setTexture(this._rt0.getColorBuffer());
        this._bitblit = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_2__["default"](resourceManager);
        return this._blur.ready;
    };
    SSAO.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    SSAO.prototype.destroy = function () {
        if (this._ready) {
            this._rt0.destroy();
            this._rt0 = null;
            delete this._rt0;
            this._rt1.destroy();
            this._rt1 = null;
            delete this._rt1;
            this._rt2.destroy();
            this._rt2 = null;
            delete this._rt2;
            this._blur.destroy();
            this._blur = null;
            delete this._blur;
            this._blit.destroy();
            this._blit = null;
            delete this._blit;
            this._maskeds.destroy();
            this._maskeds = null;
            delete this._maskeds;
            this._opaques.destroy();
            this._opaques = null;
            delete this._opaques;
        }
        _super.prototype.destroy.call(this);
    };
    SSAO.prototype.recompileShader = function (flag, enabled) {
        if (this._ready) {
            this._opaques.recompileOverridedShader(flag, enabled);
            this._maskeds.recompileOverridedShader(flag, enabled);
        }
    };
    SSAO.prototype.resize = function (width, height) {
        if (this._ready) {
            this._ready = false;
            this._rt0.resize(width, height);
            this._rt1.resize(width, height);
            this._rt2.resize(width, height);
            this._ready = (this._rt0.ready &&
                this._rt1.ready &&
                this._rt2.ready);
            if (!this._ready) {
                this._ready = true;
                this.destroy();
            }
        }
    };
    SSAO.prototype.draw = function (renderTarget, prFrame) {
        if (prFrame === void 0) { prFrame = -1; }
        if (!this._ready || !this._enabled) {
            return;
        }
        // Only used in PR mode.
        if (!prFrame || prFrame < 1) {
            return;
        }
        prFrame -= 1;
        var renderer = this._renderScene.getRenderer();
        var lights = this._renderScene.getScene().getMainLight();
        var clipping = this._renderScene.getScene().clipping;
        var camera = this._renderScene.getCamera();
        var scene = this._renderScene.getScene();
        // 1. Render the scene (only opaques) with current camera and
        // obtain the eyespace depth and normals. 
        //
        // Since camera doesn't change much in PR frames, we only generate
        // normal and depth at the first frame.
        // FIXME: The downside is since we already downsize the SSAO offline screen,
        // it is very easy to miss the rasterization of thin (like lines) objects
        // and cause holes on the depth normal buffer.
        //
        if (prFrame === 0) {
            renderer.clear(this._rt0, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            camera.resize(this._rt0.getWidth(), this._rt0.getHeight());
            this._opaques.render(this._rt0, renderer, camera, null, clipping, lights);
            this._maskeds.render(this._rt0, renderer, camera, null, clipping, lights);
            camera.resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
            this._blit.setParameter("uNearAxis", camera.getNearPlaneSize());
            this._blit.setParameter("uIsPerspective", camera.isPerspective());
            this._blit.setParameter("uTexTransform", [1, 0]); // FIXME: Note this value is not correct in VR mode.
            this._blit.setParameter("uRadius", 5.0 / scene.scaleRatio);
            this._blit.setParameter("uTexSizeAndInv", [this._rt0.getWidth(),
                this._rt0.getHeight(),
                1.0 / this._rt0.getWidth(),
                1.0 / this._rt0.getHeight()]);
            if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
                this._blit.setParameter("uNearFar", [camera._znear, camera._zfar]);
                this._blit.setDepthTexture(this._rt0.getDepthBuffer());
            }
        }
        // 2. Generate AO
        this._blit.setParameter("uFrameCount", prFrame);
        this._blit.setParameter("SAMPLES[0]", _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__["default"]._8x8_2D_LIST[prFrame]);
        renderer.renderState.viewport([0, 0, this._rt1.getWidth(), this._rt1.getHeight()]);
        this._blit.render(renderer, this._rt1);
        // 3. Smooth AO
        var texture = this._blur.smooth(this._rt1, this._rt2, renderer, 1);
        // 4. Multiply the current color buffer with AO and don't change the alpha value.
        this._bitblit.setTexture(texture);
        //this._bitblit.setTexture(this._rt1.getColorBuffer());
        // FIXME: don't change the blend func instead changing the shader output.
        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.ONE);
        renderer.renderState.viewport([0, 0, renderTarget.getWidth(), renderTarget.getHeight()]);
        // Only compute AO at the scene pixels.
        this._bitblit.render(renderer, renderTarget, true, true);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    };
    SSAO.prototype.onSceneChanged = function () {
        if (!this._ready) {
            return;
        }
        var opaques = this._renderScene.getOpaques();
        var maskeds = this._renderScene.getMaskeds();
        this._opaques.queue.copy(opaques.queue);
        this._maskeds.queue.copy(maskeds.queue);
        this._opaques.setCullFace(opaques.getCullFace());
        this._maskeds.setCullFace(maskeds.getCullFace());
    };
    return SSAO;
}(_RenderEffect__WEBPACK_IMPORTED_MODULE_5__["RenderEffect"]));
/* harmony default export */ __webpack_exports__["default"] = (SSAO);
;


/***/ }),

/***/ "./04renderer/rendereffects/Sketch.ts":
/*!********************************************!*\
  !*** ./04renderer/rendereffects/Sketch.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _RenderEffect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RenderEffect */ "./04renderer/rendereffects/RenderEffect.ts");
/* harmony import */ var _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pipeline/RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _m3d_blit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../m3d_blit.js */ "./04renderer/m3d_blit.js");
//
// Sketch.ts
// Sketch effect
//
// Copyright Modelo XX - 2017, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var Sketch = /** @class */ (function (_super) {
    __extends(Sketch, _super);
    function Sketch(renderScene) {
        return _super.call(this, "Sketch", _RenderEffect__WEBPACK_IMPORTED_MODULE_2__["RenderEffectPriorityEnum"].NORMAL, renderScene) || this;
    }
    Sketch.prototype._initialize = function () {
        _super.prototype._initialize.call(this);
        var resourceManager = this._renderScene.getResourceManager();
        this._color = [0, 0, 0];
        this._surfaceColor = [1, 1, 1, 1];
        this._blit = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_5__["default"](resourceManager, _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["sketch"], _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile);
        var materialManager = this._renderScene.getScene().materialManager;
        this._material = materialManager.createMaterialAdhoc("sketch-surface");
        this.setParameter("contrast", 30);
        this.setParameter("detail", 2);
        this.setParameter("colored", false);
        this.setParameter("color", [0, 0, 0]);
        this.setParameter("surfaceColor", [1, 1, 1, 1]);
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._renderTarget = new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("sketch-position", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: true,
                depthFunc: gl.LEQUAL,
                colorFormat: gl.RGBA8,
                clearColor: [0.5, 0.5, 1.0, 0.0],
                colorFilter: gl.NEAREST,
                depthFormat: gl.DEPTH_COMPONENT24,
                colorBuffer: 0,
                depthBuffer: 0
            });
        }
        else {
            this._renderTarget = new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("sketch-position", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
                depthTest: true,
                colorFormat: gl.RGBA32F,
                clearColor: [0.0, 0.0, 1.0, 0.0],
                colorFilter: gl.NEAREST,
                colorBuffer: 0,
                depthBuffer: 0
            });
        }
        if (!this._renderTarget.ready) {
            this._renderTarget.destroy();
            this._renderTarget = null;
            delete this._renderTarget;
            this._blit.destroy();
            this._blit = null;
            delete this._blit;
            return false;
        }
        this._opaques = new _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_3__["default"](resourceManager, false, { transparent: false, mask: false });
        this._maskeds = new _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_3__["default"](resourceManager, false, { mask: true });
        var flags = [];
        var scene = this._renderScene.getScene();
        if (scene.clipping.isEnabled()) {
            flags.push("CLIPPING");
        }
        if (scene.needRenderDoubleSided()) {
            flags.push("DOUBLESIDED");
        }
        if (scene.compressed) {
            flags.push("COMPRESSION");
        }
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            flags.push("ENCODE_NORMAL");
        }
        var shader;
        shader = resourceManager.getShader("normaldepth", flags);
        if (!shader.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["normaldepth"];
            shader.createFromShaderSource(shaderSource, flags);
        }
        this._opaques.setOverridedShader(shader);
        flags.push("ALPHATEST");
        shader = resourceManager.getShader("normaldepth", flags);
        if (!shader.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["normaldepth"];
            shader.createFromShaderSource(shaderSource, flags);
        }
        this._maskeds.setOverridedShader(shader);
        this._opaques.setOverridedMaterial(materialManager.createMaterialAdhoc("sketch"));
        this._maskeds.setOverridedMaterial(materialManager.createMaterialAdhoc("sketch"));
        return true;
    };
    Sketch.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    Sketch.prototype.destroy = function () {
        if (this._ready) {
            this._renderTarget.destroy();
            this._renderTarget = null;
            delete this._renderTarget;
            this._blit.destroy();
            this._blit = null;
            delete this._blit;
            this._opaques.destroy();
            this._opaques = null;
            delete this._opaques;
            this._maskeds.destroy();
            this._maskeds = null;
            delete this._maskeds;
            this._material.destroy();
            this._material = null;
            delete this._material;
            this._surfaceColor = null;
            delete this._surfaceColor;
            this._color = null;
            delete this._color;
        }
        _super.prototype.destroy.call(this);
    };
    Sketch.prototype.resize = function (width, height) {
        if (this._ready) {
            this._ready = false;
            this._renderTarget.resize(width, height);
            this._ready = this._renderTarget.ready;
            if (!this._ready) {
                this._ready = true;
                this.destroy();
            }
        }
    };
    Sketch.prototype.setParameter = function (parameter, value) {
        switch (parameter) {
            // detail ~ [0, 100]
            case "detail":
                var t = Math.min(Math.max(value, 0.0), 99.9) / 100.0;
                this._threshold = Math.sqrt(1.0 - t * t) * 0.55;
                this._blit.setParameter("uThreshold", this._threshold);
                this._detailout = value;
                break;
            // contrast ~ [0, 100]
            case "contrast":
                this._contrast = Math.min(Math.max(value, 0.0), 100.0);
                this._contrast = this._contrast / 100;
                this._blit.setParameter("uContrast", this._contrast);
                this._contrastout = value;
                break;
            case "colored":
                this._colored = value;
                if (this._colored) {
                    this._renderScene.setOverridedRenderingAppearance(null);
                }
                else {
                    this._renderScene.setOverridedRenderingAppearance(this._material);
                    this._material.setDiffuse(this._surfaceColor);
                    this._material.setTransparent(this._surfaceColor[3]);
                }
                break;
            case "color":
                this._color[0] = value[0];
                this._color[1] = value[1];
                this._color[2] = value[2];
                this._blit.setParameter("uColor", this._color);
                break;
            case "surfaceColor":
                this._surfaceColor[0] = value[0];
                this._surfaceColor[1] = value[1];
                this._surfaceColor[2] = value[2];
                this._surfaceColor[3] = value[3];
                this._material.setDiffuse(this._surfaceColor);
                this._material.setTransparent(this._surfaceColor[3]);
                break;
        }
    };
    Sketch.prototype.getParameter = function (parameter) {
        switch (parameter) {
            case "detail":
                return this._detailout;
            case "contrast":
                return this._contrastout;
            case "colored":
                return this._colored;
            case "color":
                return this._color;
            case "surfaceColor":
                return this._surfaceColor;
        }
    };
    Sketch.prototype.draw = function (renderTarget, frameIdx) {
        if (frameIdx === void 0) { frameIdx = -1; }
        if (!this._ready || !this._enabled) {
            return;
        }
        var camera = this._renderScene.getCamera();
        var renderer = this._renderScene.getRenderer();
        var lights = this._renderScene.getScene().getMainLight();
        var clipping = this._renderScene.getScene().clipping;
        // Render the positions and normals of drawables.
        renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this._opaques.render(this._renderTarget, renderer, camera, null, clipping, lights);
        this._maskeds.render(this._renderTarget, renderer, camera, null, clipping, lights);
        // Render the sketch strokes
        this._blit.setParameter("uNearAxis", camera.getNearPlaneSize());
        this._blit.setParameter("uIsPerspective", camera.isPerspective());
        this._blit.setTexture(this._renderTarget.getColorBuffer());
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._blit.setParameter("uNearFar", [camera._znear, camera._zfar]);
            this._blit.setDepthTexture(this._renderTarget.getDepthBuffer());
        }
        renderer.renderState.viewport([0, 0, renderTarget.getWidth(), renderTarget.getHeight()]);
        this._blit.render(renderer, renderTarget, true);
    };
    Sketch.prototype.onSceneChanged = function () {
        if (!this._ready) {
            return;
        }
        var opaques = this._renderScene.getOpaques();
        var maskeds = this._renderScene.getMaskeds();
        this._opaques.queue.copy(opaques.queue);
        this._maskeds.queue.copy(maskeds.queue);
        this._opaques.setCullFace(opaques.getCullFace());
        this._maskeds.setCullFace(maskeds.getCullFace());
    };
    Sketch.prototype.recompileShader = function (flag, enabled) {
        if (this._ready) {
            this._opaques.recompileOverridedShader(flag, enabled);
            this._maskeds.recompileOverridedShader(flag, enabled);
        }
    };
    Sketch.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
        if (this._ready) {
            if (!this._enabled) {
                this._renderScene.setOverridedRenderingAppearance(null);
            }
            else {
                this._renderScene.setOverridedRenderingAppearance(this._material);
            }
        }
    };
    return Sketch;
}(_RenderEffect__WEBPACK_IMPORTED_MODULE_2__["RenderEffect"]));
/* harmony default export */ __webpack_exports__["default"] = (Sketch);
;


/***/ }),

/***/ "./04renderer/shadow/Shadow.ts":
/*!*************************************!*\
  !*** ./04renderer/shadow/Shadow.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_camera_m3d_shadow_camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/camera/m3d_shadow_camera.js */ "./03scene/camera/m3d_shadow_camera.js");
/* harmony import */ var _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pipeline/RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
//
// Shadow.js
//
// Copyright Modelo XX - 2018, All rights reserved.
// The base class of real-time shadow.




var Shadow = /** @class */ (function () {
    function Shadow(renderScene) {
        this._renderScene = renderScene;
        // shadow map size.
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width < 512 && _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height < 512) {
            this.smSize = 1024;
        }
        else {
            this.smSize = 2048;
        }
        var scene = this._renderScene.getScene();
        var resourceManager = this._renderScene.getResourceManager();
        // render queue of shadow casters
        this._opaques = new _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_2__["default"](resourceManager, false, { shadowCaster: true, mask: false });
        this._maskeds = new _pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_2__["default"](resourceManager, false, { shadowCaster: true, mask: true });
        // Generate shadow shaders. In fact they are not used at as color mask will be set to false.
        var flags = ["VISIBILITY", "ONLY_DEPTH"];
        if (scene.clipping.isEnabled()) {
            flags.push("CLIPPING");
        }
        if (scene.compressed) {
            flags.push("COMPRESSION");
        }
        var shader1 = resourceManager.getShader("normaldepth", flags);
        if (!shader1.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__["default"]["normaldepth"];
            shader1.createFromShaderSource(shaderSource, flags);
        }
        this._opaques.setOverridedShader(shader1);
        flags.push("ALPHATEST");
        var shader2 = resourceManager.getShader("normaldepth", flags);
        if (!shader2.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__["default"]["normaldepth"];
            shader2.createFromShaderSource(shaderSource, flags);
        }
        this._maskeds.setOverridedShader(shader2);
        this._opaques.setOverridedMaterial(scene.materialManager.createMaterialAdhoc("shadow"));
        this._maskeds.setOverridedMaterial(scene.materialManager.createMaterialAdhoc("shadow"));
        this._lightCamera = new _03scene_camera_m3d_shadow_camera_js__WEBPACK_IMPORTED_MODULE_1__["default"](this._renderScene.getScene());
        this._lightCamera.setViewport([0, 0, this.smSize, this.smSize]);
        this._lightCamera.setCullingEnabled(true);
        this._renderTargets = [];
        this.shadowMaps = [];
        this.shadowMatrices = [];
        this.shadowSplit = 10000.0;
        this._ready = true;
    }
    Shadow.prototype.destroy = function () {
        this._opaques.destroy();
        this._opaques = null;
        delete this._opaques;
        this._maskeds.destroy();
        this._maskeds = null;
        delete this._maskeds;
        this._lightCamera.destroy();
        this._lightCamera = null;
        delete this._lightCamera;
        this._renderScene = null;
        delete this._renderScene;
        for (var i = 0; i < this._renderTargets.length; i++) {
            this._renderTargets[i].destroy();
        }
        this._renderTargets = null;
        delete this._renderTargets;
        this.shadowMatrices = null;
        delete this.shadowMatrices;
        this.shadowMaps = null;
        delete this.shadowMaps;
    };
    Shadow.prototype.recompileShader = function (flag, enabled) {
        this._opaques.recompileOverridedShader(flag, enabled);
        this._maskeds.recompileOverridedShader(flag, enabled);
    };
    Shadow.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    Shadow.prototype.draw = function (prFrame) {
        if (prFrame === void 0) { prFrame = -1; }
        if (!this._ready) {
            return;
        }
    };
    Shadow.prototype.onSceneChanged = function () {
        if (!this._ready) {
            return;
        }
        var opaques = this._renderScene.getOpaques();
        var maskeds = this._renderScene.getMaskeds();
        this._opaques.queue.copy(opaques.queue);
        this._maskeds.queue.copy(maskeds.queue);
        this._opaques.setCullFace(opaques.getCullFace());
        this._maskeds.setCullFace(maskeds.getCullFace());
    };
    return Shadow;
}());
/* harmony default export */ __webpack_exports__["default"] = (Shadow);
;


/***/ }),

/***/ "./04renderer/shadow/ShadowCSM.ts":
/*!****************************************!*\
  !*** ./04renderer/shadow/ShadowCSM.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_camera_m3d_shadow_camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/camera/m3d_shadow_camera.js */ "./03scene/camera/m3d_shadow_camera.js");
/* harmony import */ var _03scene_camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/camera/m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _Shadow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Shadow */ "./04renderer/shadow/Shadow.ts");
/* harmony import */ var _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../m3d_samples.js */ "./04renderer/m3d_samples.js");
/* harmony import */ var _ShadowHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShadowHelper */ "./04renderer/shadow/ShadowHelper.ts");
//
// ShadowCSM.js
// Cascaded shadow map
//
// Copyright Modelo XX - 2018, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var ShadowCSM = /** @class */ (function (_super) {
    __extends(ShadowCSM, _super);
    function ShadowCSM(renderScene) {
        var _this = _super.call(this, renderScene) || this;
        if (!_this._ready) {
            return _this;
        }
        _this._partitions = 2;
        _this.smSize = _this.smSize / _this._partitions;
        var resourceManager = _this._renderScene.getResourceManager();
        _this.shadowMaps = new Array(_this._partitions);
        _this.shadowMatrices = new Array(_this._partitions);
        _this._renderTargets = new Array(_this._partitions);
        _this._lightCameras = new Array(_this._partitions);
        _this._sceneCameras = new Array(_this._partitions);
        for (var i = 0; i < _this._partitions; i++) {
            // Split the frustum into two.
            _this._renderTargets[i] =
                new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_2__["default"]("shadowcsm-depth" + i, resourceManager, _this.smSize, _this.smSize, {
                    colorMask: [0, 0, 0, 0],
                    colorFormat: gl.R8,
                    colorBuffer: 0,
                    depthFilter: gl.NEAREST,
                    depthFormat: gl.DEPTH_COMPONENT24,
                    depthBuffer: i,
                });
            _this.shadowMaps[i] = _this._renderTargets[i].getDepthBuffer();
            _this.shadowMatrices[i] = mat4.create();
            _this._ready = (_this._ready && _this._renderTargets[i].ready);
            _this._lightCameras[i] = new _03scene_camera_m3d_shadow_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"](renderScene.getScene());
            _this._sceneCameras[i] = new _03scene_camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_1__["default"](renderScene.getScene());
        }
        return _this;
    }
    ShadowCSM.prototype.destroy = function () {
        this._lightCameras = null;
        delete this._lightCameras;
        this._sceneCameras = null;
        delete this._sceneCameras;
        _super.prototype.destroy.call(this);
    };
    // FIXME: We only allow 2 partitions any way.
    //public setPartitions(partitions: number) : void {
    //    if (this._partitions === partitions) {
    //        return ;
    //    }
    //    // We only allow 2 partitions any way.
    //    for (let i = 0; i < this._partitions; i++) {
    //        // Split the frustum into two.
    //        this._renderTargets[i].destroy();
    //    }
    //    this._partitions = partitions;
    //    if (Globals.width < 512 && Globals.height < 512) {
    //        this.smSize = 512;
    //    } else {
    //        this.smSize = 1024;
    //    }
    //    this._partitions = Math.min(Math.max(this._partitions, 2), 4);
    //    this.shadowMaps = new Array(this._partitions);
    //    this.shadowMatrices = new Array(this._partitions);
    //    this._lightCameras = new Array(this._partitions);
    //    this._renderTargets = new Array(this._partitions);
    //    
    //    const smSize = this.smSize / (this._partitions <= 3? 2 : 4);
    //    this._ready = false;
    //    const resourceManager = this._renderScene.getResourceManager();
    //    for (let i = 0; i < this._partitions; i++) {
    //        // Split the frustum into two.
    //        this._renderTargets[i] = 
    //            new RenderTarget("shadow-depth" + i, resourceManager,
    //                smSize, smSize, {
    //                    colorMask: [0, 0, 0, 0],
    //                    colorFormat: gl.R8,
    //                    depthFilter: gl.NEAREST,
    //                    depthFormat: gl.DEPTH_COMPONENT24,
    //                });
    //        
    //        this.shadowMaps[i] = this._renderTargets[i].getDepthBuffer();
    //        this.shadowMatrices[i] = mat4.create();
    //        this._ready = (this._ready && this._renderTargets[i]);
    //        
    //        this._lightCameras[i] = new ShadowCamera(this._renderScene.getScene());
    //    }
    //}
    ShadowCSM.prototype.draw = function (prFrame) {
        if (prFrame === void 0) { prFrame = -1; }
        if (!this._ready) {
            return;
        }
        if (prFrame === 1) {
            // Split the view frustum into partitions.
            var camera = this._renderScene.getCamera();
            var scene = this._renderScene.getScene();
            var splits = camera.split(this._partitions, this._sceneCameras);
            for (var i = 0; i < this._partitions; i++) {
                Object(_ShadowHelper__WEBPACK_IMPORTED_MODULE_5__["ComputeShadowCameraTight"])(scene, this._sceneCameras[i], this._lightCameras[i]);
                this._lightCameras[i].setViewport([0, 0, this.smSize, this.smSize]);
            }
            // 0.5 * ((2 * znear * zfar / splitDistance - znear - zfar) / (znear - zfar) + 1);
            // split distance is z, then the coord in the camera's view-space is [0, 0, -z, 1]
            // transform this with porjection matrix will get a [-1, 1] value, transform it to [0, 1] value then
            this.shadowSplit = (-camera.projectMatrix[10] + camera.projectMatrix[14] / splits[0] + 1) * 0.5;
        }
        prFrame -= 1;
        var dx = _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__["default"]._4x4_2D[prFrame * 2] - 0.5;
        var dy = _m3d_samples_js__WEBPACK_IMPORTED_MODULE_4__["default"]._4x4_2D[prFrame * 2 + 1] - 0.5;
        var renderer = this._renderScene.getRenderer();
        var lights = this._renderScene.getScene().getMainLight();
        var clipping = this._renderScene.getScene().clipping;
        for (var i = 0; i < this._partitions; i++) {
            this._lightCameras[i].jitter(dx / this.smSize, dy / this.smSize);
            renderer.renderState.invalidateOther();
            renderer.clear(this._renderTargets[i], gl.DEPTH_BUFFER_BIT);
            this._opaques.render(this._renderTargets[i], renderer, this._lightCameras[i], null, clipping, lights);
            this._maskeds.render(this._renderTargets[i], renderer, this._lightCameras[i], null, clipping, lights);
            mat4.copy(this.shadowMatrices[i], this._lightCameras[i].vpMatrix);
            this._lightCameras[i].jitter(-dx / this.smSize, -dy / this.smSize);
        }
    };
    return ShadowCSM;
}(_Shadow__WEBPACK_IMPORTED_MODULE_3__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (ShadowCSM);
;


/***/ }),

/***/ "./04renderer/shadow/ShadowController.ts":
/*!***********************************************!*\
  !*** ./04renderer/shadow/ShadowController.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ShadowESM__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShadowESM */ "./04renderer/shadow/ShadowESM.ts");
/* harmony import */ var _ShadowCSM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShadowCSM */ "./04renderer/shadow/ShadowCSM.ts");
//
// ShadowController.js
//
// Copyright Modelo XX - 2018, All rights reserved.
//
// Control the shadow map generation and rendering.


var ShadowController = /** @class */ (function () {
    function ShadowController(renderScene) {
        this.fine = false;
        this._enabled = false;
        this._coarseShadow = new _ShadowESM__WEBPACK_IMPORTED_MODULE_0__["default"](renderScene);
        // FIXME: need to hardcode the renderScene shadow toggle function to add CSM shader compiling flag.
        this._fineShadow = new _ShadowCSM__WEBPACK_IMPORTED_MODULE_1__["default"](renderScene);
        this.size = this._coarseShadow.smSize;
        this.shadowSplit = this._coarseShadow.shadowSplit;
    }
    ShadowController.prototype.destroy = function () {
        this.shadowMaps = null;
        delete this.shadowMaps;
        this.shadowMatrices = null;
        delete this.shadowMatrices;
        this._fineShadow.destroy();
        this._fineShadow = null;
        delete this._fineShadow;
        this._coarseShadow.destroy();
        this._coarseShadow = null;
        delete this._coarseShadow;
    };
    ShadowController.prototype.recompileShader = function (flag, enabled) {
        this._fineShadow.recompileShader(flag, enabled);
        this._coarseShadow.recompileShader(flag, enabled);
    };
    ShadowController.prototype.onSceneChanged = function () {
        this._fineShadow.onSceneChanged();
        this._coarseShadow.onSceneChanged();
    };
    ShadowController.prototype.draw = function (prFrame) {
        if (prFrame === void 0) { prFrame = -1; }
        if (!this._enabled) {
            return;
        }
        this.fine = prFrame > 0;
        if (this.fine) {
            this._fineShadow.draw(prFrame);
            this.shadowMaps = this._fineShadow.shadowMaps;
            this.shadowMatrices = this._fineShadow.shadowMatrices;
            this.size = this._fineShadow.smSize;
            this.shadowSplit = this._fineShadow.shadowSplit;
        }
        else {
            this._coarseShadow.draw(prFrame);
            this.shadowMaps = this._coarseShadow.shadowMaps;
            this.shadowMatrices = this._coarseShadow.shadowMatrices;
            this.size = this._coarseShadow.smSize;
            this.shadowSplit = this._coarseShadow.shadowSplit;
        }
    };
    ShadowController.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
    };
    return ShadowController;
}());
/* harmony default export */ __webpack_exports__["default"] = (ShadowController);
;


/***/ }),

/***/ "./04renderer/shadow/ShadowESM.ts":
/*!****************************************!*\
  !*** ./04renderer/shadow/ShadowESM.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _m3d_blit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../m3d_blit.js */ "./04renderer/m3d_blit.js");
/* harmony import */ var _Shadow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Shadow */ "./04renderer/shadow/Shadow.ts");
/* harmony import */ var _ShadowHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShadowHelper */ "./04renderer/shadow/ShadowHelper.ts");
//
// Shadow.js
//
// Copyright Modelo XX - 2018, All rights reserved.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// FIXME: don't use mobile shadow on Microsoft Surface (drop Globals.isMobile)






var ShadowESM = /** @class */ (function (_super) {
    __extends(ShadowESM, _super);
    function ShadowESM(renderScene) {
        var _this = _super.call(this, renderScene) || this;
        if (!_this._ready) {
            return _this;
        }
        _this.shadowMatrices.push(mat4.create());
        var resourceManager = _this._renderScene.getResourceManager();
        _this._renderTargets.push(new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_2__["default"]("shadowesm-depth", resourceManager, _this.smSize, _this.smSize, {
            colorMask: [0, 0, 0, 0],
            colorFormat: gl.R8,
            colorBuffer: 0,
            depthFilter: gl.NEAREST,
            depthFormat: gl.DEPTH_COMPONENT24,
            depthBuffer: 0
        }));
        if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            _this._renderTargets.push(new _pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_2__["default"]("shadowesm-smooth", resourceManager, _this.smSize, _this.smSize, {
                colorFormat: gl.R32F,
                colorFilter: gl.NEAREST,
                depthTest: false,
                depthBufer: 0
            }));
            _this._blit = new _m3d_blit_js__WEBPACK_IMPORTED_MODULE_3__["default"](resourceManager, _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["shadowsmooth"]);
            _this._blit.setTexture(_this._renderTargets[0].getDepthBuffer());
            _this.shadowMaps.push(_this._renderTargets[1].getColorBuffer());
            _this._ready = _this._blit.ready && _this._renderTargets[0].ready && _this._renderTargets[1].ready;
        }
        else {
            _this.shadowMaps.push(_this._renderTargets[0].getDepthBuffer());
            _this._ready = _this._renderTargets[0].ready;
        }
        return _this;
    }
    ShadowESM.prototype.destroy = function () {
        this._blit.destroy();
        this._blit = null;
        delete this._blit;
        _super.prototype.destroy.call(this);
    };
    ShadowESM.prototype.draw = function (prFrame) {
        if (prFrame === void 0) { prFrame = -1; }
        if (!this._ready) {
            return;
        }
        var scene = this._renderScene.getScene();
        Object(_ShadowHelper__WEBPACK_IMPORTED_MODULE_5__["ComputeShadowCamera"])(scene, this._lightCamera);
        mat4.copy(this.shadowMatrices[0], this._lightCamera.vpMatrix);
        this._lightCamera.setBimCullingEnabled(this._renderScene.getCamera().isBimCullingEnabled());
        var renderer = this._renderScene.getRenderer();
        var lights = this._renderScene.getScene().getMainLight();
        var clipping = this._renderScene.getScene().clipping;
        renderer.clear(this._renderTargets[0], gl.DEPTH_BUFFER_BIT);
        this._opaques.render(this._renderTargets[0], renderer, this._lightCamera, null, clipping, lights);
        this._maskeds.render(this._renderTargets[0], renderer, this._lightCamera, null, clipping, lights);
        if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._blit.render(renderer, this._renderTargets[1]);
        }
    };
    return ShadowESM;
}(_Shadow__WEBPACK_IMPORTED_MODULE_4__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (ShadowESM);
;


/***/ }),

/***/ "./04renderer/shadow/ShadowHelper.ts":
/*!*******************************************!*\
  !*** ./04renderer/shadow/ShadowHelper.ts ***!
  \*******************************************/
/*! exports provided: ComputeShadowCameraTight, ComputeShadowCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeShadowCameraTight", function() { return ComputeShadowCameraTight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputeShadowCamera", function() { return ComputeShadowCamera; });
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
//
// ShadowHelper.js
//
// Copyright Modelo XX - 2018, All rights reserved.
//
// A few helper functions for real-time shadow.

function ComputeShadowCameraTight(scene, camera, outCamera) {
    // Compute the tight bounding box of light frustum which is the intersection
    // of scene camera frustum and scene bbox.
    var frustum = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].frustum.createFromMatrix(camera.vpMatrix);
    var intersections = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].intersect.aabb_frustum(scene.clipping.get(), frustum);
    var direction = vec3.create();
    vec3.copy(direction, scene.getMainLight().direction);
    var scale = Math.min(0.005 + scene.radius / camera._distance * 0.01, 0.01);
    // create vector basis orthogonal to light direction
    var up = vec3.create();
    if (Math.abs(direction[0]) > Math.abs(direction[2])) {
        vec3.set(up, -direction[1], direction[0], 0.0);
    }
    else {
        vec3.set(up, 0.0, -direction[2], direction[1]);
    }
    vec3.normalize(up, up);
    var right = vec3.create();
    vec3.cross(right, direction, up);
    vec3.normalize(right, right);
    vec3.normalize(direction, direction);
    outCamera.createFromLightTight(direction, scene.clipping.get(), intersections);
    outCamera._cull.update();
}
function ComputeShadowCamera(scene, outCamera) {
    outCamera.createFromLight(scene.getMainLight().direction, scene.clipping.get());
    outCamera._cull.update();
}


/***/ }),

/***/ "./04renderer/volumeRenderer.ts":
/*!**************************************!*\
  !*** ./04renderer/volumeRenderer.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_drawables_m3d_drawable_library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../03scene/drawables/m3d_drawable_library.js */ "./03scene/drawables/m3d_drawable_library.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _02resource_m3d_texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../02resource/m3d_texture */ "./02resource/m3d_texture.js");
/* harmony import */ var _04renderer_m3d_blit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../04renderer/m3d_blit */ "./04renderer/m3d_blit.js");




var VolumeRenderer = /** @class */ (function () {
    function VolumeRenderer(viewer, resouceManager) {
        this._textureWidth = 2048;
        this._textureHeight = 2048;
        this._viewer = viewer;
        this._resourceManager = resouceManager;
        this._enabled = false;
        this._ready = false;
        this._dfData = new Float32Array(this._textureWidth * this._textureHeight);
        this._floorData = new Float32Array(this._textureWidth * this._textureHeight);
    }
    VolumeRenderer.prototype.updateVolumeData = function (populationData) {
        var processedData = new Float32Array(this._textureWidth * this._textureHeight);
        for (var i = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) {
                for (var ii = 0; ii < 256; ii++) {
                    for (var jj = 0; jj < 256; jj++) {
                        var index = (i * 256 + ii) * 8 * 256 + j * 256 + jj;
                        if (this._dfData[index] == 0) {
                            continue;
                        }
                        var floorNumber = i * 8 + j;
                        var data = populationData[floorNumber];
                        if (data === undefined) {
                            continue;
                        }
                        var unitNumber = Math.round(this._floorData[index] * 255);
                        var population = data[unitNumber];
                        // to prevent the noise points in the source image.
                        if (population === undefined) {
                            processedData[index] = 0.0;
                        }
                        else {
                            processedData[index] = this._dfData[index] * population;
                        }
                    }
                }
            }
        }
        this._processedTexture.update(processedData);
    };
    VolumeRenderer.prototype.create = function (matrix, dfTextureUrl, floorTextureUrl, colorMapUrl, populationData) {
        var _this = this;
        var blit = new _04renderer_m3d_blit__WEBPACK_IMPORTED_MODULE_3__["default"](_this._resourceManager);
        var rt0 = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_1__["default"]("dfTexture", _this._resourceManager, this._textureWidth, this._textureHeight, {
            depthTest: false,
            colorFormat: gl.R32F,
            clearColor: [0.0, 0.0, 1.0, 0.0],
            colorFilter: gl.NEAREST,
            depthBuffer: 0
        });
        var rt1 = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_1__["default"]("floorTexture", _this._resourceManager, this._textureWidth, this._textureHeight, {
            depthTest: false,
            colorFormat: gl.R32F,
            clearColor: [0.0, 0.0, 1.0, 0.0],
            colorFilter: gl.NEAREST,
            depthBuffer: 0
        });
        var floorTexture = new _02resource_m3d_texture__WEBPACK_IMPORTED_MODULE_2__["default"]("floor-texture", _this._resourceManager);
        var dfTexture = new _02resource_m3d_texture__WEBPACK_IMPORTED_MODULE_2__["default"]("df-texture", _this._resourceManager);
        this._processedTexture = new _02resource_m3d_texture__WEBPACK_IMPORTED_MODULE_2__["default"]("processed-texture", _this._resourceManager);
        this._processedTexture.create(this._textureWidth, this._textureHeight, gl.R32F, gl.NEAREST);
        floorTexture.createFromFile(floorTextureUrl, gl.RGBA, gl.NEAREST, gl.CLAMP_TO_EDGE, function () {
            // set the viewport before blit.
            blit.setTexture(floorTexture);
            _this._viewer.getRenderer().renderState.invalidateStates();
            _this._viewer.getRenderer().renderState.viewport([0, 0, _this._textureWidth, _this._textureHeight]);
            blit.render(_this._viewer.getRenderer(), rt1, false, false);
            gl.readPixels(0, 0, _this._textureWidth, _this._textureHeight, gl.RED, gl.FLOAT, _this._floorData);
            dfTexture.createFromFile(dfTextureUrl, gl.RGBA, gl.NEAREST, gl.CLAMP_TO_EDGE, function () {
                blit.setTexture(dfTexture);
                blit.render(_this._viewer.getRenderer(), rt0, false, false);
                gl.readPixels(0, 0, _this._textureWidth, _this._textureHeight, gl.RED, gl.FLOAT, _this._dfData);
                _this.updateVolumeData(populationData);
                var toneTexture = _this._resourceManager.getTexture("toneMapTexture");
                toneTexture.createFromFile(colorMapUrl, gl.RGBA, gl.NEAREST, gl.CLAMP_TO_EDGE, null);
                _this._volume = _03scene_drawables_m3d_drawable_library_js__WEBPACK_IMPORTED_MODULE_0__["default"].createHeatmapVolume(_this._resourceManager, matrix, _this._processedTexture, toneTexture);
                _this._ready = true;
            });
        });
    };
    VolumeRenderer.prototype.render = function (renderTarget, renderer, camera, clipping, lights) {
        if (!this._enabled || !this._ready) {
            return;
        }
        renderer.drawDrawables(renderTarget, [this._volume], camera, [null, null, null], null, clipping, lights, null, null, gl.CCW);
    };
    VolumeRenderer.prototype.setEnable = function (enable) {
        this._enabled = enable;
    };
    return VolumeRenderer;
}());
/* harmony default export */ __webpack_exports__["default"] = (VolumeRenderer);


/***/ }),

/***/ "./07loadsave/Load360.ts":
/*!*******************************!*\
  !*** ./07loadsave/Load360.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_errors.js */ "./m3d_errors.js");
/* harmony import */ var _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./m3d_load_misc.js */ "./07loadsave/m3d_load_misc.js");
//
// Load360.ts
// Load the panoramas
//
// Copyright Modelo XX - 2018, All rights reserved.
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var cacheBuster = 0;
var Load360 = /** @class */ (function () {
    function Load360(panoramaData) {
        this._data = panoramaData;
    }
    Load360.prototype.load = function (token, filePromises, onComplete1, onComplete2, onProgress) {
        return __awaiter(this, void 0, void 0, function () {
            var length, assetId, idx, _a, _b, _i, assetId, imagePromises, i, imagesData;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        console.group("Loading scene ");
                        length = 0;
                        for (assetId in this._data) {
                            length++;
                        }
                        idx = 0;
                        _a = [];
                        for (_b in this._data)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 5];
                        assetId = _a[_i];
                        if (!!this._data[assetId].ready) return [3 /*break*/, 3];
                        imagePromises = [];
                        if (this._data[assetId].type === "cubemaps") {
                            for (i = 0; i < this._data[assetId].imageUrls.length; i++) {
                                //Stop looking for the cashe image in browser, which will cause cross origin problem
                                imagePromises.push(_m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_1__["default"].LoadImage1(this._data[assetId].imageUrls[i] + "?i=" + cacheBuster++).downloadFile());
                            }
                        }
                        else {
                            throw (new _m3d_errors_js__WEBPACK_IMPORTED_MODULE_0__["default"]('Unsupported panorama file types!'));
                        }
                        return [4 /*yield*/, Promise.all(imagePromises)];
                    case 2:
                        imagesData = _c.sent();
                        this._data[assetId].images = imagesData.slice(0);
                        this._data[assetId].ready = true;
                        _c.label = 3;
                    case 3:
                        if (idx === 0) {
                            onComplete1();
                        }
                        onProgress((idx + 1) / length - 0.001);
                        idx++;
                        _c.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 1];
                    case 5:
                        onProgress(1.0);
                        onComplete2();
                        return [2 /*return*/];
                }
            });
        });
    };
    return Load360;
}());
/* harmony default export */ __webpack_exports__["default"] = (Load360);
;


/***/ }),

/***/ "./07loadsave/LoadScene.ts":
/*!*********************************!*\
  !*** ./07loadsave/LoadScene.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../m3d_errors.js */ "./m3d_errors.js");
/* harmony import */ var _mx3_m3d_load_mx3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mx3/m3d_load_mx3.js */ "./07loadsave/mx3/m3d_load_mx3.js");
/* harmony import */ var _mt1_m3d_load_mt1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mt1/m3d_load_mt1.js */ "./07loadsave/mt1/m3d_load_mt1.js");
/* harmony import */ var _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./m3d_load_misc.js */ "./07loadsave/m3d_load_misc.js");
//
// LoadScene.ts
// load the model file (.mx format)
//
// Copyright Modelo XX - 2018, All rights reserved.





var LoadScene = /** @class */ (function () {
    function LoadScene(sceneObject, cameraObject, resourceManager, renderer) {
        // When useLocalServer is true, we will download the model file from the local
        // server which is for debugging purpose.
        this._useLocalServer = false;
        this._sceneObject = sceneObject;
        this._cameraObject = cameraObject;
        this._resourceManager = resourceManager;
        this._renderer = renderer;
        this._loadmx3 = null;
        this._loadmt1 = null;
    }
    ;
    LoadScene.prototype.load = function (fileId, initialTransform, filePromises, onComplete1, onComplete2, onProgress) {
        var that = this;
        console.group("Loading scene " + fileId);
        this._useLocalServer = (fileId === "551d4326e437414c17000005");
        if (this._useLocalServer) {
            var url = "/local/" + fileId + "/scene.json";
            filePromises["scene.json"] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_4__["default"].OpenFile1(url, "json");
        }
        var version = 0;
        var sceneJson = null;
        return filePromises["scene.json"].downloadFile(function (eventData) {
            onProgress(eventData.loaded / eventData.total * 0.05);
        })
            .then(function (res) {
            if (typeof (res.data) === "string") {
                sceneJson = JSON.parse(res.data);
            }
            else {
                sceneJson = res.data;
            }
            var versionDigits = sceneJson.version.split(".");
            version = parseInt(versionDigits[0]) * 10000 +
                parseInt(versionDigits[1]) * 100 +
                parseInt(versionDigits[2]);
            if (version < 403) {
                return Promise.reject(_m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR_INCOMPATIBLE_MODEL_FILE_VERSION);
            }
            console.time("Loading scene " + fileId + " takes ");
            return fileId;
        })
            .then(function () {
            var onProgress1 = function (progress) {
                onProgress(0.05 + progress * 0.95);
            };
            if (sceneJson.type && sceneJson.type === "terrain") {
                console.log("A mt 1.0 model");
                that._loadmt1 = new _mt1_m3d_load_mt1_js__WEBPACK_IMPORTED_MODULE_3__["default"](that._useLocalServer, initialTransform, that._sceneObject, that._cameraObject, that._resourceManager, that._renderer);
                return that._loadmt1.load(filePromises, sceneJson, onComplete1, onProgress1);
            }
            else {
                if (version >= 30000) { // MX 3.0
                    console.log("A mx 3.0 model.");
                    that._sceneObject.compressed = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].compressScene;
                    that._loadmx3 = new _mx3_m3d_load_mx3_js__WEBPACK_IMPORTED_MODULE_2__["default"](that._useLocalServer, that._sceneObject, that._cameraObject, that._resourceManager, that._renderer, fileId);
                    return that._loadmx3.load(filePromises, sceneJson, onComplete1, onProgress1);
                }
                else {
                    console.log("The format is not supported");
                }
            }
        })
            .then(function () {
            console.timeEnd("Loading scene " + fileId + " takes ");
            if (sceneJson.type && sceneJson.type === "terrain") {
                //console.log("Terrain:\n");
                //console.log("  current drawables:  " + that._sceneObject.terrain.tiles.length);
            }
            else {
                //console.log("Optimization:\n");
                //console.log("  original drawables: " + sceneJson.scene.nodes);
                var model = that._sceneObject.models.find(function (item) {
                    return item.id == fileId;
                });
                //model && console.log("  current drawables:  " + model.drawables.length);
            }
            if (that._loadmx3) {
                that._loadmx3.destroy();
                that._loadmx3 = null;
                delete that._loadmx3;
            }
            if (that._loadmt1) {
                that._loadmt1.destroy();
                that._loadmt1 = null;
                delete that._loadmt1;
            }
            onProgress(1.0);
            onComplete2(fileId);
            console.groupEnd();
        });
    };
    return LoadScene;
}());
/* harmony default export */ __webpack_exports__["default"] = (LoadScene);
;


/***/ }),

/***/ "./07loadsave/m3d_load_misc.js":
/*!*************************************!*\
  !*** ./07loadsave/m3d_load_misc.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
//
// m3d_load_misc.js
// Misc helper functions for loading models
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var LoadMisc = {};
    LoadMisc.OpenFile = function (sceneId, url, filename, type, $q) {
        return {
            downloadFile: function () {
                var deferred = $q.defer();
                var progressCallback = function (eventData) {
                    //deferred.notify(eventData.lengthComputable? eventData.loaded / eventData.total : eventData.loaded);
                    deferred.notify(eventData);
                };
                try {
                    _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.downloadFileXHR(url, type, progressCallback).then(function (data) {
                        //httpRequest.get(url, type, progressCallback).then(function(data) {
                        var res = { "filename": filename, "data": data };
                        deferred.resolve(res);
                        res = null;
                    });
                }
                catch (e) {
                    console.log({ "url": url, "type": type });
                    console.error(e);
                }
                return deferred.promise;
            }
        };
    };
    LoadMisc.OpenImage = function (sceneId, uri) {
        return {
            downloadFile: function () {
                var url = "/local/" + sceneId + "/" + uri;
                return _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.createImgElmFromUrl(url);
            }
        };
    };
    LoadMisc.OpenImage1 = function (sceneId, uri) {
        return {
            downloadFile: function () {
                var url = "/local/" + sceneId + "/" + uri;
                return new _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].Promise(function (resolve, reject) {
                    var image = new Image();
                    image.name = name;
                    image.src = url;
                    image.crossOrigin = "";
                    image.onload = function () { return resolve(image); };
                    image.onerror = function (error) {
                        reject({
                            message: "ImageUtils.downloadImage() error",
                            url: url,
                            name: name,
                            error: error
                        });
                    };
                });
            }
        };
    };
    LoadMisc.LoadImage1 = function (uri) {
        return {
            downloadFile: function () {
                var url = uri;
                return new _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].Promise(function (resolve, reject) {
                    var image = new Image();
                    image.name = name;
                    image.src = url;
                    image.crossOrigin = "";
                    image.onload = function () { return resolve(image); };
                    image.onerror = function (error) {
                        reject({
                            message: "ImageUtils.downloadImage() error",
                            url: url,
                            name: name,
                            error: error
                        });
                    };
                });
            }
        };
    };
    LoadMisc.OpenFile1 = function (url, type) {
        return {
            downloadFile: function (onProgress) {
                return new _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].Promise(function (resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    if (!xhr) {
                        reject("CORS not supported");
                    }
                    xhr.responseType = type;
                    xhr.onerror = function (error) {
                        reject(error);
                    };
                    xhr.setRequestHeader("Accept", "*/*");
                    xhr.onload = function () {
                        if (xhr.status === 200 || xhr.status === 206) {
                            resolve({ "data": xhr.response });
                        }
                        else {
                            reject("fail to retrieve " + url + " http status error:" + xhr.status);
                        }
                    };
                    xhr.onprogress = function (eventData) {
                        if (onProgress) {
                            onProgress(eventData);
                        }
                    };
                    xhr.send();
                });
            }
        };
    };
    LoadMisc.ProgressTracker = function (onProgress) {
        this._onProgress = onProgress;
        this._currentDownload = 0;
        this.totalDownload = 0;
    };
    LoadMisc.ProgressTracker.prototype.onProgress = function (deltaProgress) {
        this._currentDownload += deltaProgress;
        this._onProgress(Math.max(Math.min(this._currentDownload / this.totalDownload, 1.0), 0.0));
    };
    LoadMisc.ProgressTracker.prototype.getSingleFileProgress = function () {
        var downloaded = 0;
        var that = this;
        return function (loaded) {
            var deltaDownloaded = loaded - downloaded;
            downloaded = loaded;
            that.onProgress(deltaDownloaded);
        };
    };
    LoadMisc.MakeIndividualOnProgress = function (onProgress) {
        var downloaded = 0;
        return function (loaded) {
            var deltaDownloaded = loaded - downloaded;
            downloaded = loaded;
            onProgress.onprogress(deltaDownloaded);
        };
    };
    return LoadMisc;
})());


/***/ }),

/***/ "./07loadsave/mt1/m3d_load_mt1.js":
/*!****************************************!*\
  !*** ./07loadsave/mt1/m3d_load_mt1.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _m3d_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../m3d_errors.js */ "./m3d_errors.js");
/* harmony import */ var _03scene_m3d_layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/m3d_layer.js */ "./03scene/m3d_layer.js");
/* harmony import */ var _03scene_terrain_m3d_terrain_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/terrain/m3d_terrain.js */ "./03scene/terrain/m3d_terrain.js");
/* harmony import */ var _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../m3d_load_misc.js */ "./07loadsave/m3d_load_misc.js");
/* harmony import */ var _m3d_load_tiles_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./m3d_load_tiles.js */ "./07loadsave/mt1/m3d_load_tiles.js");
/* harmony import */ var _m3d_load_terrainbin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./m3d_load_terrainbin.js */ "./07loadsave/mt1/m3d_load_terrainbin.js");
//
// m3d_load_mt1.js
// Load the terrain model (.mt format)
//
// Copyright Modelo XX - 2018, All rights reserved.








/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function LoadMT1(useLocalServer, transform, sceneObject, cameraObject, resourceManager, renderer) {
        this._useLocalServer = useLocalServer;
        this._sceneObject = sceneObject;
        this._cameraObject = cameraObject;
        this._resourceManager = resourceManager;
        this._renderer = renderer;
        this._transform = transform || [1.0, 0.0, 0.0, 0.0, 0.0];
        this._tilesLoader = new _m3d_load_tiles_js__WEBPACK_IMPORTED_MODULE_6__["default"](useLocalServer, sceneObject, renderer, resourceManager);
        this._terrainBinLoader = null;
        this.levelIndex = -1; // The index of level in the scene.json
    }
    ;
    LoadMT1.prototype.destroy = function () {
        this._tilesLoader.destroy();
        this._terrainBinLoader.destroy();
        this._tilesLoader = null;
        this._terrainBinLoader = null;
        delete this._tilesLoader;
        delete this._terrainBinLoader;
    };
    LoadMT1.prototype.load = function (terrainFilePromises, sceneJson, onComplete1, onProgress) {
        // FIXME: in first version of our terrain loader and renderer, we only load+render two
        // levels of the terrain. We first load the corase level and then after finish the loading
        // the model, we load the fine level.
        if (!this._sceneObject.terrain) {
            this.levelIndex = 0;
        }
        else {
            this.levelIndex = 1;
        }
        if (this.levelIndex >= sceneJson.levels.length) {
            throw new _m3d_errors_js__WEBPACK_IMPORTED_MODULE_2__["default"]("The specified level doesn't exist in the scene.json");
        }
        if (this._useLocalServer) {
            var $q = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.getPromiseLibrary();
            var url = "/local/" + this._sceneObject.id + "/terrain/terrain.bin";
            terrainFilePromises["terrain.bin"] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_5__["default"].OpenFile(this._sceneObject.id, url, "terrain.bin", "arraybuffer", $q);
        }
        var progressTracker = new _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_5__["default"].ProgressTracker(onProgress);
        progressTracker.totalDownload = sceneJson["terrain.bin"].byteLength;
        progressTracker.totalDownload += sceneJson.levels[this.levelIndex].byteLength;
        onComplete1(sceneJson);
        var onprogress = progressTracker.getSingleFileProgress();
        var that = this;
        return terrainFilePromises["terrain.bin"].downloadFile()
            .then(function (res) {
            // Create the terrain object.
            return that._load(terrainFilePromises, sceneJson, res.data, progressTracker);
        }, function () { }, function (eventData) {
            onprogress(eventData.loaded);
        });
    };
    LoadMT1.prototype._load = function (terrainFilePromises, sceneJson, terrainBin, progressTracker) {
        this._terrainBinLoader = new _m3d_load_terrainbin_js__WEBPACK_IMPORTED_MODULE_7__["default"](sceneJson, terrainBin);
        // Create terrain object if not exists
        if (!this._sceneObject.terrain) {
            this._sceneObject.terrain = new _03scene_terrain_m3d_terrain_js__WEBPACK_IMPORTED_MODULE_4__["default"](sceneJson.totalLevels, sceneJson.bbox);
            // Create a terrain layer for 
            if (this._sceneObject.layers.length === 0) {
                var layerObject = new _03scene_m3d_layer_js__WEBPACK_IMPORTED_MODULE_3__["default"]("default", 0, [1, 1, 1], true);
                this._sceneObject.layers.push(layerObject);
            }
            var fields = sceneJson.source.split(".");
            this._sceneObject.terrain.source = fields[fields.length - 1];
            this._sceneObject.terrain.setScaling(this._transform[0]);
            this._sceneObject.terrain.setRotation(this._transform[1]);
            this._sceneObject.terrain.setTranslation(this._transform[2], this._transform[3], this._transform[4]);
            // Update the scene's bbox
            _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.union(this._sceneObject.bbox, this._sceneObject.terrain.bbox, this._sceneObject.bbox);
            this._sceneObject.setBBox(this._sceneObject.bbox); // Update scene radius and etc
            this._sceneObject.clipping.initialize(this._sceneObject.bbox);
            // Initialize camera.
            this._cameraObject.reset(true);
        }
        var that = this;
        return this._tilesLoader.loadLevel(terrainFilePromises, sceneJson, this._terrainBinLoader, this.levelIndex, progressTracker).then(function () {
            var level = sceneJson.levels[that.levelIndex].name;
            // Update the rendering terrain drawables.
            var drawables = that._sceneObject.terrain.drawables;
            for (var i = 0; i < drawables.length; i++) {
                that._renderer.removeDrawable(drawables[i]);
            }
            that._sceneObject.terrain.useLevel(level);
            var drawables = that._sceneObject.terrain.drawables;
            for (var i = 0; i < drawables.length; i++) {
                that._renderer.addDrawable(drawables[i]);
            }
            that._renderer.removeDrawable();
        });
    };
    return LoadMT1;
})());


/***/ }),

/***/ "./07loadsave/mt1/m3d_load_terrainbin.js":
/*!***********************************************!*\
  !*** ./07loadsave/mt1/m3d_load_terrainbin.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_load_terrain.js
// Load the terrain.bin, the terrain information
//
// Copyright Modelo XX - 2018, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var UINT32_BYTES = 4;
    function TerrainBinLoader(sceneJson, terrainBin) {
        this._terrainBin = terrainBin;
        // The offset of each level binary in the terrain.bin.
        this._levelOffsets = Array(sceneJson.levels.length);
        this._levelNames = Array(sceneJson.levels.length);
        // initialize
        var offset = 0;
        for (var i = 0; i < this._levelNames.length; i++) {
            this._levelNames[i] = sceneJson.levels[i].name;
            var size = (1 << this._levelNames[i]);
            this._levelOffsets[i] = offset;
            offset += size * size * UINT32_BYTES * 7;
        }
    }
    ;
    TerrainBinLoader.prototype.destroy = function () {
        this._terrainBin = null;
        delete this._terrainBin;
        this._levelOffsets = null;
        delete this._levelOffsets;
        this._levelNames = null;
        delete this._levelNames;
    };
    TerrainBinLoader.prototype.readTile = function (levelIndex, tileIndex) {
        if (levelIndex >= this._levelOffsets.length) {
            return null;
        }
        var offset = this._levelOffsets[levelIndex];
        return new Uint32Array(this._terrainBin, offset + tileIndex * 7 * UINT32_BYTES, 7);
    };
    return TerrainBinLoader;
})());


/***/ }),

/***/ "./07loadsave/mt1/m3d_load_tiles.js":
/*!******************************************!*\
  !*** ./07loadsave/mt1/m3d_load_tiles.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _02resource_m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../02resource/m3d_mesh_attribute.js */ "./02resource/m3d_mesh_attribute.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_terrain_m3d_terrain_level_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/terrain/m3d_terrain_level.js */ "./03scene/terrain/m3d_terrain_level.js");
/* harmony import */ var _03scene_terrain_m3d_terrain_tile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../03scene/terrain/m3d_terrain_tile.js */ "./03scene/terrain/m3d_terrain_tile.js");
/* harmony import */ var _03scene_drawables_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../03scene/drawables/m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
/* harmony import */ var _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../m3d_load_misc.js */ "./07loadsave/m3d_load_misc.js");
//
// m3d_load_tiles.js
// Load the tiles' data (mesh, texture and other ) per level of a terrain scene
//
// Copyright Modelo XX - 2018, All rights reserved.
//
//








/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function TilesLoader(useLocalServer, sceneObject, renderer, resourceManager) {
        this._sceneObject = sceneObject;
        this._renderer = renderer;
        this._resourceManager = resourceManager;
        this._useLocalSever = useLocalServer;
        this._attributes = new _02resource_m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this._attributes.builtin(gl.FLOAT, null, gl.FLOAT, null);
    }
    ;
    TilesLoader.prototype.destroy = function () {
        this._sceneObject = null;
        delete this._sceneObject;
        this._renderer = null;
        delete this._renderer;
        this._resourceManager = null;
        delete this._resourceManager;
        this._attributes = null;
        delete this._attributes;
    };
    TilesLoader.prototype.loadLevel = function (terrainFilePromises, sceneJson, terrainBin, levelIndex, progressTracker) {
        var level = sceneJson.levels[levelIndex].name;
        var size = (1 << level);
        var offset = ((1 << (sceneJson.totalLevels - 1)) >> level);
        // We generate texture download promises
        var texturePromises = [];
        var textureNames = [];
        var textureBytes = [];
        var tiles = size * size;
        for (var i = 0; i < tiles; i++) {
            var tileData = terrainBin.readTile(levelIndex, i);
            if (tileData[1] > 0) { // A valid tile.
                var x = (tileData[0] & 0xffff) * offset;
                var y = (tileData[0] >> 16) * offset;
                //var textureFileName = `tile_${level}_${x}_${y}_tex_tex0.jpg`;
                var textureFileName = "tile_" + level + "_" + x + "_" + y + "_tex_tex0.jpg";
                textureNames.push(textureFileName);
                if (this._useLocalSever) {
                    texturePromises.push(_m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_7__["default"].OpenImage(this._sceneObject.id, "terrain/" + textureFileName));
                }
                else {
                    texturePromises.push(terrainFilePromises[textureFileName]);
                }
                var textureFileBytes = (tileData[1] >> 1);
                textureBytes.push(textureFileBytes);
            }
        }
        var meshPromise = null;
        var meshName = "mesh" + levelIndex + ".bin";
        if (this._useLocalSever) {
            var $q = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.getPromiseLibrary();
            var url = "/local/" + this._sceneObject.id + "/terrain/" + meshName;
            meshPromise = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_7__["default"].OpenFile(this._sceneObject.id, url, meshName, "arraybuffer", $q);
        }
        else {
            meshPromise = terrainFilePromises[meshName];
        }
        var layerObject = this._sceneObject.layers[0];
        var levelObject = new _03scene_terrain_m3d_terrain_level_js__WEBPACK_IMPORTED_MODULE_4__["default"](level);
        this._sceneObject.terrain.setLevel(levelObject);
        var shaderObject = this._createShaderObject();
        var that = this;
        // Load the texturex
        return this._loadTextures(texturePromises, textureNames, textureBytes, progressTracker)
            .then(function () {
            // Load the mesh binary.
            var onprogress = progressTracker.getSingleFileProgress();
            return meshPromise.downloadFile()
                .then(function (res) {
                var meshBinary = res.data;
                var indicesOffset = 0;
                for (var i = 0; i < tiles; i++) {
                    var tileData = terrainBin.readTile(levelIndex, i);
                    if (tileData[1] > 0) {
                        indicesOffset += tileData[4];
                    }
                }
                var vbuffer = that._resourceManager.getBuffer("tile_" + level + "_vertices.bin");
                var ibuffer = that._resourceManager.getBuffer("tile_" + level + "_indices.bin");
                var vertices = new Uint8Array(meshBinary, 0, indicesOffset);
                var indices = new Uint8Array(meshBinary, indicesOffset, meshBinary.byteLength - indicesOffset);
                vbuffer.create(gl.ARRAY_BUFFER, vertices);
                ibuffer.create(gl.ELEMENT_ARRAY_BUFFER, indices);
                for (var i = 0; i < tiles; i++) {
                    var tileData = terrainBin.readTile(levelIndex, i);
                    if (tileData[1] > 0) { // A valid tile.
                        var x = (tileData[0] & 0xffff) * offset;
                        var y = (tileData[0] >> 16) * offset;
                        tileData[5] -= indicesOffset;
                        var meshObject = that._createMeshObject(level, tileData, vbuffer, ibuffer);
                        if (meshObject.ready) {
                            //var textureFileName = `tile_${level}_${x}_${y}_tex_tex0.jpg`;
                            var textureFileName = "tile_" + level + "_" + x + "_" + y + "_tex_tex0.jpg";
                            var materialObject = that._createMaterialObject(textureFileName, shaderObject);
                            var tileObject = that._createTileObject(level, tileData, meshObject, shaderObject, materialObject, layerObject);
                            levelObject.addTile(tileObject);
                        }
                    }
                }
            }, function () {
            }, function (eventData) {
                onprogress(eventData.loaded);
            });
        });
    };
    TilesLoader.prototype._createMeshObject = function (level, tileData, verticesBuffer, indicesBuffer) {
        var x = (tileData[0] & 0xffff);
        var y = (tileData[0] >> 16);
        //var meshName = `tile_${level}_${x}_${y}`;
        var meshName = "tile_" + level + "_" + x + "_" + y;
        var meshObject = this._resourceManager.getMesh(meshName);
        if (!meshObject.ready) {
            var indexTypes = [
                gl.UNSIGNED_BYTE,
                gl.UNSIGNED_BYTE,
                gl.UNSIGNED_SHORT,
                gl.UNSIGNED_SHORT,
                gl.UNSIGNED_INT,
            ];
            var vertices = {
                "byteLength": tileData[4],
                "byteOffset": tileData[3]
            };
            var indices = {
                "byteLength": tileData[6],
                "byteOffset": tileData[5]
            };
            var attributes = this._attributes.clone();
            for (var i = 0, len = attributes.values.length; i < len; i++) {
                attributes.values[i].offset += vertices.byteOffset;
            }
            meshObject.createShared(gl.TRIANGLES, attributes, vertices, indices, indexTypes[(tileData[2] & 0xff)], verticesBuffer, indicesBuffer);
        }
        return meshObject;
    };
    var WHITE = [1, 1, 1];
    TilesLoader.prototype._createMaterialObject = function (textureName, shaderObject) {
        var materialName = textureName;
        var materialObject = this._sceneObject.materialManager.getMaterial(materialName);
        if (!materialObject) {
            materialObject = this._sceneObject.materialManager.createMaterialAdhoc(materialName);
            materialObject.attachShader(shaderObject);
            // Set material properties.
            materialObject.setDiffuse(WHITE);
            materialObject.setTransparent(1.0);
            materialObject.transparent = false;
            var textureObject = this._resourceManager.getTexture(textureName);
            materialObject.setDiffuseTexture(textureObject);
        }
        return materialObject;
    };
    var tile_bbox = [0, 0, 0, 0, 0, 0];
    TilesLoader.prototype._createTileObject = function (level, tileData, meshObject, shaderObject, materialObject, layerObject) {
        // Compute the tile bbox from the tile coordinate.
        // The (0, 0) tile is at the left bottom corner of the xy plane. 
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.copy(tile_bbox, this._sceneObject.terrain._originalBBox);
        var x = (tileData[0] & 0xffff);
        var y = (tileData[0] >> 16);
        var size = (1 << level);
        var tileWidth = (tile_bbox[3] - tile_bbox[0]) / size; // x
        var tileHeight = (tile_bbox[4] - tile_bbox[1]) / size; // y
        tile_bbox[0] += x * tileWidth;
        tile_bbox[1] += y * tileHeight;
        tile_bbox[3] = tile_bbox[0] + tileWidth;
        tile_bbox[4] = tile_bbox[1] + tileHeight;
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.scale(tile_bbox, tile_bbox, 1.05); // scale up a little bit
        //var drawableName = `tile_${level}_${x}_${y}`;
        var drawableName = "tile_" + level + "_" + x + "_" + y;
        var drawableObject = new _03scene_drawables_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_6__["default"](drawableName, meshObject, layerObject, shaderObject, materialObject, null, tile_bbox);
        drawableObject.visible = true;
        layerObject.drawables.push(drawableObject);
        var tileObject = new _03scene_terrain_m3d_terrain_tile_js__WEBPACK_IMPORTED_MODULE_5__["default"](x, y, drawableObject, tile_bbox);
        return tileObject;
    };
    TilesLoader.prototype._loadTextures = function (texturePromises, textureNames, textureBytes, progressTracker) {
        var $q = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.getPromiseLibrary();
        var that = this;
        // Load textures
        var loadTextureImage = function (textureIndex) {
            return texturePromises[textureIndex].downloadFile().then(function (image) {
                var textureName = textureNames[textureIndex];
                var textureObject = that._resourceManager.getTexture(textureName);
                textureObject.createFromImage(image, gl.RGB, gl.UNSIGNED_BYTE, gl.LINEAR_MIPMAP_NEAREST, gl.CLAMP_TO_EDGE);
                if (!textureObject.ready) {
                    return $q.reject("modelo3d loader errors at creating texture object '" + textureName + "'.");
                }
                var onprogress = progressTracker.getSingleFileProgress();
                onprogress(textureBytes[textureIndex]);
            });
        };
        var prev = loadTextureImage(0);
        for (var i = 1, len = texturePromises.length; i < len; i++) {
            prev = (function (textureIndex) {
                return prev.then(function () {
                    return loadTextureImage(textureIndex);
                });
            })(i);
        }
        return prev;
    };
    TilesLoader.prototype._createShaderObject = function () {
        var shaderType = "plain_texture";
        var flags = [];
        flags.push("MODEL_TRANSFORM");
        if (this._sceneObject.clipping.isEnabled()) {
            flags.push("CLIPPING");
        }
        var shaderObject = this._resourceManager.getShader(shaderType, flags);
        if (!shaderObject.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__["default"][shaderType];
            shaderObject.createFromShaderSource(shaderSource, flags);
            if (!shaderObject.ready) {
                throw ("modelo3d error at creating shader '" + shaderType + "'!");
            }
        }
        return shaderObject;
    };
    return TilesLoader;
})());


/***/ }),

/***/ "./07loadsave/mx2/m3d_load_texture.js":
/*!********************************************!*\
  !*** ./07loadsave/mx2/m3d_load_texture.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
//
// m3d_load_texture.js
// Load the texture section in scene
//
// Copyright Modelo XX - 2017, All rights reserved.

/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function TextureLoader(sceneObject, resourceManager, model) {
        this._sceneObject = sceneObject;
        this._resourceManager = resourceManager;
        this._model = model;
    }
    ;
    TextureLoader.prototype.destroy = function () {
        delete this._sceneObject;
        delete this._resourceManager;
        delete this._model;
    };
    function SamplerData() {
        this.filter = gl.LINEAR_MIPMAP_LINEAR;
        this.wrap = gl.REPEAT;
    }
    ;
    TextureLoader.prototype.load = function (modelPromises, sceneJson, sceneBin, progressTracker) {
        var $q = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.getPromiseLibrary();
        // If there is no texture, return immediately
        if (sceneJson.textures.length === 0) {
            return $q.resolve("ok");
        }
        var that = this;
        // Collect samplers
        var samplersData = new Array(sceneJson.samplers.length);
        for (var i = 0, len = sceneJson.samplers.length; i < len; i++) {
            samplersData[i] = new SamplerData();
            var samplerData = sceneBin.readSampler(i);
            if (samplerData[0] === 1) { // linear or not
                // FIXME: if trilinear texture sampling drag down the performance
                // too much, revive following line.
                samplersData[i].filter = samplerData[2] === 1 ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;
            }
            else {
                samplersData[i].filter = samplerData[2] === 1 ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST;
            }
            // repeat or not
            samplersData[i].wrap = samplerData[1] === 1 ? gl.REPEAT : gl.CLAMP_TO_EDGE;
        }
        var lowercasedModelPromises = getLowercasedModelPromises(modelPromises);
        // Load textures
        var loadTextureImage = function (textureIndex) {
            var textureName = that._model.id + "/" + sceneJson.textures[textureIndex].name;
            var lowercasedTextureName = textureName.toLowerCase();
            return lowercasedModelPromises[lowercasedTextureName].downloadFile().then(function (image) {
                if (!(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.INITIALIZED || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.RENDERING)) {
                    throw new Error("Loading is interrupted");
                }
                var textureData = sceneBin.readTexture(textureIndex);
                var samplerData = samplersData[textureData[1]];
                var textureObject = that._resourceManager.getTexture(textureName);
                var format = textureData[0] === 4 ? gl.RGBA : gl.RGB;
                textureObject.updateImage(image, format, gl.UNSIGNED_BYTE, samplerData.filter, samplerData.wrap);
                if (!textureObject.ready) {
                    return $q.reject("modelo3d loader errors at creating texture object '" +
                        textureName + "'.");
                }
                var onprogress = progressTracker.getSingleFileProgress();
                onprogress(sceneJson.textures[textureIndex].byteLength);
            });
        };
        // Fetch the textures.
        var prev = loadTextureImage(0);
        for (var i = 1, len = sceneJson.textures.length; i < len; i++) {
            prev = (function (textureIndex) {
                return prev.then(function () {
                    return loadTextureImage(textureIndex);
                });
            })(i);
        }
        return prev;
    };
    // lowercases the keys to make matching files work as expected
    function getLowercasedModelPromises(modelPromises) {
        var mappedModelPromises = {};
        Object.keys(modelPromises).forEach(function (name) {
            var lowercasedName = name.toLowerCase();
            mappedModelPromises[lowercasedName] = modelPromises[name];
        });
        return mappedModelPromises;
    }
    return TextureLoader;
})());


/***/ }),

/***/ "./07loadsave/mx3/m3d_load_mesh.js":
/*!*****************************************!*\
  !*** ./07loadsave/mx3/m3d_load_mesh.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../m3d_errors.js */ "./m3d_errors.js");
/* harmony import */ var _02resource_m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../02resource/m3d_mesh_attribute.js */ "./02resource/m3d_mesh_attribute.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_drawables_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/drawables/m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");
/* harmony import */ var _03scene_drawables_m3d_drawable_instanced_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../03scene/drawables/m3d_drawable_instanced.js */ "./03scene/drawables/m3d_drawable_instanced.js");
/* harmony import */ var _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../03scene/graph/m3d_node.js */ "./03scene/graph/m3d_node.js");
/* harmony import */ var _m3d_load_mesh_sync_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./m3d_load_mesh_sync.js */ "./07loadsave/mx3/m3d_load_mesh_sync.js");
//
// m3d_load_mesh.js
// Load the meshes of scene
//
// Copyright Modelo XX - 2017, All rights reserved.
//








/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MeshLoader(sceneObject, renderer, resourceManager, model) {
        this._sceneObject = sceneObject;
        this._resourceManager = resourceManager;
        this._renderer = renderer;
        this._model = model;
        this._modelIdPrefix = model.id + "/";
        this._worker = null;
        this._memoryBudget = 0; // in bytes
        this._attributes = null;
        this._sceneJson = null;
        this._sceneBin = null;
    }
    ;
    MeshLoader.prototype.destroy = function () {
        this._worker.destroy();
        this._worker = null;
        delete this._worker;
        this._sceneJson = null;
        this._sceneBin = null;
        this._sceneObject = null;
        this._attributes = null;
        this._renderer = null;
        this._model = null;
        this._modelIdPrefix = null;
        delete this._sceneJson;
        delete this._sceneBin;
        delete this._sceneObject;
        delete this._renderer;
        delete this._attributes;
        delete this._model;
        delete this._modelIdPrefix;
    };
    MeshLoader.prototype.load = function (modelPromises, sceneJson, sceneBin, modelJson, progressTracker) {
        this._sceneJson = sceneJson;
        this._modelJson = modelJson;
        this._sceneBin = sceneBin;
        // Fill the attributes
        var attributes = new Array(sceneJson.attributes.length);
        var primitives = [
            gl.POINTS,
            gl.LINES,
            gl.LINES,
            gl.LINES,
            gl.TRIANGLES,
        ];
        var types = [
            gl.BYTE,
            gl.UNSIGNED_BYTE,
            gl.SHORT,
            gl.UNSIGNED_SHORT,
            gl.INT,
            gl.UNSIGNED_INT,
            0,
            gl.FLOAT,
            0 //gl.DOUBLE,
        ];
        for (var i = 0, len = sceneJson.attributes.length; i < len; i++) {
            attributes[i] = new _02resource_m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
            var attributeName = sceneJson.attributes[i];
            var attributeData = sceneBin.readAttribute(i);
            // FIXME: in order to reuse old code, we still insert primitive
            // into the attributes class.
            attributes[i].primitive = primitives[attributeData[0]];
            var normalType = attributeData[1] >= 0 ? types[attributeData[1]] : null;
            var uvType = attributeData[2] >= 0 ? types[attributeData[2]] : null;
            var colorType = attributeData[3] >= 0 ? types[attributeData[3]] : null;
            attributes[i].builtin(gl.FLOAT, normalType, uvType, colorType);
        }
        this._attributes = attributes;
        // Download meshXXX.bin one by one.
        this._worker = new _m3d_load_mesh_sync_js__WEBPACK_IMPORTED_MODULE_7__["default"](this._resourceManager, sceneJson, sceneBin, modelJson, this._attributes, this._sceneObject.compressed, this._model);
        // Execute $q promises sequentially, http://www.codeducky.org/q-serial/
        var that = this;
        var prev = that._loadMesh(0, modelPromises["mesh0.bin"], progressTracker);
        for (i = 1, len = modelJson.buffers.length; i < len; i++) {
            prev = function (index) {
                return prev.then(function () {
                    var meshBufferName = "mesh" + index.toString() + ".bin";
                    return that._loadMesh(index, modelPromises[meshBufferName], progressTracker);
                });
            }(i);
        }
        return prev;
    };
    // Load mesh buffer binary
    MeshLoader.prototype._loadMesh = function (meshBufferIndex, promise, progressTracker) {
        var onprogress = progressTracker.getSingleFileProgress();
        promise.onProgress(function (eventData) {
            onprogress(eventData.loaded);
        });
        // We run initialization of worker and downloading file at the same time.
        this._worker.initialize();
        var that = this;
        return promise.downloadFile().then(function (res) {
            if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state !== modelo3d.UNINITIALIZED) {
                that._worker.load(meshBufferIndex, res.data, MeshLoader.prototype.onNodeDataReady.bind(that));
            }
        });
    };
    // Callbacks for sync.
    MeshLoader.prototype.onNodeDataReady = function (nodeInfo, vertexBuffer, indexBuffer, vertices, indices, nodesInfo, isStagedMesh) {
        var shaderObject = this._createShaderObject(nodeInfo);
        if (shaderObject) {
            var materialObject = this._createMaterialObject(nodeInfo, shaderObject);
            if (materialObject) {
                var meshObject = this._createMeshObject(nodeInfo, vertices, indices, vertexBuffer, indexBuffer, isStagedMesh);
                if (meshObject) {
                    this._createDrawableObject(nodeInfo, meshObject, shaderObject, materialObject, nodesInfo);
                }
                else {
                    // It is most likely GPU mem is used up, we should return the control
                    // to browser to trigger context-lost event callback.
                    _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"].error = _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR_INSUFFICIENT_RESOURCE;
                    throw _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"].error;
                }
            }
        }
    };
    var NODEINFO_INT32 = 9;
    MeshLoader.prototype._createMeshObject = function (nodeInfo, vertices, indices, vertexBuffer, indexBuffer, isStaged) {
        if (isStaged) {
            var meshObject = this._resourceManager.getStagedMesh(nodeInfo[1] >= 0 ? this._modelIdPrefix + nodeInfo[1].toString() : this._modelIdPrefix + (-nodeInfo[0].toString()));
        }
        else {
            var meshObject = this._resourceManager.getMesh(nodeInfo[1] >= 0 ? this._modelIdPrefix + nodeInfo[1].toString() : this._modelIdPrefix + (-nodeInfo[0].toString()));
        }
        if (!meshObject.ready) {
            var indexTypes = [
                gl.UNSIGNED_BYTE,
                gl.UNSIGNED_BYTE,
                gl.UNSIGNED_SHORT,
                gl.UNSIGNED_SHORT,
                gl.UNSIGNED_INT,
            ];
            var attributesIndex = ((nodeInfo[8] >> 8) & 0xff);
            var attributes = this._attributes[attributesIndex];
            attributes = attributes.clone();
            // TODO: don't create duplicated compressed mesh attributes.
            // Compress the attributes if mesh is already compressed. 
            if (this._sceneObject.compressed) {
                attributes.compress();
            }
            var vertexNumber = vertices.byteLength / (attributes.values[0].stride + (nodeInfo[3] >= 0 ? 1 : 0));
            if (!isStaged) {
                for (var i = 0, len = attributes.values.length; i < len; i++) {
                    attributes.values[i].offset += vertices.byteOffset;
                }
            }
            // When this node is a merged one, its mesh has an additonal piece of data after
            // other vertex attribute at the back part of mesh. We should update the vertex
            // attribute accordingly.
            if (nodeInfo[3] >= 0) {
                attributes.add("m_aMaterial", gl.UNSIGNED_BYTE, true, 1);
                var attribute = attributes.values[attributes.values.length - 1];
                attribute.index = 6;
                attribute.offset = attributes.values[0].offset + vertexNumber * (attributes.values[0].stride);
                attribute.stride = 1;
            }
            meshObject.createShared(attributes.primitive, attributes, vertices, indices, indexTypes[(nodeInfo[8] & 0xff)], vertexBuffer, indexBuffer);
        }
        return meshObject;
    };
    var retTransform = new Float32Array(16);
    function ExtendTransform(transform) {
        retTransform[0] = transform[0];
        retTransform[1] = transform[1];
        retTransform[2] = transform[2];
        retTransform[3] = 0;
        retTransform[4] = transform[3];
        retTransform[5] = transform[4];
        retTransform[6] = transform[5];
        retTransform[7] = 0;
        retTransform[8] = transform[6];
        retTransform[9] = transform[7];
        retTransform[10] = transform[8];
        retTransform[11] = 0;
        retTransform[12] = transform[9];
        retTransform[13] = transform[10];
        retTransform[14] = transform[11];
        retTransform[15] = 1;
        return retTransform;
    }
    ;
    MeshLoader.prototype._createDrawableObject = function (nodeInfo, meshObject, shaderObject, materialObject, nodesInfo) {
        // We have only one layer in the scene
        var layerObject = this._sceneObject.layers[0];
        // Create the drawable object.
        var attributes = this._attributes[(nodeInfo[8] >> 8) & 0xff];
        if ((nodeInfo[2] & 0x30000000)) {
            var transformData = new Float32Array(nodeInfo[6] * 16);
            var i = 0;
            var childNodeIndex = nodeInfo[0]; // start from this node.
            while (childNodeIndex != -1) {
                var offset = i * 16;
                var t = this._sceneBin.readNodeTransform(nodesInfo[childNodeIndex * NODEINFO_INT32]);
                transformData[offset + 0] = t[0];
                transformData[offset + 1] = t[1];
                transformData[offset + 2] = t[2];
                transformData[offset + 3] = 0;
                transformData[offset + 4] = t[3];
                transformData[offset + 5] = t[4];
                transformData[offset + 6] = t[5];
                transformData[offset + 7] = 0;
                transformData[offset + 8] = t[6];
                transformData[offset + 9] = t[7];
                transformData[offset + 10] = t[8];
                transformData[offset + 11] = 0;
                transformData[offset + 12] = t[9];
                transformData[offset + 13] = t[10];
                transformData[offset + 14] = t[11];
                transformData[offset + 15] = 1;
                childNodeIndex = nodesInfo[childNodeIndex * NODEINFO_INT32 + 3];
                i++;
            }
            var meshBBoxData = this._sceneBin.readNodeBBox(nodeInfo[0]);
            var bboxData = this._sceneBin.readNodeBBox(nodeInfo[0]);
            var drawableObject = new _03scene_drawables_m3d_drawable_instanced_js__WEBPACK_IMPORTED_MODULE_5__["default"](nodeInfo[0], meshObject, layerObject, shaderObject, materialObject, transformData, bboxData, meshBBoxData);
        }
        else {
            var transformData = null;
            if ((nodeInfo[2] & 0x40000000) === 0) {
                transformData = ExtendTransform(this._sceneBin.readNodeTransform(nodeInfo[0]));
            }
            var bboxData = this._sceneBin.readNodeBBox(nodeInfo[0]);
            var drawableObject = new _03scene_drawables_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_4__["default"](nodeInfo[0].toString(), meshObject, layerObject, shaderObject, materialObject, transformData, bboxData);
        }
        // Add drawable object to view.
        drawableObject.visible = true;
        this._renderer.addDrawable(drawableObject);
        // this._sceneObject.model.drawables.push(drawableObject);
        this._model.drawables.push(drawableObject);
        // The drawables that use the same material. It is a helper data
        // structure for change material.
        drawableObject.material.drawables.push(drawableObject);
        // Complete the node information and bind the drawable
        // drawable to its scene graph node.
        var currRegion = _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_6__["default"].STRUCTURE;
        var childNodeIndex = nodeInfo[0];
        var hidableIdx = 0;
        while (childNodeIndex >= 0) {
            var node = this._model.graph.nodes[childNodeIndex];
            var region = ((nodesInfo[childNodeIndex * NODEINFO_INT32 + 2] >> 24) & 0x0f);
            drawableObject.nodes.push(node);
            node.region = region;
            node.drawable = drawableObject;
            //node.originalMatarial = drawableObject.material.name;
            if (nodesInfo[childNodeIndex * NODEINFO_INT32 + 2] & 0x30000000) { // if it is an instance
                node.indicesOffset = 1; // subrender doesn't work on instanced node.
                node.indicesCount = 1;
            }
            else {
                node.indicesOffset = nodesInfo[childNodeIndex * NODEINFO_INT32 + 6];
                node.indicesCount = nodesInfo[childNodeIndex * NODEINFO_INT32 + 7];
            }
            //MOD-8851 Drawables with no children needs to set to mesh data
            //nodeInfo[5] indicates the node indices bytes
            if (node.indicesOffset === 0 && node.indicesCount === 0) {
                node.indicesCount = nodeInfo[5] / meshObject.indexSize;
            }
            node.verticesCount = nodesInfo[childNodeIndex * NODEINFO_INT32 + 4];
            if (currRegion !== region) {
                currRegion = region;
                // We are looking for which elements can be hidable during rendering.
                // FIXME: change the hidablility strength to other region.
                if (region >= _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_6__["default"].STRUCTURE_INTERIOR && drawableObject.hidables < 0) {
                    drawableObject.hidables = hidableIdx;
                }
            }
            childNodeIndex = nodesInfo[childNodeIndex * NODEINFO_INT32 + 3];
            hidableIdx++;
        }
        // Since instanced drawable is a group of same kind of drawables, they should be either
        // culled or not in BIM culling.
        if (nodeInfo[2] & 0x30000000) {
            drawableObject.hidables = (((nodeInfo[2] >> 24) & 0x0f) >= _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_6__["default"].STRUCTURE_INTERIOR) ? 0 : -1;
        }
        layerObject.drawables.push(drawableObject);
        return drawableObject;
    };
    var diffuse = [1.0, 1.0, 1.0];
    MeshLoader.prototype._createMaterialObject = function (nodeInfo, shaderObject) {
        var materialName = this._sceneJson.materials[nodeInfo[2] & 0xffff];
        var materialObject = this._sceneObject.materialManager.getMaterial(this._modelIdPrefix + materialName);
        if (!materialObject) {
            var materialData = this._sceneBin.readMaterial(nodeInfo[2] & 0xffff);
            materialObject = this._sceneObject.materialManager.createMaterialAdhoc(this._modelIdPrefix + materialName);
            materialObject.attachShader(shaderObject);
            // Set material properties.
            diffuse[0] = materialData[0] / 255.0;
            diffuse[1] = materialData[1] / 255.0;
            diffuse[2] = materialData[2] / 255.0;
            materialObject.setDiffuse(diffuse);
            materialObject.setTransparent(materialData[3] / 255.0);
            if (materialData[4] !== 0xff) { // has texture
                var textureIndex = ((materialData[5] << 8) | materialData[4]);
                var textureName = this._modelIdPrefix + this._sceneJson.textures[textureIndex].name;
                var textureData = this._sceneBin.readTexture(textureIndex);
                if (textureData[0] === 4) {
                    if (textureData[2] === 1) {
                        materialObject.hasMask = true;
                        materialObject.transparent = false;
                    }
                    else {
                        materialObject.transparent = true;
                    }
                }
                else if (materialObject.transparent) {
                    materialObject.transparent = true;
                }
                else {
                    materialObject.transparent = false;
                }
                var textureObject = this._resourceManager.getTexture(textureName);
                materialObject.setDiffuseTexture(textureObject);
            }
        }
        return materialObject;
    };
    MeshLoader.prototype._createShaderObject = function (nodeInfo) {
        var materialData = this._sceneBin.readMaterial(nodeInfo[2] & 0xffff);
        var attributes = this._attributes[(nodeInfo[8] >> 8) & 0xff];
        var hasTexture = (materialData[4] !== 0xff);
        var shaderType = "solid";
        if (attributes.primitive === gl.LINES) {
            shaderType = "plain";
        }
        else if (attributes.hasColor) {
            shaderType = "color";
        }
        else if (hasTexture) {
            shaderType = "texture";
        }
        // Sort the flags in their change frequency. Those at the back will be changed in 
        // a more frequent manner, e.g., shadow.
        var flags = [];
        if (nodeInfo[2] & 0x30000000) {
            flags.push("INSTANCING");
        }
        if (!(nodeInfo[2] & 0x40000000)) {
            flags.push("MODEL_TRANSFORM");
        }
        if (this._sceneObject.needRenderDoubleSided() && !transparency) {
            flags.push("DOUBLESIDED");
        }
        if (hasTexture) {
            var textureIndex = ((materialData[5] << 8) | materialData[4]);
            var textureData = this._sceneBin.readTexture(textureIndex);
            if (textureData[2]) {
                flags.push("ALPHATEST");
            }
        }
        if (this._sceneObject.compressed) {
            flags.push("COMPRESSION");
        }
        // Textured objects are always opaque and their transparent pixels
        // will be culled using alpha testing.
        var transparency = (materialData[3] < 250 && !hasTexture);
        if (this._renderer.isShadowEnabled() && !transparency) {
            flags.push("SHADOW");
        }
        if (this._sceneObject.clipping.isEnabled()) {
            flags.push("CLIPPING");
        }
        var shaderObject = this._resourceManager.getShader(shaderType, flags);
        if (!shaderObject.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__["default"][shaderType];
            shaderObject.createFromShaderSource(shaderSource, flags);
            if (!shaderObject.ready) {
                throw ("modelo3d error at creating shader '" + shaderType + "'!");
            }
        }
        return shaderObject;
    };
    return MeshLoader;
})());


/***/ }),

/***/ "./07loadsave/mx3/m3d_load_mesh_sync.js":
/*!**********************************************!*\
  !*** ./07loadsave/mx3/m3d_load_mesh_sync.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/graph/m3d_node.js */ "./03scene/graph/m3d_node.js");
//
// m3d_load_mesh_sync.js
// Merge meshes into large one to reduce drawcall
//
// Copyright Modelo XX - 2018, All rights reserved.
//


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function LoadMeshSync(resourceManager, sceneJson, modelBin, modelJson, attributesData, compressNormal, model) {
        this._resourceManager = resourceManager;
        this._sceneJson = sceneJson;
        this._modelBin = modelBin;
        this._modelJson = modelJson;
        this._attributesData = attributesData;
        this._maxVertexNumber = 65536;
        this._meshes = 0;
        this._compressNormal = compressNormal;
        this._nodesInfo = null;
        this._buffersNodes = [];
        this._verticesBinary = null;
        this._indicesBinary = null;
        this._model = model;
        this._modelIdPrefix = model.id + "/";
        //this._study           = false;
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].useStagedMesh) {
            this._stagedVBuffer = this._resourceManager.getBuffer(this._modelIdPrefix + "stagedVBuffer");
            this._stagedIBuffer = this._resourceManager.getBuffer(this._modelIdPrefix + "stagedIBuffer");
            // Initialize the buffer data so that meshes sharing these buffer are valid.
            this._stagedVBuffer.create(gl.ARRAY_BUFFER, new Uint8Array(1));
            this._stagedIBuffer.create(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(1));
        }
    }
    ;
    LoadMeshSync.prototype.destroy = function () {
        this._attributesData = null;
        delete this._attributesData;
        this._sceneJson = null;
        delete this._sceneJson;
        this._modelBin = null;
        delete this._modelBin;
        this._nodesInfo = null;
        delete this._nodesInfo;
        this._buffersNodes = null;
        delete this._buffersNodes;
        this._verticesBinary = null;
        delete this._verticesBinary;
        this._indicesBinary = null;
        delete this._indicesBinary;
        this._model = null;
        delete this._model;
        //if (this._study) {
        //    console.groupEnd("Study mesh loading");
        //}
    };
    var SCALE = 16;
    var studyStats = {
        maxMeshBytes: 0,
    };
    var NODEINFO_INT32 = 9;
    LoadMeshSync.prototype.initialize = function () {
        // Already initialized
        if (this._nodesInfo !== null) {
            return;
        }
        var numNodes = this._modelJson["model.bin"].nodes;
        var numBuffers = this._modelJson.buffers.length;
        var meshBinBytes = 0;
        for (var i = 0; i < numBuffers; i++) {
            meshBinBytes += this._modelJson.buffers[i].byteLength;
            this._meshes += this._modelJson.buffers[i].meshes;
        }
        if (meshBinBytes > _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].gpuMemory * 1024 * 1024) {
            throw new Error("No enough GPU memory to load this model: " + meshBinBytes);
        }
        //if (this._study) {
        //    console.group("Study mesh loading");
        //    console.info(`nodes number:            ${numNodes}`);
        //    console.info(`mesh buffer number:      ${numBuffers}`);
        //    console.info(`mesh buffer total bytes: ${meshBinBytes}`);
        //    console.info(`expected GPU mem bytes:  ${Globals.gpuMemory * 1024 * 1024}`);
        //    //this._stats.meshBins     = numBuffers;
        //    //this._stats.meshBinBytes = meshBinBytes;
        //    //this._stats.meshes       = this._meshes;
        //    //this._stats.meshMaxBytes = 0;
        //    //this._getNodeStats(this._sceneJson);
        //}
        this._nodesInfo = new Int32Array(NODEINFO_INT32 * numNodes);
        this._buffersNodes = new Array(numBuffers);
        for (var i = 0; i < numBuffers; i++) {
            this._buffersNodes[i] = [];
        }
        for (var i = 0; i < numNodes; i++) {
            var nodeInfo = new Int32Array(this._nodesInfo.buffer, i * NODEINFO_INT32 * 4, NODEINFO_INT32);
            var nodeData = this._modelBin.readNodeData(i);
            nodeInfo[0] = i;
            nodeInfo[1] = nodeData[1]; // mesh
            nodeInfo[2] = (nodeData[0] & 0xffff); // material and ...
            nodeInfo[2] |= 0x80000000; // valid, 31
            nodeInfo[2] |= (((nodeData[2] >> 30) & 0x1) ? 0x40000000 : 0x00000000); // identity
            //nodeInfo[2] |= 0x30000000; // instanced (1 instanced, 3 instance confirmed)
            nodeInfo[2] |= (((nodeData[2] >> 25) & 0x0f) << 24); // region
            nodeInfo[3] = -1; // next
            //nodeInfo[6] = 0; // temp1, output: the children length for instance, indicesOffset for merged
            //nodeInfo[7] = 0; // temp2, merging: the original mesh mem cost, output: indicesCount
            var meshData = this._modelBin.readMesh(nodeInfo[1]);
            nodeInfo[4] = meshData[2]; // merging: vertices bytes, output: vertices number of this node's original (before merge) mesh.
            nodeInfo[5] = meshData[4]; // merging: indices bytes, output: indices bytes
            nodeInfo[8] = (meshData[0] & 0xffff); // index, attribute 
            var bufferIndex = (meshData[0] >> 16);
            this._buffersNodes[bufferIndex].push(i);
        }
        for (var i = 0, len = numBuffers; i < len; i++) {
            this._groupNodesByMaterial(this._buffersNodes[i]);
        }
        this._createMerges(new Uint32Array(numBuffers), _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].gpuMemory * 1024 * 1024);
        var maxVbSize = 0;
        var maxIbSize = 0;
        for (var i = 0, len = this._buffersNodes.length; i < len; ++i) {
            var bufferNodes = this._buffersNodes[i];
            var vbSize = 0;
            var ibSize = 0;
            for (var j = 0, len2 = bufferNodes.length; j < len2; j++) {
                var nodeInfo = new Int32Array(this._nodesInfo.buffer, 4 * bufferNodes[j] * NODEINFO_INT32, NODEINFO_INT32);
                if (nodeInfo[2] & 0x80000000) { // only for valid
                    var verticesBytes = nodeInfo[4];
                    var indicesBytes = nodeInfo[5];
                    var attributes = this._attributesData[(nodeInfo[8] >> 8) & 0xff];
                    var vertices = verticesBytes / attributes.values[0].stride;
                    if (this._compressNormal && attributes.hasNormal) {
                        verticesBytes = vertices * (attributes.values[0].stride - 4);
                    }
                    // Add the vertex visible/material bytes for each mesh 
                    verticesBytes += vertices;
                    // Align to 4 bytes.
                    verticesBytes = (verticesBytes + 3) & (-4);
                    indicesBytes = (indicesBytes + 3) & (-4);
                    vbSize += verticesBytes;
                    ibSize += indicesBytes;
                }
            }
            if (maxVbSize < vbSize) {
                maxVbSize = vbSize;
            }
            if (maxIbSize < ibSize) {
                maxIbSize = ibSize;
            }
        }
        this._verticesBinary = new ArrayBuffer(maxVbSize);
        this._indicesBinary = new ArrayBuffer(maxIbSize);
    };
    // Combine nodes together if they use the same material
    LoadMeshSync.prototype._groupNodesByMaterial = function (bufferNodes) {
        if (bufferNodes.length <= 1) {
            return;
        }
        var that = this;
        bufferNodes.sort(function (a, b) {
            var addr1 = a * NODEINFO_INT32;
            var addr2 = b * NODEINFO_INT32;
            var material1 = (that._nodesInfo[addr1 + 2] & 0xffff);
            var material2 = (that._nodesInfo[addr2 + 2] & 0xffff);
            if (material1 !== material2) {
                return material1 - material2;
            }
            var attribute1 = ((that._nodesInfo[addr1 + 8] >> 8) & 0xff);
            var attribute2 = ((that._nodesInfo[addr2 + 8] >> 8) & 0xff);
            return attribute1 - attribute2;
        });
        var addr = bufferNodes[0] * NODEINFO_INT32;
        var currentMaterial = (this._nodesInfo[addr + 2] & 0xffff);
        var currentAttribute = ((this._nodesInfo[addr + 8] >> 8) & 0xff);
        var nodesGroup = [bufferNodes[0]];
        for (var i = 1, len = bufferNodes.length; i < len; ++i) {
            addr = bufferNodes[i] * NODEINFO_INT32;
            var material = (this._nodesInfo[addr + 2] & 0xffff);
            var attribute = ((this._nodesInfo[addr + 8] >> 8) & 0xff);
            var indexType = (this._nodesInfo[addr + 8] & 0xff);
            if (indexType > 2 ||
                material !== currentMaterial ||
                attribute !== currentAttribute ||
                false) {
                this._splitNodesGroup(nodesGroup);
                nodesGroup = [bufferNodes[i]];
                currentMaterial = material;
                currentAttribute = attribute;
            }
            else {
                nodesGroup.push(bufferNodes[i]);
            }
        }
        this._splitNodesGroup(nodesGroup);
    };
    LoadMeshSync.prototype._splitNodesGroup = function (nodesGroup) {
        if (nodesGroup.length > 1) {
            // Group nodes and each group should not have exceed more than max vertices limit.
            var nodeIndex = nodesGroup[0];
            var prevIndex = nodeIndex;
            var headIndex = nodeIndex;
            var addr = nodeIndex * NODEINFO_INT32;
            this._nodesInfo[addr + 2] |= 0x80000000; // valid = true
            var currentBytes = this._nodesInfo[addr + 4]; // vertices bytes
            var attribute = ((this._nodesInfo[addr + 8] >> 8) & 0xff);
            var maxBytes = this._attributesData[attribute].values[0].stride * this._maxVertexNumber;
            for (var j = 1, len1 = nodesGroup.length; j < len1; ++j) {
                nodeIndex = nodesGroup[j];
                var bytes = this._nodesInfo[nodeIndex * NODEINFO_INT32 + 4];
                if (currentBytes + bytes > maxBytes) {
                    // FIXME: should already have been inited to 1
                    this._nodesInfo[nodeIndex * NODEINFO_INT32 + 2] |= 0x80000000; // valid = true 
                    headIndex = nodeIndex;
                    currentBytes = bytes;
                }
                else {
                    this._nodesInfo[nodeIndex * NODEINFO_INT32 + 2] &= ~0x80000000; // valid = false
                    this._nodesInfo[prevIndex * NODEINFO_INT32 + 3] = nodeIndex;
                    this._nodesInfo[headIndex * NODEINFO_INT32 + 6]++;
                    currentBytes += bytes;
                }
                prevIndex = nodeIndex;
            }
        }
    };
    // Compute the extra memory it consumes if we merge nodes.
    LoadMeshSync.prototype._computeMergeInfo = function (nodeIndex, meshes) {
        var addr = nodeIndex * NODEINFO_INT32;
        var attribute = ((this._nodesInfo[addr + 8] >> 8) & 0xff);
        var indexType = (this._nodesInfo[addr + 8] & 0xff);
        var attributeData = this._attributesData[attribute];
        var stride = attributeData.values[0].stride;
        var bytes = 0;
        var verticesBytes1 = this._nodesInfo[addr + 4];
        var indicesBytes1 = this._nodesInfo[addr + 5];
        var mesh = this._nodesInfo[addr + 1];
        if (!meshes[mesh]) {
            meshes[mesh] = 1;
            bytes += verticesBytes1 + indicesBytes1;
        }
        var verticesBytes = verticesBytes1;
        var indices = indicesBytes1 / indexType;
        var next = this._nodesInfo[addr + 3];
        while (next >= 0) {
            addr = next * NODEINFO_INT32;
            verticesBytes1 = this._nodesInfo[addr + 4];
            indicesBytes1 = this._nodesInfo[addr + 5];
            indexType = (this._nodesInfo[addr + 8] & 0xff);
            mesh = this._nodesInfo[addr + 1];
            if (!meshes[mesh]) {
                meshes[mesh] = 1;
                bytes += verticesBytes1 + indicesBytes1;
            }
            verticesBytes += verticesBytes1;
            indices += indicesBytes1 / indexType;
            next = this._nodesInfo[addr + 3];
        }
        var vertices = verticesBytes / stride;
        // Update index type.
        indexType = 1;
        if (vertices > 65536) {
            indexType = 4;
        }
        else if (vertices > 256) {
            indexType = 2;
        }
        var addr = nodeIndex * NODEINFO_INT32;
        this._nodesInfo[addr + 4] = verticesBytes;
        this._nodesInfo[addr + 5] = indices * indexType;
        this._nodesInfo[addr + 7] = bytes;
        this._nodesInfo[addr + 8] = (this._nodesInfo[addr + 8] & 0xffffff00) | indexType;
    };
    LoadMeshSync.prototype._deleteMergeInfo = function (nodeIndex, meshes) {
        var childNodeIndex = nodeIndex;
        var nodeInfo = new Int32Array(this._nodesInfo.buffer, childNodeIndex * NODEINFO_INT32 * 4, NODEINFO_INT32);
        var addr = childNodeIndex * NODEINFO_INT32;
        var meshData = this._modelBin.readMesh(nodeInfo[1]);
        this._nodesInfo[addr + 4] = meshData[2];
        this._nodesInfo[addr + 5] = meshData[4];
        this._nodesInfo[addr + 6] = 0;
        this._nodesInfo[addr + 8] = meshData[0];
        while (childNodeIndex >= 0) {
            addr = childNodeIndex * NODEINFO_INT32;
            var next = this._nodesInfo[addr + 3];
            this._nodesInfo[addr + 2] |= 0x80000000; // valid = true
            this._nodesInfo[addr + 3] = -1; // remove the child
            childNodeIndex = next;
        }
    };
    LoadMeshSync.prototype._createMerges = function (offsets, memoryBudget) {
        var mergeNodes = [];
        var mergeBytes = 0;
        var minCost = 1024 * 1024 * 1024;
        // flags if this mesh has been used by any nodes.
        var meshes = new Uint8Array(this._meshes);
        for (var i = 0, len = this._buffersNodes.length; i < len; i++) {
            var bufferNodes = this._buffersNodes[i];
            for (var j = offsets[i], len1 = bufferNodes.length; j < len1; ++j) {
                var nodeIndex = bufferNodes[j];
                var addr = nodeIndex * NODEINFO_INT32;
                if (this._nodesInfo[addr + 2] & 0x80000000) { // valid == true
                    if (this._nodesInfo[addr + 3] >= 0) {
                        this._computeMergeInfo(nodeIndex, meshes);
                        // If the extra memory cost is smaller than 128KB, we simply merge it.
                        var extraMemCost = this._nodesInfo[addr + 4] + this._nodesInfo[addr + 5] -
                            this._nodesInfo[addr + 7];
                        var bytes = this._nodesInfo[addr + 4] + this._nodesInfo[addr + 5];
                        if (extraMemCost < 130000) {
                            memoryBudget -= bytes;
                        }
                        else {
                            if (minCost > extraMemCost) {
                                minCost = extraMemCost;
                            }
                            memoryBudget -= this._nodesInfo[addr + 7]; // original mesh size
                            mergeNodes.push(nodeIndex);
                            mergeBytes += extraMemCost;
                        }
                    }
                    else {
                        if (!meshes[this._nodesInfo[addr + 1]]) {
                            memoryBudget -= (this._nodesInfo[addr + 4] + this._nodesInfo[addr + 5]);
                            meshes[this._nodesInfo[addr + 1]] = 1;
                        }
                    }
                    if (memoryBudget < 0) {
                        console.log("No enough GPU memory to load this model.");
                        throw (new Error("No enough GPU memory to load this model."));
                    }
                }
            }
        }
        // Check if the remaining memory can still meet the fullly merge. Solve
        // Knapsack problem if not.
        if (memoryBudget < mergeBytes) {
            // Normalize the cost 
            for (var i = 0, len = mergeNodes.length; i < len; i++) {
                var addr = mergeNodes[i] * NODEINFO_INT32;
                this._nodesInfo[addr + 7] = (this._nodesInfo[addr + 4] +
                    this._nodesInfo[addr + 5] -
                    this._nodesInfo[addr + 7]) / minCost;
            }
            // Use dynamic programming to solve Knapsack problem.
            // https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html
            var N = mergeNodes.length;
            var C = Math.ceil(memoryBudget / minCost);
            var V = new Uint32Array((N + 1) * (C + 1));
            for (var i = 1; i <= N; i++) {
                var c = this._nodesInfo[mergeNodes[i - 1] * NODEINFO_INT32 + 7];
                var v = this._nodesInfo[mergeNodes[i - 1] * NODEINFO_INT32 + 6];
                for (var j = 1; j <= C; j++) {
                    var i0 = i * (C + 1) + j;
                    var i1 = (i - 1) * (C + 1) + j;
                    if (j < c) {
                        V[i0] = V[i1];
                    }
                    else {
                        var i2 = (i - 1) * (C + 1) + j - c;
                        if (V[i1] > V[i2] + v) {
                            V[i0] = V[i1];
                        }
                        else {
                            V[i0] = V[i2] + v;
                        }
                    }
                }
            }
            var merges = new Uint8Array(mergeNodes.length);
            var that = this;
            var findMerges = function FindMerges(i, j) {
                if (i > 0) {
                    var c = that._nodesInfo[mergeNodes[i - 1] * NODEINFO_INT32 + 7];
                    var v = that._nodesInfo[mergeNodes[i - 1] * NODEINFO_INT32 + 6];
                    if (V[i * (C + 1) + j] === V[(i - 1) * (C + 1) + j]) {
                        FindMerges(i - 1, j);
                    }
                    else if (j - c >= 0 && V[i * (C + 1) + j] === V[(i - 1) * (C + 1) + j - c] + v) {
                        merges[i - 1] = 1;
                        FindMerges(i - 1, j - c);
                    }
                }
            };
            findMerges(N, C);
            var meshes1 = new Uint8Array(this._meshes);
            for (var i = 0, len = merges.length; i < len; i++) {
                if (!merges[i]) {
                    // We split the merge nodes.
                    this._deleteMergeInfo(mergeNodes[i], meshes1);
                }
            }
        }
    };
    LoadMeshSync.prototype.load = function (meshBufferIndex, meshBinary, onNodeDataReady) {
        var bufferNodes = this._buffersNodes[meshBufferIndex];
        var vertexBuffer = this._resourceManager.getBuffer(this._modelIdPrefix + "vmesh" + meshBufferIndex + ".bin");
        var indexBuffer = this._resourceManager.getBuffer(this._modelIdPrefix + "imesh" + meshBufferIndex + ".bin");
        // Initialize the buffer data so that meshes sharing these buffer are valid.
        vertexBuffer.create(gl.ARRAY_BUFFER, new Uint8Array(1));
        indexBuffer.create(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(1));
        this._verticesOffset = 0;
        this._indicesOffset = 0;
        //if (this._study) {
        //    var orphans = 0;
        //    var orphanMeshBytes = 0;
        //    var merges = 0;
        //    var mergedMeshBytes = 0;
        //}
        //console.log(`mesh.bin,orphans,orphanMeshBytes,merges,mergedMeshBytes`);
        for (var i = 0, len = bufferNodes.length; i < len; ++i) {
            var nodeIndex = bufferNodes[i];
            var nodeInfo = new Int32Array(this._nodesInfo.buffer, 4 * nodeIndex * NODEINFO_INT32, NODEINFO_INT32);
            if (nodeInfo[2] & 0x80000000) {
                var vertices = null;
                var indices = null;
                if (nodeInfo[3] < 0) { // It is a longly node without any slibings sharing the same mesh.
                    var meshData = this._modelBin.readMesh(nodeInfo[1]);
                    // if a scene has too many stagedMeshes, the gpu will be busy and cpu will be idle during rendering
                    var isStagedMesh = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].useStagedMesh && ((nodeInfo[2] >> 24) & 0x0f) > _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_1__["default"].MEP;
                    // If this mesh has never been created before.
                    if (!this._resourceManager.hasMesh(nodeInfo[1] >= 0 ? this._modelIdPrefix + nodeInfo[1].toString() : this._modelIdPrefix + (-nodeInfo[0].toString()))) {
                        var attributeData = this._attributesData[(nodeInfo[8] >> 8) & 0xff];
                        var encodedIndexType = (meshData[0] & 0xff);
                        var verticesFloats = meshData[2] / 4;
                        var verticesNumber = meshData[2] / attributeData.values[0].stride;
                        if (this._compressNormal && attributeData.hasNormal) {
                            verticesFloats -= meshData[2] / attributeData.values[0].stride;
                        }
                        if (isStagedMesh) {
                            vertices = new Float32Array(verticesFloats);
                            indices = new Uint8Array(meshData[4]);
                        }
                        else {
                            vertices = new Float32Array(this._verticesBinary, this._verticesOffset, verticesFloats);
                            indices = new Uint8Array(this._indicesBinary, this._indicesOffset, meshData[4]);
                        }
                        var encodedVertices = new Float32Array(meshBinary, meshData[1], meshData[2] / 4);
                        UncompressVertices(vertices, encodedVertices, attributeData, this._compressNormal);
                        var encodedIndices = new Uint8Array(meshBinary, meshData[3], meshData[4]);
                        UncompressIndices(indices, encodedIndices, meshData[4], 0);
                        nodeInfo[4] = verticesNumber;
                        // Note that since for simple drawable with only one node, we don't need to 
                        // pad the vis/mat vertex attribute as it can be changed in CPU side.
                        if (!isStagedMesh) {
                            this._verticesOffset += verticesFloats * 4;
                            this._indicesOffset += meshData[4];
                            this._verticesOffset = (this._verticesOffset + 3) & (-4);
                            this._indicesOffset = (this._indicesOffset + 3) & (-4);
                            onNodeDataReady(nodeInfo, vertexBuffer, indexBuffer, vertices, indices, this._nodesInfo, isStagedMesh);
                        }
                        else {
                            onNodeDataReady(nodeInfo, this._stagedVBuffer, this._stagedIBuffer, new Uint8Array(vertices.buffer, vertices.byteOffset, vertices.byteLength), indices, this._nodesInfo, isStagedMesh);
                        }
                    }
                    else {
                        onNodeDataReady(nodeInfo, vertexBuffer, indexBuffer, null, null, this._nodesInfo, isStagedMesh);
                    }
                }
                else {
                    // if a scene has too many stagedMeshes, the gpu will be busy and cpu will be idle during rendering
                    var isStagedMesh = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].useStagedMesh;
                    var childNodeIndex = nodeInfo[0];
                    while (isStagedMesh && childNodeIndex >= 0) {
                        var region = (this._nodesInfo[childNodeIndex * NODEINFO_INT32 + 2] >> 24) & 0x0f;
                        if (region <= _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_1__["default"].STRUCTURE_INTERIOR) {
                            isStagedMesh = false;
                            break;
                        }
                        childNodeIndex = this._nodesInfo[childNodeIndex * NODEINFO_INT32 + 3];
                    }
                    if (isStagedMesh) {
                        var attributeData = this._attributesData[(nodeInfo[8] >> 8) & 0xff];
                        var bufferInfo = {
                            verticesBinary: new ArrayBuffer(nodeInfo[4] + nodeInfo[4] / attributeData.values[0].stride),
                            indicesBinary: new ArrayBuffer(nodeInfo[5]),
                            verticesOffset: 0,
                            indicesOffset: 0
                        };
                        nodeInfo = this._populateMergedNode(nodeInfo, meshBinary, bufferInfo);
                        var vertices = new Uint8Array(bufferInfo.verticesBinary);
                        var indices = new Uint8Array(bufferInfo.indicesBinary);
                        onNodeDataReady(nodeInfo, this._stagedVBuffer, this._stagedIBuffer, vertices, indices, this._nodesInfo, isStagedMesh);
                    }
                    else {
                        var verticesOffset = this._verticesOffset;
                        var indicesOffset = this._indicesOffset;
                        var bufferInfo = {
                            verticesBinary: this._verticesBinary,
                            indicesBinary: this._indicesBinary,
                            verticesOffset: this._verticesOffset,
                            indicesOffset: this._indicesOffset
                        };
                        nodeInfo = this._populateMergedNode(nodeInfo, meshBinary, bufferInfo);
                        this._verticesOffset = bufferInfo.verticesOffset;
                        this._indicesOffset = bufferInfo.indicesOffset;
                        var verticesBytes = this._verticesOffset - verticesOffset;
                        var indicesBytes = this._indicesOffset - indicesOffset;
                        // Align the vertices and indices binary to 4.
                        this._verticesOffset = (this._verticesOffset + 3) & (-4);
                        this._indicesOffset = (this._indicesOffset + 3) & (-4);
                        var vertices = new Uint8Array(this._verticesBinary, verticesOffset, verticesBytes);
                        var indices = new Uint8Array(this._indicesBinary, indicesOffset, indicesBytes);
                        onNodeDataReady(nodeInfo, vertexBuffer, indexBuffer, vertices, indices, this._nodesInfo, isStagedMesh);
                    }
                }
            }
        }
        //console.log(`mesh${meshBufferIndex},${orphans},${orphanMeshBytes},${merges},${mergedMeshBytes},${this._verticesOffset},${this._indicesOffset}`);
        // Update the buffer data.
        vertexBuffer.update(new Uint8Array(this._verticesBinary, 0, this._verticesOffset));
        indexBuffer.update(new Uint8Array(this._indicesBinary, 0, this._indicesOffset));
    };
    var translate = new Float32Array([0, 0, 0]);
    var scale = new Float32Array([0, 0, 0]);
    var tempVector31 = new Float32Array(3); // temporary variable
    var tempVector32 = new Float32Array(3); // ditto
    function IsTranslationMatrix(mat) {
        return Math.abs(mat[0] - 1.0) < 1e-6 &&
            Math.abs(mat[1]) < 1e-6 &&
            Math.abs(mat[2]) < 1e-6 &&
            Math.abs(mat[3]) < 1e-6 &&
            Math.abs(mat[4] - 1.0) < 1e-6 &&
            Math.abs(mat[5]) < 1e-6 &&
            Math.abs(mat[6]) < 1e-6 &&
            Math.abs(mat[7]) < 1e-6 &&
            Math.abs(mat[8] - 1.0) < 1e-6;
    }
    ;
    function IsTranslationScalingMatrix(mat) {
        return Math.abs(mat[1]) < 1e-6 &&
            Math.abs(mat[2]) < 1e-6 &&
            Math.abs(mat[3]) < 1e-6 &&
            Math.abs(mat[5]) < 1e-6 &&
            Math.abs(mat[6]) < 1e-6 &&
            Math.abs(mat[7]) < 1e-6;
    }
    ;
    // out = box | out
    function UnionBBox(out, bbox) {
        out[0] = Math.min(out[0], bbox[0]);
        out[1] = Math.min(out[1], bbox[1]);
        out[2] = Math.min(out[2], bbox[2]);
        out[3] = Math.max(out[3], bbox[3]);
        out[4] = Math.max(out[4], bbox[4]);
        out[5] = Math.max(out[5], bbox[5]);
    }
    ;
    function TransformUncompressVertices1(vertices, encodedVertices, attributeData, translate, compressNormal) {
        var vertexNumber = ((encodedVertices.byteLength / attributeData.values[0].stride) | 0);
        var numFloats = (((attributeData.values[0].stride | 0) >> 2) | 0);
        var totalNumFloats = (((numFloats | 0) * (vertexNumber | 0)) | 0);
        var i;
        if (attributeData.primitive === 4) {
            if (compressNormal) {
                var normals = new Uint8Array(vertices.buffer, vertices.byteOffset, vertices.byteLength);
                var encodedNormals = new Uint8Array(encodedVertices.buffer, encodedVertices.byteOffset, encodedVertices.byteLength);
                for (i = 0; i < vertexNumber; i++) {
                    var d = i * (numFloats - 1);
                    var s = i * numFloats;
                    // position
                    vertices[d] = encodedVertices[s] + translate[0];
                    vertices[d + 1] = encodedVertices[s + 1] + translate[1];
                    vertices[d + 2] = encodedVertices[s + 2] + translate[2];
                    // normal
                    d = (d << 2);
                    s = (s << 2);
                    normals[d] = encodedNormals[s + 12];
                    normals[d + 4] = encodedNormals[s + 13];
                    normals[d + 8] = encodedNormals[s + 14];
                }
                if (attributeData.values.length > 2) {
                    if (attributeData.values[2].index === 4) { // texcoord 
                        for (i = 0; i < vertexNumber; i++) {
                            var s = i * 6 + 4;
                            var d = i * 5 + 3;
                            vertices[d] = encodedVertices[s];
                            vertices[d + 1] = encodedVertices[s + 1];
                        }
                    }
                    else { // vertex color
                        for (i = 0; i < vertexNumber; i++) {
                            var s = i * 5 + 4;
                            var d = i * 4 + 3;
                            vertices[d] = encodedVertices[s];
                        }
                    }
                }
            }
            else {
                for (i = 0; i < totalNumFloats; i += numFloats) {
                    // position
                    vertices[i] = encodedVertices[i] + translate[0];
                    vertices[i + 1] = encodedVertices[i + 1] + translate[1];
                    vertices[i + 2] = encodedVertices[i + 2] + translate[2];
                    // normal
                    vertices[i + 3] = encodedVertices[i + 3];
                }
                if (attributeData.values.length > 2) {
                    if (attributeData.values[2].index === 4) { // texcoord 
                        for (i = 4; i < totalNumFloats; i += numFloats) {
                            vertices[i] = encodedVertices[i];
                            vertices[i + 1] = encodedVertices[i + 1];
                        }
                    }
                    else { // vertex color
                        for (i = 4; i < totalNumFloats; i += numFloats) {
                            vertices[i] = encodedVertices[i];
                        }
                    }
                }
            }
        }
        else {
            for (i = 0; i < totalNumFloats; i += 3) {
                vertices[i] = encodedVertices[i] + translate[0];
                vertices[i + 1] = encodedVertices[i + 1] + translate[1];
                vertices[i + 2] = encodedVertices[i + 2] + translate[2];
            }
        }
    }
    ;
    function TransformUncompressVertices2(vertices, encodedVertices, attributeData, scale, translate, compressNormal) {
        var vertexNumber = ((encodedVertices.byteLength / attributeData.values[0].stride) | 0);
        var numFloats = (((attributeData.values[0].stride | 0) >> 2) | 0);
        var totalNumFloats = (((numFloats | 0) * (vertexNumber | 0)) | 0);
        var i;
        if (attributeData.primitive === 4) {
            var normals = new Uint8Array(vertices.buffer, vertices.byteOffset, vertices.byteLength);
            var encodedNormals = new Uint8Array(encodedVertices.buffer, encodedVertices.byteOffset, encodedVertices.byteLength);
            // If it is a uniform scaling
            // FIXME: if the scaling is negative.
            if (scale[0] === scale[1] && scale[1] === scale[2]) {
                if (compressNormal) {
                    for (i = 0; i < vertexNumber; i++) {
                        var d = i * (numFloats - 1);
                        var s = i * numFloats;
                        // position
                        vertices[d] = encodedVertices[s] * scale[0] + translate[0];
                        vertices[d + 1] = encodedVertices[s + 1] * scale[1] + translate[1];
                        vertices[d + 2] = encodedVertices[s + 2] * scale[2] + translate[2];
                        // normal
                        d = (d << 2);
                        s = (s << 2);
                        normals[d] = encodedNormals[s + 12];
                        normals[d + 4] = encodedNormals[s + 13];
                        normals[d + 8] = encodedNormals[s + 14];
                    }
                }
                else {
                    for (i = 0; i < totalNumFloats; i += numFloats) {
                        // position
                        vertices[i] = encodedVertices[i] * scale[0] + translate[0];
                        vertices[i + 1] = encodedVertices[i + 1] * scale[1] + translate[1];
                        vertices[i + 2] = encodedVertices[i + 2] * scale[2] + translate[2];
                        // normal
                        vertices[i + 3] = encodedVertices[i + 3];
                    }
                }
            }
            else {
                var n = tempVector31;
                var invScale = tempVector32;
                invScale[0] = 1.0 / scale[0];
                invScale[1] = 1.0 / scale[1];
                invScale[2] = 1.0 / scale[2];
                if (compressNormal) {
                    for (i = 0; i < vertexNumber; i++) {
                        var d = i * (numFloats - 1);
                        var s = i * numFloats;
                        // position
                        vertices[d] = encodedVertices[s] * scale[0] + translate[0];
                        vertices[d + 1] = encodedVertices[s + 1] * scale[1] + translate[1];
                        vertices[d + 2] = encodedVertices[s + 2] * scale[2] + translate[2];
                        // normal
                        d = (d << 2);
                        s = (s << 2);
                        var normal0 = encodedNormals[s + 12];
                        var normal1 = encodedNormals[s + 13];
                        var normal2 = encodedNormals[s + 14];
                        n[0] = normal0 * invScale[0];
                        n[1] = normal1 * invScale[1];
                        n[2] = normal2 * invScale[2];
                        var inv = 127.0 / Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
                        index = i << 2;
                        normals[d] = n[0] * inv;
                        normals[d + 4] = n[1] * inv;
                        normals[d + 8] = n[2] * inv;
                    }
                }
                else {
                    for (i = 0; i < totalNumFloats; i += numFloats) {
                        // position
                        vertices[i] = encodedVertices[i] * scale[0] + translate[0];
                        vertices[i + 1] = encodedVertices[i + 1] * scale[1] + translate[1];
                        vertices[i + 2] = encodedVertices[i + 2] * scale[2] + translate[2];
                        // normal
                        var index = (i << 2) + 12;
                        var normal0 = encodedNormals[index];
                        var normal1 = encodedNormals[index + 1];
                        var normal2 = encodedNormals[index + 2];
                        n[0] = normal0 * invScale[0];
                        n[1] = normal1 * invScale[1];
                        n[2] = normal2 * invScale[2];
                        var inv = 127.0 / Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
                        normals[index] = n[0] * inv;
                        normals[index + 1] = n[1] * inv;
                        normals[index + 2] = n[2] * inv;
                    }
                }
            }
            if (attributeData.values.length > 2) {
                if (compressNormal) {
                    if (attributeData.values[2].index === 4) { // texcoord 
                        for (i = 0; i < vertexNumber; i++) {
                            var s = i * 6 + 4;
                            var d = i * 5 + 3;
                            vertices[d] = encodedVertices[s];
                            vertices[d + 1] = encodedVertices[s + 1];
                        }
                    }
                    else { // vertex color
                        for (i = 0; i < vertexNumber; i++) {
                            var s = i * 5 + 4;
                            var d = i * 4 + 3;
                            vertices[d] = encodedVertices[s];
                        }
                    }
                }
                else {
                    if (attributeData.values[2].index === 4) { // texcoord 
                        for (i = 4; i < totalNumFloats; i += numFloats) {
                            vertices[i] = encodedVertices[i];
                            vertices[i + 1] = encodedVertices[i + 1];
                        }
                    }
                    else { // vertex color
                        for (i = 4; i < totalNumFloats; i += numFloats) {
                            vertices[i] = encodedVertices[i];
                        }
                    }
                }
            }
        }
        else {
            for (i = 0; i < totalNumFloats; i += 3) {
                // position
                vertices[i] = encodedVertices[i] * scale[0] + translate[0];
                vertices[i + 1] = encodedVertices[i + 1] * scale[1] + translate[1];
                vertices[i + 2] = encodedVertices[i + 2] * scale[2] + translate[2];
            }
        }
    }
    ;
    function TransformUncompressVertices3(vertices, encodedVertices, attributeData, transform, compressNormal) {
        var vertexNumber = ((encodedVertices.byteLength / attributeData.values[0].stride) | 0);
        var numFloats = (((attributeData.values[0].stride | 0) >> 2) | 0);
        var totalNumFloats = (((numFloats | 0) * (vertexNumber | 0)) | 0);
        var m0 = transform[0];
        var m1 = transform[1];
        var m2 = transform[2];
        var m4 = transform[3];
        var m5 = transform[4];
        var m6 = transform[5];
        var m8 = transform[6];
        var m9 = transform[7];
        var m10 = transform[8];
        var m12 = transform[9];
        var m13 = transform[10];
        var m14 = transform[11];
        var i;
        if (attributeData.primitive === 4) {
            var n = tempVector31;
            var encodedNormals = new Int8Array(encodedVertices.buffer, encodedVertices.byteOffset, totalNumFloats * 4);
            var normals = new Int8Array(vertices.buffer, vertices.byteOffset, vertices.byteLength);
            if (compressNormal) {
                for (i = 0; i < vertexNumber; i++) {
                    var d = i * (numFloats - 1);
                    var s = i * numFloats;
                    // position
                    var x = encodedVertices[s];
                    var y = encodedVertices[s + 1];
                    var z = encodedVertices[s + 2];
                    var nx = m0 * x + m4 * y + m8 * z + m12;
                    var ny = m1 * x + m5 * y + m9 * z + m13;
                    var nz = m2 * x + m6 * y + m10 * z + m14;
                    vertices[d] = nx;
                    vertices[d + 1] = ny;
                    vertices[d + 2] = nz;
                    // normal
                    d = (d << 2);
                    s = (s << 2);
                    var normal0 = encodedNormals[s + 12];
                    var normal1 = encodedNormals[s + 13];
                    var normal2 = encodedNormals[s + 14];
                    n[0] = m0 * normal0 + m4 * normal1 + m8 * normal2;
                    n[1] = m1 * normal0 + m5 * normal1 + m9 * normal2;
                    n[2] = m2 * normal0 + m6 * normal1 + m10 * normal2;
                    var inv = 127.0 / Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
                    normals[d] = n[0] * inv;
                    normals[d + 4] = n[1] * inv;
                    normals[d + 8] = n[2] * inv;
                }
                if (attributeData.values.length > 2) {
                    if (attributeData.values[2].index === 4) { // texcoord 
                        for (i = 0; i < vertexNumber; i++) {
                            var s = i * 6 + 4;
                            var d = i * 5 + 3;
                            vertices[d] = encodedVertices[s];
                            vertices[d + 1] = encodedVertices[s + 1];
                        }
                    }
                    else { // vertex color
                        for (i = 0; i < vertexNumber; i++) {
                            var s = i * 5 + 4;
                            var d = i * 4 + 3;
                            vertices[d] = encodedVertices[s];
                        }
                    }
                }
            }
            else {
                for (i = 0; i < totalNumFloats; i += numFloats) {
                    // position
                    var x = encodedVertices[i];
                    var y = encodedVertices[i + 1];
                    var z = encodedVertices[i + 2];
                    var nx = m0 * x + m4 * y + m8 * z + m12;
                    var ny = m1 * x + m5 * y + m9 * z + m13;
                    var nz = m2 * x + m6 * y + m10 * z + m14;
                    vertices[i] = nx;
                    vertices[i + 1] = ny;
                    vertices[i + 2] = nz;
                    // normal
                    var index = (i << 2) + 12;
                    var normal0 = encodedNormals[index];
                    var normal1 = encodedNormals[index + 1];
                    var normal2 = encodedNormals[index + 2];
                    n[0] = m0 * normal0 + m4 * normal1 + m8 * normal2;
                    n[1] = m1 * normal0 + m5 * normal1 + m9 * normal2;
                    n[2] = m2 * normal0 + m6 * normal1 + m10 * normal2;
                    var inv = 127.0 / Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
                    normals[index] = n[0] * inv;
                    normals[index + 1] = n[1] * inv;
                    normals[index + 2] = n[2] * inv;
                }
                if (attributeData.values.length > 2) {
                    if (attributeData.values[2].index === 4) { // texcoord 
                        for (i = 4; i < totalNumFloats; i += numFloats) {
                            vertices[i] = encodedVertices[i];
                            vertices[i + 1] = encodedVertices[i + 1];
                        }
                    }
                    else { // vertex color
                        for (i = 4; i < totalNumFloats; i += numFloats) {
                            vertices[i] = encodedVertices[i];
                        }
                    }
                }
            }
        }
        else {
            for (i = 0; i < totalNumFloats; i += 3) {
                // position
                var x = encodedVertices[i];
                var y = encodedVertices[i + 1];
                var z = encodedVertices[i + 2];
                var nx = m0 * x + m4 * y + m8 * z + m12;
                var ny = m1 * x + m5 * y + m9 * z + m13;
                var nz = m2 * x + m6 * y + m10 * z + m14;
                vertices[i] = nx;
                vertices[i + 1] = ny;
                vertices[i + 2] = nz;
            }
        }
    }
    ;
    function UncompressIndices(indices, encodedIndices, numIndices, vertexIndexOffset) {
        for (var i = 0; i < numIndices; i++) {
            indices[i] = (encodedIndices[i] + (vertexIndexOffset | 0));
        }
    }
    ;
    function UncompressVertices(vertices, encodedVertices, attributeData, compressNormal) {
        var vertexNumber = ((encodedVertices.byteLength / attributeData.values[0].stride) | 0);
        var numFloats = (((attributeData.values[0].stride | 0) >> 2) | 0);
        var i;
        var totalNumFloats = (((numFloats | 0) * (vertexNumber | 0)) | 0);
        if (attributeData.primitive === 4 && compressNormal) {
            var encodedNormals = new Int8Array(encodedVertices.buffer, encodedVertices.byteOffset, encodedVertices.byteLength);
            var normals = new Int8Array(vertices.buffer, vertices.byteOffset, vertices.byteLength);
            for (var d = 0, s = 0; s < totalNumFloats; s += numFloats, d += (numFloats - 1)) {
                // position
                vertices[d] = encodedVertices[s];
                vertices[d + 1] = encodedVertices[s + 1];
                vertices[d + 2] = encodedVertices[s + 2];
                // normal
                var d1 = (d << 2);
                var s1 = (s << 2);
                normals[d1] = encodedNormals[s1 + 12];
                normals[d1 + 4] = encodedNormals[s1 + 13];
                normals[d1 + 8] = encodedNormals[s1 + 14];
            }
            if (attributeData.values.length > 2) {
                if (attributeData.values[2].index === 4) { // texcoord 
                    for (var d = 3, s = 4; s < totalNumFloats; d += 5, s += 6) {
                        vertices[d] = encodedVertices[s];
                        vertices[d + 1] = encodedVertices[s + 1];
                    }
                }
                else { // vertex color
                    for (var d = 3, s = 4; s < totalNumFloats; d += 4, s += 5) {
                        vertices[d] = encodedVertices[s];
                    }
                }
            }
        }
        else {
            vertices.set(encodedVertices, 0, totalNumFloats);
        }
    }
    ;
    LoadMeshSync.prototype._populateMergedNode = function (nodeInfo, meshBinary, bufferInfo) {
        var attributeData = this._attributesData[(nodeInfo[8] >> 8) & 0xff];
        var baseIndicesOffset = bufferInfo.indicesOffset;
        var indexTypeAttribute = nodeInfo[8];
        var nodeBBoxData = this._modelBin.readNodeBBox(nodeInfo[0]);
        var indexType = (nodeInfo[8] & 0xff);
        var nodes = [];
        var childNodeIndex = nodeInfo[0];
        while (childNodeIndex >= 0) {
            nodes.push(childNodeIndex);
            childNodeIndex = this._nodesInfo[childNodeIndex * NODEINFO_INT32 + 3];
        }
        var that = this;
        // Sort the nodes in the ascending order of rendering importance (region + bbox)
        nodes.sort(function (a, b) {
            var region1 = ((that._nodesInfo[a * NODEINFO_INT32 + 2] >> 24) & 0x0f);
            var region2 = ((that._nodesInfo[b * NODEINFO_INT32 + 2] >> 24) & 0x0f);
            return region1 - region2; // The smaller region value is, the more important it is.
        });
        // The current vertices number.
        var vertexNumber = 0;
        for (var i = 0, len = nodes.length; i < len; i++) {
            var nodeData = new Int32Array(this._nodesInfo.buffer, 4 * NODEINFO_INT32 * nodes[i], NODEINFO_INT32);
            var transformData = this._modelBin.readNodeTransform(nodeData[0]);
            var bboxData = this._modelBin.readNodeBBox(nodeData[0]);
            var meshData = this._modelBin.readMesh(nodeData[1]);
            var encodedVertices = new Float32Array(meshBinary, meshData[1], meshData[2] / 4);
            var verticesFloats = meshData[2] / 4;
            if (this._compressNormal && attributeData.hasNormal) {
                verticesFloats -= meshData[2] / attributeData.values[0].stride;
            }
            var vertices = new Float32Array(bufferInfo.verticesBinary, bufferInfo.verticesOffset, verticesFloats);
            if ((nodeData[2] & 0x40000000) === 0) {
                if (IsTranslationMatrix(transformData)) {
                    translate[0] = transformData[9];
                    translate[1] = transformData[10];
                    translate[2] = transformData[11];
                    TransformUncompressVertices1(vertices, encodedVertices, attributeData, translate, this._compressNormal);
                }
                else if (IsTranslationScalingMatrix(transformData)) {
                    translate[0] = transformData[9];
                    translate[1] = transformData[10];
                    translate[2] = transformData[11];
                    scale[0] = transformData[0];
                    scale[1] = transformData[4];
                    scale[2] = transformData[8];
                    TransformUncompressVertices2(vertices, encodedVertices, attributeData, scale, translate, this._compressNormal);
                }
                else {
                    TransformUncompressVertices3(vertices, encodedVertices, attributeData, transformData, this._compressNormal);
                }
            }
            else {
                UncompressVertices(vertices, encodedVertices, attributeData, this._compressNormal);
            }
            bufferInfo.verticesOffset += verticesFloats * 4;
            UnionBBox(nodeBBoxData, bboxData);
            var indices = null;
            var encodedIndices = null;
            var numIndices = 0;
            var encodedIndexType = (meshData[0] & 0xff);
            switch (encodedIndexType) {
                case 4:
                    numIndices = meshData[4] / 4;
                    encodedIndices = new Uint32Array(meshBinary, meshData[3], numIndices);
                    break;
                case 2:
                    numIndices = meshData[4] / 2;
                    encodedIndices = new Uint16Array(meshBinary, meshData[3], numIndices);
                    break;
                default:
                    numIndices = meshData[4];
                    encodedIndices = new Uint8Array(meshBinary, meshData[3], numIndices);
                    break;
            }
            switch (indexType) {
                case 4:
                    indices = new Uint32Array(bufferInfo.indicesBinary, bufferInfo.indicesOffset, numIndices);
                    break;
                case 2:
                    indices = new Uint16Array(bufferInfo.indicesBinary, bufferInfo.indicesOffset, numIndices);
                    break;
                default:
                    indices = new Uint8Array(bufferInfo.indicesBinary, bufferInfo.indicesOffset, numIndices);
                    break;
            }
            UncompressIndices(indices, encodedIndices, numIndices, vertexNumber);
            nodeData[6] = bufferInfo.indicesOffset - baseIndicesOffset;
            nodeData[7] = numIndices;
            nodeData[4] = meshData[2] / attributeData.values[0].stride;
            ;
            vertexNumber += nodeData[4];
            bufferInfo.indicesOffset += numIndices * indexType;
        }
        // Add the vertex material/visiblity bytes to the end of vertices buffer of each mesh.
        var mvBytes = new Uint8Array(bufferInfo.verticesBinary, bufferInfo.verticesOffset, vertexNumber);
        mvBytes.fill(0);
        bufferInfo.verticesOffset += vertexNumber;
        // Re-order the nodes in the list according to the previous sorting result.
        for (var i = 0, len = nodes.length - 1; i < len; i++) {
            var nodeIndex = nodes[i];
            this._nodesInfo[nodeIndex * NODEINFO_INT32 + 3] = nodes[i + 1];
        }
        var nodeIndex = nodes[i];
        this._nodesInfo[nodeIndex * NODEINFO_INT32 + 3] = -1;
        // Fetch the first node information. 
        nodeInfo = new Int32Array(this._nodesInfo.buffer, nodes[0] * NODEINFO_INT32 * 4, NODEINFO_INT32);
        // Since the first node of the node list of the merge node has changed, we should update its
        // information for the merge node.
        // Update the bbox of the first node to merged bbox.
        var nodeBBoxData1 = this._modelBin.readNodeBBox(nodeInfo[0]);
        nodeBBoxData1[0] = nodeBBoxData[0];
        nodeBBoxData1[1] = nodeBBoxData[1];
        nodeBBoxData1[2] = nodeBBoxData[2];
        nodeBBoxData1[3] = nodeBBoxData[3];
        nodeBBoxData1[4] = nodeBBoxData[4];
        nodeBBoxData1[5] = nodeBBoxData[5];
        // Set the attribute and index type
        nodeInfo[8] = indexTypeAttribute;
        // It is a new mesh.
        nodeInfo[1] = -1;
        // Remove the transform
        nodeInfo[2] |= 0x40000000;
        return nodeInfo;
    };
    return LoadMeshSync;
})());


/***/ }),

/***/ "./07loadsave/mx3/m3d_load_modelgraph.js":
/*!***********************************************!*\
  !*** ./07loadsave/mx3/m3d_load_modelgraph.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/graph/m3d_element.js */ "./03scene/graph/m3d_element.js");
//
// m3d_load_modelgraph.js
// Load the model scene graph 
//
// Copyright Modelo XX - 2017, All rights reserved.



/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function ModelGraphLoader(sceneObject, resourceManager, model) {
        this._sceneObject = sceneObject;
        this._resourceManager = resourceManager;
        this._model = model;
    }
    ;
    ModelGraphLoader.prototype.destroy = function () {
        this._sceneObject = null;
        delete this._sceneObject;
        this._resourceManager = null;
        delete this._resourceManager;
        this._model = null;
        delete this._model;
    };
    ModelGraphLoader.prototype.load = function (modelFilePromises, progressTracker) {
        var that = this;
        var onprogress1 = progressTracker.getSingleFileProgress();
        return modelFilePromises["modelgraph.bin"].downloadFile(function (eventData) {
            onprogress1(eventData.loaded);
        })
            .then(function (res) {
            return that._parse(res.data);
        });
    };
    ModelGraphLoader.prototype._parse = function (modelGraphBin) {
        var graph = this._model.graph;
        var rootElement = new _03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__["default"](_03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROOT, -1);
        graph.root = rootElement;
        var byteLength = modelGraphBin.byteLength;
        var len = byteLength / 9;
        var index = 0;
        var e_name, e_father, e_type;
        var fathers = [];
        fathers.push(rootElement);
        var currentDocName = 0;
        for (var i = 0; i < len; i++) {
            var data = new Uint8Array(modelGraphBin, i * 9, 9);
            e_name = ((data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0]);
            e_father = ((data[7] << 24) | (data[6] << 16) | (data[5] << 8) | data[4]);
            e_type = data[8];
            // Find the father 
            while (fathers.length > 0 && fathers[fathers.length - 1].name !== e_father) {
                fathers.pop();
            }
            if (fathers.length === 0) {
                console.log("father of " + e_name + " is wrong");
                return _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.getPromiseLibrary().reject("error");
            }
            var father = fathers[fathers.length - 1];
            // Create the element node object
            if (e_type === _03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__["default"].NODE) {
                var node = graph.nodes[e_name];
                node.father = father;
                father.children.push(node);
            }
            else {
                if (e_type === _03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINK) {
                    currentDocName = e_name;
                }
                // The element name in the tree is cat result of model Id, doc Id and element Id.
                var elementName = this._model.id + "+" + currentDocName + '/' + e_name;
                var element = new _03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__["default"](e_type, e_name);
                if (e_type == _03scene_graph_m3d_element_js__WEBPACK_IMPORTED_MODULE_2__["default"].ELEMENT) {
                    graph.elements[elementName] = element;
                    graph.elementsNum++;
                }
                element.father = father;
                father.children.push(element);
                fathers.push(element);
            }
        }
        // Compute the bbox of each element
        for (var i = 0, len = rootElement.children.length; i < len; i++) {
            this._computeBBox(rootElement.children[i]);
        }
        // DEBUGGING
        //console.log("root");
        //for (var i = 0, len = rootElement.children.length; i < len; i++) {
        //    this._printTree(1, rootElement.children[i]);
        //}
        return _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendCallbacks.getPromiseLibrary().resolve("ok");
    };
    ModelGraphLoader.prototype._printTree = function (depth, node) {
        var line = '';
        for (var i = 0; i < depth; i++) {
            line += ' ';
        }
        var types = [
            "root",
            "i",
            "g",
            "e",
            "n",
            "l",
        ];
        if (node.hasOwnProperty("id")) { // Node
            line += "n " + "id=" + node.id;
            console.log(line);
        }
        else {
            line += types[node.type] + " name=" + node.name;
            console.log(line);
            for (var i = 0, len = node.children.length; i < len; i++) {
                this._printTree(depth + 1, node.children[i]);
            }
        }
    };
    var bbox1 = new Float32Array(6);
    ModelGraphLoader.prototype._computeBBox = function (node) {
        for (var i = 0, len = node.children.length; i < len; i++) {
            var child = node.children[i];
            var bbox;
            if (child.hasOwnProperty("id")) { // Node
                var graph = this._model.graph;
                graph.getNodeBBox(child.id, bbox1);
                bbox = bbox1;
            }
            else { // Node
                this._computeBBox(child);
                bbox = child.bbox;
            }
            _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.union(node.bbox, node.bbox, bbox);
        }
    };
    return ModelGraphLoader;
})());


/***/ }),

/***/ "./07loadsave/mx3/m3d_load_mx3.js":
/*!****************************************!*\
  !*** ./07loadsave/mx3/m3d_load_mx3.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../m3d_errors.js */ "./m3d_errors.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _03scene_m3d_layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/m3d_layer.js */ "./03scene/m3d_layer.js");
/* harmony import */ var _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/graph/m3d_node.js */ "./03scene/graph/m3d_node.js");
/* harmony import */ var _03scene_m3d_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../03scene/m3d_model.js */ "./03scene/m3d_model.js");
/* harmony import */ var _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../m3d_load_misc.js */ "./07loadsave/m3d_load_misc.js");
/* harmony import */ var _m3d_load_mesh_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./m3d_load_mesh.js */ "./07loadsave/mx3/m3d_load_mesh.js");
/* harmony import */ var _mx2_m3d_load_texture_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../mx2/m3d_load_texture.js */ "./07loadsave/mx2/m3d_load_texture.js");
/* harmony import */ var _m3d_load_scenemodelbin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./m3d_load_scenemodelbin.js */ "./07loadsave/mx3/m3d_load_scenemodelbin.js");
/* harmony import */ var _m3d_load_modelgraph_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./m3d_load_modelgraph.js */ "./07loadsave/mx3/m3d_load_modelgraph.js");
//
// m3d_load_mx3.js
// Load mx format version 3.0
//
// Copyright Modelo XX - 2017, All rights reserved.











/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function LoadMX3(useLocalServer, sceneObject, cameraObject, resourceManager, renderer, fileId) {
        this._useLocalServer = useLocalServer;
        this._sceneObject = sceneObject;
        this._cameraObject = cameraObject;
        this._resourceManager = resourceManager;
        this._model = new _03scene_m3d_model_js__WEBPACK_IMPORTED_MODULE_5__["default"];
        this._model.id = fileId;
        sceneObject.models.push(this._model);
        this._meshLoader = new _m3d_load_mesh_js__WEBPACK_IMPORTED_MODULE_7__["default"](this._sceneObject, renderer, this._resourceManager, this._model);
        this._textureLoader = new _mx2_m3d_load_texture_js__WEBPACK_IMPORTED_MODULE_8__["default"](this._sceneObject, this._resourceManager, this._model);
        this._modelGraphLoader = new _m3d_load_modelgraph_js__WEBPACK_IMPORTED_MODULE_10__["default"](this._sceneObject, this._resourceManager, this._model);
        this._sceneModelBinLoader = null;
        this._renderer = renderer;
        // FIXME: In .mx3, frontend takes over bim information. Modelo3d assumes it is always in bim mode.
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].bim = true;
    }
    ;
    LoadMX3.prototype.destroy = function () {
        this._meshLoader.destroy();
        this._textureLoader.destroy();
        this._sceneModelBinLoader.destroy();
        this._modelGraphLoader.destroy();
        this._meshLoader = null;
        this._textureLoader = null;
        this._sceneModelBinLoader = null;
        this._modelGraphLoader = null;
        this._model = null;
        delete this._meshLoader;
        delete this._textureLoader;
        delete this._sceneModelBinLoader;
        delete this._modelGraphLoader;
        delete this._model;
    };
    LoadMX3.prototype.load = function (modelFilePromises, sceneJson, onComplete1, onProgress) {
        if (this._useLocalServer) {
            var url = "/local/" + this._sceneObject.id + "/scene.bin";
            modelFilePromises["scene.bin"] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].OpenFile1(url, "arraybuffer");
            var url = "/local/" + this._sceneObject.id + "/model.json";
            modelFilePromises["model.json"] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].OpenFile1(url, "json");
            var url = "/local/" + this._sceneObject.id + "/model.bin";
            modelFilePromises["model.bin"] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].OpenFile1(url, "arraybuffer");
            var url = "/local/" + this._sceneObject.id + "/modelgraph.bin";
            modelFilePromises["modelgraph.bin"] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].OpenFile1(url, "arraybuffer");
            for (var i = 0, len = sceneJson.textures.length; i < len; i++) {
                var uri = sceneJson.textures[i].name;
                modelFilePromises[uri] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].OpenImage1(this._sceneObject.id, uri);
            }
        }
        for (var i = 0, len = sceneJson.textures.length; i < len; i++) {
            var key = sceneJson.textures[i].name;
            var uri = this._model.id + "/" + sceneJson.textures[i].name;
            modelFilePromises[uri] = modelFilePromises[key];
            delete modelFilePromises[key];
        }
        // FIXME: The model.json and scene.bin are small so we don't track their download progress.
        var that = this;
        return modelFilePromises["model.json"].downloadFile()
            .then(function (res) {
            var modelJson = res.data;
            // To be compatible with .mx 2.0 so that code at upper layer doesn't need
            // to differ 2.0 and 3.0.
            sceneJson.scene.nodes = modelJson["model.bin"].nodes;
            var progressTracker = new _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].ProgressTracker(onProgress);
            for (var i = 0, len = sceneJson.textures.length; i < len; i++) {
                progressTracker.totalDownload += sceneJson.textures[i].byteLength;
            }
            for (var i = 0, len = modelJson.buffers.length; i < len; i++) {
                progressTracker.totalDownload += modelJson.buffers[i].byteLength;
                if (that._useLocalServer) {
                    var meshName = "mesh" + i + ".bin";
                    var url = "/local/" + that._sceneObject.id + "/" + meshName;
                    modelFilePromises[meshName] = _m3d_load_misc_js__WEBPACK_IMPORTED_MODULE_6__["default"].OpenFile1(url, "arraybuffer");
                }
            }
            progressTracker.totalDownload += modelJson["model.bin"].byteLength;
            progressTracker.totalDownload += modelJson["modelgraph.bin"].byteLength;
            var onprogress1 = progressTracker.getSingleFileProgress();
            return modelFilePromises["scene.bin"].downloadFile()
                .then(function (res) {
                var sceneBin = res.data;
                return modelFilePromises["model.bin"].downloadFile(function (eventData) {
                    onprogress1(eventData.loaded);
                })
                    .then(function (res) {
                    return that._load(modelFilePromises, sceneJson, sceneBin, modelJson, res.data, onComplete1, progressTracker);
                });
            });
        });
    };
    LoadMX3.prototype._load = function (modelFilePromises, sceneJson, sceneBin, modelJson, modelBin, onComplete1, progressTracker) {
        if (!(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.INITIALIZED || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.RENDERING)) {
            throw new _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"]("Loading is interrupted");
        }
        this._sceneModelBinLoader = new _m3d_load_scenemodelbin_js__WEBPACK_IMPORTED_MODULE_9__["default"](sceneJson, sceneBin, modelJson, modelBin);
        // Create scene graph leaves for each drawable node which is only 
        // needed for BIM.
        this._model.bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_2__["default"].aabb.createFromArray(modelJson["model.bin"].bbox);
        var graph = this._model.graph;
        var numNodes = modelJson["model.bin"].nodes;
        graph.createNodes(numNodes);
        for (var i = 0; i < numNodes; i++) {
            graph.nodes[i] = new _03scene_graph_m3d_node_js__WEBPACK_IMPORTED_MODULE_4__["default"](i);
            var src = this._sceneModelBinLoader.readNodeBBox(i);
            var dst = new Float32Array(graph.nodeBBoxes.buffer, i * 24, 6);
            _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_2__["default"].aabb.scale(dst, src, 1.01);
        }
        // Create a default layer if there is not.
        if (this._sceneObject.layers.length === 0) {
            this._sceneObject.layers = new Array(1);
            var layerObject = new _03scene_m3d_layer_js__WEBPACK_IMPORTED_MODULE_3__["default"]("default", 0, [1, 1, 1], true);
            this._sceneObject.layers[0] = layerObject;
        }
        // Initialize the size of the scene.
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_2__["default"].aabb.union(this._sceneObject.bbox, this._model.bbox, this._sceneObject.bbox);
        this._sceneObject.setBBox(this._sceneObject.bbox); // Update scene radius and etc
        this._sceneObject.isBimCullingNeeded = true;
        // Initialize camera.
        if (!this._sceneObject.terrain) {
            this._cameraObject.reset(true);
        }
        // Whether this scene needs to be rendered in double-sided way based
        // the source file type of this model.
        if (sceneJson.source) {
            var fields = sceneJson.source.split(".");
            switch (fields[fields.length - 1]) {
                case "skp":
                    this._sceneObject.faces = 2;
                    this._sceneObject.isBimCullingNeeded = true;
                    break;
                case "rfa":
                case "rvt":
                    // FIXME: whenever the scene has a rvt, we think of the scene as a rvt file.
                    // It affects the measurement result.
                    this._sceneObject.faces = 0;
                    this._sceneObject.hasProfileLines = true;
                    this._sceneObject.isBimCullingNeeded = true;
                    break;
                case "vgx":
                case "stl":
                case "max":
                    this._sceneObject.faces = 1;
                    break;
                case "obj":
                case "3dm":
                    this._sceneObject.faces = 0;
                    this._sceneObject.hasCurveOrLine = true;
                    break;
                case "nwd":
                    this._sceneObject.faces = 0;
                    break;
                default:
                    this._sceneObject.faces = 1;
                    break;
            }
            this._sceneObject.source = fields[fields.length - 1];
        }
        // The callback of first stage of loading.
        onComplete1(modelJson["model.bin"]);
        var that = this;
        return this._textureLoader.load(modelFilePromises, sceneJson, that._sceneModelBinLoader, progressTracker)
            .then(function () {
            if (!(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.INITIALIZED || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.RENDERING)) {
                throw new _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"]("Loading is interrupted");
            }
            return that._meshLoader.load(modelFilePromises, sceneJson, that._sceneModelBinLoader, modelJson, progressTracker)
                .then(function () {
                if (!(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.INITIALIZED || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === modelo3d.RENDERING)) {
                    throw new _m3d_errors_js__WEBPACK_IMPORTED_MODULE_1__["default"]("Loading is interrupted");
                }
                return that._modelGraphLoader.load(modelFilePromises, progressTracker);
            });
        });
    };
    return LoadMX3;
})());


/***/ }),

/***/ "./07loadsave/mx3/m3d_load_scenemodelbin.js":
/*!**************************************************!*\
  !*** ./07loadsave/mx3/m3d_load_scenemodelbin.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_load_scenebin.js
// Parse scene.bin in MX 2.0
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function SceneModelBinLoader(sceneJson, sceneBin, modelJson, modelBin) {
        this._sceneJson = sceneJson;
        this._sceneBin = sceneBin;
        this._modelJson = modelJson;
        this._modelBin = modelBin;
        // inside scene.bin
        this._samplersLocation = 0;
        this._texturesLocation = 0;
        this._materialsLocation = 0;
        this._attributesLocation = 0;
        // inside model.bin
        this._meshesLocation = 0;
        this._nodesLocation = 0;
        this._initialize(sceneJson, sceneBin, modelJson, modelBin);
    }
    ;
    SceneModelBinLoader.prototype.destroy = function () {
        this._sceneBin = null;
        this._sceneJson = null;
        this._modelBin = null;
        this._modelJson = null;
        delete this._sceneBin;
        delete this._sceneJson;
        delete this._modelBin;
        delete this._modelJson;
        this._samplersLocation = null;
        this._texturesLocation = null;
        this._materialsLocation = null;
        this._attributesLocation = null;
        delete this._samplersLocation;
        delete this._texturesLocation;
        delete this._materialsLocation;
        delete this._attributesLocation;
        this._meshesLocations = null;
        this._nodesLocation = null;
        delete this._meshesLocations;
        delete this._nodesLocation;
    };
    var UINT32 = 4;
    var FLOAT32 = 4;
    var INT32 = 4;
    var UINT8 = 1;
    SceneModelBinLoader.prototype._initialize = function (sceneJson, sceneBin, modelJson, modelBin) {
        var offset = 0;
        // scene.bin
        if (sceneJson.samplers.length > 0) {
            this._samplersLocation = offset;
            offset += sceneJson.samplers.length * (4 * UINT8);
        }
        if (sceneJson.textures.length > 0) {
            this._texturesLocation = offset;
            offset += sceneJson.textures.length * (4 * UINT8);
        }
        if (sceneJson.materials.length > 0) {
            this._materialsLocation = offset;
            offset += sceneJson.materials.length * (16 * UINT8);
        }
        if (sceneJson.attributes.length > 0) {
            this._attributesLocation = offset;
        }
        // model.bin
        this._meshesLocation = 8;
        var num = new Uint32Array(modelBin, 0, 2);
        this._nodesLocation = num[0] * (UINT32 * 5) + 8;
        ; // First two uint32 are about #meshes and #nodes
    };
    // uint8array(4)
    // linear: uint8,
    // repeat: uint8,
    // mipmap: uint8
    // padding: uint8
    SceneModelBinLoader.prototype.readSampler = function (index) {
        return new Uint8Array(this._sceneBin, this._samplersLocation + index * UINT8 * 4, 4);
    };
    // uint8array(4)
    // nchannels: uint8
    // sampler: uint8
    // alphaMask: uint8
    // padding: uint8
    SceneModelBinLoader.prototype.readTexture = function (index) {
        return new Uint8Array(this._sceneBin, this._texturesLocation + index * UINT8 * 4, 4);
    };
    // uint8array(16)
    // kd: uint8 * 3
    // transparent: uint8
    // diffuse texture: int16
    // placeholder0: int16
    // placeholder1: float32
    // placeholder2: float32
    SceneModelBinLoader.prototype.readMaterial = function (index) {
        return new Uint8Array(this._sceneBin, this._materialsLocation + index * UINT8 * 16, 16);
    };
    // int8array(8)
    // primitive: int8 (0, 1, 4 - points, lines, triangles)
    // normal: int8
    // uv: int8
    // color: int8
    // padding: int8
    // padding: int8
    // padding: int8
    // padding: int8
    SceneModelBinLoader.prototype.readAttribute = function (index) {
        return new Int8Array(this._sceneBin, this._attributesLocation + index * UINT8 * 8, 8);
    };
    // uint32array(5)
    // indexType: uint8
    // attribute: uint8
    // meshXXX.bin index: uint16
    // verticesOffset: uint32
    // verticesBytes: uint32
    // indicesOffset: uint32
    // indicesBytes: uint32
    SceneModelBinLoader.prototype.readMesh = function (meshIndex) {
        return new Uint32Array(this._modelBin, this._meshesLocation + meshIndex * UINT32 * 5, 5);
    };
    // uint32array(3)
    // material:      uint16
    // layer:         uint16
    // mesh:          uint32
    // flags:         uint32 (31: billboard, 30: identity, 29: mergible, 28-25: region)
    SceneModelBinLoader.prototype.readNodeData = function (index) {
        return new Uint32Array(this._modelBin, this._nodesLocation + index * UINT32 * 21, 3);
    };
    // float32array(6)
    SceneModelBinLoader.prototype.readNodeBBox = function (index) {
        return new Float32Array(this._modelBin, this._nodesLocation + (index * 21 + 3) * FLOAT32, 6);
    };
    // float32array(12)
    SceneModelBinLoader.prototype.readNodeTransform = function (index) {
        return new Float32Array(this._modelBin, this._nodesLocation + (index * 21 + 9) * FLOAT32, 12);
    };
    return SceneModelBinLoader;
})());


/***/ }),

/***/ "./08ui/input/Input.ts":
/*!*****************************!*\
  !*** ./08ui/input/Input.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @hidden
 */
var Input = /** @class */ (function () {
    /**
     * constructor
     */
    function Input(name, viewer) {
        this.name = name;
        this._enabled = false;
        this._canvas = viewer.getCanvas();
        this._event = null;
    }
    /**
     * Destroy the input method object.
     */
    Input.prototype.destroy = function () {
        this._enabled = null;
        delete this._enabled;
        this.name = null;
        delete this.name;
        this._event = null;
        delete this._event;
        this._canvas = null;
        delete this._canvas;
    };
    /**
     * Whether this input method is available on current platform.
     */
    Input.prototype.isAvailable = function (isMobile) {
        return false;
    };
    Input.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
    };
    ;
    return Input;
}());
/* harmony default export */ __webpack_exports__["default"] = (Input);


/***/ }),

/***/ "./08ui/input/Keyboard.ts":
/*!********************************!*\
  !*** ./08ui/input/Keyboard.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Input */ "./08ui/input/Input.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var KeyStatusEnum;
(function (KeyStatusEnum) {
    KeyStatusEnum[KeyStatusEnum["KEY_PRESSED"] = 0] = "KEY_PRESSED";
    KeyStatusEnum[KeyStatusEnum["KEY_DOWN"] = 1] = "KEY_DOWN";
    KeyStatusEnum[KeyStatusEnum["KEY_UP"] = 2] = "KEY_UP";
})(KeyStatusEnum || (KeyStatusEnum = {}));
;
var Keyboard = /** @class */ (function (_super) {
    __extends(Keyboard, _super);
    function Keyboard(viewer) {
        var _this = _super.call(this, "keyboard", viewer) || this;
        // private:
        _this.status = KeyStatusEnum.KEY_UP; // DOWN, PRESSED or UP.
        _this._enabled = true;
        _this._upListeners = [];
        _this._downListeners = [];
        // public:
        _this.key = 0; // The key scancode
        // we need to keep a reference to the function as need to remove the listeners from document on Keyboard destroy
        _this._keyDownFn = _this._keyDown.bind(_this);
        _this._keyUpFn = _this._keyUp.bind(_this);
        // initialization
        document.addEventListener("keydown", _this._keyDownFn);
        document.addEventListener("keyup", _this._keyUpFn);
        return _this;
    }
    Keyboard.prototype.destroy = function () {
        this._upListeners = null;
        delete this._upListeners;
        this._downListeners = null;
        delete this._downListeners;
        document.removeEventListener("keydown", this._keyDownFn);
        document.removeEventListener("keyup", this._keyUpFn);
        this._keyDownFn = null;
        delete this._keyDownFn;
        this._keyUpFn = null;
        delete this._keyUpFn;
        _super.prototype.destroy.call(this);
    };
    Keyboard.prototype.isAvailable = function (isMobile) {
        return !isMobile;
    };
    Keyboard.prototype.addKeyUpListener = function (cbk) {
        this._upListeners.push(cbk);
    };
    Keyboard.prototype.addKeyDownListener = function (cbk) {
        this._downListeners.push(cbk);
    };
    Keyboard.prototype._keyDown = function (event) {
        if (!this._doesCanvasHaveFocus()) {
            return;
        }
        event.preventDefault();
        this.status = KeyStatusEnum.KEY_PRESSED;
        this.key = event.keyCode;
        for (var i = this._downListeners.length - 1; i >= 0; --i) {
            if (this._downListeners[i](this)) {
                break;
            }
        }
    };
    Keyboard.prototype._keyUp = function (event) {
        if (!this._doesCanvasHaveFocus()) {
            return;
        }
        event.preventDefault();
        this.status = KeyStatusEnum.KEY_UP;
        this.key = event.keyCode;
        for (var i = this._upListeners.length - 1; i >= 0; --i) {
            if (this._upListeners[i](this)) {
                break;
            }
        }
    };
    Keyboard.prototype._doesCanvasHaveFocus = function () {
        if (!this._enabled) {
            return false;
        }
        // check if anything but the body has focus.
        var focusedElement = document.activeElement;
        var anotherElementHasFocus = (focusedElement && focusedElement !== document.body);
        if (anotherElementHasFocus) {
            return false;
        }
        // check if anything is selected
        var text = "";
        if (typeof window.getSelection !== "undefined") {
            text = window.getSelection().toString();
        }
        else if (typeof document.selection !== "undefined" && document.selection.type === "Text") {
            text = document.selection.createRange().text;
        }
        return !text && !anotherElementHasFocus;
    };
    return Keyboard;
}(_Input__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Keyboard);


/***/ }),

/***/ "./08ui/input/Mouse.ts":
/*!*****************************!*\
  !*** ./08ui/input/Mouse.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ "./08ui/input/Input.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Mouse = /** @class */ (function (_super) {
    __extends(Mouse, _super);
    function Mouse(viewer) {
        var _this = _super.call(this, "mouse", viewer) || this;
        _this.LEFT_BUTTON = 0; // Match the event.button values.
        _this.MIDDLE_BUTTON = 1; // Ditto
        _this.RIGHT_BUTTON = 2;
        _this._x0 = -1;
        _this._y0 = -1;
        _this._lastWheelTime = 0;
        _this._eventQueue = [];
        _this.x = -1;
        _this.y = -1;
        _this.dx = -1;
        _this.dy = -1;
        _this.pressed = false;
        _this.moved = false;
        _this.delta = 0;
        _this.button = _this.LEFT_BUTTON;
        _this._downListeners = []; // Callback functions when mouse down.
        _this._moveListeners = []; // Ditto.
        _this._upListeners = []; // Ditto.
        _this._wheelListeners = []; // Ditto.
        // Hook up canvas mouse events
        var eventType = 0;
        var that = _this;
        function NormalizeMouse(func) {
            return function (e) {
                var source = e.relatedTarget || e.toElement;
                if (source !== that._canvas) {
                    return;
                }
                e.offsetX_norm = (e.offsetX === undefined) ? e.layerX : e.offsetX;
                e.offsetY_norm = (e.offsetY === undefined) ? e.layerY : e.offsetY;
                if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].browserName === "firefox" || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].browserName === "edge") {
                    e.buttonDown = eventType;
                }
                else {
                    e.buttonDown = e.which;
                }
                return func.call(that, e);
            };
        }
        ;
        _this._canvas.onwheel = NormalizeMouse(_this._onMouseWheel);
        _this._canvas.onmousemove = NormalizeMouse(_this._onMouseMove);
        var mouseDown = NormalizeMouse(_this._onMouseDown);
        _this._canvas.onmousedown = function (e) {
            eventType = e.which;
            mouseDown(e);
        };
        var mouseUp = NormalizeMouse(_this._onMouseUp);
        _this._canvas.onmouseup = function (e) {
            mouseUp(e);
            eventType = 0;
        };
        _this._onMouseLeave = function (e) {
            eventType = 0;
        };
        document.addEventListener("mouseout", _this._onMouseLeave, false);
        return _this;
    }
    Mouse.prototype.destroy = function () {
        this._canvas.onmousedown = null;
        this._canvas.onmouseup = null;
        this._canvas.onmouseleave = null;
        this._canvas.ondblclick = null;
        this._canvas.onwheel = null;
        this._canvas.onmousemove = null;
        document.removeEventListener("mouseout", this._onMouseLeave);
        this._downListeners = null;
        delete this._downListeners;
        this._upListeners = null;
        delete this._upListeners;
        this._moveListeners = null;
        delete this._moveListeners;
        this._wheelListeners = null;
        delete this._wheelListeners;
        this._enabled = null;
        delete this._eventQueue;
        _super.prototype.destroy.call(this);
    };
    Mouse.prototype.addMouseDownListener = function (cbk) {
        this._downListeners.push(cbk);
    };
    Mouse.prototype.addMouseMoveListener = function (cbk) {
        this._moveListeners.push(cbk);
    };
    Mouse.prototype.addMouseUpListener = function (cbk) {
        this._upListeners.push(cbk);
    };
    Mouse.prototype.addMouseWheelListener = function (cbk) {
        this._wheelListeners.push(cbk);
    };
    Mouse.prototype.isAvailable = function (isMobile) {
        return !isMobile;
    };
    Mouse.prototype._onMouseDown = function (event) {
        if (!this._enabled) {
            return;
        }
        event.preventDefault();
        this.pressed = true;
        var x = event.offsetX_norm;
        var y = event.offsetY_norm;
        this.dx = 0;
        this.dy = 0;
        this.x = x;
        this.y = y;
        this.moved = false;
        this.button = event.button;
        this._x0 = this.x;
        this._y0 = this.y;
        this._event = event;
        // FIXME: we can't preempt down click events as it will affect many press-and-drag UX.
        //if (this._doubleClickPreemptive) {
        //    this._eventQueue.push(setTimeout(() => {
        //        for (let i = this._downListeners.length - 1; i >= 0; --i) {
        //            // When event is processed, we stop the propagating the mouse event
        //            // to more receivers.
        //            if (this._downListeners[i](this)) {
        //                break;
        //            }
        //        }
        //    }, 400));
        //} else {
        for (var i = this._downListeners.length - 1; i >= 0; --i) {
            // When event is processed, we stop the propagating the mouse event
            // to more receivers.
            if (this._downListeners[i](this)) {
                break;
            }
        }
        //}
    };
    Mouse.prototype._onMouseUp = function (event) {
        if (!this._enabled) {
            return;
        }
        event.preventDefault();
        this.pressed = false;
        var x = event.offsetX_norm;
        var y = event.offsetY_norm;
        this.dx = x - this.x;
        this.dy = y - this.y;
        this.x = x;
        this.y = y;
        this._event = event;
        this.button = event.button;
        if (Math.abs(this.x - this._x0) > 3 || Math.abs(this.y - this._y0) > 3) {
            this.moved = true;
        }
        for (var i = this._upListeners.length - 1; i >= 0; --i) {
            // When event is processed, we stop the propagating the mouse event
            // to more receivers.
            if (this._upListeners[i](this)) {
                break;
            }
        }
    };
    Mouse.prototype._onMouseMove = function (event) {
        if (!this._enabled) {
            return;
        }
        event.preventDefault();
        var x = event.offsetX_norm;
        var y = event.offsetY_norm;
        this.dx = x - this.x;
        this.dy = y - this.y;
        this.x = x;
        this.y = y;
        this._event = event;
        if (Math.abs(this.x - this._x0) > 3 || Math.abs(this.y - this._y0) > 3) {
            this.moved = true;
        }
        for (var i = this._moveListeners.length - 1; i >= 0; --i) {
            // When event is processed, we stop the propagating the mouse event
            // to more receivers.
            if (this._moveListeners[i](this)) {
                break;
            }
        }
    };
    Mouse.prototype._onMouseWheel = function (event) {
        if (!this._enabled) {
            return;
        }
        event.preventDefault();
        // Clamp deltaY to (-1, 1)
        var deltaY = event.deltaY;
        this.delta = -Math.max(-1, Math.min(1, deltaY));
        // Using trackpad will generate deltaY less than 50
        // at an inertia scrolling. We want to iron out the effect of 
        // the inertia scrolling movement to just a little.
        // Using mouse to scroll will generate inertia larger than 200
        // according to experiments, so the bound [0, 50] can capture
        // the tarckpad scrolling.
        // FIXME: The firefox case is really complicated. In windows, the deltaY
        // is +-3, +-6, +-9 with mouse and trackpad. In mac, the deltaY is
        // from -20 to 20 with inertia scrolling, let's just uniform the delta
        // to +- 1 in firefox for now.
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].browserName !== "firefox") {
            this.delta *= Math.min(deltaY * deltaY / 2500.0, 1.0);
        }
        for (var i = this._wheelListeners.length - 1; i >= 0; --i) {
            // When event is processed, we stop the propagating the mouse event
            // to more receivers.
            if (this._wheelListeners[i](this)) {
                break;
            }
        }
    };
    Mouse.prototype.getEvent = function () {
        return this._event;
    };
    return Mouse;
}(_Input__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Mouse);


/***/ }),

/***/ "./08ui/tool/CameraManipulator.ts":
/*!****************************************!*\
  !*** ./08ui/tool/CameraManipulator.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_transition.js */ "./03scene/camera/m3d_camera_animator_transition.js");
/* harmony import */ var _DepthQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DepthQuery */ "./08ui/tool/DepthQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var cubeDirections = {
    "top": [Math.PI * 0.49999, -Math.PI * 0.49999],
    "bottom": [Math.PI * -0.49999, -Math.PI * 0.49999],
    "left": [0, Math.PI],
    "right": [0, 0],
    "front": [0, Math.PI * -0.5],
    "back": [0, Math.PI * 0.5]
};
/**
 * @hidden
 */
var CameraManipulator = /** @class */ (function (_super) {
    __extends(CameraManipulator, _super);
    function CameraManipulator(viewer) {
        var _this = _super.call(this, "CameraManipulator", false, viewer) || this;
        if (_this._viewer) {
            _this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_2__["default"](_this._scene, _this._resourceManager);
        }
        else {
            _this._depthQuery = null;
        }
        _this._animator = new _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this._restricted = false;
        _this._clippingEnabled = _this._scene ? _this._scene.clipping.isEnabled() : false;
        // FIXME: tweak the following numbers to get a good UX.
        // Speed to control the touch laptop & mobile devices
        _this._touchPanSpeedScaling = 1.86 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        _this._touchZoomSpeedScaling = 0.0596 * Math.sqrt(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        _this._touchRotateSpeedScaling = 0.44 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        // Speed to control the desktop
        // PS:trackpad belongs to desktop here
        _this._mousePanSpeedScaling = 0.37;
        _this._mouseZoomSpeedScaling = 0.278;
        _this._mouseRotateSpeedScaling = 0.45;
        _this._keyRotateSpeed = 12;
        // Speed to control keyboard
        _this._keyPanSpeed = 1.0;
        _this._keyForwardSpeed = 0.0092;
        //this._orientation             = orientation;
        // FIXME: the following commented out variables are from modelo3d. They are no more
        // needed in api seemingly.
        //this._pressed                 = false;      // if left button is pressed down.
        //this._hasSavedFPV             = false;      // is saved first person view
        //this._isFPV                   = false;      // camera status
        //this._adjusting               = false;      // is adjusting point direction, for in app nav
        //this._isOrthoView             = false;
        _this._isPanorama = false; // is panorama mode
        return _this;
    }
    CameraManipulator.prototype.destroy = function () {
        this._camera = null;
        delete this._camera;
        this._animator.destroy();
        this._animator = null;
        delete this._animator;
        if (this._depthQuery) {
            this._depthQuery.destroy();
            this._depthQuery = null;
            delete this._depthQuery;
        }
        _super.prototype.destroy.call(this);
    };
    CameraManipulator.prototype.isAvailable = function (isMobile) {
        return true;
    };
    CameraManipulator.prototype.isSupport3D = function () {
        return true;
    };
    CameraManipulator.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseDownListener(this._onMouseDown.bind(this));
            input.addMouseMoveListener(this._onMouseMove.bind(this));
            input.addMouseUpListener(this._onMouseUp.bind(this));
            input.addMouseWheelListener(this._onMouseWheel.bind(this));
        }
        else if (input.name === "touch") {
            //input.addTouchMoveListener(this._onTouchMove.bind(this));
            //input.addTouchStartListener(this._onTouchStart.bind(this));
        }
        else if (input.name === "gyrosensor") {
            //input.addGyrnsensorListener(this._onGyrosensor.bind(this));
        }
        else if (input.name === "keyboard") {
            input.addKeyDownListener(this._onKeyDown.bind(this));
        }
    };
    CameraManipulator.prototype._onMouseDown = function (mouse) {
        //this._restoreFPV();
        //if (mouse.event.buttonDown === 1) {
        //    this._exitTransit();
        //    //this._pressed = true;
        //}
        this._exitTransit();
        return false; // never prevent other tools seeing this mouse event.
    };
    CameraManipulator.prototype._onMouseMove = function (mouse) {
        if (mouse.button === mouse.LEFT_BUTTON && mouse.pressed) {
            //if (this._adjusting) {
            //    this._camera.rotate(-mouse.dx * this._mouseRotateSpeedScaling, 0);
            //no viewer is attached to cameramanipulator when in panorama mode.
            if (this._isPanorama) {
                this._camera.rotate(-mouse.dx * this._mouseRotateSpeedScaling, -mouse.dy * this._mouseRotateSpeedScaling);
            }
            else {
                this._camera.rotate(mouse.dx * this._mouseRotateSpeedScaling, mouse.dy * this._mouseRotateSpeedScaling);
            }
        }
        else if (mouse.button === mouse.MIDDLE_BUTTON && mouse.pressed && !this._restricted) {
            //this._saveFPV(false);
            //this._exitTransit();
            this._camera.zoom(mouse.dx * 0.01 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        }
        else if (mouse.button === mouse.RIGHT_BUTTON && mouse.pressed && !this._restricted) {
            //this._saveFPV(false);
            //this._exitTransit();
            this._camera.pan(mouse.dx * this._mousePanSpeedScaling, mouse.dy * this._mousePanSpeedScaling);
        }
        //if (mouse.button !== 0 && this._isOrthoView){
        //    Globals.frontendEmitter.emit("exitOrthoView");
        //    this._isOrthoView = false;
        //}
        //if (this._pressed && this._adjusting) {
        //    Globals.frontendEmitter.emit("getMapPosition");
        //}
        return false; // never prevent other tools seeing this mouse event.
    };
    CameraManipulator.prototype.doesSupportMobile = function (isMobile) {
        return false; // never prevent other tools seeing this mouse event.
    };
    CameraManipulator.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    CameraManipulator.prototype._onMouseUp = function (mouse) {
        //this._restoreFPV();
        //if (mouse.button === 1) {
        //    this._pressed = false;
        //}
        return false;
    };
    CameraManipulator.prototype._onMouseWheel = function (mouse) {
        //this._restoreFPV();
        //this._saveFPV(false);
        this._exitTransit();
        var delta = mouse.delta * this._mouseZoomSpeedScaling;
        this._camera.zoom(delta, mouse.x * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio, mouse.y * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        return false;
    };
    //private _onTouchMove(touch:any) : void {
    //    let cursor0 = touch.cursor(0);
    //    this._exitTransit();
    //    let dx, dy;
    //    if (touch.numCursors === 1) { // One finger to rotate
    //        this._restoreFPV();
    //        cursor0 = touch.cursor(0);
    //        if(this._isPanorama) {
    //            this._camera.rotate(-cursor0.dx * this._touchRotateSpeedScaling,
    //                                -cursor0.dy * this._touchRotateSpeedScaling);
    //        } else {
    //            this._camera.rotate(cursor0.dx * this._touchRotateSpeedScaling,
    //                                cursor0.dy * this._touchRotateSpeedScaling);
    //        }
    //    } else if (touch.numCursors === 2) { // Two fingers to pinch or move
    //        this._restoreFPV();
    //        this._saveFPV(false);
    //        cursor0 = touch.cursor(0);
    //        var cursor1 = touch.cursor(1);
    //        // If the movement direction of two cursors
    //        // are the same, it is a pan.
    //        var direction = cursor0.dx * cursor1.dx + cursor0.dy * cursor1.dy;
    //        if (direction > 0) { // pan
    //            dx = (cursor0.dx + cursor1.dx) * this._touchPanSpeedScaling;
    //            dy = (cursor0.dy + cursor1.dy) * this._touchPanSpeedScaling;
    //            this._camera.pan(dx, dy);
    //        } else { // pinch
    //            var x0 = cursor0.x - cursor0.dx;
    //            var y0 = cursor0.y - cursor0.dy;
    //            var x1 = cursor1.x - cursor1.dx;
    //            var y1 = cursor1.y - cursor1.dy;
    //            dx = x0 - x1;
    //            dy = y0 - y1;
    //            var prevDist = Math.sqrt(dx * dx + dy * dy);
    //            dx = cursor0.x - cursor1.x;
    //            dy = cursor0.y - cursor1.y;
    //            var nowDist = Math.sqrt(dx * dx + dy * dy);
    //            var diffDist = nowDist - prevDist;
    //            // number is determined by user experience.
    //            // TODO: in future, we may use PPI to determine a
    //            // more physically correct zooming speed.
    //            var offset = (<any>Math).sign(diffDist) * this._touchZoomSpeedScaling;
    //            this._camera.zoom(offset);
    //        }
    //    } else { // move the object.
    //        this._restoreFPV();
    //        this._saveFPV(false);
    //        dx = 0;
    //        dy = 0;
    //        for (var i = 0; i < touch.numCursors; ++i) {
    //            var t = touch.cursor(i);
    //            dx += t.dx;
    //            dy += t.dy;
    //        }
    //        dx /= touch.numCursors;
    //        dy /= touch.numCursors;
    //        dx *= this._touchPanSpeedScaling;
    //        dy *= this._touchPanSpeedScaling;
    //        this._camera.pan(dx, dy);
    //    }
    //    if (touch.numCursors !== 0  && this._isOrthoView) {
    //        if (Globals.frontendEmitter) {
    //            Globals.frontendEmitter.emit("exitOrthoView");
    //        }
    //        
    //        this._isOrthoView = false;
    //    }
    //    if (Globals.frontendEmitter) {
    //        Globals.frontendEmitter.emit("getMapPosition");
    //    }
    //}
    //private _onTouchStart(touch:any) : void {
    //    if (touch.isDoubleClick && !this._camera.isFirstPerson()) {
    //        this._exitTransit();
    //        const cursor0 = touch.cursor(0);
    //        // Close-up view
    //        const worldPosition = this._depthQuery.unproject(cursor0.x, cursor0.y, this._renderer, this._camera);
    //        if (worldPosition !== null) {
    //            this._camera.lookTo(worldPosition);
    //            if (this._isOrthoView) {
    //                if (Globals.frontendEmitter) {
    //                    Globals.frontendEmitter.emit("exitOrthoView");
    //                }
    //                this._isOrthoView = false;
    //            }
    //        }
    //    }
    //}
    CameraManipulator.prototype._onKeyDown = function (keyboard) {
        // uses both arrow keys and wasd
        switch (keyboard.key) {
            // right, D, d
            case 39:
            case 68:
            case 100:
                {
                    //this._exitTransit();
                    //this._restoreFPV();
                    //this._saveFPV(true);
                    this._camera.rotate(this._keyRotateSpeed, 0);
                    //if (this._adjusting) {
                    //    Globals.frontendEmitter.emit("getMapPosition");
                    //}
                }
                break;
            // up, W, w
            case 38:
            case 87:
            case 119:
                {
                    //this._exitTransit();
                    //this._restoreFPV();
                    //this._saveFPV(false);
                    if (!this._restricted) {
                        this._camera.forward(this._keyForwardSpeed);
                    }
                }
                break;
            // left, A, a
            case 37:
            case 65:
            case 97:
                {
                    //this._exitTransit();
                    //this._restoreFPV();
                    //this._saveFPV(true);
                    this._camera.rotate(-this._keyRotateSpeed, 0);
                    //if (this._adjusting) {
                    //    Globals.frontendEmitter.emit("getMapPosition");
                    //}
                }
                break;
            // down, S, s
            case 40:
            case 83:
            case 115:
                {
                    //this._exitTransit();
                    //this._restoreFPV();
                    //this._saveFPV(false);
                    if (!this._restricted) {
                        this._camera.forward(-this._keyForwardSpeed);
                    }
                }
                break;
        }
    };
    // save camera status in camera manipulator
    // then set camera view mode for camera motion
    //private _saveFPV(enabled:boolean) : void {
    //    if(!this._hasSavedFPV) {
    //        this._isFPV = this._camera.isFirstPerson();
    //        this._hasSavedFPV = true;
    //        this._camera.setFirstPerson(enabled);
    //    }
    //}
    CameraManipulator.prototype._exitTransit = function () {
        if (this._camera._restricted) {
            return;
        }
        if (this._camera.animator instanceof _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            this._camera.animator.stop();
        }
    };
    //private _restoreFPV() : void {
    //    if (this._hasSavedFPV) {
    //        this._hasSavedFPV = false;
    //        this._camera.setFirstPerson(this._isFPV);
    //    }
    //};
    //public resetFirstPersonView(enabled:boolean) {
    //    this._isFPV = enabled;
    //    this._hasSavedFPV = false;
    //}
    CameraManipulator.prototype.setCamera = function (camera) {
        this._camera = camera;
    };
    CameraManipulator.prototype.switchToView = function (direction) {
        var angle = cubeDirections[direction.toLowerCase()];
        //this._hasSavedFPV = false;
        //this._camera.setFirstPerson(false);
        this._camera.reset(false);
        this._camera.rotateTo(angle[0], angle[1]);
        //this._isOrthoView = true;
    };
    CameraManipulator.prototype.switchToWorldView = function () {
        //this._hasSavedFPV = false;
        this._camera.setFirstPerson(false);
        // The world view is always in perspective projection.
        this._camera.setPerspective(true);
        this._camera.reset(false);
        //this._isOrthoView = false;
    };
    //public exitOrthoView() : void {
    //   if (this._isOrthoView){
    //       Globals.frontendEmitter.emit("exitOrthoView");
    //       this._isOrthoView = false;
    //   }
    //}
    /**
     * @description change to a user view.
     * @param {object} viewData - the view data.
     * @param {boolean} isVrEnabled - in VR mode?
     */
    CameraManipulator.prototype.switchToUserView = function (viewData, isVrEnabled) {
        //this._restoreFPV();
        if (viewData && this._scene) {
            this._scene.setActiveView(viewData.name);
            this._scene.clipping.reset();
            if (this._camera.animator instanceof _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                this._camera.animator.stop();
            }
            this._animator.bind(this._camera);
            this._animator.start(viewData, isVrEnabled);
            //if (this._orientation && this._orientation.enabled) {
            //    this._orientation.reset(this._camera);
            //}
        }
    };
    CameraManipulator.prototype.setTransitionSpeed = function (speed) {
        this._animator.setTransitionSpeed(speed);
    };
    CameraManipulator.prototype.setInputSensitivity = function (options) {
        for (var o in options) {
            switch (o) {
                case "touchPan":
                    this._touchPanSpeedScaling = options[o] * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
                    break;
                case "touchZoom":
                    this._touchZoomSpeedScaling = options[o] * Math.sqrt(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
                    break;
                case "touchRotate":
                    this._touchRotateSpeedScaling = options[o] * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
                    break;
                case "mousePan":
                    this._mousePanSpeedScaling = options[o];
                    break;
                case "mouseZoom":
                    this._mouseZoomSpeedScaling = options[o];
                    this._camera.setZoomMinMax(options[o]);
                    break;
                case "mouseRotate":
                    this._mouseRotateSpeedScaling = options[o];
                    break;
                case "keyPan":
                    this._keyPanSpeed = options[o];
                    break;
                case "keyForward":
                    this._keyForwardSpeed = options[o];
                    break;
            }
        }
    };
    //public setInAppNaviAdjusting(enabled) : void {
    //    this._adjusting = enabled;
    //}
    CameraManipulator.prototype.setPanoramaEnabled = function (enabled) {
        this._isPanorama = enabled;
    };
    CameraManipulator.prototype.setRestrictedViewEnabled = function (enabled) {
        this._restricted = enabled;
    };
    CameraManipulator.prototype.isRestrictedViewEnabled = function () {
        return this._restricted;
    };
    CameraManipulator.prototype.recompileShader = function (flags) {
        if (!this._scene) {
            return;
        }
        var flags1 = flags.slice(0);
        flags.push("CLIPPING");
        if (this._scene.compressed) {
            flags.push("COMPRESSION");
        }
        if (this._scene.needRenderDoubleSided()) {
            flags.push("DOUBLESIDED");
        }
        this._depthQuery.recompileShader(this._resourceManager, flags);
    };
    return CameraManipulator;
}(_Tool__WEBPACK_IMPORTED_MODULE_3__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (CameraManipulator);


/***/ }),

/***/ "./08ui/tool/Comment.ts":
/*!******************************!*\
  !*** ./08ui/tool/Comment.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_transition.js */ "./03scene/camera/m3d_camera_animator_transition.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_navigate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_navigate.js */ "./03scene/camera/m3d_camera_animator_navigate.js");
/* harmony import */ var _DepthQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DepthQuery */ "./08ui/tool/DepthQuery.ts");
/* harmony import */ var _PickQuery__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PickQuery */ "./08ui/tool/PickQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(viewer) {
        var _this = _super.call(this, "Comment", false, viewer) || this;
        // FIXME: drawables for pick query should be described later.
        _this._pickQuery = new _PickQuery__WEBPACK_IMPORTED_MODULE_5__["default"](_this._scene, _this._resourceManager);
        _this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_4__["default"](_this._scene, _this._resourceManager);
        _this._animator = new _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_2__["default"](_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frontendEmitter);
        _this._clippingEnabled = _this._scene.clipping.isEnabled();
        _this._comments = {};
        return _this;
    }
    Comment.prototype.destroy = function () {
        this._pickQuery.destroy();
        this._pickQuery = null;
        delete this._pickQuery;
        this._depthQuery.destroy();
        this._depthQuery = null;
        delete this._depthQuery;
        this._comments = null;
        delete this._comments;
    };
    Comment.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    Comment.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    Comment.prototype._recompileShader = function () {
        if (this._scene.clipping.isEnabled() !== this._clippingEnabled) {
            this._clippingEnabled = this._scene.clipping.isEnabled();
            var flags = [];
            if (this._scene.compressed) {
                flags.push("COMPRESSION");
            }
            if (this._scene.needRenderDoubleSided()) {
                flags.push("DOUBLESIDED");
            }
            this._pickQuery.recompileShader(this._resourceManager, flags);
            this._depthQuery.recompileShader(this._resourceManager, flags);
        }
    };
    // Focus a specific comment. 
    Comment.prototype.activate = function (commentId) {
        var sectionChanged = false;
        var oldSectionEnabled = this._scene.clipping.isEnabled();
        var newSectionEnabled = false;
        if (!this._comments || this._comments.hasOwnProperty(commentId)) {
            console.warn("comment {commendId} does not have rendering data.");
            return;
        }
        var renderData = this._comments[commentId].renderData;
        // Restore to clipping state when the comment has section information.
        if (renderData.section) {
            newSectionEnabled = true;
            if (oldSectionEnabled) {
                var clip = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.create(renderData.section.min, renderData.section.max);
                // See if the section/clipping box has changed.
                sectionChanged = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.isEqual(this._scene.clipping.get(), clip);
            }
            // if section has min and max, which means it's old version's section data
            if (renderData.section.min && renderData.section.max) {
                this._scene.clipping.set(renderData.section.min, renderData.section.max);
            }
            else {
                this._scene.clipping.set(renderData.section.planes, renderData.section.points);
            }
        }
        else {
            this._scene.clipping.reset();
            newSectionEnabled = false;
        }
        // Either the section mode changed or the current section is on, we think the
        // section status is not the same before, and thus ask to update the rendering.
        sectionChanged = sectionChanged || (oldSectionEnabled !== newSectionEnabled);
        if (this._camera.animator instanceof _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_2__["default"] ||
            this._camera.animator instanceof _03scene_camera_m3d_camera_animator_navigate_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            this._camera.animator.stop(true);
        }
        this._animator.attach(this._camera);
        this._animator.start(renderData.camera, false);
    };
    Comment.prototype.setTransitionSpeed = function (speed) {
        this._animator.setTransitionSpeed(speed);
    };
    // Create a specific comment's render data at given mouse coordinate. The
    // comment will try to pick a element at the mouse coordinate. If no
    // coordinate is given or no element is selected, the comment's render data
    // is not associated to any elements.
    Comment.prototype.create = function (x, y) {
        var elementPath = "";
        var modelId = this._pickQuery.pickModel(x, y, this._renderer, this._camera);
        if (modelId >= 0) {
            var model = this._scene.models[modelId];
            var nodes = this._pickQuery.pickNodesInsideRegion(x, y, x, y, this._renderer, this._camera, model.drawables);
            if (!nodes) {
                console.warn("There is an internal error at selecting element. No element selected in the model.");
                return null;
            }
            var element = nodes[0].getElement();
            elementPath = model.graph.getElementPathString(element);
        }
        // Find the world position of the mouse click
        var worldPosition = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        var renderData = {
            position: worldPosition,
            element: elementPath,
            camera: this._camera.dump(),
            section: this._scene.clipping.isEnabled() ? {
                planes: this._scene.clipping.getClippingPlanes(true),
                points: this._scene.clipping.getClippingPoints(true)
            } : null // dump the section information if it is currently in section mode
        };
        return renderData;
    };
    // Update all comments positions and visibility
    Comment.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        var cameraDirection = this._camera.getViewDirection();
        var commentToCamera = vec3.create(0, 0, 0);
        var worldPosition = vec3.create();
        var canvasWidth = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var canvasHeight = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var commentRenderStatus = {};
        for (var id in this._comments) {
            var comment = this._comments[id];
            var commentRenderStatus1 = {
                x: -1,
                y: -1,
                visible: true
            };
            commentRenderStatus[id] = commentRenderStatus1;
            // TODO: if the comment associated element is not visible, the comment should
            // be invisible too.
            if (comment.elementPath === "") {
                commentRenderStatus1.visible = false;
                continue;
            }
            // When the current camera has no intersection with camera when comment is created,
            // the comment is marked as invisible.
            //let dotProduct =  vec3.dot(comment.renderData.normal, cameraDirection);
            //if (dotProduct < 0) {
            //    commentRenderStatus1.visible = false;
            //    continue;
            //}
            // If the comment is behind the viewer, hide it.
            var position = comment.position;
            vec3.subtract(commentToCamera, position, this._camera.eye);
            if (vec3.dot(commentToCamera, cameraDirection) < 0) {
                commentRenderStatus1.visible = false;
                continue;
            }
            // If the comment is out of viewport, make it invisible
            var screenPosition = this._camera.project(position);
            if (screenPosition[0] >= canvasWidth || screenPosition[0] < 0 ||
                screenPosition[1] >= canvasHeight || screenPosition[1] < 0) {
                commentRenderStatus1.visible = false;
                continue;
            }
            // Does comment get culled
            if (this._scene.clipping.isEnabled()) {
                var planes = this._scene.clipping.getClippingPlanes();
                //although it a vec4 of plane[i], but vec3.dot will only use the first 3 components
                if (vec3.dot(position, planes[0]) > -planes[0][3] ||
                    vec3.dot(position, planes[1]) > -planes[1][3] ||
                    vec3.dot(position, planes[2]) > -planes[2][3] ||
                    vec3.dot(position, planes[3]) > -planes[3][3] ||
                    vec3.dot(position, planes[4]) > -planes[4][3] ||
                    vec3.dot(position, planes[5]) > -planes[5][3]) {
                    commentRenderStatus1.visible = false;
                    continue;
                }
            }
            commentRenderStatus1.x = Math.floor(screenPosition[0] + 0.5);
            commentRenderStatus1.y = Math.floor(screenPosition[1] + 0.5);
        }
        this._viewer.getEventEmitter().emit("Comment-UpdateRenderStatus", commentRenderStatus);
    };
    // Intialize the comments with an array of elements
    Comment.prototype.setComments = function (comments) {
        for (var i = 0; i < comments.length; i++) {
            this._comments[comments[i].id] = comments[i].renderData;
        }
    };
    // Add comment
    Comment.prototype.addComment = function (comment) {
        this._comments[comment.id] = comment.renderData;
    };
    // Remove comment
    Comment.prototype.deleteComment = function (commentId) {
        delete this._comments[commentId];
    };
    Comment.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
        this._recompileShader();
        // Exit the comment mode and update all comments positions and visibility
        if (!this._enabled) {
            var commentRenderStatus = {};
            for (var index = 0, len = this._comments.length; index < len; index++) {
                var comment = this._comments[index];
                var commentRenderStatus1 = {
                    x: -1,
                    y: -1,
                    visible: false
                };
                commentRenderStatus[comment.id] = commentRenderStatus1;
            }
            this._viewer.getEventEmitter().emit("Comment-UpdateRenderStatus", commentRenderStatus);
        }
    };
    return Comment;
}(_Tool__WEBPACK_IMPORTED_MODULE_6__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Comment);


/***/ }),

/***/ "./08ui/tool/DepthQuery.ts":
/*!*********************************!*\
  !*** ./08ui/tool/DepthQuery.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/camera/m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/materials/m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
//
// DepthQuery.ts
// depth query
//
// Copyright Modelo XX - 2017, All rights reserved.





var DepthQuery = /** @class */ (function () {
    function DepthQuery(scene, resourceManager) {
        // prviate:
        this._scene = scene;
        this._renderTarget = null;
        this._shaders = [null, null, null];
        this._ready = false;
        this._phonyCamera = new _03scene_camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this._pickMatrix = mat4.create();
        this._material = new _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_3__["default"]("depth-query");
        // initialization
        this.recompileShader(resourceManager, []);
        this._renderTarget = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("query", resourceManager, 5, 5, { clearColor: [0, 0, 0, 0] });
        this._ready = this._renderTarget.ready;
    }
    DepthQuery.prototype.destroy = function () {
        if (this._ready) {
            this._material.destroy();
            this._material = null;
            delete this._material;
            this._renderTarget.destroy();
            this._renderTarget = null;
            delete this._renderTarget;
            this._pickMatrix = null;
            delete this._pickMatrix;
            this._phonyCamera = null;
            delete this._phonyCamera;
        }
    };
    DepthQuery.prototype._begin = function (x, y, camera, renderer, width, height) {
        // Prepare the query matrix
        y = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - y;
        this._pickMatrix[0] = camera.viewport[2] / width;
        this._pickMatrix[5] = camera.viewport[3] / height;
        this._pickMatrix[12] = (camera.viewport[2] - 2.0 * x) / width;
        this._pickMatrix[13] = (camera.viewport[3] - 2.0 * y) / height;
        mat4.multiply(this._phonyCamera.vpMatrix, this._pickMatrix, camera.vpMatrix);
        this._phonyCamera.viewport[0] = camera.viewport[0];
        this._phonyCamera.viewport[1] = camera.viewport[1];
        this._phonyCamera.viewport[2] = width;
        this._phonyCamera.viewport[3] = height;
    };
    DepthQuery.prototype._end = function (width, height) {
        if (!width && !height) {
            var buffer = new Uint8Array(5 * 5 * 4);
            gl.readPixels(2, 2, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
            if (buffer[0] === 0 &&
                buffer[1] === 0 &&
                buffer[2] === 0 &&
                buffer[3] === 0) {
                return null;
            }
            return buffer[0] / 255.0 * (1.0 / (255.0 * 255.0 * 255.0)) +
                buffer[1] / 255.0 * (1.0 / (255.0 * 255.0)) +
                buffer[2] / 255.0 * (1.0 / (255.0)) +
                buffer[3] / 255.0;
        }
        else {
            var buffer = new Uint8Array(width * height * 4);
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
            var nearest = Number.POSITIVE_INFINITY;
            var stride = 1;
            var steps = width * height;
            for (var i = 0; i < steps; i += stride) {
                if (buffer[i * 4 + 0] !== 0 ||
                    buffer[i * 4 + 1] !== 0 ||
                    buffer[i * 4 + 2] !== 0 ||
                    buffer[i * 4 + 3] !== 0) {
                    var z = buffer[i * 4 + 0] / 255.0 * (1.0 / (255.0 * 255.0 * 255.0)) +
                        buffer[i * 4 + 1] / 255.0 * (1.0 / (255.0 * 255.0)) +
                        buffer[i * 4 + 2] / 255.0 * (1.0 / (255.0)) +
                        buffer[i * 4 + 3] / 255.0;
                    if (z < nearest) {
                        nearest = z;
                    }
                }
            }
            if (nearest === Number.POSITIVE_INFINITY) {
                return null;
            }
            else {
                return nearest;
            }
        }
    };
    // Find the world position of the pixel in the framebuffer.
    // It will render the entire scene, so do not use this function
    // frequently.
    DepthQuery.prototype.unproject = function (x, y, renderer, camera) {
        if (!this._ready) {
            return null;
        }
        x = Math.floor(x * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        y = Math.floor(y * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        // When the scene is rendered in double-sided mode, we can simply
        // disable the face culling instead of rendering twice.
        this._renderTarget.resize(5, 5);
        this._begin(x, y, camera, renderer, 5, 5);
        renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        if (this._scene.clipping.isEnabled()) {
            renderer.renderState.invalidateClip();
        }
        for (var i = 0, len = this._scene.models.length; i < len; i++) {
            renderer.drawDrawables(this._renderTarget, this._scene.models[i].drawables, this._phonyCamera, this._shaders, this._material, this._scene.clipping, null, null, this._scene.needRenderDoubleSided() ? false : gl.CCW);
        }
        if (this._scene.terrain) {
            renderer.drawDrawables(this._renderTarget, this._scene.terrain.drawables, this._phonyCamera, this._shaders, this._material, this._scene.clipping, null, null, this._scene.needRenderDoubleSided() ? false : gl.CCW);
        }
        var depth = this._end();
        if (depth === null) {
            console.warn("failed to find valid depth value.");
            return null;
        }
        return this._getPosition(x, y, depth, camera);
    };
    // Find the closest point in terms of z in the region stretched by (sx, sy)
    // and (ex, ey) on screen.
    DepthQuery.prototype.getNearest = function (sx, sy, ex, ey, renderer, camera) {
        if (!this._ready) {
            return null;
        }
        sx = Math.floor(sx * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        sy = Math.floor(sy * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        ex = Math.floor(ex * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        ey = Math.floor(ey * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var x = Math.floor((sx + ex) / 2);
        var y = Math.floor((sy + ey) / 2);
        var width = ex - sx;
        var height = ey - sy;
        this._renderTarget.resize(width, height);
        this._begin(x, y, camera, renderer, width, height);
        renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        if (this._scene.clipping.isEnabled()) {
            renderer.renderState.invalidateClip();
        }
        for (var i = 0, len = this._scene.models.length; i < len; i++) {
            renderer.drawDrawables(this._renderTarget, this._scene.models[i].drawables, this._phonyCamera, this._shaders, this._material, this._scene.clipping, null, null, this._scene.needRenderDoubleSided() ? false : gl.CCW);
        }
        if (this._scene.terrain) {
            renderer.drawDrawables(this._renderTarget, this._scene.terrain.drawables, this._phonyCamera, this._shaders, this._material, this._scene.clipping, null, null, this._scene.needRenderDoubleSided() ? false : gl.CCW);
        }
        var depth = this._end(width, height);
        if (depth === null) {
            console.warn("failed to find valid depth value.");
            return null;
        }
        return this._getPosition(x, y, depth, camera);
    };
    DepthQuery.prototype._getPosition = function (x, y, depth, camera) {
        var w = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
        var h = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        var p = vec4.fromValues(2.0 * (x / w - 0.5), 2.0 * ((h - 1 - y) / h - 0.5), 2 * depth - 1.0, 1.0);
        var inversedVPMatrix = mat4.create();
        mat4.invert(inversedVPMatrix, camera.vpMatrix);
        var tmp = vec4.fromValues();
        vec4.transformMat4(tmp, p, inversedVPMatrix);
        if (tmp[3] !== 0.0) {
            p[0] = tmp[0] / tmp[3];
            p[1] = tmp[1] / tmp[3];
            p[2] = tmp[2] / tmp[3];
            p[3] = 1.0;
        }
        else {
            vec4.copy(p, tmp);
        }
        return p;
    };
    DepthQuery.prototype.recompileShader = function (resourceManager, flags) {
        var flags1 = flags.slice(0);
        flags1.push("ENCODE_DEPTH");
        this._shaders[0] = resourceManager.getShader("depth-query", flags1);
        if (!this._shaders[0].ready) {
            this._shaders[0].createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["depth"], flags1);
        }
        flags1.push("MODEL_TRANSFORM");
        this._shaders[1] = resourceManager.getShader("depth-query", flags1);
        if (!this._shaders[1].ready) {
            this._shaders[1].createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["depth"], flags1);
        }
        flags1.push("INSTANCING");
        this._shaders[2] = resourceManager.getShader("depth-query", flags1);
        if (!this._shaders[2].ready) {
            this._shaders[2].createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["depth"], flags1);
        }
        this._material.attachShader(this._shaders[0]);
    };
    return DepthQuery;
}());
/* harmony default export */ __webpack_exports__["default"] = (DepthQuery);


/***/ }),

/***/ "./08ui/tool/InAppNavigation.ts":
/*!**************************************!*\
  !*** ./08ui/tool/InAppNavigation.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/camera/m3d_scene_camera.js */ "./03scene/camera/m3d_scene_camera.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_navigate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_navigate.js */ "./03scene/camera/m3d_camera_animator_navigate.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_transition.js */ "./03scene/camera/m3d_camera_animator_transition.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _DepthQuery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DepthQuery */ "./08ui/tool/DepthQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var Keypoint = /** @class */ (function () {
    function Keypoint() {
        this.eye3d = vec3.create();
        this.at3d = vec3.create();
        this.eye2d = vec2.create();
        this.at2d = vec2.create();
        this.adjust = 1.0;
        this.angleDiff = 0.0;
    }
    return Keypoint;
}());
var InAppNavigation = /** @class */ (function (_super) {
    __extends(InAppNavigation, _super);
    function InAppNavigation(viewer) {
        var _this = _super.call(this, "InAppNavigation", false, viewer) || this;
        _this._floorPlan = false;
        _this._keypoints = []; // List saving the key points, includes several Keypoints
        _this._trajectories = []; // List saving height trajectory between two key points in 3d world
        _this._distances = []; // The distance table of current keypoint to the first one.
        _this._mileage = 0; // The travelled distance after navigation starts
        _this._speed = 0.08; // camera move speed
        _this.mapWidth = 1000;
        _this.mapHeight = 1000;
        _this._cameraHeight = Number.MIN_VALUE; // The height of camera r.w.t the world space origin
        _this.ORDINARY_PEOPLE_HEIGHT = 5.5 /* / this._scene.scaleRatio*/; // height from the floor. 5.41333 feets is 1.6764 meters
        _this._state = 0; // 0: on the way to the 1st keypoint,
        // 1: arriving at the 1st keypoint
        // 2: during navigation
        _this._lod = {
            level: 0,
            // 1: 1 * 1 = 1 patch
            // 2: 2 * 2 = 4 patches
            // 3: 3 * 3 = 9 patches and so on
            depthbuffers: [],
            inversedVPMatrices: [],
        };
        //God view camera info
        _this._godView = new _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"](_this._scene);
        _this._godView._perspective = false;
        _this._godView.resize = function () { };
        _this._godView.update = function () { };
        _this._godView.invertVPMatrix = mat4.create();
        //LOD view camera info
        _this._lodCamera = new _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"](_this._scene);
        _this._lodCamera._perspective = false;
        _this._lodCamera.resize = function () { };
        _this._lodCamera.update = function () { };
        _this._renderTarget = null;
        _this._depthQuery = null;
        _this._miniMap = null;
        _this._sceneScale = 1;
        _this._animator = new _03scene_camera_m3d_camera_animator_navigate_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
        _this._at3d = vec3.create();
        _this._at2d = vec2.create();
        _this._tmpAt = vec3.create();
        _this._tmpKeypoint = new Keypoint();
        return _this;
    }
    /**
     * @description Need a clean exit when the scene is about to reload. Otherwise
     * it will cause significant memory leak.
     */
    InAppNavigation.prototype.destroy = function () {
        this._keypoints = null;
        this._distances = null;
        this._depthQuery = null;
        if (this._renderTarget) {
            this._renderTarget.destroy();
            this._renderTarget = null;
            delete this._renderTarget;
        }
        this._lod = null;
    };
    ;
    InAppNavigation.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    InAppNavigation.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    /**
     * @description enable or disable the in app navigation mode.
     * @param {boolean} enabled - true for enable or false for disable.
     */
    InAppNavigation.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
        if (enabled) {
            if (!this._renderTarget) {
                this._renderTarget = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_5__["default"]("inapp", this._resourceManager, this.mapWidth, this.mapHeight, { clearColor: [0, 0, 0, 0] });
                var bboxSize = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.size(this._scene.clipping.get());
                var length_1 = Math.max(bboxSize.width, bboxSize.height) * this._scene.scaleRatio;
                // convert length to meter
                switch (this._scene.unit) {
                    case "feet":
                        length_1 *= 0.3048;
                        break;
                    case "cm":
                        length_1 *= 0.01 * 30.48;
                        break;
                    case "m":
                        length_1 *= 0.3048;
                        break;
                    case "in":
                        length_1 *= 0.0254 * 12;
                        break;
                }
                // every 80m, we increase one level
                var level = Math.ceil(length_1 / 80);
                // clamp the level from 1 to 3, too big will cause speed issue
                // if level is 1, which means the depth map is only one 1000 * 1000 images
                // if level is 2, which means the depth map is 2 * 2 = 4 patches, each is 1000 * 1000
                // and so on. The max level is 3, which means there will be 9 patches, each time update
                // depth map, the scene will draw 9 times. I think 9 patches is big enough already.
                level = Math.min(Math.max(level, 1), 3);
                this._setLOD(level);
            }
            if (!this._depthQuery) {
                this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_6__["default"](this._scene, this._resourceManager);
            }
        }
    };
    ;
    InAppNavigation.prototype.setFloorPlanEnabled = function (enabled) {
        this._floorPlan = true;
    };
    ;
    InAppNavigation.prototype._setLOD = function (level) {
        this._lod.level = level;
        this._lod.depthbuffers = [];
        this._lod.inversedVPMatrices = [];
        for (var i = 0; i < this._lod.level * this._lod.level; i++) {
            this._lod.depthbuffers.push(new Uint8Array(this.mapWidth * this.mapHeight * 4));
            this._lod.inversedVPMatrices.push(mat4.create());
        }
    };
    ;
    /**
     * @description Add a new key point into the keypoint list
     * @param {integer} x - the x coord.
     * @param {integer} y - the y coord.
     * @return {object} keypoint which includes the screen eye coord, at coord, 3d scene's eye position
     * and at position
     */
    InAppNavigation.prototype.addKeyPoint = function (x, y) {
        // generate key point
        var keypoint = new Keypoint();
        vec3.copy(keypoint.eye3d, this._camera.eye);
        vec2.copy(keypoint.eye2d, [x, y]);
        vec3.copy(keypoint.at3d, [this._at3d[0], this._at3d[1], this._camera.eye[2]]);
        vec2.copy(keypoint.at2d, this._at2d);
        // normalize look at point
        var distance = vec3.distance(keypoint.at3d, keypoint.eye3d);
        vec3.lerp(keypoint.at3d, keypoint.eye3d, keypoint.at3d, 1 / distance);
        // push into list
        this._keypoints.push(keypoint);
        this._calculateAdjust();
        var length = this._keypoints.length;
        if (length > 1) {
            //calculate distance from two key points
            var distance_1 = vec3.distance(this._keypoints[length - 2].eye3d, this._keypoints[length - 1].eye3d);
            this._distances.push(distance_1 + this._distances[this._distances.length - 1]);
            //calculate height path from point A to B, and save them
            this._trajectories.push([]);
            this._calculateTrajectory(length - 2);
        }
        else {
            this._distances.push(0);
        }
        this.restart();
        this.stop();
        return { keypoint: this._keypoints[length - 1] };
    };
    ;
    /**
     * @description Adjust an exsiting key point's eye position and update trajectory
     * @param {integer} idx - the index in the key point list.
     * @param {integer} x - the x coord.
     * @param {integer} y - the y coord.
     * @return {boolean} true if the x, y position is valid in the 3D scene, false if not.
     */
    InAppNavigation.prototype.adjustPathPoint = function (idx, x, y) {
        var worldPosition = this._getWorldPosition(x, y);
        if (worldPosition === null) {
            return false;
        }
        vec3.copy(this._keypoints[idx].eye3d, worldPosition);
        vec2.copy(this._keypoints[idx].eye2d, [x, y]);
        this._calculateAdjust();
        //TODO: start from idx instead of re-calculating to save time
        this._distances = [];
        this._distances.push(0);
        for (var i = 1; i < this._keypoints.length; i++) {
            var distance = vec3.distance(this._keypoints[i - 1].eye3d, this._keypoints[i].eye3d);
            this._distances.push(distance + this._distances[this._distances.length - 1]);
        }
        var length = this._trajectories.length;
        // no trajectories exists
        if (length === 0) {
            return true;
        }
        this._calculateTrajectory(idx);
        this._calculateTrajectory(idx - 1);
        return true;
    };
    ;
    /**
     * @description Adjust an existing key point's at position both in 2d and 3d
     * @param {integer} idx - the index in the key point list.
     * @param {integer} x - the x coord.
     * @param {integer} y - the y coord.
     * @return {boolean} true if the x, y position is valid in the 3D scene, false if not.
     */
    InAppNavigation.prototype.adjustFocusPoint = function (idx, x, y) {
        var worldPosition = this._getWorldPosition(x, y);
        this._keypoints[idx].at3d[0] = worldPosition[0];
        this._keypoints[idx].at3d[1] = worldPosition[1];
        this._keypoints[idx].at2d[0] = x;
        this._keypoints[idx].at2d[1] = y;
        this._calculateAdjust();
        // normalize look at point
        var distance = vec3.distance(this._keypoints[idx].at3d, this._keypoints[idx].eye3d);
        vec3.lerp(this._keypoints[idx].at3d, this._keypoints[idx].eye3d, this._keypoints[idx].at3d, 1 / distance);
        this.restart();
        return { keypoint: this._keypoints[idx] };
    };
    ;
    /**
     * @description Delete a key point by it's index
     * @param {integer} idx - the index in the key point list.
     */
    InAppNavigation.prototype.deleteKeyPoint = function (idx) {
        for (var i = idx; i < this._keypoints.length - 1; i++) {
            this._keypoints[i] = this._keypoints[i + 1];
        }
        this._keypoints.pop();
        this._calculateAdjust();
        //TODO: start from idx instead of re-calculating to save time
        this._distances = [];
        if (this._keypoints.length > 1) {
            this._distances.push(0);
            for (var i = 1; i < this._keypoints.length; i++) {
                var distance = vec3.distance(this._keypoints[i - 1].eye3d, this._keypoints[i].eye3d);
                this._distances.push(distance + this._distances[this._distances.length - 1]);
            }
        }
        for (var i = idx; i < this._trajectories.length - 1; i++) {
            this._trajectories[i] = this._trajectories[i + 1];
        }
        this._trajectories.pop();
        this._calculateTrajectory(idx - 1);
        this.restart();
    };
    ;
    /**
     * @description Update the camera using the navigation path and elapsed time since navigation starts.
     * @return {object} The return value is the if the navigation moves and the 2D point on navigation path
     *                  and progress
     */
    InAppNavigation.prototype.navigate = function (stepFraction) {
        if (!this._enabled) {
            return { update: false, info: null, progress: 0.0 };
        }
        // Before starting the navigation, first jump to the first point
        if (this._state === 0) {
            vec3.copy(this._camera.eye, this._keypoints[0].eye3d);
            vec3.copy(this._camera._at, this._keypoints[0].at3d);
            this._moveTo(this._keypoints[0].eye3d, this._keypoints[0].at3d);
            this._state++;
            return { update: true, info: null, progress: 0.0 };
            // When arriving to the 1st key point, we start walking the navigation path.
        }
        // 1st Check if we reach the end.
        if (this._mileage >= this._distances[this._distances.length - 1]) {
            var eye2d = this._keypoints[this._keypoints.length - 1].eye2d;
            var at2d = this._keypoints[this._keypoints.length - 1].at2d;
            return { update: false, info: vec4.fromValues(eye2d[0], eye2d[1], at2d[0], at2d[1]), progress: 1.0 };
        }
        // Find the position of the navigation.
        var keypoint = 0;
        // A veteran programmer should always use binary search here. However,
        // since there is no many keypoints (< 50), linear search won't be much less efficient.
        for (keypoint = 0; keypoint < this._keypoints.length; keypoint++) {
            if (this._distances[keypoint] > this._mileage) {
                keypoint -= 1;
                break;
            }
        }
        // Keep walking at constant speed in every navigate(). Since navigate is called
        // at a constant frequency, we ensure the movement is smooth.
        var fraction = stepFraction ? (stepFraction * this._keypoints[keypoint].adjust) : 1;
        this._mileage += (this._speed * fraction);
        if (this._mileage > this._distances[keypoint + 1]) {
            keypoint++;
        }
        var prog = 0;
        if (keypoint < this._keypoints.length - 1) {
            var ratio = (this._mileage - this._distances[keypoint]) / (this._distances[keypoint + 1] - this._distances[keypoint]);
            vec3.lerp(this._tmpKeypoint.eye3d, this._keypoints[keypoint].eye3d, this._keypoints[keypoint + 1].eye3d, ratio);
            vec3.lerp(this._tmpKeypoint.eye2d, this._keypoints[keypoint].eye2d, this._keypoints[keypoint + 1].eye2d, ratio);
            if (this._keypoints[keypoint].adjust !== 1) {
                vec3.rotateZ(this._tmpKeypoint.at3d, this._keypoints[keypoint].at3d, this._keypoints[keypoint].eye3d, -this._keypoints[keypoint].angleDiff * ratio);
                vec3.subtract(this._tmpKeypoint.at3d, this._tmpKeypoint.at3d, this._keypoints[keypoint].eye3d);
                vec3.add(this._tmpKeypoint.at3d, this._tmpKeypoint.at3d, this._tmpKeypoint.eye3d);
                vec2.rotate(this._tmpKeypoint.at2d, this._keypoints[keypoint].at2d, this._keypoints[keypoint].eye2d, this._keypoints[keypoint].angleDiff * ratio);
                vec3.subtract(this._tmpKeypoint.at2d, this._tmpKeypoint.at2d, this._keypoints[keypoint].eye2d);
                vec3.add(this._tmpKeypoint.at2d, this._tmpKeypoint.at2d, this._tmpKeypoint.eye2d);
            }
            else {
                vec3.lerp(this._tmpKeypoint.at3d, this._keypoints[keypoint].at3d, this._keypoints[keypoint + 1].at3d, ratio);
                vec3.lerp(this._tmpKeypoint.at2d, this._keypoints[keypoint].at2d, this._keypoints[keypoint + 1].at2d, ratio);
            }
            // Get the height from the saved list
            var num = this._trajectories[keypoint].length;
            var height = this._trajectories[keypoint][Math.floor(num * ratio)];
            this._tmpKeypoint.eye3d[2] = height;
            this._tmpKeypoint.at3d[2] = height;
            prog = this._mileage / this._distances[this._distances.length - 1];
        }
        else {
            vec3.copy(this._tmpKeypoint.eye3d, this._keypoints[this._keypoints.length - 1].eye3d);
            vec3.copy(this._tmpKeypoint.at3d, this._keypoints[this._keypoints.length - 1].at3d);
            vec2.copy(this._tmpKeypoint.eye2d, this._keypoints[this._keypoints.length - 1].eye2d);
            vec2.copy(this._tmpKeypoint.at2d, this._keypoints[this._keypoints.length - 1].at2d);
            prog = 1.0;
        }
        this._moveTo(this._tmpKeypoint.eye3d, this._tmpKeypoint.at3d);
        return { update: true, info: vec4.fromValues(this._tmpKeypoint.eye2d[0], this._tmpKeypoint.eye2d[1], this._tmpKeypoint.at2d[0], this._tmpKeypoint.at2d[1]), progress: prog };
    };
    ;
    /**
     * @description Jump to a point during the navigation by the ratio
     * @return {object} The return value is the if the navigation moves and the 2D point on navigation path
     *                  and progress
     */
    InAppNavigation.prototype.jumpTo = function (ratio) {
        this._state = 1;
        this._mileage = this._distances[this._distances.length - 1] * ratio;
        return this.navigate();
    };
    ;
    /**
     * @description Get the total steps
     * @return {int} step count
     */
    InAppNavigation.prototype.getSteps = function () {
        return Math.floor(this._distances[this._distances.length - 1] / this._speed);
    };
    ;
    /**
     * @description Add a new key point into the keypoint list
     * @param {integer} x - the x coord.
     * @param {integer} y - the y coord.
     * @return {object} keypoint which includes the screen eye coord, at coord, 3d scene's eye position
     * and at position
     */
    // Restart the navigation from the beginning.
    InAppNavigation.prototype.restart = function () {
        this._state = 0;
        this._mileage = 0;
    };
    ;
    /**
     * @description Load path data from the server
     * @param {object} data - navigation path info from the server.
     * @return {boolean} return true if the current height is different from the loaded height
     */
    InAppNavigation.prototype.loadData = function (data) {
        var isUpdateMap = false;
        this._clearData();
        var i;
        for (i = 0; i < data.points.length; i++) {
            var keypoint = new Keypoint();
            keypoint.eye2d = [data.points[i].x, data.points[i].y];
            keypoint.eye3d = data.points[i].eye3d.slice(0);
            keypoint.at2d = [data.points[i].targetX, data.points[i].targetY];
            keypoint.at3d = data.points[i].at3d.slice(0);
            this._keypoints.push(keypoint);
        }
        this._calculateAdjust();
        this._trajectories = data.trajectories;
        // When current floor height is different from required one, we
        // need to regenerate the minimap.
        if (Math.abs(this._cameraHeight - this._keypoints[0].eye3d[2]) > 1e-3) {
            this._cameraHeight = this._keypoints[0].eye3d[2];
            isUpdateMap = true;
        }
        this._distances.push(0);
        for (i = 1; i < this._keypoints.length; i++) {
            var distance = vec3.distance(this._keypoints[i - 1].eye3d, this._keypoints[i].eye3d);
            this._distances.push(distance + this._distances[this._distances.length - 1]);
        }
        this.restart();
        return isUpdateMap;
    };
    ;
    /**
     * @description Add the starting point of the navigation, and the camera will move to the point
     * @param {integer} x - the x coord.
     * @param {integer} y - the y coord.
     * @return {object} return a 3D position if pin point to a valid position otherwise null.
     */
    // Add the starting point of the navigation.
    InAppNavigation.prototype.pinPoint = function (x, y) {
        var worldPosition = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (worldPosition !== null) {
            this._clearData();
            worldPosition[2] += this.ORDINARY_PEOPLE_HEIGHT;
            this._cameraHeight = worldPosition[2];
            // When we're done with the navigating from current camera
            // to the first pin point, we want the camera look parallelly to
            // the ground. That is how we create the at.
            var lookat = vec3.create();
            vec3.lerp(lookat, this._camera.eye, worldPosition, 1.01);
            lookat[2] = worldPosition[2];
            this._moveTo(worldPosition, lookat);
            return worldPosition;
        }
        return null;
    };
    ;
    /**
     * @description Dump the depth map into a buffer for getting the correct height during the navigation
     * @return {null} return nothing
     */
    InAppNavigation.prototype.generateDepthMap = function () {
        if (this._lod.level === 1) {
            this._renderDepthMap(this._godView, 0);
        }
        else {
            var bbox = this._scene.clipping.get();
            var modelSize = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.size(bbox);
            var mapSize = Math.max(modelSize.width, modelSize.height) * 1.1;
            var range = mapSize / this._lod.level * 0.5;
            for (var y = 0; y < this._lod.level; y++) { //y coord
                for (var x = 0; x < this._lod.level; x++) { //x coord
                    //generate a tight split view
                    this._renderTarget.resize(this.mapWidth, this.mapHeight);
                    this._lodCamera.eye[0] = (bbox[0] + bbox[3]) * 0.5 + (x / this._lod.level + 0.5 / this._lod.level - 0.5) * mapSize;
                    this._lodCamera.eye[1] = (bbox[1] + bbox[4]) * 0.5 + ((this._lod.level - 1 - y) / this._lod.level + 0.5 / this._lod.level - 0.5) * mapSize;
                    this._lodCamera.eye[2] = this._cameraHeight + 0.01;
                    vec3.set(this._lodCamera._at, this._lodCamera.eye[0], this._lodCamera.eye[1], this._lodCamera.eye[2] - 1.01);
                    mat4.lookAt(this._lodCamera.viewMatrix, this._lodCamera.eye, this._lodCamera._at, [0, 1, 0]);
                    mat4.ortho(this._lodCamera.projectMatrix, -range, range, -range, range, 0.01, this._cameraHeight - bbox[2] + 0.02);
                    this._lodCamera.viewport = [0, 0, this.mapWidth, this.mapHeight];
                    mat4.multiply(this._lodCamera.vpMatrix, this._lodCamera.projectMatrix, this._lodCamera.viewMatrix);
                    this._lodCamera._cull.update();
                    this._renderDepthMap(this._lodCamera, x + y * this._lod.level);
                }
            }
        }
    };
    ;
    InAppNavigation.prototype._renderDepthMap = function (camera, index) {
        this._renderer.invalidate();
        this._renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this._renderer.drawDrawables(this._renderTarget, // target
        this._scene.drawables, // drawables
        camera, // camera
        this._depthQuery._shaders, // overridedShader
        this._depthQuery._material, // target
        this._scene.clipping, null, null, this._scene.needRenderDoubleSided() ? false : gl.CCW);
        gl.readPixels(0, 0, this.mapWidth, this.mapHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._lod.depthbuffers[index]);
        mat4.invert(this._lod.inversedVPMatrices[index], camera.vpMatrix);
    };
    ;
    /**
     * @description Get the correct eye position and at position and move to there from the mini map's coord
     * @param {integer} x - the x coord of the eye.
     * @param {integer} y - the y coord of the eye.
     * @param {integer} tx - the x coord of the at.
     * @param {integer} ty - the y coord of the at.
     * @return {boolean} always true
     */
    InAppNavigation.prototype.lookAt = function (x, y, tx, ty) {
        if (this._floorPlan) {
            x *= this.mapWidth;
            y *= this.mapHeight;
            if (tx !== undefined && ty !== undefined) {
                tx *= this.mapWidth;
                ty *= this.mapHeight;
            }
        }
        var eye = this._getWorldPosition(x, y);
        if (tx !== undefined && ty !== undefined) {
            var at = this._getWorldPosition(tx, ty);
            vec3.set(this._at3d, at[0], at[1], eye[2]);
            vec3.set(this._at2d, tx, ty);
            if (vec3.distance(this._at3d, eye) < 1e-3) {
                vec3.set(this._at3d, this._camera._at[0], this._camera._at[1], eye[2]);
            }
            this._moveTo(eye, this._at3d);
        }
        else {
            vec3.lerp(this._tmpAt, this._camera.eye, eye, 1.01);
            this._moveTo(eye, this._tmpAt);
        }
        return true;
    };
    ;
    /**
     * @description Set the mini map in the left corner of the page
     * @param {object} miniMap - the mini map image.
     * @return {null} - return nothing
     */
    InAppNavigation.prototype.setMiniMap = function (miniMap) {
        this._miniMap = miniMap;
    };
    ;
    /**
     * @description Set the mini map image
     * @return {object} the mini map image
     */
    InAppNavigation.prototype.getMiniMap = function () {
        return this._miniMap;
    };
    ;
    /**
     * @description  The minimap is 2000*2000 by default, but this size may not be enough for big model such as city.
     * |-----------|    So we want to have a close-up view.
     * |  minimap  |    example: eyeX = 0.5, eyeY = 0.5, widthRange = 0.5, heightRange = 0.5, imgWidth =2000, imgHeight = 2000
     * |           |    will get exactly same as the original minimap
     * |           |    example: eyeX = 0.0, eyeY = 0.0, widthRange = 0.5, heightRange = 0.5, imgWidth =2000, imgHeight = 2000
     * |-----------|    will get the following minimap
     *
     *      |<0.5>|
     * |----------|
     * |  new map |
     * |    |-----|----|
     * |    |     |    |
     * |----|-----|    |
     *      | original |
     *      |----------|
     * @param {integer} eyeX - the eye position relative to the model center in proportion to the width of model.
     * @param {integer} eyeY - ditto.
     * @param {float} widthRange - the half of width of camera proportion to the width of model
     * @param {float} heightRange - ditto.
     * @param {integer} imgWidth - final dumped image pixel width
     * @param {integer} imgHeight - final dumped image pixel height
     * @return {object} the god view camera matrix info
     */
    InAppNavigation.prototype.getGodView = function (eyeX, eyeY, widthRange, heightRange, imgWidth, imgHeight, resetScreenPosition) {
        this.mapWidth = imgWidth || 1000;
        this.mapHeight = imgHeight || 1000;
        //This two line of code is caused by the fact that the retina ration which has pixel ratio not 1 case.
        //(1.25, 1.5, 2.0 and so on), which means the real width and height after Math.floor of the canvas will not
        //be same as original size after resize.
        //The mini map is suppose to be 1000 * 1000, but if the device ratio is 1.5, 1000 / 1.5 = 666, 666 * 1.5 = 999
        //There will be one pixel different between render target and camera viewport. This can cause progressive 
        //rendering wrong.
        this.mapWidth = Math.floor(Math.floor(this.mapWidth / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio) * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        this.mapHeight = Math.floor(Math.floor(this.mapHeight / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio) * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        widthRange = widthRange || 1;
        heightRange = heightRange || 1;
        this._renderTarget.resize(this.mapWidth, this.mapHeight);
        var bbox = this._scene.clipping.get();
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.scale(bbox, bbox, this._sceneScale);
        var size = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.size(bbox);
        var aspect = this.mapWidth / this.mapHeight;
        var width = size.height * 0.5 * 1.1; // times with 1.1 to add some blank region around the model in minimap.
        var height = size.width * 0.5 * 1.1;
        width = Math.max(aspect * height, width);
        height = width / aspect;
        //eyeX and eyeY should be during 0 ~ 1
        this._godView._perspective = false;
        if (eyeX && eyeY) {
            this._godView.eye[0] = (bbox[0] + bbox[3]) * 0.5 + (eyeY * 2 - 1) * width;
            this._godView.eye[1] = (bbox[1] + bbox[4]) * 0.5 + ((1.0 - eyeX) * 2 - 1) * height;
            this._godView.eye[2] = this._cameraHeight + 0.01;
        }
        else {
            vec3.set(this._godView.eye, (bbox[0] + bbox[3]) * 0.5, (bbox[1] + bbox[4]) * 0.5, this._cameraHeight + 0.01);
        }
        vec3.set(this._godView._at, this._godView.eye[0], this._godView.eye[1], this._godView.eye[2] - 1.01);
        mat4.lookAt(this._godView.viewMatrix, this._godView.eye, this._godView._at, [0, 1, 0]);
        width = widthRange ? width * widthRange : width;
        height = heightRange ? height * heightRange : height;
        mat4.ortho(this._godView.projectMatrix, -width, width, -height, height, 0.01, this._cameraHeight - bbox[2] + 0.02);
        this._godView.viewport = [0, 0, this.mapWidth, this.mapHeight];
        mat4.multiply(this._godView.vpMatrix, this._godView.projectMatrix, this._godView.viewMatrix);
        this._godView._cull.update();
        if (resetScreenPosition) {
            while (!this._resetScreenPostion()) {
                this._sceneScale++;
                this.getGodView(eyeX, eyeY, widthRange, heightRange, imgWidth, imgHeight, resetScreenPosition);
            }
        }
        this._sceneScale = 1;
        return this._godView;
    };
    ;
    //range = [minx, miny, minz, maxx, maxy, maxz]
    InAppNavigation.prototype.getGodViewForFloorPlan = function (range, imgWidth) {
        this.mapWidth = imgWidth || 1000;
        this.mapHeight = this.mapWidth * (range[4] - range[1]) / (range[3] - range[0]);
        this.mapWidth = Math.floor(Math.floor(this.mapWidth / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio) * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        this.mapHeight = Math.floor(Math.floor(this.mapHeight / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio) * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        this._cameraHeight = range[2] + this.ORDINARY_PEOPLE_HEIGHT;
        var bbox = new Float32Array(6);
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.copy(bbox, range);
        //SVG is reversed Y coord
        var tmp = bbox[4];
        bbox[4] = -range[1];
        bbox[1] = -tmp;
        var size = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.size(bbox);
        var aspect = this.mapWidth / this.mapHeight;
        var height = size.height * 0.5;
        var width = size.width * 0.5;
        //eyeX and eyeY should be during 0 ~ 1
        this._godView._perspective = false;
        vec3.set(this._godView.eye, (bbox[0] + bbox[3]) * 0.5, (bbox[1] + bbox[4]) * 0.5, bbox[5]);
        vec3.set(this._godView._at, this._godView.eye[0], this._godView.eye[1], bbox[2]);
        mat4.lookAt(this._godView.viewMatrix, this._godView.eye, this._godView._at, [0, 1, 0]);
        mat4.ortho(this._godView.projectMatrix, -width, width, -height, height, 0.01, (bbox[5] - bbox[2]) + 0.01);
        this._godView.viewport = [0, 0, this.mapWidth, this.mapHeight];
        mat4.multiply(this._godView.vpMatrix, this._godView.projectMatrix, this._godView.viewMatrix);
        mat4.invert(this._godView.invertVPMatrix, this._godView.vpMatrix);
        this._godView._cull.update();
    };
    ;
    InAppNavigation.prototype.getScreenPosList = function () {
        var res = [];
        for (var i = 0, len = this._keypoints.length; i < len; i++) {
            res.push({
                eye2d: this._keypoints[i].eye2d,
                at2d: this._keypoints[i].at2d,
            });
        }
        return res;
    };
    ;
    /**
     * @description get the x, y position for pos in god viewport
     * @param {object} pos - 3d position.
     * @return {object} x and y coord in mini map
     */
    InAppNavigation.prototype.getMapCoord = function (pos) {
        //get the x, y position for pos in god viewport
        var _pos = pos || this._camera._at;
        var posHom = vec3.fromValues(_pos[0], _pos[1], _pos[2]);
        vec3.transformMat4(posHom, posHom, this._godView.vpMatrix);
        var x = (posHom[0] / 2.0 + 0.5) * this.mapWidth;
        var y = this.mapHeight - 1 - (posHom[1] / 2.0 + 0.5) * this.mapHeight;
        return { x: x, y: y, height: 0 };
    };
    ;
    /**
     * @description Move camera vertically by the ratio value, up or down
     * @param {float} ratio - the height in ratio for 0 to 1.
     * @return {null} - return nothing
     */
    InAppNavigation.prototype.setViewHeightByRatio = function (ratio) {
        var clip = this._scene.clipping.get();
        if (ratio !== undefined || ratio !== null) {
            this._cameraHeight = clip[2] + this.ORDINARY_PEOPLE_HEIGHT + ratio * (clip[5] - clip[2] - this.ORDINARY_PEOPLE_HEIGHT);
        }
        else {
            this._cameraHeight = this._keypoints[this._keypoints.length - 1].eye3d[2];
        }
        var targetEye = vec3.fromValues(this._camera.eye[0], this._camera.eye[1], this._cameraHeight);
        var targetAt = vec3.fromValues(this._camera._at[0], this._camera._at[1], this._cameraHeight);
        this._moveTo(targetEye, targetAt);
    };
    ;
    /**
     * @description Get the camera's z height
     * @return {null} - return nothing
     */
    InAppNavigation.prototype.getViewHeight = function () {
        return this._cameraHeight;
    };
    ;
    /**
     * @description Get the trajectories, the navigation path
     * @return {null} - return nothing
     */
    InAppNavigation.prototype.getTrajectories = function () {
        return this._trajectories;
    };
    ;
    /**
     * @description Get the height in range to adjust the slider bar in frontend page
     * @return {float} ratio from 0 to 1
     */
    InAppNavigation.prototype.getViewHeightRatio = function () {
        var clip = this._scene.clipping.get();
        var height = this._keypoints.length > 1 ? this._camera.eye[2] : this._cameraHeight;
        var ratio = (height - clip[2] - this.ORDINARY_PEOPLE_HEIGHT) / (clip[5] - clip[2] - this.ORDINARY_PEOPLE_HEIGHT);
        return ratio;
    };
    ;
    /**
     * @description Set the navigation speed
     * @param {float} speed - new speed.
     * @return {null} - return nothing
     */
    InAppNavigation.prototype.setSpeed = function (speed) {
        this._speed = speed;
        this._calculateAdjust();
    };
    ;
    InAppNavigation.prototype._resetScreenPostion = function () {
        var screenPostion = vec3.create();
        var x, y;
        for (var i = 0, len = this._keypoints.length; i < len; i++) {
            vec3.transformMat4(screenPostion, this._keypoints[i].eye3d, this._godView.vpMatrix);
            x = (screenPostion[0] / 2.0 + 0.5) * this.mapWidth;
            y = this.mapHeight - 1 - (screenPostion[1] / 2.0 + 0.5) * this.mapHeight;
            this._keypoints[i].eye2d[0] = x;
            this._keypoints[i].eye2d[1] = y;
            vec3.transformMat4(screenPostion, this._keypoints[i].at3d, this._godView.vpMatrix);
            x = (screenPostion[0] / 2.0 + 0.5) * this.mapWidth;
            y = this.mapHeight - 1 - (screenPostion[1] / 2.0 + 0.5) * this.mapHeight;
            this._keypoints[i].at2d[0] = x;
            this._keypoints[i].at2d[1] = y;
            if (x < 0 || x > this.mapWidth || y < 0 || y > this.mapHeight) {
                return false;
            }
        }
        return true;
    };
    ;
    /**
     * @description private function to get the 3d position according to the depth buffer and x, y coord
     * @param {integer} x - the x coord.
     * @param {integer} y - the y coord.
     * @return {object} world position in 3d
     */
    InAppNavigation.prototype._getWorldPosition = function (x, y) {
        if (this._floorPlan) {
            var worldPosition_1 = vec3.fromValues(2.0 * (x / this.mapWidth - 0.5), 2.0 * ((this.mapHeight - 1 - y) / this.mapHeight - 0.5), 1.0);
            vec3.transformMat4(worldPosition_1, worldPosition_1, this._godView.invertVPMatrix);
            worldPosition_1[2] = this._cameraHeight;
            return worldPosition_1;
        }
        var depthBuffer;
        var inversedVPMatrix;
        if (this._lod.level === 1) {
            depthBuffer = this._lod.depthbuffers[0];
            inversedVPMatrix = this._lod.inversedVPMatrices[0];
            //clamp value to 0~999
            x = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(Math.floor(x), 1, this.mapWidth);
            y = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(Math.floor(y), 1, this.mapHeight);
        }
        else {
            //decide which piece to use
            var partX = Math.floor(x * this._lod.level / this.mapWidth);
            var partY = Math.floor(y * this._lod.level / this.mapWidth);
            var index = partX + partY * this._lod.level;
            var depthBuffer_1 = this._lod.depthbuffers[index];
            var inversedVPMatrix_1 = this._lod.inversedVPMatrices[index];
            x = x * this._lod.level - partX * this.mapWidth;
            y = y * this._lod.level - partY * this.mapHeight;
            //clamp value to 0~999
            x = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(Math.floor(x), 1, this.mapWidth);
            y = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(Math.floor(y), 1, this.mapHeight);
        }
        var offset = 4 * (Math.floor(x) + Math.floor(this.mapHeight - y) * this.mapWidth);
        var depthPixel = [depthBuffer[offset],
            depthBuffer[offset + 1],
            depthBuffer[offset + 2],
            depthBuffer[offset + 3]];
        var depth;
        // Even the depth may be invalid, we still compute the correct (x, y) in world space.
        if (depthPixel[0] === 0 &&
            depthPixel[1] === 0 &&
            depthPixel[2] === 0 &&
            depthPixel[3] === 0) {
            depth = 0.5;
        }
        else {
            depth = depthPixel[0] / 255.0 * (1.0 / (255.0 * 255.0 * 255.0)) +
                depthPixel[1] / 255.0 * (1.0 / (255.0 * 255.0)) +
                depthPixel[2] / 255.0 * (1.0 / (255.0)) +
                depthPixel[3] / 255.0;
        }
        var worldPosition = vec3.fromValues(2.0 * (x / this.mapWidth - 0.5), 2.0 * ((this.mapHeight - 1 - y) / this.mapHeight - 0.5), 2 * depth - 1.0);
        vec3.transformMat4(worldPosition, worldPosition, inversedVPMatrix);
        worldPosition[2] += this.ORDINARY_PEOPLE_HEIGHT;
        return worldPosition;
    };
    ;
    InAppNavigation.prototype._calculateAdjust = function () {
        if (this._keypoints.length === 0) {
            return;
        }
        if (this._keypoints.length > 1) {
            var diff1 = vec2.create();
            var diff2 = vec2.create();
            for (var i = 0, len = this._keypoints.length - 1; i < len; i++) {
                var k1 = this._keypoints[i];
                var k2 = this._keypoints[i + 1];
                //1 get the distance of two points
                var distance = vec3.distance(k1.eye3d, k2.eye3d);
                vec2.subtract(diff1, k1.at2d, k1.eye2d);
                vec2.subtract(diff2, k2.at2d, k2.eye2d);
                vec2.normalize(diff1, diff1);
                vec2.normalize(diff2, diff2);
                var angle1 = Math.atan2(diff1[1], diff1[0]) + Math.PI;
                var angle2 = Math.atan2(diff2[1], diff2[0]) + Math.PI;
                var sign = Math.sign(angle2 - angle1);
                //2 get the angle difference
                var angleDiff = Math.abs(angle2 - angle1);
                //3 if bigger than PI, use the other half
                if (angleDiff > Math.PI) {
                    angleDiff = 2 * Math.PI - angleDiff;
                    sign *= -1;
                }
                this._keypoints[i].angleDiff = angleDiff * sign;
                if (angleDiff == 0) {
                    this._keypoints[i].adjust = 1;
                }
                else {
                    this._keypoints[i].adjust = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(0.08 * distance / angleDiff, 0.1, 1);
                }
                //this._keypoints[i].adjust = 1.0;
                //console.log("Point " + i + ", adjust ratio: " + this._keypoints[i].adjust);
            }
        }
        this._keypoints[this._keypoints.length - 1].adjust = 1;
    };
    ;
    /**
     * @description private function to move the camera to the specific position
     * @param {object} eye - the eye position.
     * @param {object} at - the at position.
     * @return {null} - return nothing
     */
    InAppNavigation.prototype._moveTo = function (eye, at) {
        this._animator.attach(this._camera);
        this._animator.start(eye, at);
        this._animator.stop();
    };
    ;
    /**
     * @description private function to stop the navigation
     * @param {boolean} forceStop - force to stop the navigation
     */
    InAppNavigation.prototype.stop = function (forceStop) {
        if (this._camera.animator instanceof _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
            this._camera.animator.stop();
        }
        if (this._camera.animator instanceof _03scene_camera_m3d_camera_animator_navigate_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            this._animator.stop(forceStop);
        }
    };
    ;
    /**
     * @description Calculate the trajectory between two key points
     * @param {integer} idx - the specific key point's index.
     * @return {null} - return nothing
     */
    InAppNavigation.prototype._calculateTrajectory = function (idx) {
        if (idx < 0 || idx > this._trajectories.length - 1) {
            return;
        }
        this._trajectories[idx] = [];
        var distance = this._distances[idx + 1] - this._distances[idx];
        var num = Math.ceil(distance / this._speed);
        for (var i = 0; i < num; i++) {
            var eye2d = vec2.create();
            vec3.lerp(eye2d, this._keypoints[idx].eye2d, this._keypoints[idx + 1].eye2d, i / num);
            var p = this._getWorldPosition(eye2d[0], eye2d[1]);
            this._trajectories[idx].push(p[2]);
        }
    };
    ;
    /**
     * @description Clear all the navigation info data to save memory
     * @return {null} - return nothing
     */
    InAppNavigation.prototype._clearData = function () {
        this._keypoints = [];
        this._distances = [];
        this._trajectories = [];
    };
    ;
    InAppNavigation.prototype.recompileShader = function (states) {
        if (!this._depthQuery) {
            this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_6__["default"](this._scene, this._resourceManager);
        }
        this._depthQuery.recompileShader(this._resourceManager, states);
    };
    ;
    return InAppNavigation;
}(_Tool__WEBPACK_IMPORTED_MODULE_7__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (InAppNavigation);


/***/ }),

/***/ "./08ui/tool/MagnifyGlass.ts":
/*!***********************************!*\
  !*** ./08ui/tool/MagnifyGlass.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_drawables_m3d_gizmo2d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo2d.js */ "./03scene/drawables/m3d_gizmo2d.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_transition.js */ "./03scene/camera/m3d_camera_animator_transition.js");
/* harmony import */ var _DepthQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DepthQuery */ "./08ui/tool/DepthQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
/* harmony import */ var _assets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./assets */ "./08ui/tool/assets.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var MAGNIFY_GLASS_ZOOM_LIMIT = 0.01;
var MagnifyGlass = /** @class */ (function (_super) {
    __extends(MagnifyGlass, _super);
    function MagnifyGlass(viewer) {
        var _this = _super.call(this, "MagnifyGlass", true, viewer) || this;
        _this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_3__["default"](_this._scene, viewer.getResourceManager());
        _this._animator = new _03scene_camera_m3d_camera_animator_transition_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _this._renderTarget = _this._getRenderTarget({ depthTest: false });
        _this._lineWidth = 1;
        _this._dashLength = 1;
        var mesh = _this._resourceManager.getMesh("magnify");
        mesh.createQuad();
        _this._drawable = new _03scene_drawables_m3d_gizmo2d_js__WEBPACK_IMPORTED_MODULE_1__["default"]("magnify", mesh, _this._resourceManager);
        var texture = _this._resourceManager.getTexture("magnify");
        texture.createFromFile(_assets__WEBPACK_IMPORTED_MODULE_5__["DASH_LINE_TEXTURE_IMAGE"], gl.RGB, gl.LINEAR, gl.REPEAT, function (texture) {
            _this._drawable.setTexture(texture);
            _this._dashLength = texture.width;
        });
        _this._vertices = new Float32Array(80);
        _this._indices = new Uint8Array(24);
        for (var i = 0; i < 4; ++i) {
            _this._indices[0 + i * 6] = 0 + i * 4;
            _this._indices[1 + i * 6] = 1 + i * 4;
            _this._indices[2 + i * 6] = 2 + i * 4;
            _this._indices[3 + i * 6] = 2 + i * 4;
            _this._indices[4 + i * 6] = 3 + i * 4;
            _this._indices[5 + i * 6] = 0 + i * 4;
        }
        _this._resetVertices();
        return _this;
    }
    ;
    MagnifyGlass.prototype.destroy = function () {
        this._animator.destroy();
        this._animator = null;
        delete this._animator;
        this._depthQuery.destroy();
        this._depthQuery = null;
        delete this._depthQuery;
        this._drawable.destroy();
        this._drawable = null;
        delete this._drawable;
        this._vertices = null;
        delete this._vertices;
        this._indices = null;
        delete this._indices;
        _super.prototype.destroy.call(this);
    };
    MagnifyGlass.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    MagnifyGlass.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    MagnifyGlass.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
        if (!this._enabled) {
            this._startX = 0;
            this._startY = 0;
            this._endX = 0;
            this._endY = 0;
        }
    };
    MagnifyGlass.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        this._renderer.drawDrawable(this._renderTarget, this._drawable, this._camera, null, null, null, false);
    };
    MagnifyGlass.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseDownListener(this._onMouseDown.bind(this));
            input.addMouseMoveListener(this._onMouseMove.bind(this));
            input.addMouseUpListener(this._onMouseUp.bind(this));
        }
        else if (input.name === "touch") {
            //input.addTouchMoveListener(this._onTouchMove.bind(this));
            //input.addTouchStartListener(this._onTouchStart.bind(this));
        }
    };
    MagnifyGlass.prototype._onMouseDown = function (mouse) {
        if (!this._enabled || mouse.button !== mouse.LEFT_BUTTON) {
            return false;
        }
        this._startX = mouse.x;
        this._startY = mouse.y;
        this._endX = this._startX;
        this._endY = this._startY;
        return true;
    };
    MagnifyGlass.prototype._onMouseMove = function (mouse) {
        if (!this._enabled || mouse.button !== mouse.LEFT_BUTTON || !mouse.pressed) {
            return false;
        }
        this._endX += mouse.dx;
        this._endY += mouse.dy;
        this._updateVertices();
        return true;
    };
    MagnifyGlass.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.button !== mouse.LEFT_BUTTON) {
            return false;
        }
        this._inputStop();
        this._viewer.getEventEmitter().emit("MagnifyGlass-Selected");
        return true;
    };
    //private _onTouchStart(touch) {
    //    if (!this._enabled || touch.numCursors !== 1) {
    //        return true;
    //    }
    //    var cursor0 = touch.cursor(0);
    //    this._startX = cursor0.x;
    //    this._startY = cursor0.y;
    //    this._endX = this._startX;
    //    this._endY = this._startY;
    //    return false;
    //};
    //MagnifyGlass.prototype.onTouchMove = function(touch) {
    //    if (!this._enabled || touch.numCursors !== 1) {
    //        return true;
    //    }
    //    var cursor0 = touch.cursor(0);
    //    this._endX += cursor0.dx;
    //    this._endY += cursor0.dy;
    //    this._updateVertices();
    //    return false;
    //};
    //MagnifyGlass.prototype.onTouchStop = function(touch, renderer) {
    //    if (!this._enabled || touch.numCursors !== 1) {
    //        return true;
    //    }
    //    this._inputStop(renderer);
    //    return false;
    //};
    MagnifyGlass.prototype._inputStop = function () {
        var renderer = this._renderer;
        this._resetVertices();
        if (this._startX > this._endX) {
            var tmp = this._startX;
            this._startX = this._endX;
            this._endX = tmp;
        }
        if (this._startY > this._endY) {
            var tmp = this._startY;
            this._startY = this._endY;
            this._endY = tmp;
        }
        if (this._startX === this._endX || this._startY === this._endY) {
            this.setEnabled(false);
            return;
        }
        var position = this._depthQuery.getNearest(this._startX, this._startY, this._endX, this._endY, renderer, this._camera);
        if (position === null) {
            this.setEnabled(false);
            return;
        }
        var dir = vec3.create();
        vec3.subtract(dir, position, this._camera.eye);
        var distance = vec3.length(dir);
        if (distance < MAGNIFY_GLASS_ZOOM_LIMIT * this._scene.radius) {
            this.setEnabled(false);
            return;
        }
        var scale = Math.max(Math.abs(this._endX - this._startX) / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, Math.abs(this._endY - this._startY) / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        if (this._camera.isPerspective()) {
            var cameraData = {
                fov: this._camera._fov,
                theta: this._camera._theta,
                phi: this._camera._phi,
                at: [position[0], position[1], position[2]],
                distance: scale * distance
            };
            this._animator.attach(this._camera);
            this._animator.start(cameraData, false, 50);
        }
        else {
            this._camera.zoomBy(scale);
        }
        this.setEnabled(false);
    };
    /**
     * Need to be called when canvas gets resized.
     * @param width
     * @param height
     */
    MagnifyGlass.prototype.resize = function (width, height) {
        this._renderTarget.resize(width, height);
        _super.prototype.resize.call(this, width, height);
    };
    ;
    /**
     * Set the line with of the magnify glass border.
     * @param lineWidth - the width in pixel.
     */
    MagnifyGlass.prototype.setLineWidth = function (lineWidth) {
        this._lineWidth = lineWidth;
    };
    MagnifyGlass.prototype._updateVertices = function () {
        var sx = this._startX;
        var ex = this._endX;
        var sy = this._startY;
        var ey = this._endY;
        if (this._startX > this._endX) {
            sx = this._endX;
            ex = this._startX;
        }
        if (this._startY > this._endY) {
            sy = this._endY;
            ey = this._startY;
        }
        sx = Math.floor(sx * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        sy = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - sy * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        ex = Math.floor(ex * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        ey = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - ey * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var w = ex - sx;
        var h = sy - ey;
        var t = Math.floor(this._lineWidth * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        this._addQuad(sx, sy, sx + t, ey, 0, 0, h, h, 0);
        this._addQuad(sx, sy, ex, sy + t, 0, w, w, 0, 20);
        this._addQuad(ex - t, sy, ex, ey, 0, 0, h, h, 40);
        this._addQuad(sx, ey - t, ex, ey, 0, w, w, 0, 60);
        this._drawable.mesh.update(this._vertices, this._indices, gl.UNSIGNED_BYTE);
    };
    MagnifyGlass.prototype._addQuad = function (sx, sy, ex, ey, t0, t1, t2, t3, offset) {
        sx = sx / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
        ex = ex / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
        sy = sy / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 2.0 - 1.0;
        ey = ey / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 2.0 - 1.0;
        this._vertices[0 + offset] = sx;
        this._vertices[1 + offset] = sy;
        this._vertices[2 + offset] = 0.0;
        this._vertices[3 + offset] = t0 / this._dashLength;
        this._vertices[4 + offset] = 0.5;
        this._vertices[5 + offset] = ex;
        this._vertices[6 + offset] = sy;
        this._vertices[7 + offset] = 0.0;
        this._vertices[8 + offset] = t1 / this._dashLength;
        this._vertices[9 + offset] = 0.5;
        this._vertices[10 + offset] = ex;
        this._vertices[11 + offset] = ey;
        this._vertices[12 + offset] = 0.0;
        this._vertices[13 + offset] = t2 / this._dashLength;
        this._vertices[14 + offset] = 0.5;
        this._vertices[15 + offset] = sx;
        this._vertices[16 + offset] = ey;
        this._vertices[17 + offset] = 0.0;
        this._vertices[18 + offset] = t3 / this._dashLength;
        this._vertices[19 + offset] = 0.5;
    };
    MagnifyGlass.prototype._resetVertices = function () {
        for (var i = 0; i < 80; ++i) {
            this._vertices[i] = -1000000;
        }
        this._drawable.mesh.update(this._vertices, this._indices, gl.UNSIGNED_BYTE);
    };
    return MagnifyGlass;
}(_Tool__WEBPACK_IMPORTED_MODULE_4__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MagnifyGlass);


/***/ }),

/***/ "./08ui/tool/Measure.ts":
/*!******************************!*\
  !*** ./08ui/tool/Measure.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DepthQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DepthQuery */ "./08ui/tool/DepthQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var Measure = /** @class */ (function (_super) {
    __extends(Measure, _super);
    function Measure(name, viewer) {
        var _this = _super.call(this, name, true, viewer) || this;
        _this._vertices = [];
        _this._lines = [];
        _this._subLines = [];
        _this._snapCoord = [0, 0]; // in Window coordinate (origin is left top with device pixel ratio)
        _this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_0__["default"](_this._scene, _this._resourceManager);
        _this._rtLine = _this._getRenderTarget({ depthTest: false });
        _this._clippingEnabled = _this._scene.clipping.isEnabled();
        _this._snappingEnabled = true; // Turn on snapping by default
        _this._snapping = null;
        _this._lineColor = [0.969, 0.398, 0.238];
        _this._clicks = 0; // How many times we clicked.
        _this._finished = false;
        _this._smartCullingEnabled = false;
        _this._unit = "m";
        _this._scaling = 0.3048;
        _this._lastEventName = "";
        _this._lastEventObject = null;
        _this._lastAnchorUpdates = null;
        var canvas = viewer.getCanvas();
        _this._overlays = Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createOverlays"])();
        // mouse anchor use orange color
        _this._mouseAnchor = Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorPoint"])("#f75223");
        // point anchors
        _this._anchorPoints = [
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorPoint"])(),
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorPoint"])(),
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorPoint"])()
        ];
        // measure value anchors
        _this._anchorValues = [
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorValue"])(),
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorValue"])(),
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorValue"])()
        ];
        // pre add mouse anchor cause it shows across all measure tools
        _this._overlays.appendChild(_this._mouseAnchor);
        return _this;
    }
    Measure.prototype.doesSupportMobile = function (isMobile) {
        return !isMobile;
    };
    Measure.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    Measure.prototype.destroy = function () {
        this._rtLine = null;
        delete this._rtLine;
        for (var i = 0; i < this._lines.length; i++) {
            this._lines[i]._drawable.mesh.destroy();
            this._lines[i].destroy();
        }
        this._lines = null;
        delete this._lines;
        for (var i = 0; i < this._subLines.length; i++) {
            this._subLines[i]._drawable.mesh.destroy();
            this._subLines[i].destroy();
        }
        this._subLines = null;
        delete this._subLines;
        this._depthQuery.destroy();
        this._depthQuery = null;
        delete this._depthQuery;
        this._vertices = null;
        delete this._vertices;
        this._overlays.remove();
        this._overlays = null;
        delete this._overlays;
        this._anchorPoints = null;
        delete this._anchorPoints;
        this._anchorValues = null;
        delete this._anchorValues;
        this._mouseAnchor = null;
        delete this._mouseAnchor;
        this._lastEventObject = null;
        delete this._lastEventObject;
        this._lastAnchorUpdates = null;
        delete this._lastAnchorUpdates;
    };
    Measure.prototype.resize = function (width, height) {
        this._rtLine.resize(width, height);
        if (this._snapping) {
            this._snapping.resize(width, height);
        }
    };
    Measure.prototype._reset = function () {
        for (var i = 0; i < this._lines.length; i++) {
            this._lines[i]._drawable.mesh.destroy();
            this._lines[i].destroy();
        }
        this._lines = [];
        this._vertices = [];
        this._clicks = 0;
        this._finished = false;
        this._notifyResult("Measure-Update", {
            distance: 0.0,
            x: 0.0,
            y: 0.0,
            z: 0.0,
            angle: 0.0,
            area: 0.0
        });
    };
    Measure.prototype._recompileShader = function () {
        // Check if the scene is clipping enabled but ruler doesn't have that flag.
        // If yes, recompile shaders.
        if (this._scene.clipping.isEnabled() !== this._clippingEnabled) {
            this._clippingEnabled = this._scene.clipping.isEnabled();
            var flags = [];
            if (this._scene.compressed) {
                flags.push("COMPRESSION");
            }
            if (this._scene.needRenderDoubleSided()) {
                flags.push("DOUBLESIDED");
            }
            this._depthQuery.recompileShader(this._resourceManager, flags);
            if (this._snapping) {
                this._snapping.recompileShader(this._resourceManager, flags);
            }
        }
    };
    Measure.prototype._updateMouseAnchor = function (update) {
        Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorPoint"])(this._mouseAnchor, update);
    };
    Measure.prototype._hideMouseAnchor = function () {
        Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorPoint"])(this._mouseAnchor, null);
    };
    Measure.prototype._updateAnchorPoints = function (points) {
        if (points === void 0) { points = []; }
        if (points.length > this._anchorPoints.length) {
            var newAnchor = Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["createAnchorPoint"])();
            this._overlays.appendChild(newAnchor);
            this._anchorPoints.push(newAnchor);
        }
        this._anchorPoints.forEach(function (anchor, i) {
            if (points[i]) {
                Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorPoint"])(anchor, { pos: points[i] });
            }
            else {
                Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorPoint"])(anchor, null);
            }
        });
    };
    Measure.prototype._hideAnchorPoints = function () {
        this._anchorPoints.forEach(function (anchor) {
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorPoint"])(anchor, null);
        });
    };
    Measure.prototype._updateAnchorValues = function (updates) {
        if (updates === void 0) { updates = []; }
        this._anchorValues.forEach(function (anchor, i) {
            if (updates[i]) {
                Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorValue"])(anchor, updates[i]);
            }
        });
        var anchorValueUpdates = updates
            .filter(function (u) {
            return !!u.value;
        })
            .map(function (u) {
            return { value: u.value };
        });
        if (anchorValueUpdates.length > 0) {
            this._lastAnchorUpdates = anchorValueUpdates;
        }
    };
    Measure.prototype._hideAnchorValues = function () {
        this._anchorValues.forEach(function (anchor) {
            Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorValue"])(anchor, null);
        });
    };
    //protected _getScreenPosition(point0 : any, point1 : any) : Array<number> {
    //    let res = this._projectLineSegmentToScreen(point0, point1, );
    //    if (res[0]) {
    //        return [(res[1][0] + res[2][0]) * 0.5, (res[1][1] + res[2][1]) * 0.5];
    //    } else {
    //        return [-100000, -100000, -100000];
    //    }
    //}
    Measure.prototype._updateSnapping = function () {
        this._snapping.update(this._renderer, this._scene, this._camera);
    };
    Measure.prototype._projectLineSegmentToScreen = function (start, end, point0, point1) {
        var direction = this._camera.getViewDirection();
        var d = -vec3.dot(direction, this._camera.eye);
        vec3.copy(point0, start);
        vec3.copy(point1, end);
        var sign0 = vec3.dot(point0, direction) + d;
        var sign1 = vec3.dot(point1, direction) + d;
        var diff = vec3.create();
        if (sign0 > 0 || sign1 > 0) {
            if (sign0 < 0) {
                vec3.subtract(diff, point0, point1);
                var m = (0.001 - d - vec3.dot(point1, direction)) / vec3.dot(diff, direction);
                vec3.scaleAndAdd(point0, point1, diff, m);
            }
            if (sign1 < 0) {
                vec3.subtract(diff, point1, point0);
                var m = (0.001 - d - vec3.dot(point0, direction)) / vec3.dot(diff, direction);
                vec3.scaleAndAdd(point1, point0, diff, m);
            }
            var coord0 = this._camera.project(point0);
            point0[0] = coord0[0];
            point0[1] = coord0[1];
            var coord1 = this._camera.project(point1);
            point1[0] = coord1[0];
            point1[1] = coord1[1];
            return true;
        }
        else {
            return false;
        }
    };
    Measure.prototype.setSnappingEnabled = function (enabled) {
        this._snappingEnabled = enabled;
    };
    Measure.prototype.setEnabled = function (enabled) {
        var _this = this;
        this._enabled = enabled;
        if (!this._enabled) {
            this._camera.removeUpdateStopListener(this._updateSnapping.bind(this));
            this._reset();
        }
        else {
            // Check if the scene is clipping enabled but ruler doesn't have that flag.
            // If yes, recompile shaders.
            this._snapping = this._viewer.getSnapping();
            this._camera.addUpdateStopListener(this._updateSnapping.bind(this));
            this._recompileShader();
            this._camera.setBimCullingEnabled(false);
            this._updateSnapping();
        }
        if (enabled) {
            this._smartCullingEnabled = this._viewer.isSmartCullingEnabled();
            this._viewer.setSmartCullingEnabled(false);
            // add overlays to DOM
            this._viewer.getCanvas().insertAdjacentElement("afterend", this._overlays);
            this._anchorPoints.concat(this._anchorValues).forEach(function (anchor) {
                _this._overlays.appendChild(anchor);
            });
        }
        else {
            this._viewer.setSmartCullingEnabled(this._smartCullingEnabled);
            // remove overlays from DOM
            this._overlays.remove();
            this._anchorPoints.concat(this._anchorValues).forEach(function (anchor) {
                anchor.remove();
            });
        }
    };
    Measure.prototype.setLineColor = function (color) {
        this._lineColor[0] = color[0];
        this._lineColor[1] = color[1];
        this._lineColor[2] = color[2];
    };
    Measure.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseDownListener(this._onMouseDown.bind(this));
            input.addMouseWheelListener(this._onMouseWheel.bind(this));
            input.addMouseMoveListener(this._onMouseMove.bind(this));
            input.addMouseUpListener(this._onMouseUp.bind(this));
        }
        else if (input.name === "touch") {
            //input.addTouchMoveListener(this._onTouchMove.bind(this));
            //input.addTouchStartListener(this._onTouchStart.bind(this));
        }
        else if (input.name === "keyboard") {
            input.addKeyUpListener(this._onKeyUp.bind(this));
        }
    };
    Measure.prototype.setUnit = function (unit) {
        var _this = this;
        var changed = (unit !== this._unit);
        var oldScaling = this._scaling;
        // By default it is 'm'
        switch (unit) {
            case 'm':
                this._unit = "m";
                this._scaling = 0.3048;
                break;
            case 'cm':
                this._unit = "cm";
                this._scaling = 30.48;
                break;
            case 'feet':
                this._unit = "feet";
                this._scaling = 1.0;
                break;
            case 'inches':
                this._unit = "inches";
                this._scaling = 12.0;
                break;
            default:
                console.log('Unsupported length unit! Please use either "feet", "inches", "cm" or "m"');
                break;
        }
        if (changed && this._lastEventName !== "") {
            var scaling_1 = this._scaling / oldScaling;
            var eventObject = this._lastEventObject;
            if (eventObject["distance"]) {
                eventObject["distance"] *= scaling_1;
                eventObject["distance"] = eventObject["distance"].toFixed(2);
            }
            if (eventObject["x"]) {
                eventObject["x"] *= scaling_1;
                eventObject["x"] = eventObject["x"].toFixed(2);
            }
            if (eventObject["y"]) {
                eventObject["y"] *= scaling_1;
                eventObject["y"] = eventObject["y"].toFixed(2);
            }
            if (eventObject["z"]) {
                eventObject["z"] *= scaling_1;
                eventObject["z"] = eventObject["z"].toFixed(2);
            }
            this._viewer.getEventEmitter().emit(this._lastEventName, eventObject);
            this._anchorValues.forEach(function (anchor, i) {
                if (_this._lastAnchorUpdates[i]) {
                    var update = _this._lastAnchorUpdates[i];
                    if (update.value) {
                        update.value *= scaling_1;
                        update.value = update.value.toFixed(2);
                    }
                    Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_2__["updateAnchorValue"])(anchor, update);
                }
            });
        }
    };
    Measure.prototype.getUnit = function () {
        return this._unit;
    };
    Measure.prototype._convertArea = function (area) {
        return area * (this._scaling * this._scaling);
    };
    Measure.prototype._convertLength = function (length) {
        return length * this._scaling;
    };
    Measure.prototype._onKeyUp = function (keyboard) {
        return false;
    };
    Measure.prototype._onMouseDown = function (mouse) {
        this._recompileShader();
        return false;
    };
    Measure.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // if the one point is pressed, and wheel happens, do not render the line
        //this._anchor.visible = false;
        return false;
    };
    Measure.prototype._onMouseMove = function (mouse) {
        return false;
    };
    Measure.prototype._onMouseUp = function (mouse) {
        return false;
    };
    // Forward the event to the upper layer (e.g., frontend).
    Measure.prototype._notifyResult = function (eventName, eventObject) {
        this._viewer.getEventEmitter().emit(eventName, eventObject);
        this._lastEventName = eventName;
        this._lastEventObject = eventObject;
    };
    return Measure;
}(_Tool__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Measure);


/***/ }),

/***/ "./08ui/tool/MeasureAngle.ts":
/*!***********************************!*\
  !*** ./08ui/tool/MeasureAngle.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_line.js */ "./08ui/tool/m3d_line.js");
/* harmony import */ var _Measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Measure */ "./08ui/tool/Measure.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
// Fix the angle of two connect lines.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var render_p0 = [0, 0];
var render_p1 = [0, 0];
var MeasureAngle = /** @class */ (function (_super) {
    __extends(MeasureAngle, _super);
    function MeasureAngle(viewer) {
        var _this = _super.call(this, "MeasureAngle", viewer) || this;
        _this._angle = 0;
        _this._radians = false;
        return _this;
    }
    MeasureAngle.prototype.destory = function () {
        _super.prototype.destroy.call(this);
    };
    MeasureAngle.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
    };
    MeasureAngle.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // set the two endpoints to the same position
        if (this._clicks > 0 && this._clicks !== 3) {
            vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
        }
        this._hideMouseAnchor();
        return false;
    };
    // In radians
    MeasureAngle.prototype.getAngle = function () {
        return this._angle;
    };
    MeasureAngle.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        _super.prototype._onMouseMove.call(this, mouse);
        // Hide the ruler line when users are dragging the model.
        // Also make the maps dirty. Rotate movement
        if (mouse.pressed) {
            if (this._clicks > 0 && this._clicks !== 3) {
                vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
            }
            // If camera rotating happens, do not show the mouse cursor.
            this._hideMouseAnchor();
            return false;
        }
        if (mouse.moved) {
            var x = mouse.x;
            var y = mouse.y;
            // Snap the mouse cursor
            if (this._snappingEnabled) {
                this._snapCoord[0] = x;
                this._snapCoord[1] = y;
                // When camera stops, we update the buffers
                if (!mouse.pressed && !this._camera.updated) {
                    var snapped = this._snapping.snap(this._snapCoord);
                    this._updateMouseAnchor({ pos: this._snapCoord, isSnapped: snapped !== _Snapping__WEBPACK_IMPORTED_MODULE_2__["SnappingMode"].NONE });
                }
                x = this._snapCoord[0];
                y = this._snapCoord[1];
            }
            // Update the current active line.
            var position = this._camera.unproject(x, y);
            if (this._vertices.length > 0 && this._clicks < 3) {
                vec3.copy(this._vertices[this._vertices.length - 1], position);
            }
        }
        this._viewer.invalidate();
        return true;
    };
    //Do not consider wheel and double click event in ruler since we need to wait until
    //the camera stops then re-take the normal depth map. This is too complicated.
    MeasureAngle.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.moved) {
            return false;
        }
        _super.prototype._onMouseUp.call(this, mouse);
        if (mouse.button === mouse.RIGHT_BUTTON) { // right click to reset
            this._angle = 0;
            this._reset();
            return false;
        }
        var clicks = this._clicks;
        this._clicks = this._clicks % 3 + 1;
        var x = mouse.x;
        var y = mouse.y;
        if (this._snappingEnabled) {
            x = this._snapCoord[0];
            y = this._snapCoord[1];
        }
        var position = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (position) {
            if (this._snappingEnabled && !this._camera.updated) {
                this._snapping.snap(this._snapCoord, position);
            }
            this._updateLines(x, y, position);
            return true;
        }
        this._clicks = clicks;
        return false;
    };
    MeasureAngle.prototype._updateLines = function (x, y, position) {
        // For the first click, we create the first line.
        if (this._clicks === 1) {
            this._reset();
            // We start a new line
            this._vertices.push(vec3.clone(position));
            this._vertices.push(vec3.clone(position));
            this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-angle-" + this._lines.length, this._resourceManager, this._lineColor, false));
            this._clicks = 1; // The reset will clear clicks to 0 so we should recover it here.
            this._viewer.getEventEmitter().emit("Measure-Update", { angle: 0.0 });
        }
        else {
            // Update the active point.
            vec3.copy(this._vertices[this._vertices.length - 1], position);
            if (this._vertices.length < 3) {
                this._vertices.push(vec3.clone(position));
                this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-angle-" + this._lines.length, this._resourceManager, this._lineColor, false));
            }
            // Form an angle now.
            if (this._clicks === 3) {
                // Compute the angle in radians.
                var tmp0 = vec3.create();
                var tmp1 = vec3.create();
                vec3.sub(tmp0, this._vertices[0], this._vertices[1]);
                vec3.sub(tmp1, this._vertices[2], this._vertices[1]);
                this._angle = vec3.angle(tmp0, tmp1);
                var angle = this._radians ? this._angle : this._angle / Math.PI * 180;
                this._viewer.getEventEmitter().emit("Measure-Update", { angle: angle });
                this._updateAnchorValues([{
                        value: "" + angle.toFixed(2) + (this._radians ? '' : ''),
                        color: 'red'
                    }]);
                // Draw the angle spanning annotation line.
                var length0 = vec3.length(tmp0);
                var length1 = vec3.length(tmp1);
                var length_1 = Math.min(length0, length1);
                vec3.lerp(tmp0, this._vertices[1], this._vertices[0], length_1 * 0.1 / length0);
                vec3.lerp(tmp1, this._vertices[1], this._vertices[2], length_1 * 0.1 / length1);
                this._vertices.push(tmp1);
                this._vertices.push(tmp0);
                // The 3rd line is a phony line to reduce the rendering code complexity.
                this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-angle-" + this._lines.length, this._resourceManager, this._lineColor, false));
                this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-angle-" + this._lines.length, this._resourceManager, this._lineColor, false));
            }
        }
    };
    MeasureAngle.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        // We need to compute the projected lines every frame.
        for (var i = 0; i < this._lines.length; i++) {
            var point0 = this._vertices[i];
            var point1 = this._vertices[i + 1];
            if (this._projectLineSegmentToScreen(point0, point1, render_p0, render_p1)) {
                this._lines[i].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[i].render(this._rtLine, this._renderer, this._camera);
            }
        }
        var points = [];
        var len = this._vertices.length - 1;
        this._clicks === 3 && (len = 3);
        for (var i = 0; i < len; ++i) {
            points.push(this._camera.project(this._vertices[i]));
        }
        // update anchor points
        this._updateAnchorPoints(points);
        if (points.length === 3) {
            this._updateAnchorValues([{ pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(render_p0, render_p1) }]);
        }
        else {
            this._hideAnchorValues();
        }
    };
    MeasureAngle.prototype.useRadians = function (enabled) {
        if (this._radians !== enabled) {
            var angle = enabled ? this._angle : this._angle / Math.PI * 180;
            this._updateAnchorValues([{
                    value: "" + angle.toFixed(2) + (this._radians ? '' : ''),
                    color: 'red'
                }]);
            this._viewer.getEventEmitter().emit("Measure-Update", { angle: angle });
        }
        this._radians = enabled;
    };
    MeasureAngle.prototype.isRadians = function () {
        return this._radians;
    };
    return MeasureAngle;
}(_Measure__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MeasureAngle);


/***/ }),

/***/ "./08ui/tool/MeasureArea.ts":
/*!**********************************!*\
  !*** ./08ui/tool/MeasureArea.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_line.js */ "./08ui/tool/m3d_line.js");
/* harmony import */ var _Measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Measure */ "./08ui/tool/Measure.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var render_p0 = [0, 0];
var render_p1 = [0, 0];
var render_centroid = [0, 0, 0];
var MeasureArea = /** @class */ (function (_super) {
    __extends(MeasureArea, _super);
    function MeasureArea(viewer) {
        var _this = _super.call(this, "MeasureArea", viewer) || this;
        _this._area = 0;
        _this._subLines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("area_subline_0", _this._resourceManager, _this._lineColor, true));
        _this._subLines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("area_subline_1", _this._resourceManager, _this._lineColor, true));
        return _this;
    }
    MeasureArea.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
    };
    MeasureArea.prototype._onKeyUp = function (keyboard) {
        if (!this._enabled || this._finished) {
            return false;
        }
        if (keyboard.key === 27 || keyboard.key === 13) {
            this._vertices.pop();
            this._finished = true;
        }
    };
    MeasureArea.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // set the two endpoints to the same position
        this._finished || this._clicks > 0 && vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
        this._hideMouseAnchor();
        return false;
    };
    MeasureArea.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        _super.prototype._onMouseMove.call(this, mouse);
        // Hide the ruler line when users are dragging the model.
        // Also make the maps dirty. Rotate movement
        if (mouse.pressed) {
            this._finished || this._clicks > 0 && vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
            // If camera rotating happens, do not show the mouse cursor.
            this._hideMouseAnchor();
            return false;
        }
        if (mouse.moved) {
            var x = mouse.x;
            var y = mouse.y;
            // Snap the mouse cursor
            if (this._snapping) {
                this._snapCoord[0] = x;
                this._snapCoord[1] = y;
                // When camera stops, we update the buffers
                if (!mouse.pressed && !this._camera.updated) {
                    var snapped = this._snapping.snap(this._snapCoord);
                    if (this._finished) {
                        this._hideMouseAnchor();
                    }
                    else {
                        this._updateMouseAnchor({ pos: this._snapCoord, isSnapped: snapped !== _Snapping__WEBPACK_IMPORTED_MODULE_2__["SnappingMode"].NONE });
                    }
                }
                x = this._snapCoord[0];
                y = this._snapCoord[1];
            }
            var position = this._camera.unproject(x, y);
            if (this._vertices.length > 0 && !this._finished) {
                vec3.copy(this._vertices[this._vertices.length - 1], position);
            }
        }
        return true;
    };
    // Do not consider wheel and double click event in ruler since we need to wait until
    // the camera stops then re-take the normal depth map. This is too complicated.
    MeasureArea.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.moved) {
            return false;
        }
        _super.prototype._onMouseUp.call(this, mouse);
        if (mouse.button === mouse.RIGHT_BUTTON) { // right click
            this._reset();
            return false;
        }
        if (this._finished) {
            this._reset();
        }
        this._clicks++;
        var x = mouse.x;
        var y = mouse.y;
        if (this._snapping) {
            x = this._snapCoord[0];
            y = this._snapCoord[1];
        }
        var position = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (position) {
            if (this._snapping && !this._camera.updated) {
                this._snapping.snap(this._snapCoord, position);
            }
            this._updateLines(x, y, position);
            return true;
        }
        this._clicks--;
        return false;
    };
    MeasureArea.prototype._updateLines = function (x, y, position) {
        // The first point
        if (this._clicks === 1) {
            this._vertices.push(vec3.clone(position));
        }
        else {
            vec3.copy(this._vertices[this._vertices.length - 1], position);
        }
        this._vertices.push(vec3.clone(position));
        this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-area-" + this._lines.length, this._resourceManager, this._lineColor, false));
        // Calculate the area
        if (this._lines.length >= 3) {
            var edges = this._lines.length;
            var v1 = vec3.create();
            var v2 = vec3.create();
            var cross = vec3.create();
            var sum = vec3.create();
            var norm = vec3.create();
            vec3.sub(v1, this._vertices[1], this._vertices[0]);
            vec3.sub(v2, this._vertices[2], this._vertices[1]);
            vec3.cross(norm, v1, v2);
            vec3.normalize(norm, norm);
            for (var i = 0; i < edges; i++) {
                vec3.sub(v1, this._vertices[(i + 1) % edges], this._vertices[i % edges]);
                vec3.sub(v2, this._vertices[(i + 2) % edges], this._vertices[(i + 1) % edges]);
                vec3.cross(cross, v1, v2);
                vec3.add(sum, sum, cross);
            }
            this._area = Math.abs(vec3.dot(norm, sum) * 0.5);
            var area = this._convertArea(this._area);
            this._notifyResult("Measure-Update", { area: area });
            this._updateAnchorValues([{ value: area.toFixed(2), color: 'red' }]);
        }
    };
    MeasureArea.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        if (this._clicks < 1) {
            // hide anchor points;
            this._hideAnchorPoints();
            this._hideAnchorValues();
            return;
        }
        // Draw solid lines.
        var edges = this._lines.length;
        var divider = Math.max(edges, 2);
        for (var i = 0; i < edges; i++) {
            var point0 = this._vertices[i % divider];
            var point1 = this._vertices[(i + 1) % divider];
            if (this._projectLineSegmentToScreen(point0, point1, render_p0, render_p1)) {
                this._lines[i].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[i].render(this._rtLine, this._renderer, this._camera);
            }
        }
        // Draw two dashed lines connecting last vertex to the two vertex.
        if (this._clicks > 1 && !this._finished) {
            var point1 = this._vertices[this._vertices.length - 1];
            var point0 = this._vertices[0];
            if (this._projectLineSegmentToScreen(point0, point1, render_p0, render_p1)) {
                this._subLines[0].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._subLines[0].render(this._rtLine, this._renderer, this._camera);
            }
            point0 = this._vertices[this._vertices.length - 2];
            if (this._projectLineSegmentToScreen(point0, point1, render_p0, render_p1)) {
                this._subLines[1].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._subLines[1].render(this._rtLine, this._renderer, this._camera);
            }
        }
        var render_centroid = [0, 0, 0];
        var points = [];
        var len = this._finished ? this._vertices.length : this._vertices.length - 1;
        for (var i = 0; i < this._vertices.length; ++i) {
            render_centroid[0] += this._vertices[i][0];
            render_centroid[1] += this._vertices[i][1];
            render_centroid[2] += this._vertices[i][2];
            points.push(this._camera.project(this._vertices[i]));
        }
        render_centroid[0] /= len;
        render_centroid[1] /= len;
        render_centroid[2] /= len;
        // update anchor points
        this._updateAnchorPoints(points.slice(0, points.length - 1));
        // update anchor values
        this._updateAnchorValues([{ pos: this._camera.project(render_centroid) }]);
    };
    MeasureArea.prototype.setUnit = function (unit) {
        var _this = this;
        var changed = (unit !== this._unit);
        var oldScaling = this._scaling;
        // By default it is 'm'
        switch (unit) {
            case 'm':
                this._unit = "m";
                this._scaling = 0.3048;
                break;
            case 'cm':
                this._unit = "cm";
                this._scaling = 30.48;
                break;
            case 'feet':
                this._unit = "feet";
                this._scaling = 1.0;
                break;
            case 'inches':
                this._unit = "inches";
                this._scaling = 12.0;
                break;
            default:
                console.log('Unsupported length unit! Please use either "feet", "inches", "cm" or "m"');
                break;
        }
        if (changed && this._lastEventName !== "") {
            var scaling_1 = this._scaling / oldScaling;
            var eventObject = this._lastEventObject;
            if (eventObject["area"]) {
                eventObject["area"] *= scaling_1 * scaling_1;
                eventObject["area"] = eventObject["area"].toFixed(2);
            }
            this._viewer.getEventEmitter().emit(this._lastEventName, eventObject);
            this._anchorValues.forEach(function (anchor, i) {
                if (_this._lastAnchorUpdates[i]) {
                    var update = _this._lastAnchorUpdates[i];
                    if (update.value) {
                        update.value *= scaling_1 * scaling_1;
                        update.value = update.value.toFixed(2);
                    }
                    Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["updateAnchorValue"])(anchor, update);
                }
            });
        }
    };
    return MeasureArea;
}(_Measure__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MeasureArea);


/***/ }),

/***/ "./08ui/tool/MeasureLine.ts":
/*!**********************************!*\
  !*** ./08ui/tool/MeasureLine.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_line.js */ "./08ui/tool/m3d_line.js");
/* harmony import */ var _Measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Measure */ "./08ui/tool/Measure.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
// Measure the length of two points.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var render_p0 = [0, 0];
var render_p1 = [0, 0];
var MeasureLine = /** @class */ (function (_super) {
    __extends(MeasureLine, _super);
    function MeasureLine(viewer) {
        var _this = _super.call(this, "MeasureLine", viewer) || this;
        _this._perimeter = 0;
        return _this;
    }
    MeasureLine.prototype.destory = function () {
        _super.prototype.destroy.call(this);
    };
    MeasureLine.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
    };
    MeasureLine.prototype.getPerimeter = function () {
        return this._perimeter;
    };
    MeasureLine.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // set the two endpoints to the same position
        this._clicks % 2 === 1 && vec3.copy(this._vertices[1], this._vertices[0]);
        this._hideMouseAnchor();
        return false;
    };
    MeasureLine.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        _super.prototype._onMouseMove.call(this, mouse);
        // Hide the ruler line when users are dragging the model.
        // Also make the maps dirty. Rotate movement
        if (mouse.pressed) {
            this._clicks % 2 === 1 && vec3.copy(this._vertices[1], this._vertices[0]);
            // If camera rotating happens, do not show the mouse cursor.
            this._hideMouseAnchor();
            return false;
        }
        if (mouse.moved) {
            var x = mouse.x;
            var y = mouse.y;
            // Snap the mouse cursor
            if (this._snappingEnabled) {
                this._snapCoord[0] = x;
                this._snapCoord[1] = y;
                // When camera stops, we update the buffers
                if (!mouse.pressed && !this._camera.updated) {
                    var snapped = this._snapping.snap(this._snapCoord);
                    this._updateMouseAnchor({ pos: this._snapCoord, isSnapped: snapped !== _Snapping__WEBPACK_IMPORTED_MODULE_2__["SnappingMode"].NONE });
                }
                x = this._snapCoord[0];
                y = this._snapCoord[1];
            }
            // Update the current active line.
            if (this._clicks % 2 === 1) {
                var position = this._camera.unproject(x, y);
                if (this._vertices.length > 0) {
                    vec3.copy(this._vertices[1], position);
                }
            }
        }
        return true;
    };
    // Do not consider wheel and double click event in ruler since we need to wait until
    // the camera stops then re-take the normal depth map. This is too complicated.
    MeasureLine.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.moved) {
            return false;
        }
        _super.prototype._onMouseUp.call(this, mouse);
        if (mouse.button === mouse.RIGHT_BUTTON) { // right click to reset
            this._perimeter = 0;
            this._reset();
            return false;
        }
        this._clicks++;
        var x = mouse.x;
        var y = mouse.y;
        if (this._snappingEnabled) {
            x = this._snapCoord[0];
            y = this._snapCoord[1];
        }
        var position = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (position) {
            if (this._snappingEnabled && !this._camera.updated) {
                this._snapping.snap(this._snapCoord, position);
            }
            this._updateLine(x, y, position);
            return true;
        }
        this._clicks--;
        return false;
    };
    MeasureLine.prototype._updateLine = function (x, y, position) {
        // We finish a line.
        if (this._clicks % 2 === 0) {
            vec3.copy(this._vertices[1], position);
            this._vertices[2][0] = this._vertices[0][0];
            this._vertices[2][1] = this._vertices[0][1];
            this._vertices[2][2] = this._vertices[1][2];
            this._vertices[3][0] = this._vertices[0][0];
            this._vertices[3][1] = this._vertices[1][1];
            this._vertices[3][2] = this._vertices[1][2];
            // Update the total line length.
            this._perimeter = vec3.distance(this._vertices[0], this._vertices[1]);
            var dx = this._convertLength(this._vertices[1][0] - this._vertices[0][0]);
            var dy = this._convertLength(this._vertices[1][1] - this._vertices[0][1]);
            var dz = this._convertLength(this._vertices[1][2] - this._vertices[0][2]);
            this._notifyResult("Measure-Update", {
                distance: this._convertLength(this._perimeter),
                x: dx,
                y: dy,
                z: dz
            });
            this._updateAnchorValues([
                { value: dx, color: 'red' },
                { value: dy, color: 'limegreen' },
                { value: dz, color: 'blue' }
            ].map(function (u) { return ({
                value: Math.abs(u.value).toFixed(2),
                color: u.color
            }); }));
        }
        else {
            // We start a new line
            this._vertices = [];
            for (var i = 0; i < 4; i++) {
                this._vertices[i] = vec3.clone(position);
            }
            this._lines[0] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("line_0", this._resourceManager, this._lineColor, false);
            this._lines[1] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("line_1", this._resourceManager, [0, 0, 1], true);
            this._lines[2] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("line_2", this._resourceManager, [0, 1, 0], true);
            this._lines[3] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("line_3", this._resourceManager, [1, 0, 0], true);
            this._notifyResult("Measure-Update", {
                distance: 0.0,
                x: 0.0,
                y: 0.0,
                z: 0.0
            });
        }
    };
    MeasureLine.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        if (this._vertices.length === 0) {
            // hide anchors
            this._hideAnchorPoints();
            this._hideAnchorValues();
            return;
        }
        // We need to compute the projected lines every frame.
        if (this._projectLineSegmentToScreen(this._vertices[0], this._vertices[1], render_p0, render_p1)) {
            this._lines[0].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
            this._lines[0].render(this._rtLine, this._renderer, this._camera);
        }
        if (this._clicks % 2 === 0) {
            if (this._projectLineSegmentToScreen(this._vertices[0], this._vertices[2], render_p0, render_p1)) {
                this._lines[1].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[1].render(this._rtLine, this._renderer, this._camera);
            }
            if (this._projectLineSegmentToScreen(this._vertices[2], this._vertices[3], render_p0, render_p1)) {
                this._lines[2].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[2].render(this._rtLine, this._renderer, this._camera);
            }
            if (this._projectLineSegmentToScreen(this._vertices[3], this._vertices[1], render_p0, render_p1)) {
                this._lines[3].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[3].render(this._rtLine, this._renderer, this._camera);
            }
        }
        // Inform viewer the 2D line end points.
        var points = [];
        // do not send the mouse point to frontend.
        var len = this._clicks % 2 === 0 ? this._vertices.length : 1;
        for (var i = 0; i < len; ++i) {
            points.push(this._camera.project(this._vertices[i]));
        }
        // update anchor points
        // only show the original two points
        this._updateAnchorPoints([points[0], points[1]]);
        // update anchor values
        if (points.length === 4) {
            this._updateAnchorValues([
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[1], points[3]) },
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[2], points[3]) },
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[2], points[0]) }
            ]);
        }
        else {
            this._hideAnchorValues();
        }
    };
    return MeasureLine;
}(_Measure__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MeasureLine);


/***/ }),

/***/ "./08ui/tool/MeasureLineFan.ts":
/*!*************************************!*\
  !*** ./08ui/tool/MeasureLineFan.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_line.js */ "./08ui/tool/m3d_line.js");
/* harmony import */ var _Measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Measure */ "./08ui/tool/Measure.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
// Fix the first point and second point can be updated.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var render_p0 = [0, 0];
var render_p1 = [0, 0];
var MeasureLineFan = /** @class */ (function (_super) {
    __extends(MeasureLineFan, _super);
    function MeasureLineFan(viewer) {
        var _this = _super.call(this, "MeasureLineFan", viewer) || this;
        _this._perimeter = 0;
        return _this;
    }
    MeasureLineFan.prototype.destory = function () {
        _super.prototype.destroy.call(this);
    };
    MeasureLineFan.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
    };
    MeasureLineFan.prototype.getPerimeter = function () {
        return this._perimeter;
    };
    MeasureLineFan.prototype._onKeyUp = function (keyboard) {
        if (!this._enabled || this._finished) {
            return false;
        }
        if (keyboard.key === 27 || keyboard.key === 13) {
            vec3.copy(this._vertices[2], this._vertices[0]);
            this._finished = true;
        }
    };
    MeasureLineFan.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // set the three points to the same position
        this._clicks > 0 && vec3.copy(this._vertices[2], this._vertices[0]);
        this._hideMouseAnchor();
        return false;
    };
    MeasureLineFan.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        _super.prototype._onMouseMove.call(this, mouse);
        // Hide the ruler line when users are dragging the model.
        // Also make the maps dirty. Rotate movement
        if (mouse.pressed) {
            // set the three points to the same position
            this._clicks > 0 && vec3.copy(this._vertices[2], this._vertices[0]);
            // If camera rotating happens, do not show the mouse cursor.
            this._hideMouseAnchor();
            return false;
        }
        if (mouse.moved) {
            var x = mouse.x;
            var y = mouse.y;
            // Snap the mouse cursor
            if (this._snappingEnabled) {
                this._snapCoord[0] = x;
                this._snapCoord[1] = y;
                // When camera stops, we update the buffers
                if (!mouse.pressed && !this._camera.updated) {
                    var snapped = this._snapping.snap(this._snapCoord);
                    if (this._finished) {
                        this._hideMouseAnchor();
                    }
                    else {
                        this._updateMouseAnchor({ pos: this._snapCoord, isSnapped: snapped !== _Snapping__WEBPACK_IMPORTED_MODULE_2__["SnappingMode"].NONE });
                    }
                }
                x = this._snapCoord[0];
                y = this._snapCoord[1];
            }
            // Update the current active line.
            var position = this._camera.unproject(x, y);
            if (this._vertices.length > 0 && !this._finished) {
                vec3.copy(this._vertices[2], position);
            }
        }
        this._viewer.invalidate();
        return true;
    };
    //Do not consider wheel and double click event in ruler since we need to wait until
    //the camera stops then re-take the normal depth map. This is too complicated.
    MeasureLineFan.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.moved) {
            return false;
        }
        _super.prototype._onMouseUp.call(this, mouse);
        if (mouse.button === mouse.RIGHT_BUTTON) { // right click to reset
            this._perimeter = 0;
            this._reset();
            return false;
        }
        if (this._finished) {
            this._reset();
        }
        this._clicks++;
        var x = mouse.x;
        var y = mouse.y;
        if (this._snappingEnabled) {
            x = this._snapCoord[0];
            y = this._snapCoord[1];
        }
        var position = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (position) {
            if (this._snappingEnabled && !this._camera.updated) {
                this._snapping.snap(this._snapCoord, position);
            }
            this._updateLines(x, y, position);
            return true;
        }
        this._clicks--;
        return false;
    };
    MeasureLineFan.prototype._updateLines = function (x, y, position) {
        var _this = this;
        // For the first click, we create the first line.
        if (this._clicks === 1) {
            // We start a new line
            for (var i = 0; i < 5; i++) {
                this._vertices.push(vec3.clone(position));
            }
            this._lines[0] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-linefan-0", this._resourceManager, this._lineColor, false);
            this._lines[1] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-linefan-1", this._resourceManager, this._lineColor, false);
            this._lines[2] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-linefan-x", this._resourceManager, [0, 0, 1], true);
            this._lines[3] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-linefan-y", this._resourceManager, [0, 1, 0], true);
            this._lines[4] = new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-linefan-z", this._resourceManager, [1, 0, 0], true);
        }
        else {
            vec3.copy(this._vertices[1], position);
            // Update the active point.
            vec3.copy(this._vertices[2], position);
            this._vertices[3][0] = this._vertices[0][0];
            this._vertices[3][1] = this._vertices[0][1];
            this._vertices[3][2] = this._vertices[1][2];
            this._vertices[4][0] = this._vertices[0][0];
            this._vertices[4][1] = this._vertices[1][1];
            this._vertices[4][2] = this._vertices[1][2];
            // Update the current line length.
            this._perimeter = vec3.distance(this._vertices[0], this._vertices[1]);
            var dx = this._vertices[1][0] - this._vertices[0][0];
            var dy = this._vertices[1][1] - this._vertices[0][1];
            var dz = this._vertices[1][2] - this._vertices[0][2];
            var _a = [dz, dy, dz].map(function (x) { return _this._convertLength(x); }), x_1 = _a[0], y_1 = _a[1], z = _a[2];
            this._notifyResult("Measure-Update", {
                x: x_1,
                y: y_1,
                z: z,
                distance: this._convertLength(this._perimeter)
            });
            this._updateAnchorValues([
                { value: x_1, color: 'red' },
                { value: y_1, color: 'limegreen' },
                { value: z, color: 'blue' }
            ].map(function (u) { return ({
                value: Math.abs(u.value).toFixed(2),
                color: u.color
            }); }));
        }
    };
    MeasureLineFan.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        if (this._vertices.length === 0) {
            // hide anchors
            this._hideAnchorPoints();
            this._hideAnchorValues();
            return;
        }
        // We need to compute the projected lines every frame.
        if (this._projectLineSegmentToScreen(this._vertices[0], this._vertices[1], render_p0, render_p1)) {
            this._lines[0].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
            this._lines[0].render(this._rtLine, this._renderer, this._camera);
        }
        if (this._projectLineSegmentToScreen(this._vertices[0], this._vertices[2], render_p0, render_p1)) {
            this._lines[1].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
            this._lines[1].render(this._rtLine, this._renderer, this._camera);
        }
        if (this._clicks > 1) {
            if (this._projectLineSegmentToScreen(this._vertices[0], this._vertices[3], render_p0, render_p1)) {
                this._lines[2].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[2].render(this._rtLine, this._renderer, this._camera);
            }
            if (this._projectLineSegmentToScreen(this._vertices[3], this._vertices[4], render_p0, render_p1)) {
                this._lines[3].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[3].render(this._rtLine, this._renderer, this._camera);
            }
            if (this._projectLineSegmentToScreen(this._vertices[4], this._vertices[1], render_p0, render_p1)) {
                this._lines[4].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[4].render(this._rtLine, this._renderer, this._camera);
            }
        }
        var points = [];
        // do not send the mouse point to frontend.
        var len = this._clicks > 1 ? this._vertices.length : 1;
        for (var i = 0; i < len; ++i) {
            if (i === 2) {
                continue;
            }
            points.push(this._camera.project(this._vertices[i]));
        }
        // update anchor points
        // only show the original two points
        this._updateAnchorPoints([points[0], points[1]]);
        // update anchor values
        if (points.length === 4) {
            this._updateAnchorValues([
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[1], points[3]) },
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[2], points[3]) },
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[2], points[0]) }
            ]);
        }
    };
    return MeasureLineFan;
}(_Measure__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MeasureLineFan);


/***/ }),

/***/ "./08ui/tool/MeasureLineStrip.ts":
/*!***************************************!*\
  !*** ./08ui/tool/MeasureLineStrip.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_line.js */ "./08ui/tool/m3d_line.js");
/* harmony import */ var _Measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Measure */ "./08ui/tool/Measure.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
// Measure the total length of connected line strip
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var render_p0 = [0, 0];
var render_p1 = [0, 0];
var MeasureLineStrip = /** @class */ (function (_super) {
    __extends(MeasureLineStrip, _super);
    function MeasureLineStrip(viewer) {
        var _this = _super.call(this, "MeasureLineStrip", viewer) || this;
        _this._perimeter = 0;
        return _this;
    }
    MeasureLineStrip.prototype.destory = function () {
        _super.prototype.destroy.call(this);
    };
    MeasureLineStrip.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
    };
    MeasureLineStrip.prototype.getPerimeter = function () {
        return this._perimeter;
    };
    MeasureLineStrip.prototype._onKeyUp = function (keyboard) {
        if (!this._enabled || this._finished) {
            return false;
        }
        if (keyboard.key === 27 || keyboard.key === 13) {
            this._vertices.pop();
            this._lines.pop();
            this._finished = true;
        }
    };
    MeasureLineStrip.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // set the three points to the same position
        this._finished || this._clicks > 0 && vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
        this._hideMouseAnchor();
        return false;
    };
    MeasureLineStrip.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        _super.prototype._onMouseMove.call(this, mouse);
        // Hide the ruler line when users are dragging the model.
        // Also make the maps dirty. Rotate movement
        if (mouse.pressed) {
            this._finished || this._clicks > 0 && vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
            // If camera rotating happens, do not show the mouse cursor.
            this._hideMouseAnchor();
            return false;
        }
        if (mouse.moved) {
            var x = mouse.x;
            var y = mouse.y;
            // Snap the mouse cursor
            if (this._snappingEnabled) {
                this._snapCoord[0] = x;
                this._snapCoord[1] = y;
                // When camera stops, we update the buffers
                if (!mouse.pressed && !this._camera.updated) {
                    var snapped = this._snapping.snap(this._snapCoord);
                    if (this._finished) {
                        this._hideMouseAnchor();
                    }
                    else {
                        this._updateMouseAnchor({ pos: this._snapCoord, isSnapped: snapped !== _Snapping__WEBPACK_IMPORTED_MODULE_2__["SnappingMode"].NONE });
                    }
                }
                x = this._snapCoord[0];
                y = this._snapCoord[1];
            }
            // Update the current active line.
            var position = this._camera.unproject(x, y);
            if (this._vertices.length > 0 && !this._finished) {
                vec3.copy(this._vertices[this._vertices.length - 1], position);
            }
        }
        this._viewer.invalidate();
        return true;
    };
    //Do not consider wheel and double click event in ruler since we need to wait until
    //the camera stops then re-take the normal depth map. This is too complicated.
    MeasureLineStrip.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.moved) {
            return false;
        }
        _super.prototype._onMouseUp.call(this, mouse);
        if (mouse.button === mouse.RIGHT_BUTTON) { // right click to reset
            this._perimeter = 0;
            this._reset();
            return false;
        }
        if (this._finished) {
            this._reset();
        }
        this._clicks++;
        var x = mouse.x;
        var y = mouse.y;
        if (this._snappingEnabled) {
            x = this._snapCoord[0];
            y = this._snapCoord[1];
        }
        var position = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (position) {
            if (this._snappingEnabled && !this._camera.updated) {
                this._snapping.snap(this._snapCoord, position);
            }
            this._updateLines(x, y, position);
            return true;
        }
        this._clicks--;
        return false;
    };
    MeasureLineStrip.prototype._updateLines = function (x, y, position) {
        //if (!position) {
        //    return ;
        //}
        this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-linestrip-" + this._lines.length, this._resourceManager, this._lineColor, false));
        // For the first click, we create the first line.
        if (this._clicks === 1) {
            // We start a new line
            this._vertices.push(vec3.clone(position));
            this._vertices.push(vec3.clone(position));
        }
        else {
            vec3.copy(this._vertices[this._vertices.length - 1], position);
            this._vertices.push(vec3.clone(position));
            // Update the total line length.
            this._perimeter = 0;
            for (var i = 0; i < this._vertices.length - 1; i++) {
                this._perimeter += vec3.distance(this._vertices[i], this._vertices[i + 1]);
            }
            var distance = this._convertLength(this._perimeter);
            this._notifyResult("Measure-Update", { distance: distance });
            this._updateAnchorValues([{ value: distance.toFixed(2), color: 'red' }]);
        }
    };
    MeasureLineStrip.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        // We need to compute the projected lines every frame.
        for (var i = 0; i < this._lines.length; i++) {
            var point0 = this._vertices[i];
            var point1 = this._vertices[i + 1];
            if (this._projectLineSegmentToScreen(point0, point1, render_p0, render_p1)) {
                this._lines[i].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[i].render(this._rtLine, this._renderer, this._camera);
            }
        }
        var points = [];
        for (var i = 0; i < this._vertices.length; ++i) {
            points.push(this._camera.project(this._vertices[i]));
        }
        this._finished || points.pop();
        // update anchor points
        this._updateAnchorPoints(points);
        // update anchor values
        if (points.length >= 2) {
            this._updateAnchorValues([
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[points.length - 2], points[points.length - 1]) }
            ]);
        }
        else {
            this._hideAnchorValues();
        }
    };
    return MeasureLineStrip;
}(_Measure__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MeasureLineStrip);


/***/ }),

/***/ "./08ui/tool/MeasureLines.ts":
/*!***********************************!*\
  !*** ./08ui/tool/MeasureLines.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m3d_line.js */ "./08ui/tool/m3d_line.js");
/* harmony import */ var _Measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Measure */ "./08ui/tool/Measure.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../10api/utils/measure */ "./10api/utils/measure.ts");
// Measure the total length of several un-connected lines.
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var render_p0 = [0, 0];
var render_p1 = [0, 0];
var MeasureLines = /** @class */ (function (_super) {
    __extends(MeasureLines, _super);
    function MeasureLines(viewer) {
        var _this = _super.call(this, "MeasureLines", viewer) || this;
        _this._perimeter = 0;
        return _this;
    }
    MeasureLines.prototype.destory = function () {
        _super.prototype.destroy.call(this);
    };
    MeasureLines.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
    };
    MeasureLines.prototype.getPerimeter = function () {
        return this._perimeter;
    };
    MeasureLines.prototype._onKeyUp = function (keyboard) {
        if (!this._enabled || this._finished) {
            return false;
        }
        if (keyboard.key === 27 || keyboard.key === 13) {
            if (this._clicks % 2 === 1) {
                this._vertices.pop();
                this._lines.pop();
            }
            this._finished = true;
        }
    };
    MeasureLines.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // set the three points to the same position
        this._finished || this._clicks % 2 === 1 && vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
        this._hideMouseAnchor();
        return false;
    };
    MeasureLines.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        _super.prototype._onMouseMove.call(this, mouse);
        // Hide the ruler line when users are dragging the model.
        // Also make the maps dirty. Rotate movement
        if (mouse.pressed) {
            // if rotating happens, do not show the mouse blue dot
            this._finished || this._clicks % 2 === 1 && vec3.copy(this._vertices[this._vertices.length - 1], this._vertices[this._vertices.length - 2]);
            this._hideMouseAnchor();
            return false;
        }
        if (mouse.moved) {
            var x = mouse.x;
            var y = mouse.y;
            // Snap the mouse cursor
            if (this._snappingEnabled) {
                this._snapCoord[0] = x;
                this._snapCoord[1] = y;
                // When camera stops, we update the buffers
                if (!mouse.pressed && !this._camera.updated) {
                    var snapped = this._snapping.snap(this._snapCoord);
                    if (this._finished) {
                        this._hideMouseAnchor();
                    }
                    else {
                        this._updateMouseAnchor({ pos: this._snapCoord, isSnapped: snapped !== _Snapping__WEBPACK_IMPORTED_MODULE_2__["SnappingMode"].NONE });
                    }
                }
                x = this._snapCoord[0];
                y = this._snapCoord[1];
            }
            // Update the current active line.
            if (this._clicks % 2 === 1) {
                var position = this._camera.unproject(x, y);
                if (this._vertices.length > 0 && !this._finished) {
                    vec3.copy(this._vertices[this._vertices.length - 1], position);
                }
            }
        }
        this._viewer.invalidate();
        return true;
    };
    //Do not consider wheel and double click event in ruler since we need to wait until
    //the camera stops then re-take the normal depth map. This is too complicated.
    MeasureLines.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.moved) {
            return false;
        }
        _super.prototype._onMouseUp.call(this, mouse);
        if (mouse.button === mouse.RIGHT_BUTTON) { // right click to reset
            this._perimeter = 0;
            this._reset();
            return false;
        }
        if (this._finished) {
            this._reset();
        }
        this._clicks++;
        var x = mouse.x;
        var y = mouse.y;
        if (this._snappingEnabled) {
            x = this._snapCoord[0];
            y = this._snapCoord[1];
        }
        var position = this._depthQuery.unproject(x, y, this._renderer, this._camera);
        if (position) {
            if (this._snappingEnabled && !this._camera.updated) {
                this._snapping.snap(this._snapCoord, position);
            }
            this._updateLines(x, y, position);
            return true;
        }
        this._clicks--;
        return false;
    };
    MeasureLines.prototype._updateLines = function (x, y, position) {
        //if (!position) {
        //    return ;
        //}
        // We finish a line.
        if (this._clicks % 2 === 0) {
            vec3.copy(this._vertices[this._vertices.length - 1], position);
            // Update the total line length.
            this._perimeter = 0;
            for (var i = 0; i < this._vertices.length; i += 2) {
                this._perimeter += vec3.distance(this._vertices[i], this._vertices[i + 1]);
            }
            var distance = this._convertLength(this._perimeter);
            this._notifyResult("Measure-Update", { distance: distance });
            this._updateAnchorValues([{ value: distance.toFixed(2), color: 'red' }]);
        }
        else {
            // We start a new line
            this._vertices.push(vec3.clone(position));
            this._vertices.push(vec3.clone(position));
            this._lines.push(new _m3d_line_js__WEBPACK_IMPORTED_MODULE_0__["default"]("measure-lines-" + this._lines.length, this._resourceManager, this._lineColor, false));
        }
    };
    MeasureLines.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        // We need to compute the projected lines every frame.
        for (var i = 0; i < this._lines.length; i++) {
            var point0 = this._vertices[i * 2];
            var point1 = this._vertices[i * 2 + 1];
            if (this._projectLineSegmentToScreen(point0, point1, render_p0, render_p1)) {
                this._lines[i].updateVertices(render_p0[0], render_p0[1], render_p1[0], render_p1[1]);
                this._lines[i].render(this._rtLine, this._renderer, this._camera);
            }
        }
        var points = [];
        // do not send the mouse point to frontend
        for (var i = 0; i < this._vertices.length; ++i) {
            points.push(this._camera.project(this._vertices[i]));
        }
        if (!this._finished && this._clicks % 2 === 1) {
            points.pop();
        }
        // update anchor points
        this._updateAnchorPoints(points);
        // update anchor values
        if (points.length > 0 && points.length % 2 === 0) {
            this._updateAnchorValues([
                { pos: Object(_10api_utils_measure__WEBPACK_IMPORTED_MODULE_3__["getCenterPoint"])(points[points.length - 2], points[points.length - 1]) }
            ]);
        }
        else {
            this._hideAnchorValues();
        }
    };
    return MeasureLines;
}(_Measure__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (MeasureLines);


/***/ }),

/***/ "./08ui/tool/PickQuery.ts":
/*!********************************!*\
  !*** ./08ui/tool/PickQuery.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/camera/m3d_base_camera.js */ "./03scene/camera/m3d_base_camera.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
//
// m3d_pick_query.js
// picking
//
// Copyright Modelo XX - 2017, All rights reserved.




var PickQuery = /** @class */ (function () {
    function PickQuery(scene, resourceManager) {
        // private:
        this._scene = scene;
        this._material = null;
        this._shaders = [null, null, null];
        this._ready = false;
        this._renderTarget = null;
        this._phonyCamera = new _03scene_camera_m3d_base_camera_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this._pickMatrix = mat4.create();
        // initialization
        this._material = scene.materialManager.createMaterialAdhoc("pick-query");
        this.recompileShader(resourceManager, []);
        this._renderTarget = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_3__["default"]("query", resourceManager, 5, 5, { clearColor: [0, 0, 0, 0] });
        this._ready = this._renderTarget.ready;
    }
    ;
    PickQuery.prototype.destroy = function () {
        if (this._ready) {
            this._material.destroy();
            this._material = null;
            delete this._material;
            this._renderTarget.destroy();
            this._renderTarget = null;
            delete this._renderTarget;
        }
    };
    PickQuery.prototype._beginRegion = function (x0, y0, x1, y1, camera, renderer) {
        // Prepare the query matrix
        y0 = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - y0;
        y1 = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - y1;
        var w = Math.abs(x1 - x0) + 1;
        var h = Math.abs(y1 - y0) + 1;
        if (w != this._renderTarget.getWidth() || h != this._renderTarget.getHeight()) {
            this._renderTarget.resize(w, h);
        }
        this._pickMatrix[0] = camera.viewport[2] / w;
        this._pickMatrix[5] = camera.viewport[3] / h;
        this._pickMatrix[12] = (camera.viewport[2] - x0 - x1) / w;
        this._pickMatrix[13] = (camera.viewport[3] - y0 - y1) / h;
        mat4.multiply(this._phonyCamera.vpMatrix, this._pickMatrix, camera.vpMatrix);
        this._phonyCamera.viewport[0] = camera.viewport[0];
        this._phonyCamera.viewport[1] = camera.viewport[1];
        this._phonyCamera.viewport[2] = w;
        this._phonyCamera.viewport[3] = h;
    };
    PickQuery.prototype._endRegion = function (w, h) {
        var results = [];
        var buffer = new Uint8Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
        var indexDrawableMap = {};
        for (var y = 0; y < h; y += 2)
            for (var x = 0; x < w; x += 2) {
                var pos = (y * w + x) * 4;
                var index = buffer[pos] +
                    buffer[pos + 1] * 256 +
                    buffer[pos + 2] * 256 * 256 +
                    buffer[pos + 3] * 256 * 256 * 256;
                if (index > 0) {
                    index -= 1;
                    if (!indexDrawableMap[index]) {
                        results.push(index);
                        indexDrawableMap[index] = 1;
                    }
                }
            }
        return results;
    };
    PickQuery.prototype._changeMaterial = function (index, material) {
        index += 1; // 0 is reserved for not-picked.
        var color = [0, 0, 0];
        color[0] = ((index & 0xff) + 0.49) / 255.0;
        color[1] = (((index >> 8) & 0xff) + 0.49) / 255.0;
        color[2] = (((index >> 16) & 0xff) + 0.49) / 255.0;
        var transparent = (((index >> 24) & 0xff) + 0.49) / 255.0;
        material.setDiffuse(color);
        material.setTransparent(transparent);
    };
    ;
    PickQuery.prototype.pickModel = function (x, y, renderer, camera) {
        for (var i = 0, len = this._scene.models.length; i < len; i++) {
            if (this.pickDrawable(x, y, renderer, camera, this._scene.models[i].drawables)) {
                return i;
            }
        }
        return -1;
    };
    ;
    PickQuery.prototype.pickDrawable = function (x, y, renderer, camera, drawables) {
        // The input (x, y) are in the normalized screen space 
        // and need to convert it to window space.
        x = Math.floor(x * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        y = Math.floor(y * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        if (this._scene.clipping.isEnabled()) {
            renderer.renderState.invalidateClip();
        }
        // step1
        this._beginRegion(x, y, x, y, camera, renderer);
        renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        renderer.drawDrawablesCustom(this._renderTarget, drawables, this._phonyCamera, this._shaders, this._material, this._scene.clipping, this._scene.needRenderDoubleSided(), this._changeMaterial);
        var resultIndices = this._endRegion(1, 1);
        if (resultIndices.length === 0) {
            return null;
        }
        return drawables[resultIndices[0]];
    };
    // step1: render all drawables to get the picked drawables.
    // step2: render picked drawables' nodes to get the picked nodes
    PickQuery.prototype.pickNodesInsideRegion = function (x0, y0, x1, y1, renderer, camera, drawables) {
        if (!this._ready) {
            return null;
        }
        // The input (x, y) are in the normalized screen space 
        // and need to convert it to window space.
        x0 = Math.floor(x0 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        y0 = Math.floor(y0 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        x1 = Math.floor(x1 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        y1 = Math.floor(y1 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        if (this._scene.clipping.isEnabled()) {
            renderer.renderState.invalidateClip();
        }
        // step1
        this._beginRegion(x0, y0, x1, y1, camera, renderer);
        renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        renderer.drawDrawablesCustom(this._renderTarget, drawables, this._phonyCamera, this._shaders, this._material, this._scene.clipping, this._scene.needRenderDoubleSided(), this._changeMaterial);
        var resultIndices = this._endRegion(x1 - x0 + 1, y1 - y0 + 1);
        var nodes = [];
        resultIndices.forEach(function (index) {
            drawables[index].nodes && drawables[index].nodes.forEach(function (node) {
                node.visible && nodes.push(node);
            });
        });
        // step2
        renderer.clear(this._renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        renderer.drawNodesCustom(this._renderTarget, nodes, this._phonyCamera, this._shaders, this._material, this._scene.clipping, this._scene.needRenderDoubleSided(), this._changeMaterial);
        resultIndices = this._endRegion(x1 - x0 + 1, y1 - y0 + 1);
        var results = [];
        resultIndices.forEach(function (index) {
            results.push(nodes[index]);
        });
        return results;
    };
    PickQuery.prototype.recompileShader = function (resourceManager, flags1) {
        var flags = flags1.slice(0);
        this._shaders[0] = resourceManager.getShader("constant", flags);
        if (!this._shaders[0].ready) {
            this._shaders[0].createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["constant"], flags);
        }
        flags.push("MODEL_TRANSFORM");
        this._shaders[1] = resourceManager.getShader("constant", flags);
        if (!this._shaders[1].ready) {
            this._shaders[1].createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["constant"], flags);
        }
        flags.push("INSTANCING");
        this._shaders[2] = resourceManager.getShader("constant", flags);
        if (!this._shaders[2].ready) {
            this._shaders[2].createFromShaderSource(_02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["constant"], flags);
        }
        this._material.attachShader(this._shaders[0]);
        this._material.setDiffuse(vec3.fromValues(0, 0, 0));
        this._material.setTransparent(0);
    };
    return PickQuery;
}());
/* harmony default export */ __webpack_exports__["default"] = (PickQuery);
;


/***/ }),

/***/ "./08ui/tool/Section.ts":
/*!******************************!*\
  !*** ./08ui/tool/Section.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _02resource_m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../02resource/m3d_mesh_attribute.js */ "./02resource/m3d_mesh_attribute.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo.js */ "./03scene/drawables/m3d_gizmo.js");
/* harmony import */ var _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../03scene/materials/m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _04renderer_pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









var _NormalDepthObject = /** @class */ (function () {
    function _NormalDepthObject(resourceManager, scene) {
        this.renderTarget = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_6__["default"]("section-normal-depth", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            colorFormat: gl.RGBA32F,
            clearColor: [0.0, 0.0, 0.0, 0.0],
            colorBuffer: 0,
            depthFormat: gl.DEPTH24_STENCIL8,
            depthBuffer: 0
        });
        this.buffer = new Float32Array(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 4);
        this.bufferDirty = true;
        this.bufferDirtyTime = 0;
        this.normal = vec3.create();
        this.position = vec3.create();
        this.nearPlaneSize = null;
        this.isPerspective = true;
        this.inversedViewMatrix = mat4.create();
        this.renderPass = new _04renderer_pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_7__["default"](resourceManager, false, { line: false });
        var shader = resourceManager.getShader("normaldepth", ["WORLDSPACE_NORMAL"]);
        if (!shader.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_3__["default"]["normaldepth"];
            shader.createFromShaderSource(shaderSource, ["WORLDSPACE_NORMAL"]);
        }
        this.renderPass.setOverridedShader(shader);
        this.renderPass.setOverridedMaterial(new _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_5__["default"]("section-normal-depth"));
    }
    _NormalDepthObject.prototype.resize = function (width, height) {
        this.renderTarget.resize(width, height);
        this.buffer = new Float32Array(width * height * 4);
    };
    _NormalDepthObject.prototype.destroy = function () {
        this.buffer = null;
        this.normal = null;
        this.inversedViewMatrix = null;
        this.renderTarget.destroy();
        this.renderPass.destroy();
    };
    _NormalDepthObject.prototype.render = function (renderer, camera) {
        //draw normal depth buffer
        renderer.invalidate();
        renderer.clear(this.renderTarget, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.renderPass.render(this.renderTarget, renderer, camera);
        gl.readPixels(0, 0, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, gl.RGBA, gl.FLOAT, this.buffer);
        this.nearPlaneSize = camera.getNearPlaneSize();
        this.isPerspective = camera.isPerspective();
        mat4.invert(this.inversedViewMatrix, camera.viewMatrix);
    };
    _NormalDepthObject.prototype.getNormalDepth = function (x, y) {
        var width = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
        var height = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        var offset = 4 * (x + (height - y) * width);
        var depth = this.buffer[offset + 3];
        if (depth === 0) {
            return false;
        }
        this.normal[0] = this.buffer[offset];
        this.normal[1] = this.buffer[offset + 1];
        this.normal[2] = this.buffer[offset + 2];
        //Line does not have normal info
        if (isNaN(this.normal[0]) || isNaN(this.normal[1]) || isNaN(this.normal[2])) {
            return false;
        }
        this.position[2] = depth;
        if (this.isPerspective) {
            this.position[0] = this.nearPlaneSize[0] * 2.0 * (x / width - 0.5) * depth / this.nearPlaneSize[2];
            this.position[1] = this.nearPlaneSize[1] * 2.0 * ((height - 1 - y) / height - 0.5) * depth / this.nearPlaneSize[2];
        }
        else {
            this.position[0] = this.nearPlaneSize[0] * 2.0 * (x / width - 0.5);
            this.position[1] = this.nearPlaneSize[1] * 2.0 * ((height - 1 - y) / height - 0.5);
        }
        vec3.transformMat4(this.position, this.position, this.inversedViewMatrix);
        return true;
    };
    return _NormalDepthObject;
}());
var CUBE_INDICES = new Uint8Array([0, 1, 1, 2, 2, 3, 3, 0,
    0, 4, 1, 5, 2, 6, 3, 7,
    4, 5, 5, 6, 6, 7, 7, 4]);
var Section = /** @class */ (function (_super) {
    __extends(Section, _super);
    function Section(viewer) {
        var _this = _super.call(this, "Section", true, viewer) || this;
        _this._cube = null;
        _this._plane = null;
        _this._sensitivity = 0.005;
        _this._smartCullingEnabled = false;
        // to change the section box.
        _this._vertices = new Float32Array(24); // Plane mesh
        _this._indices = []; // Plane
        _this._indices[0] = new Uint16Array([0, 4, 7, 7, 3, 0]); // -x
        _this._indices[1] = new Uint16Array([0, 1, 5, 5, 4, 0]); // -y
        _this._indices[2] = new Uint16Array([0, 3, 2, 2, 1, 0]); // -z
        _this._indices[3] = new Uint16Array([5, 1, 2, 2, 6, 5]); // +x
        _this._indices[4] = new Uint16Array([6, 2, 3, 3, 7, 6]); // +y
        _this._indices[5] = new Uint16Array([4, 5, 6, 6, 7, 4]); // +z
        _this._cubeRT = _this._getRenderTarget();
        _this._planeRT = _this._getRenderTarget({ depthTest: false, blend: true });
        // Cube
        var mesh = _this._resourceManager.getMesh("wiredcube");
        mesh.createWiredCube();
        _this._cube = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_4__["default"]("clipbox", mesh, _this._resourceManager);
        _this._cube.setColor([0.2, 0.2, 0.2]);
        _this._cube.setTransparent(1.0);
        // Plane
        var attributes = new _02resource_m3d_mesh_attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
        attributes.builtin(gl.FLOAT);
        mesh = _this._resourceManager.getMesh("cliplane");
        mesh.create(gl.TRIANGLES, attributes, _this._vertices, _this._indices[0]);
        _this._plane = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_4__["default"]("clipplane", mesh, _this._resourceManager);
        _this._plane.setColor([0.969, 0.322, 0.137]);
        _this._plane.setTransparent(0.19);
        _this._isPressed = false;
        _this._planeUpdated = false;
        _this._gizmoPlaneIndex = null;
        _this._rotate = false;
        _this._rotateMatrix = mat4.create();
        _this._invertedRotateMatrix = mat4.create();
        _this._bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.create();
        _this._sectionedBBox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.create();
        _this._points = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.points(_this._scene.clipping.getBBox());
        if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            _this._normalDepth = new _NormalDepthObject(_this._resourceManager, _this._scene);
        }
        else {
            console.warn("Rotation section box is not supported on iOS.");
        }
        return _this;
    }
    Section.prototype.destroy = function () {
        this._vertices = null;
        this._indices = null;
        this._plane.destroy();
        this._cube.destroy();
        if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._normalDepth.destroy();
        }
    };
    Section.prototype.resize = function (width, height) {
        this._cubeRT.resize(width, height);
        this._planeRT.resize(width, height);
        if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._normalDepth.resize(width, height);
        }
    };
    Section.prototype.doesSupportMobile = function (isMobile) {
        return !isMobile;
    };
    Section.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    // update cube's vertices for rendering
    Section.prototype.updateGeometry = function (renderer) {
        this._vertices[0] = this._points[0][0];
        this._vertices[1] = this._points[0][1];
        this._vertices[2] = this._points[0][2];
        this._vertices[3] = this._points[1][0];
        this._vertices[4] = this._points[1][1];
        this._vertices[5] = this._points[1][2];
        this._vertices[6] = this._points[2][0];
        this._vertices[7] = this._points[2][1];
        this._vertices[8] = this._points[2][2];
        this._vertices[9] = this._points[3][0];
        this._vertices[10] = this._points[3][1];
        this._vertices[11] = this._points[3][2];
        this._vertices[12] = this._points[4][0];
        this._vertices[13] = this._points[4][1];
        this._vertices[14] = this._points[4][2];
        this._vertices[15] = this._points[5][0];
        this._vertices[16] = this._points[5][1];
        this._vertices[17] = this._points[5][2];
        this._vertices[18] = this._points[6][0];
        this._vertices[19] = this._points[6][1];
        this._vertices[20] = this._points[6][2];
        this._vertices[21] = this._points[7][0];
        this._vertices[22] = this._points[7][1];
        this._vertices[23] = this._points[7][2];
        this._cube.mesh.update(this._vertices, CUBE_INDICES, gl.UNSIGNED_BYTE);
        if (renderer) {
            renderer.renderState.invalidateClip();
        }
    };
    Section.prototype.render = function () {
        if (this._enabled && this._interactive) {
            // Draw the clipping box
            this._renderer.drawGizmo(this._cubeRT, this._cube, this._camera, gl.CCW);
            this._renderer.clear(this._renderer._renderTarget, gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            // Draw the _gizmo plane
            if (this._gizmoPlaneIndex !== null) {
                this._renderer.drawGizmo(this._planeRT, this._plane, this._camera, gl.CCW);
            }
        }
    };
    Section.prototype.reset = function (renderer) {
        this._rotate = false;
        this._updateBBox([0, -1, 0]);
        this._updatePoints();
        this.updateGeometry(renderer);
        if (!_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMobile) {
            this._normalDepth.bufferDirty = true;
        }
        this._viewer.getRenderScene().updateShadow();
    };
    Section.prototype.setClipRanges = function (min, max) {
        this._scene.clipping.set(min, max);
        if (typeof max[0] === 'number') {
            this._updateBBox([0, -1, 0]);
        }
        else {
            this._updateBBox(min[5]);
            for (var i = 0; i < this._points.length; i++) {
                vec3.copy(this._points[i], max[i]);
            }
        }
        for (var i = 0; i < this._points.length; i++) {
            vec3.transformMat4(this._points[i], this._points[i], this._rotateMatrix);
        }
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.createFromPoints(this._sectionedBBox, this._points);
        this._updatePoints();
        this.updateGeometry();
        this._gizmoPlaneIndex = null;
    };
    Section.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
        if (!this._enabled) {
            this.reset(this._renderer);
        }
        else {
            this._scene.clipping.initialize(this._scene.bbox);
            this._updateBBox([0, -1, 0]);
            this._updatePoints();
            this.updateGeometry(this._renderer);
        }
        if (this._enabled && this._normalDepth && !this._normalDepth.renderPass.queue.isValid()) {
            for (var i = 0, len1 = this._scene.models.length; i < len1; i++) {
                var model = this._scene.models[i];
                for (var j = 0, len2 = model.drawables.length; j < len2; j++) {
                    this._normalDepth.renderPass.queue.addDrawable(model.drawables[j]);
                }
            }
        }
        this._scene.clipping.setEnabled(enabled);
        this._viewer.getRenderScene().setClippingEnabled(enabled);
        // Disable smart bim culling.
        if (enabled) {
            this._smartCullingEnabled = this._viewer.isSmartCullingEnabled();
            this._viewer.setSmartCullingEnabled(false);
        }
        else {
            this._viewer.setSmartCullingEnabled(this._smartCullingEnabled);
        }
        // Update the camera
        if (!enabled) {
            this._scene.updateBBox();
            this._camera.update();
        }
        var flags = [];
        if (this._scene.clipping.isEnabled()) {
            flags.push("CLIPPING");
        }
        if (this._scene.compressed) {
            flags.push("COMPRESSION");
        }
        if (this._scene.needRenderDoubleSided()) {
            flags.push("DOUBLESIDED");
        }
        this._recompileShader(flags);
    };
    Section.prototype.setRotatable = function (enabled) {
        this._rotate = enabled;
        if (enabled) {
            this._gizmoPlaneIndex = null;
        }
    };
    Section.prototype.isRotatable = function () {
        return this._rotate;
    };
    /*
    Section.prototype.onTouchStart = function(touch, camera) {
        if (!this.enabled || !this._interactive || touch.numCursors !== 1) {
            return false;
        }
        let cursor0 = touch.cursor(0);
        let x = cursor0.x;
        let y = cursor0.y;

        return this._focusPlane(x, y, camera);
    }
    
    Section.prototype.onTouchMove = function(touch) {
        if (!this.enabled || !this._interactive || touch.numCursors !== 1) {
            return false;
        }
        this._isPressed = true;
        let cursor0 = touch.cursor(0);
        return this._updatePlane(cursor0.dx);
    }
    
    Section.prototype.onTouchStop = function() {
        if (!this.enabled || !this._interactive) {
            return;
        }
        this._gizmoPlaneIndex = null;
        this._isPressed = false;
    }

    */
    Section.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseDownListener(this._onMouseDown.bind(this));
            input.addMouseWheelListener(this._onMouseWheel.bind(this));
            input.addMouseMoveListener(this._onMouseMove.bind(this));
            input.addMouseUpListener(this._onMouseUp.bind(this));
        }
        else if (input.name === "touch") {
            //input.addTouchMoveListener(this._onTouchMove.bind(this));
            //input.addTouchStartListener(this._onTouchStart.bind(this));
        }
    };
    Section.prototype._onMouseDown = function (mouse) {
        return this._enabled && this._interactive;
    };
    Section.prototype._onMouseWheel = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // if the one point is pressed, and wheel happens, do not render the line
        if (this._rotate) {
            this._normalDepth.bufferDirty = true;
            this._normalDepth.bufferDirtyTime = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame;
        }
        return false;
    };
    Section.prototype._onMouseMove = function (mouse) {
        if (!this._enabled || !this._interactive) {
            return false;
        }
        this._isPressed = mouse.pressed;
        if (mouse.getEvent().buttonDown !== 0 && mouse.moved && this._rotate) {
            this._normalDepth.bufferDirty = true;
            this._normalDepth.bufferDirtyTime = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame;
            return false;
        }
        if (mouse.moved && this._normalDepth.bufferDirty && (!this._camera.updated && this._normalDepth.bufferDirtyTime < _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame)) {
            this._normalDepth.render(this._renderer, this._camera);
            this._normalDepth.bufferDirty = false;
        }
        var res = false;
        if (mouse.pressed) {
            res = this._updatePlane(mouse.dx);
        }
        else {
            if (this._rotate && !this._normalDepth.bufferDirty) {
                res = this.updateCube(mouse, [0.5, 0.5, 0.5]);
            }
            else {
                res = this._focusPlane(mouse.x, mouse.y);
            }
        }
        this._renderer.renderState.invalidateClip();
        this._viewer.invalidate();
        return res;
    };
    Section.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || !this._interactive) {
            return false;
        }
        if (this._rotate && !this._normalDepth.bufferDirty) {
            var res = this.updateCube(mouse, [0.2, 0.2, 0.2]);
            if (res) {
                this._cutByFaceClicked();
                this._viewer.getEventEmitter().emit("Section-RotateFacePicked");
            }
        }
        this._gizmoPlaneIndex = null;
        this._isPressed = false;
        this._renderer.renderState.invalidateClip();
        this._viewer.invalidate();
        return true;
    };
    Section.prototype._cutByFaceClicked = function () {
        //1. decide which plane to pick
        var dummp1 = vec3.create();
        var dummp2 = vec3.create();
        vec3.transformMat4(dummp1, this._normalDepth.normal, this._rotateMatrix);
        vec3.transformMat4(dummp2, dummp2, this._rotateMatrix);
        vec3.sub(dummp1, dummp1, dummp2);
        var planes = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.planes(this._sectionedBBox); //-x, -y, -z, x, y, z
        for (var i = 0; i < 6; ++i) {
            if (Math.abs(vec3.dot(dummp1, planes[i]) - 1) < 1e-6) {
                this._gizmoPlaneIndex = i;
                break;
            }
        }
        vec3.transformMat4(dummp1, this._normalDepth.position, this._rotateMatrix);
        vec3.scaleAndAdd(dummp1, dummp1, planes[this._gizmoPlaneIndex], 1);
        this._updatePlane(null, dummp1[2]);
    };
    Section.prototype.updateCube = function (mouse, color) {
        var res = this._normalDepth.getNormalDepth(Math.floor(mouse.x * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio), Math.floor(mouse.y * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio));
        if (res) {
            //update rotated cube's 8 points' world position
            this._updateBBox(this._normalDepth.normal);
            this._cube.setColor(color);
            //update buffer of cube
            this.updateGeometry();
            this._scene.radius = this._scene.clipping.getRadius();
            this._camera._updateProjection();
        }
        return res;
    };
    Section.prototype.setSensitivity = function (sensitivity) {
        this._sensitivity = sensitivity;
    };
    Section.prototype._updatePlane = function (dx, dis) {
        if (this._gizmoPlaneIndex !== null) {
            var index = this._gizmoPlaneIndex > 2 ? 1 : 0;
            var axis = this._gizmoPlaneIndex % 3;
            var sign = this._gizmoPlaneIndex > 2 ? -1 : 1;
            var maxRange = void 0, minRange = void 0;
            var bufferRange = 2e-5;
            if (index === 0) {
                minRange = this._bbox[axis] + bufferRange;
                maxRange = this._sectionedBBox[3 + axis] - bufferRange;
            }
            else {
                minRange = this._sectionedBBox[axis] + bufferRange;
                maxRange = this._bbox[3 + axis] - bufferRange;
            }
            if (dis) {
                this._sectionedBBox[index * 3 + axis] = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(dis, minRange, maxRange);
            }
            else {
                var offset = dx * this._sensitivity;
                offset *= sign * (this._scene.bbox[3 + axis] - this._scene.bbox[axis]);
                this._sectionedBBox[index * 3 + axis] = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].clamp(this._sectionedBBox[index * 3 + axis] + offset, minRange, maxRange);
            }
            this._updatePoints();
            this.updateGeometry();
            this._plane.mesh.update(this._vertices, this._indices[this._gizmoPlaneIndex]);
            return true;
        }
        else {
            return false;
        }
    };
    // See which face of the clipping box the cursor is over.
    Section.prototype._focusPlane = function (x, y) {
        if (!this._rotate) {
            var q = void 0, p = void 0, direction = void 0;
            if (this._camera.isPerspective()) {
                q = vec3.create();
                vec3.copy(q, this._camera.eye);
                p = this._camera.unproject(x, y);
            }
            else {
                q = this._camera.unproject(x, y);
                p = vec3.create();
                direction = this._camera.getViewDirection();
                vec3.add(p, q, direction);
            }
            vec3.transformMat4(q, q, this._rotateMatrix);
            vec3.transformMat4(p, p, this._rotateMatrix);
            direction = [];
            direction[0] = p[0] - q[0];
            direction[1] = p[1] - q[1];
            direction[2] = p[2] - q[2];
            var intersect = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].intersect.ray_aabb(q, direction, this._sectionedBBox);
            var planes = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.planes(this._sectionedBBox); //-x, -y, -z, x, y, z
            if (intersect !== null) {
                for (var i = 0; i < 6; ++i) {
                    if (Math.abs(vec3.dot(intersect, planes[i]) + planes[i][3]) < 1e-6) {
                        if (this._gizmoPlaneIndex !== i) {
                            this._gizmoPlaneIndex = i;
                            this._plane.mesh.update(this._vertices, this._indices[i]);
                            this._planeUpdated = true;
                        }
                        return true;
                    }
                }
            }
            else {
                this._gizmoPlaneIndex = null;
            }
        }
        return false;
    };
    Section.prototype._updateBBox = function (normal) {
        var center = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.center(this._scene.bbox);
        var eye = vec3.create();
        vec3.scaleAndAdd(eye, center, normal, this._scene.radius);
        // Create the transformation matrix of world->rotate space
        if (Math.abs(normal[2]) > 0.9999) {
            mat4.lookAt(this._rotateMatrix, eye, center, [0, 1, 0]);
        }
        else {
            mat4.lookAt(this._rotateMatrix, eye, center, [0, 0, 1]);
        }
        mat4.invert(this._invertedRotateMatrix, this._rotateMatrix);
        var aabb = this._scene.clipping.getBBox();
        if (this._scene.compressed) {
            var offset = 1e-4;
            aabb[0] -= offset;
            aabb[1] -= offset;
            aabb[2] -= offset;
            aabb[3] += offset;
            aabb[4] += offset;
            aabb[5] += offset;
        }
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.points2(aabb, this._points);
        // Transform points into rotate space and create new bbox in the rotate space.
        for (var i = 0, len = this._points.length; i < len; i++) {
            vec3.transformMat4(this._points[i], this._points[i], this._rotateMatrix);
        }
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.createFromPoints(this._bbox, this._points);
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.copy(this._sectionedBBox, this._bbox);
        // Convert points back of new aabb to the world space.
        this._updatePoints();
    };
    // update points and transfer them into world space
    Section.prototype._updatePoints = function () {
        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.points2(this._sectionedBBox, this._points);
        vec3.transformMat4(this._points[0], this._points[0], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[1], this._points[1], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[2], this._points[2], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[3], this._points[3], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[4], this._points[4], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[5], this._points[5], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[6], this._points[6], this._invertedRotateMatrix);
        vec3.transformMat4(this._points[7], this._points[7], this._invertedRotateMatrix);
        this._scene.clipping.update(this._points);
    };
    Section.prototype._recompileShader = function (flags) {
        flags.push("WORLDSPACE_NORMAL");
        if (this._normalDepth) {
            this._normalDepth.renderPass.recompileOverridedShader(this._resourceManager, flags);
        }
    };
    return Section;
}(_Tool__WEBPACK_IMPORTED_MODULE_8__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Section);


/***/ }),

/***/ "./08ui/tool/SelectElements.ts":
/*!*************************************!*\
  !*** ./08ui/tool/SelectElements.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _PickQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PickQuery */ "./08ui/tool/PickQuery.ts");
/* harmony import */ var _DepthQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DepthQuery */ "./08ui/tool/DepthQuery.ts");
/* harmony import */ var _03scene_drawables_m3d_gizmo2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo2d */ "./03scene/drawables/m3d_gizmo2d.js");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
/* harmony import */ var _assets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./assets */ "./08ui/tool/assets.ts");
/* harmony import */ var _04renderer_pipeline_RenderQueue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderQueue */ "./04renderer/pipeline/RenderQueue.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var SelectElement = /** @class */ (function (_super) {
    __extends(SelectElement, _super);
    function SelectElement(viewer) {
        var _this = _super.call(this, "SelectElement", true, viewer) || this;
        _this._dashLength = 1;
        _this._lineWidth = 1;
        _this._renderScene = viewer.getRenderScene();
        _this._callback = null;
        _this._multiselect = false;
        _this._elements = {};
        _this._pickQuery = null;
        _this._depthQuery = null;
        _this._regionSelectEnabled = false;
        _this._interactive = false;
        _this._closeup = true;
        _this._bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.create();
        _this._renderScene = viewer.getRenderScene();
        _this._renderTarget = _this._getRenderTarget({ depthTest: false });
        _this._material = _this._scene.materialManager.createMaterialAdhoc("select-elements-other");
        _this._smartCullingEnabled = false;
        _this._startX = -1;
        _this._startY = -1;
        _this._endX = -1;
        _this._endY = -1;
        _this._vertices = new Float32Array(80);
        _this._indices = new Uint8Array(24);
        for (var i = 0; i < 4; ++i) {
            _this._indices[0 + i * 6] = 0 + i * 4;
            _this._indices[1 + i * 6] = 1 + i * 4;
            _this._indices[2 + i * 6] = 2 + i * 4;
            _this._indices[3 + i * 6] = 2 + i * 4;
            _this._indices[4 + i * 6] = 3 + i * 4;
            _this._indices[5 + i * 6] = 0 + i * 4;
        }
        _this._clippingEnabled = _this._scene.clipping.isEnabled();
        var mesh = _this._resourceManager.getMesh("region-select");
        mesh.createQuad();
        _this._drawable = new _03scene_drawables_m3d_gizmo2d__WEBPACK_IMPORTED_MODULE_4__["default"]("region-select", mesh, _this._resourceManager);
        _this._drawable.setColor([0.969, 0.398, 0.238]);
        var texture = _this._resourceManager.getTexture("regionSelect");
        texture.createFromFile(_assets__WEBPACK_IMPORTED_MODULE_6__["DASH_LINE_TEXTURE_IMAGE"], gl.RGB, gl.LINEAR, gl.REPEAT, function (texture) {
            _this._drawable.setTexture(texture);
            _this._dashLength = texture.width;
        });
        _this._resetVertices();
        return _this;
    }
    SelectElement.prototype.destroy = function () {
        if (this._pickQuery) {
            this._pickQuery.destroy();
            this._pickQuery = null;
            delete this._pickQuery;
        }
        if (this._depthQuery) {
            this._depthQuery.destroy();
            this._depthQuery = null;
            delete this._depthQuery;
        }
        this._bbox = null;
        delete this._bbox;
        this._elements = null;
        delete this._elements;
        this._vertices = null;
        delete this._vertices;
        this._indices = null;
        delete this._indices;
        this._renderScene = null;
        delete this._renderScene;
        this._material.destroy();
        this._material = null;
        delete this._material;
        _super.prototype.destroy.call(this);
    };
    SelectElement.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    SelectElement.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    /**
     * Change the color of selection rectangluar gizmo color and transparency.
     */
    SelectElement.prototype.setSelectionRectangleColor = function (color) {
        this._drawable.setColor(color);
        this._drawable.setTransparent(color[3]);
    };
    SelectElement.prototype.setEnabled = function (enabled) {
        var mouse = this._viewer.getMouse();
        if (!mouse && enabled) {
            console.log("SelectElement tools requires mouse.");
            return;
        }
        _super.prototype.setEnabled.call(this, enabled);
        if (enabled) {
            if (this._pickQuery === null) {
                this._pickQuery = new _PickQuery__WEBPACK_IMPORTED_MODULE_2__["default"](this._scene, this._resourceManager);
            }
            if (this._depthQuery === null) {
                this._depthQuery = new _DepthQuery__WEBPACK_IMPORTED_MODULE_3__["default"](this._scene, this._resourceManager);
            }
        }
        //this._renderScene.setElementsEnabled(enabled);
        //this._renderScene.adjustOverrideStatus();
    };
    SelectElement.prototype.render = function () {
        if (!this._enabled || !this._interactive) {
            return;
        }
        if (Math.abs(this._endX - this._startX) < 2 ||
            Math.abs(this._endY - this._startY) < 2) {
            return;
        }
        this._renderer.drawDrawable(this._renderTarget, this._drawable, this._camera, null, null, null, false);
    };
    SelectElement.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseDownListener(this._onMouseDown.bind(this));
            input.addMouseMoveListener(this._onMouseMove.bind(this));
            input.addMouseUpListener(this._onMouseUp.bind(this));
        }
        else if (input.name === "touch") {
            //input.addTouchStartListener(this._onTouchStop.bind(this));
        }
        else if (input.name == "keyboard") {
            input.addKeyDownListener(this._onKeyDown.bind(this));
            input.addKeyUpListener(this._onKeyUp.bind(this));
        }
    };
    SelectElement.prototype.setRegionSelectEnabled = function (enabled) {
        if (this._regionSelectEnabled != enabled) {
            this._regionSelectEnabled = enabled;
            if (enabled) {
                this._smartCullingEnabled = this._viewer.isSmartCullingEnabled();
                this._viewer.setSmartCullingEnabled(false);
            }
            else {
                this._viewer.setSmartCullingEnabled(this._smartCullingEnabled);
            }
            this._interactive = enabled;
            this._viewer.invalidate();
        }
    };
    // Move camera to a close up view after selected.
    SelectElement.prototype.setCloseUpEnabled = function (enabled) {
        this._closeup = enabled;
    };
    SelectElement.prototype._onKeyDown = function (keyboard) {
        if (keyboard.key == 17) {
            this.setMultiselectEnabled(true);
        }
        return false;
    };
    SelectElement.prototype._onKeyUp = function (keyboard) {
        if (keyboard.key == 17) {
            this.setMultiselectEnabled(false);
        }
        return false;
    };
    SelectElement.prototype._onMouseDown = function (mouse) {
        if (!this._enabled || mouse.button !== mouse.LEFT_BUTTON) {
            return false;
        }
        document.activeElement.blur();
        this._startX = mouse.x;
        this._startY = mouse.y;
        this._endX = this._startX;
        this._endY = this._startY;
        // Update the shader if scene's clipping is enabled recently.
        if (this._scene.clipping.isEnabled() && !this._clippingEnabled) {
            this._clippingEnabled = true;
            var flags = ["VISIBILITY", "CLIPPING"];
            if (this._scene.compressed) {
                flags.push("COMPRESSION");
            }
            if (this._scene.needRenderDoubleSided()) {
                flags.push("DOUBLESIDED");
            }
            this.recompileShader(flags);
        }
        else if (!this._scene.clipping.isEnabled() && !this._clippingEnabled) {
            this._clippingEnabled = false;
            var flags = ["VISIBILITY"];
            if (this._scene.compressed) {
                flags.push("COMPRESSION");
            }
            if (this._scene.needRenderDoubleSided()) {
                flags.push("DOUBLESIDED");
            }
            this.recompileShader(flags);
        }
        if (this._regionSelectEnabled) {
            this._updateVertices();
        }
        return true;
    };
    SelectElement.prototype._onMouseMove = function (mouse) {
        if (!this._enabled || mouse.button !== mouse.LEFT_BUTTON || !mouse.pressed || !this._regionSelectEnabled) {
            return false;
        }
        if (this._regionSelectEnabled) {
            this._endX += mouse.dx;
            this._endY += mouse.dy;
            this._updateVertices();
            return true;
        }
        return false;
    };
    SelectElement.prototype._onMouseUp = function (mouse) {
        if (!this._enabled || mouse.button !== mouse.LEFT_BUTTON) {
            return false;
        }
        this._endX = mouse.x;
        this._endY = mouse.y;
        if (Math.abs(this._endX - this._startX) < 1 ||
            Math.abs(this._endY - this._startY) < 1) {
            this._select();
        }
        else if (this._regionSelectEnabled) {
            if (this._startX > this._endX) {
                var temp = this._startX;
                this._startX = this._endX;
                this._endX = temp;
            }
            if (this._startY > this._endY) {
                var temp = this._startY;
                this._startY = this._endY;
                this._endY = temp;
            }
            this._selectRegion();
            this._resetVertices();
            this._viewer.getEventEmitter().emit("SelectElemets-Disabled");
        }
        return true;
    };
    SelectElement.prototype.setMultiselectEnabled = function (enabled) {
        this._multiselect = enabled;
    };
    SelectElement.prototype.recompileShader = function (flags) {
        if (!this._enabled) {
            return;
        }
        if (this._pickQuery) {
            this._pickQuery.recompileShader(this._resourceManager, flags);
        }
        if (this._depthQuery) {
            this._depthQuery.recompileShader(this._resourceManager, flags);
        }
    };
    /**
     * Pick the element at the specified window coordinate.
     */
    SelectElement.prototype._select = function () {
        var _this = this;
        var x = this._endX;
        var y = this._endY;
        // Find the drawable that intersects the pick ray using object ID
        // rasterization.
        var pickedNodes = this._pickQuery.pickNodesInsideRegion(x, y, x, y, this._renderer, this._camera, this._getPickables());
        var pickedElement = null;
        if (pickedNodes && pickedNodes.length > 0) {
            // Trace the intersected element drawable with element type.
            pickedElement = pickedNodes[0].getElement();
            //modelo3d.debug("element " + picked.name + " is picked");
        }
        if (pickedElement) {
            if (this._multiselect) {
                // Remove the element from the selection set if it has been selected.
                if (!this._elements[pickedElement.name]) {
                    this._elements[pickedElement.name] = pickedElement;
                }
                else {
                    delete this._elements[pickedElement.name];
                }
            }
            else {
                this._elements = {};
                this._elements[pickedElement.name] = pickedElement;
                if (this._closeup) {
                    this._camera.lookTo(_00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.center(pickedElement.bbox), _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.length(pickedElement.bbox) / 2);
                }
            }
            var nodes_1 = [];
            for (var name_1 in this._elements) {
                var elementNodes = this._elements[name_1].getNodes();
                elementNodes && elementNodes.forEach(function (node) {
                    nodes_1.push(node);
                });
            }
            this._viewer.invalidate();
        }
        else {
            if (!this._multiselect) {
                this._elements = {};
                this._viewer.invalidate();
            }
        }
        var res = [];
        this._scene.models.forEach(function (model) {
            var paths = model.graph.getElementPaths(_this._elements);
            paths.forEach(function (path) {
                res.push(path.modelId + "+" + path.docId + "/" + path.element);
            });
        });
        this._viewer.getEventEmitter().emit("onElementSelected", res);
    };
    SelectElement.prototype._getPickables = function () {
        if (!this._pickables) {
            var renderQueue_1 = new _04renderer_pipeline_RenderQueue__WEBPACK_IMPORTED_MODULE_7__["default"]("pickQueue", {
                line: false
            });
            this._scene.models.forEach(function (model) {
                model.drawables.forEach(function (drawable) {
                    renderQueue_1.addDrawable(drawable);
                });
            });
            this._pickables = renderQueue_1.drawables;
        }
        return this._pickables;
    };
    SelectElement.prototype._selectRegion = function () {
        var _this = this;
        if (this._scene.models.length == 0) {
            return;
        }
        var pickedElements = {};
        var nodes = this._pickQuery.pickNodesInsideRegion(this._startX, this._startY, this._endX, this._endY, this._renderer, this._camera, this._getPickables());
        if (nodes !== null && nodes.length > 0) {
            nodes.forEach(function (node) {
                // Trace the intersected element drawable with element type.
                var element = node.getElement();
                if (!pickedElements[element.name]) {
                    pickedElements[element.name] = element;
                }
            });
            var bbox = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.create();
            for (var name_2 in pickedElements) {
                nodes = nodes.concat(pickedElements[name_2].getNodes());
                _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.union(bbox, bbox, pickedElements[name_2].bbox);
            }
            // Move the camera to the center of selected elements.
            if (this._closeup) {
                this._camera.lookTo(_00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.center(bbox), _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.length(bbox) / 2);
            }
            this._elements = pickedElements;
        }
        else {
            this._elements = {};
        }
        this._viewer.invalidate();
        var res = [];
        this._scene.models.forEach(function (model) {
            var paths = model.graph.getElementPathStrings(_this._elements);
            paths.forEach(function (path) {
                res.push(path);
            });
        });
        this._viewer.getEventEmitter().emit("onElementSelected", res);
    };
    /**
     * Pick elements by specifying their names.
     * @param elementNames - The names/ids of elements
     * @param changeCamera - Change the camera to a close up view of elements if true.
     */
    SelectElement.prototype.pick = function (elementNames, changeCamera) {
        var _this = this;
        if (!this._enabled) {
            return;
        }
        // If pick nothing, we remove the previous selection.
        if (!elementNames || elementNames.length < 1) {
            this._elements = {};
            this._renderScene.setOverridedRenderingAppearance(null);
            this._renderScene.renderNodes(null);
            return;
        }
        var nodes = [];
        for (var i = 0, len = elementNames.length; i < len; i++) {
            // Collect focused nodes.
            var elementName = elementNames[i];
            for (var j = 0, len2 = this._scene.models.length; j < len2; j++) {
                var model = this._scene.models[j];
                var element = model.graph.elements[elementName];
                if (element) {
                    nodes = nodes.concat(model.graph.elements[elementName].getNodes());
                    this._elements[elementName] = element;
                    break;
                }
            }
            // Update the internal focused elements
        }
        this._renderScene.setOverridedRenderingAppearance(this._material);
        // FIXME: change the color of unselected elements here.
        this._material.setDiffuse([1, 1, 1]);
        this._material.setTransparent(0.4);
        this._renderScene.renderNodes(nodes);
        // Find the bbox of selection.
        if (changeCamera) {
            this._bbox = new _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.createFromArray([Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity]);
            elementNames.forEach(function (elementName) {
                for (var j = 0, len2 = _this._scene.models.length; j < len2; j++) {
                    var model = _this._scene.models[j];
                    var element = model.graph.elements[elementName];
                    if (element) {
                        _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.union(_this._bbox, _this._bbox, element.bbox);
                        break;
                    }
                }
            });
            if (this._closeup) {
                this._camera.lookTo(_00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.center(this._bbox), _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_1__["default"].aabb.length(this._bbox) / 2);
            }
        }
    };
    SelectElement.prototype._updateVertices = function () {
        var sx = this._startX;
        var ex = this._endX;
        var sy = this._startY;
        var ey = this._endY;
        if (this._startX > this._endX) {
            sx = this._endX;
            ex = this._startX;
        }
        if (this._startY > this._endY) {
            sy = this._endY;
            ey = this._startY;
        }
        sx = Math.floor(sx * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        sy = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - sy * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        ex = Math.floor(ex * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        ey = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - ey * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var w = ex - sx;
        var h = sy - ey;
        var t = Math.floor(this._lineWidth * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        this._addQuad(sx, sy, sx + t, ey, 0, 0, h, h, 0);
        this._addQuad(sx, sy, ex, sy + t, 0, w, w, 0, 20);
        this._addQuad(ex - t, sy, ex, ey, 0, 0, h, h, 40);
        this._addQuad(sx, ey - t, ex, ey, 0, w, w, 0, 60);
        this._drawable.mesh.update(this._vertices, this._indices, gl.UNSIGNED_BYTE);
    };
    SelectElement.prototype._addQuad = function (sx, sy, ex, ey, t0, t1, t2, t3, offset) {
        sx = sx / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
        ex = ex / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
        sy = sy / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 2.0 - 1.0;
        ey = ey / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 2.0 - 1.0;
        this._vertices[0 + offset] = sx;
        this._vertices[1 + offset] = sy;
        this._vertices[2 + offset] = 0.0;
        this._vertices[3 + offset] = t0 / this._dashLength;
        this._vertices[4 + offset] = 0.5;
        this._vertices[5 + offset] = ex;
        this._vertices[6 + offset] = sy;
        this._vertices[7 + offset] = 0.0;
        this._vertices[8 + offset] = t1 / this._dashLength;
        this._vertices[9 + offset] = 0.5;
        this._vertices[10 + offset] = ex;
        this._vertices[11 + offset] = ey;
        this._vertices[12 + offset] = 0.0;
        this._vertices[13 + offset] = t2 / this._dashLength;
        this._vertices[14 + offset] = 0.5;
        this._vertices[15 + offset] = sx;
        this._vertices[16 + offset] = ey;
        this._vertices[17 + offset] = 0.0;
        this._vertices[18 + offset] = t3 / this._dashLength;
        this._vertices[19 + offset] = 0.5;
    };
    SelectElement.prototype.setCallback = function (cbk) {
        this._callback = cbk;
    };
    SelectElement.prototype._resetVertices = function () {
        for (var i = 0; i < 80; ++i) {
            this._vertices[i] = -1000000;
        }
        this._drawable.mesh.update(this._vertices, this._indices, gl.UNSIGNED_BYTE);
    };
    return SelectElement;
}(_Tool__WEBPACK_IMPORTED_MODULE_5__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (SelectElement);


/***/ }),

/***/ "./08ui/tool/SelectModel.ts":
/*!**********************************!*\
  !*** ./08ui/tool/SelectModel.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _PickQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PickQuery */ "./08ui/tool/PickQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
// SelectModel.ts
// Select model in a scene with multiple models
// The model selection will snapping to either corner or edge of the model
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var mouse_move_coord = [0, 0];
var mouse_move_position = [0, 0, 0];
var SelectModel = /** @class */ (function (_super) {
    __extends(SelectModel, _super);
    function SelectModel(viewer) {
        var _this = _super.call(this, "SelectModel", false, viewer) || this;
        _this._snapping = null;
        _this._pickQuery = null;
        _this._snapped = -1;
        _this.currentModel = -1; // Current picked model
        _this.currentPosition = new Array(3); // Current picked position.
        return _this;
        //this._textureViewer = new TextureViewer(this._resourceManager);
        //this._textureViewer.setEnabled(true);
    }
    SelectModel.prototype.destroy = function () {
        if (this._snapping) {
            this._snapping.destroy();
            this._snapping = null;
            delete this._snapping;
        }
        if (this._pickQuery) {
            this._pickQuery.destroy();
            this._pickQuery = null;
            delete this._pickQuery;
        }
        // FIXME: debuggin only
        //this._textureViewer.destroy();
        //this._textureViewer = null;
        //delete this._textureViewer;
        this.currentModel = null;
        delete this.currentModel;
        this.currentPosition = null;
        delete this.currentPosition;
    };
    SelectModel.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseMoveListener(this._onMouseMove.bind(this));
            input.addMouseUpListener(this._onMouseUp.bind(this));
        }
    };
    SelectModel.prototype.doesSupportMobile = function (isMobile) {
        return !isMobile;
    };
    SelectModel.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    SelectModel.prototype._udpateSnapping = function (sceneCamera) {
        this._snapping.update(this._renderer, this._scene, this._camera);
    };
    SelectModel.prototype.render = function () {
        if (this._enabled) {
            //this._textureViewer.setTexture(this._snapping._rtEdge.getColorBuffer());
            //this._textureViewer.render(this._renderer);
            this._snapping.render(this._renderer, this._camera);
        }
    };
    SelectModel.prototype.resize = function (width, height) {
        this._snapping.resize(width, height);
    };
    SelectModel.prototype.setEnabled = function (enabled) {
        _super.prototype.setEnabled.call(this, enabled);
        if (enabled) {
            if (this._snapping === null) {
                this._snapping = new _Snapping__WEBPACK_IMPORTED_MODULE_0__["default"](this._scene, this._camera, this._resourceManager);
                this._snapping.setRenderingEnabled(true);
                this._snapping.setSnappingRadius(8);
            }
            if (this._pickQuery === null) {
                this._pickQuery = new _PickQuery__WEBPACK_IMPORTED_MODULE_1__["default"](this._scene, this._resourceManager);
            }
            this._camera.addUpdateStopListener(this._udpateSnapping.bind(this));
        }
        else {
            this._camera.removeUpdateStopListener(this._udpateSnapping.bind(this));
        }
        this._viewer.setSmartCullingEnabled(!enabled);
    };
    SelectModel.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // Start snapping when the camera stops.
        if (!mouse.pressed && !this._camera.updated) {
            mouse_move_coord[0] = mouse.x;
            mouse_move_coord[1] = mouse.y;
            this._snapped = this._snapping.snap(mouse_move_coord, mouse_move_position);
            if (this._snapped >= 0) {
                this.currentPosition[0] = mouse_move_position[0];
                this.currentPosition[1] = mouse_move_position[1];
                this.currentPosition[2] = mouse_move_position[2];
            }
            this._viewer.getEventEmitter().emit("SelectModel-SnappedTo", mouse_move_coord);
        }
        return false;
    };
    SelectModel.prototype._onMouseUp = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        // If mouse has not moved since click down, we should compute the snapping point here.
        if (!mouse.moved) {
            this.currentModel = -1;
            mouse_move_coord[0] = mouse.x;
            mouse_move_coord[1] = mouse.y;
            if (this._snapped < 0) {
                this._snapped = this._snapping.snap(mouse_move_coord, mouse_move_position);
            }
            if (this._snapped >= 0) {
                this.currentModel = this._pickQuery.pickModel(mouse_move_coord[0], mouse_move_coord[1], this._renderer, this._camera);
                this._viewer.getEventEmitter().emit("SelectModel-Selected", this.currentModel, mouse_move_position);
            }
        }
        return false;
    };
    return SelectModel;
}(_Tool__WEBPACK_IMPORTED_MODULE_2__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (SelectModel);


/***/ }),

/***/ "./08ui/tool/Snapping.ts":
/*!*******************************!*\
  !*** ./08ui/tool/Snapping.ts ***!
  \*******************************/
/*! exports provided: SnappingMode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SnappingMode", function() { return SnappingMode; });
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo.js */ "./03scene/drawables/m3d_gizmo.js");
/* harmony import */ var _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/materials/m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _04renderer_pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _04renderer_pipeline_RenderPassEdgeMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderPassEdgeMap */ "./04renderer/pipeline/RenderPassEdgeMap.ts");
/* harmony import */ var _SpiralOrder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SpiralOrder */ "./08ui/tool/SpiralOrder.ts");
/**
 * Snap to nearest edge, vertex or edge midpoint.
 *
 */








var SnappingMode;
(function (SnappingMode) {
    SnappingMode[SnappingMode["NONE"] = -1] = "NONE";
    SnappingMode[SnappingMode["VERTEX"] = 0] = "VERTEX";
    SnappingMode[SnappingMode["EDGE"] = 1] = "EDGE";
    SnappingMode[SnappingMode["EDGEMIDPOINT"] = 2] = "EDGEMIDPOINT";
})(SnappingMode || (SnappingMode = {}));
;
var edge_temp_vertex = [0, 0, 0];
var Snapping = /** @class */ (function () {
    function Snapping(scene, camera, resourceManager) {
        if (!gl.isWebGL2) {
            console.warn("Snapping requires a WebGL 2.0 context");
            return;
        }
        this._rendering = false;
        this._camera = camera;
        this._edgeIndex = -1;
        this._radius = 5;
        this._edgePass = new _04renderer_pipeline_RenderPassEdgeMap__WEBPACK_IMPORTED_MODULE_6__["default"](resourceManager);
        this._notEdgePass = new _04renderer_pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_5__["default"](resourceManager, false, { line: false });
        var edgeMesh = resourceManager.getMesh("edge");
        edgeMesh.createLine();
        this._edge = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__["default"]("edge", edgeMesh, resourceManager);
        this._edge.setColor([1.0, 177.0 / 255.0, 0.0]);
        var dotMesh = resourceManager.getMesh("snapping-dot");
        if (!dotMesh.ready) {
            dotMesh.createSphere(16, 32);
        }
        this._dot = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__["default"]("dot", dotMesh, resourceManager);
        this._dot.setColor([1.0, 177.0 / 255.0, 0.0]);
        this._dot.transform.matrix[0] = 0.1;
        this._dot.transform.matrix[5] = 0.1;
        this._dot.transform.matrix[10] = 0.1;
        var shader0 = resourceManager.getShader("mark");
        if (!shader0.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["mark"];
            shader0.createFromShaderSource(shaderSource);
        }
        this._edgePass.setOverridedShader(shader0);
        this._edgePass.setOverridedMaterial(new _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_3__["default"]("edgemap"));
        this._notEdgePass.setCullFace(gl.CCW);
        // FIXME: these following two rendertargets share the framebuffers with
        // other effects.  Note these buffers (edge map) should preserve for
        // snapping. It is not a good working solution but it works now.
        this._rtEdge = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("rtEdge", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            depthTest: true,
            colorFormat: gl.RGBA8,
            colorFilter: gl.NEAREST,
            depthBuffer: 0,
            colorBuffer: 0,
            clearColor: [1, 1, 1, 1]
        });
        this._rtNotEdge = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("rtNotEdge", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            depthTest: true,
            colorFormat: gl.RGBA8,
            colorFilter: gl.NEAREST,
            depthBuffer: 0,
            colorBuffer: 0,
            colorMask: [0, 0, 0, 0],
            clearColor: [1, 1, 1, 1]
        });
        this._rtDefault = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("default", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            depthFunc: gl.LEQUAL
        });
        if (!this._edgePass.queue.isValid()) {
            for (var i = 0, len1 = scene.models.length; i < len1; ++i) {
                var m = scene.models[i].drawables;
                for (var j = 0, len = m.length; j < len; j++) {
                    this._edgePass.queue.addDrawable(m[j]);
                }
            }
        }
        if (!this._notEdgePass.queue.isValid()) {
            for (var i = 0, len1 = scene.models.length; i < len1; ++i) {
                var m = scene.models[i].drawables;
                for (var j = 0, len = m.length; j < len; j++) {
                    this._notEdgePass.queue.addDrawable(m[j]);
                }
            }
        }
        this._edgeBuffer = new Float32Array(6);
        this.resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
    }
    Snapping.prototype.destroy = function () {
        this._edge.mesh.destroy();
        this._edge.destroy();
        this._edge = null;
        delete this._edge;
        this._dot.destroy();
        this._dot = null;
        delete this._dot;
        this._edgeBuffer = null;
        delete this._edgeBuffer;
        this._edgesBuffer = null;
        delete this._edgesBuffer;
        this._rtEdge.destroy();
        this._rtEdge = null;
        delete this._rtEdge;
        this._rtNotEdge.destroy();
        this._rtNotEdge = null;
        delete this._rtNotEdge;
        this._rtDefault.destroy();
        this._rtDefault = null;
        delete this._rtDefault;
        this._edgePass.destroy();
        this._edgePass = null;
        delete this._edgePass;
        this._notEdgePass.destroy();
        this._notEdgePass = null;
        delete this._notEdgePass;
    };
    Snapping.prototype.recompileShader = function (resourceManager, flags) {
        this._edgePass.recompileOverridedShader(resourceManager, flags);
    };
    Snapping.prototype.setSnappingRadius = function (radius) {
        this._radius = Math.max(Math.min(radius, 11), 0);
    };
    Snapping.prototype.setRenderingEnabled = function (enabled) {
        this._rendering = enabled;
    };
    Snapping.prototype.resize = function (width, height) {
        this._rtEdge.resize(width, height);
        // No need to resize rtNotEdge as they share the same framebuffer.
        this._edgesBuffer = new Uint8Array(width * height * 4);
    };
    Snapping.prototype.render = function (renderer, camera) {
        if (this._rendering) {
            // TODO: rtDefault has not been linked to renderScene's current renderTarget.
            //renderer.drawGizmo(this._rtDefault, this._edge, camera);
        }
    };
    // The coord is the position in windows coordinate usually the current mouse cursor position.
    // It will be snapped to nearest primitive. The position is the snapping positions's 3D coordinate.
    // @return {number} - -1 snap to nothing,  snap to VERTEX, EDGE or EDGEMIDPOINT
    Snapping.prototype.snap = function (coord, position) {
        var w = this._rtEdge.getWidth();
        var h = this._rtEdge.getHeight();
        // Convert to GL window coordinate.
        var xCenter = Math.floor(coord[0] * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var yCenter = Math.floor(h - 1 - coord[1] * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        // If it is snapped to something.
        var ret = false;
        var oldEdgeIndex = this._edgeIndex;
        this._edgeIndex = -1;
        var num = this._radius * this._radius - 1;
        for (var idx = 0; idx < num; idx++) {
            // Get the vertex sourding id index and check if it's edge
            var i = xCenter + _SpiralOrder__WEBPACK_IMPORTED_MODULE_7__["SPIRAL"][idx][0];
            var j = yCenter + _SpiralOrder__WEBPACK_IMPORTED_MODULE_7__["SPIRAL"][idx][1];
            // If out of canvas, skip it
            if ((i < 1 || i > w - 1) || (j < 1 || j > h - 1)) {
                continue;
            }
            var index = 4 * (i + j * w);
            var a = this._edgesBuffer[index + 0];
            var b = this._edgesBuffer[index + 1];
            var c_1 = this._edgesBuffer[index + 2];
            var d = this._edgesBuffer[index + 3];
            if (!(a === 255 && b === 255 && c_1 === 255 && d === 255)) {
                var e = ((d << 24) | (c_1 << 16) | (b << 8) | a);
                this._edgeIndex = (e & ~0x1); // round to the first vertex ID of the edge.
                ret = true;
                coord[0] = Math.floor(i / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
                coord[1] = Math.floor((h - 1 - j) / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
                break;
            }
        }
        // Update the edge
        if (this._edgeIndex !== oldEdgeIndex) {
            if (ret) {
                var base = 0;
                for (var i = 0, len = this._edgePass.queue.drawables.length; i < len; i++) {
                    var drawable = this._edgePass.queue.drawables[i];
                    var mesh = drawable.mesh;
                    var vertices = mesh.length;
                    if (this._edgeIndex >= base && this._edgeIndex < (base + vertices)) {
                        // The edgeIndex is in fact the first vertex ID of this edge.
                        mesh.getVBSubData((this._edgeIndex - base) * 12, this._edgeBuffer);
                        // The edge needs to be transformed if the drawable has transformed.
                        if (!drawable.transform.identity) {
                            var m = drawable.transform.matrix;
                            vec3.transformMat4(this._edgeBuffer, this._edgeBuffer, m);
                            edge_temp_vertex[0] = this._edgeBuffer[3];
                            edge_temp_vertex[1] = this._edgeBuffer[4];
                            edge_temp_vertex[2] = this._edgeBuffer[5];
                            vec3.transformMat4(edge_temp_vertex, edge_temp_vertex, m);
                            this._edgeBuffer[3] = edge_temp_vertex[0];
                            this._edgeBuffer[4] = edge_temp_vertex[1];
                            this._edgeBuffer[5] = edge_temp_vertex[2];
                        }
                        if (this._rendering) {
                            this._edge.mesh.update(this._edgeBuffer, new Uint16Array([0, 1]));
                        }
                        break;
                    }
                    base += vertices;
                }
            }
        }
        if (ret) {
            position = position || [0, 0, 0];
            if (this._snapToMidPoint(coord, position)) {
                return SnappingMode.EDGEMIDPOINT;
            }
            else if (this._snapToVertex(coord, position)) {
                return SnappingMode.VERTEX;
            }
            else {
                this._snapToEdge(coord, position);
                return SnappingMode.EDGE;
            }
        }
        return -1;
    };
    Snapping.prototype.update = function (renderer, scene, camera) {
        renderer.invalidate();
        renderer.clear(this._rtEdge, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this._notEdgePass.render(this._rtNotEdge, renderer, camera);
        this._edgePass.render(this._rtEdge, renderer, camera);
        gl.readPixels(0, 0, this._rtEdge.getWidth(), this._rtEdge.getHeight(), gl.RGBA, gl.UNSIGNED_BYTE, this._edgesBuffer);
    };
    // position saves the snapping coordinate in world space.
    Snapping.prototype._snapToEdge = function (coord, position) {
        // https://www.jianshu.com/p/e80a6a461a49
        var a1 = [this._edgeBuffer[0], this._edgeBuffer[1], this._edgeBuffer[2]];
        var b1 = [this._edgeBuffer[3], this._edgeBuffer[4], this._edgeBuffer[5]];
        var a2 = this._camera.eye;
        var b2 = this._camera.unproject(coord[0], coord[1]);
        var d1 = vec3.create();
        var d2 = vec3.create();
        var tmp1 = vec3.create();
        var tmp2 = vec3.create();
        vec3.sub(d1, b1, a1);
        vec3.sub(d2, b2, a2);
        vec3.sub(tmp1, a2, a1);
        vec3.cross(tmp1, tmp1, d2);
        vec3.cross(tmp2, d1, d2);
        var t1 = vec3.dot(tmp1, tmp2) / vec3.squaredLength(tmp2);
        vec3.lerp(position, a1, b1, t1);
        return true;
    };
    Snapping.prototype._snapToMidPoint = function (coord, position) {
        var p = this._camera.project([
            (this._edgeBuffer[0] + this._edgeBuffer[3]) * 0.5,
            (this._edgeBuffer[1] + this._edgeBuffer[4]) * 0.5,
            (this._edgeBuffer[2] + this._edgeBuffer[5]) * 0.5
        ]);
        var dx = (p[0] - coord[0]);
        var dy = (p[1] - coord[1]);
        var d = dx * dx + dy * dy;
        var r2 = this._radius * this._radius;
        if (d < r2) {
            coord[0] = p[0];
            coord[1] = p[1];
            position[0] = (this._edgeBuffer[0] + this._edgeBuffer[3]) * 0.5;
            position[1] = (this._edgeBuffer[1] + this._edgeBuffer[4]) * 0.5;
            position[2] = (this._edgeBuffer[2] + this._edgeBuffer[5]) * 0.5;
            if (this._rendering) {
                this._dot.transform.matrix[12] = position[0];
                this._dot.transform.matrix[13] = position[1];
                this._dot.transform.matrix[14] = position[2];
            }
            return true;
        }
        return false;
    };
    Snapping.prototype._snapToVertex = function (coord, position) {
        var p1 = this._camera.project(this._edgeBuffer);
        var p2 = this._camera.project([this._edgeBuffer[3], this._edgeBuffer[4], this._edgeBuffer[5]]);
        var dx1 = (p1[0] - coord[0]);
        var dy1 = (p1[1] - coord[1]);
        var dx2 = (p2[0] - coord[0]);
        var dy2 = (p2[1] - coord[1]);
        var d1 = dx1 * dx1 + dy1 * dy1;
        var d2 = dx2 * dx2 + dy2 * dy2;
        var r2 = this._radius * this._radius;
        if (d1 < r2 && d1 < d2) {
            coord[0] = p1[0];
            coord[1] = p1[1];
            position[0] = this._edgeBuffer[0];
            position[1] = this._edgeBuffer[1];
            position[2] = this._edgeBuffer[2];
            if (this._rendering) {
                this._dot.transform.matrix[12] = position[0];
                this._dot.transform.matrix[13] = position[1];
                this._dot.transform.matrix[14] = position[2];
            }
            return true;
        }
        else if (d2 < r2 && d2 < d1) {
            coord[0] = p2[0];
            coord[1] = p2[1];
            position[0] = this._edgeBuffer[3];
            position[1] = this._edgeBuffer[4];
            position[2] = this._edgeBuffer[5];
            if (this._rendering) {
                this._dot.transform.matrix[12] = position[0];
                this._dot.transform.matrix[13] = position[1];
                this._dot.transform.matrix[14] = position[2];
            }
            return true;
        }
        return false;
    };
    return Snapping;
}());
/* harmony default export */ __webpack_exports__["default"] = (Snapping);


/***/ }),

/***/ "./08ui/tool/SnappingApprox.ts":
/*!*************************************!*\
  !*** ./08ui/tool/SnappingApprox.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_shader_library.js */ "./02resource/m3d_shader_library.js");
/* harmony import */ var _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/materials/m3d_material.js */ "./03scene/materials/m3d_material.js");
/* harmony import */ var _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo.js */ "./03scene/drawables/m3d_gizmo.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _04renderer_pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderPass */ "./04renderer/pipeline/RenderPass.ts");
/* harmony import */ var _SpiralOrder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SpiralOrder */ "./08ui/tool/SpiralOrder.ts");
/* harmony import */ var _Snapping__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Snapping */ "./08ui/tool/Snapping.ts");
/**
 * An apprxomiate way to snap to nearest edge.
 *
 */








var detect_edge_n0 = [0, 0, 0];
var detect_edge_n1 = [0, 0, 0];
var detect_edge_p0 = [0, 0, 0];
var detect_edge_p1 = [0, 0, 0];
var detect_edge_d = [0, 0, 0];
var SnappingApprox = /** @class */ (function () {
    function SnappingApprox(scene, camera, resourceManager) {
        this._normalDepthPass = new _04renderer_pipeline_RenderPass__WEBPACK_IMPORTED_MODULE_5__["default"](resourceManager, false, { line: false });
        this._rendering = false;
        this._camera = camera;
        this._rtNormalDepth = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"](name + "_depth", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            colorFormat: gl.RGBA32F,
            colorFilter: gl.NEAREST,
            colorBuffer: 0,
            depthBuffer: 0,
            clearColor: [0, 0, 0, 0]
        });
        this._rtDefault = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_4__["default"]("default", resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, {
            depthFunc: gl.LEQUAL
        });
        var shader = resourceManager.getShader("normaldepth", ["WORLDSPACE_NORMAL"]);
        if (!shader.ready) {
            var shaderSource = _02resource_m3d_shader_library_js__WEBPACK_IMPORTED_MODULE_1__["default"]["normaldepth"];
            shader.createFromShaderSource(shaderSource, ["WORLDSPACE_NORMAL"]);
        }
        this._normalDepthPass.setOverridedShader(shader);
        this._normalDepthPass.setOverridedMaterial(new _03scene_materials_m3d_material_js__WEBPACK_IMPORTED_MODULE_2__["default"]("ruler-position-depth"));
        this._radius = 10;
        this.resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        var dotMesh = resourceManager.getMesh("snapping-dot");
        if (!dotMesh.ready) {
            dotMesh.createSphere(16, 32);
        }
        this._dot = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_3__["default"]("dot", dotMesh, resourceManager);
        this._dot.setColor([1.0, 177.0 / 255.0, 0.0]);
        this._dot.transform.matrix[0] = 0.1;
        this._dot.transform.matrix[5] = 0.1;
        this._dot.transform.matrix[10] = 0.1;
        if (!this._normalDepthPass.queue.isValid()) {
            for (var i = 0, len1 = scene.models.length; i < len1; ++i) {
                var drawables = scene.models[i].drawables;
                for (var j = 0, len = drawables.length; j < len; j++) {
                    this._normalDepthPass.queue.addDrawable(drawables[j]);
                }
            }
        }
    }
    SnappingApprox.prototype.destroy = function () {
        this._normalDepthPass.destroy();
        this._normalDepthPass = null;
        delete this._normalDepthPass;
        this._dot.destroy();
        this._dot = null;
        delete this._dot;
        this._rtNormalDepth.destroy();
        this._rtNormalDepth = null;
        delete this._rtNormalDepth;
        this._rtDefault.destroy();
        this._rtDefault = null;
        delete this._rtDefault;
        this._normalDepthBuffer = null;
        delete this._normalDepthBuffer;
    };
    SnappingApprox.prototype.setSnappingRadius = function (radius) {
        this._radius = Math.max(Math.min(radius, 11), 0);
    };
    // @return {number} - -1 snap to nothing,  snap to VERTEX, EDGE or EDGEMIDPOINT
    SnappingApprox.prototype.snap = function (coord, position) {
        // Convert to GL window coordinate.
        var originX = coord[0];
        var originY = coord[1];
        var w = this._rtNormalDepth.getWidth();
        var h = this._rtNormalDepth.getHeight();
        var xCenter = Math.floor(coord[0] * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var yCenter = Math.floor(h - 1 - coord[1] * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        position = position || [0, 0, 0];
        // if current pos is invalid, no need to continue
        if (this._fetchNormal(xCenter, yCenter)) {
            for (var idx = 0; idx < this._radius * this._radius - 1; idx++) {
                // Get it's surrounding normal diff and depth diff
                var i = xCenter + _SpiralOrder__WEBPACK_IMPORTED_MODULE_6__["SPIRAL"][idx][0];
                var j = yCenter + _SpiralOrder__WEBPACK_IMPORTED_MODULE_6__["SPIRAL"][idx][1];
                // If out of canvas, skip this pixel.
                if ((i < 0 || i > w - 1) || (j < 0 || j > h - 1)) {
                    continue;
                }
                // Check if it is an edge (crease).
                if (this._detectEdge(i, j)) {
                    coord[0] = Math.floor(i / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
                    coord[1] = Math.floor((h - 1 - j) / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
                    this._fetchPosition(i, j, position);
                    if (this._rendering) {
                        this._dot.transform.matrix[12] = position[0];
                        this._dot.transform.matrix[13] = position[1];
                        this._dot.transform.matrix[14] = position[2];
                    }
                    return _Snapping__WEBPACK_IMPORTED_MODULE_7__["SnappingMode"].EDGE;
                }
            }
        }
        if (this._rendering) {
            this._fetchPosition(xCenter, yCenter, position);
            this._dot.transform.matrix[12] = position[0];
            this._dot.transform.matrix[13] = position[1];
            this._dot.transform.matrix[14] = position[2];
        }
        return -1;
    };
    SnappingApprox.prototype._fetchNormal = function (x, y, normal) {
        var index = 4 * (x + y * this._rtNormalDepth.getWidth());
        var nx = this._normalDepthBuffer[index];
        var ny = this._normalDepthBuffer[index + 1];
        var nz = this._normalDepthBuffer[index + 2];
        var d = nx * nx + ny * ny + nz * nz;
        if (d > 1e-2) {
            if (normal) {
                normal[0] = nx;
                normal[1] = ny;
                normal[2] = nz;
                vec3.normalize(normal, normal);
            }
            return true;
        }
        return false;
    };
    SnappingApprox.prototype._fetchPosition = function (x, y, position) {
        var w = this._rtNormalDepth.getWidth();
        var h = this._rtNormalDepth.getHeight();
        var offset = 4 * (x + y * w);
        var nx = this._normalDepthBuffer[offset];
        var ny = this._normalDepthBuffer[offset + 1];
        var nz = this._normalDepthBuffer[offset + 2];
        var d = nx * nx + ny * ny + nz * nz;
        if (d < 1e-2) {
            return false;
        }
        var cx = x / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        var cy = (h - 1 - y) / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        var depth = this._normalDepthBuffer[offset + 3];
        var p = this._camera.unproject(cx, cy, -depth);
        position[0] = p[0];
        position[1] = p[1];
        position[2] = p[2];
        return true;
    };
    SnappingApprox.prototype._detectEdge = function (x, y) {
        this._fetchNormal(x - 1, y, detect_edge_n0);
        this._fetchPosition(x - 1, y, detect_edge_p0);
        this._fetchNormal(x + 1, y, detect_edge_n1);
        this._fetchPosition(x + 1, y, detect_edge_p1);
        vec3.subtract(detect_edge_d, detect_edge_p0, detect_edge_p1);
        vec3.normalize(detect_edge_d, detect_edge_d);
        var planeDist0 = Math.max(Math.abs(vec3.dot(detect_edge_d, detect_edge_n0)), Math.abs(vec3.dot(detect_edge_d, detect_edge_n1)));
        this._fetchNormal(x, y - 1, detect_edge_n0);
        this._fetchPosition(x, y - 1, detect_edge_p0);
        this._fetchNormal(x, y + 1, detect_edge_n1);
        this._fetchPosition(x, y + 1, detect_edge_p1);
        vec3.subtract(detect_edge_d, detect_edge_p0, detect_edge_p1);
        vec3.normalize(detect_edge_d, detect_edge_d);
        var planeDist1 = Math.max(Math.abs(vec3.dot(detect_edge_d, detect_edge_n0)), Math.abs(vec3.dot(detect_edge_d, detect_edge_n1)));
        return planeDist0 * planeDist0 + planeDist1 * planeDist1 > 0.25;
    };
    SnappingApprox.prototype.resize = function (width, height) {
        this._rtNormalDepth.resize(width, height);
        this._normalDepthBuffer = new Float32Array(width * height * 4);
    };
    SnappingApprox.prototype.update = function (renderer, scene, camera) {
        renderer.invalidate();
        renderer.clear(this._rtNormalDepth, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this._normalDepthPass.render(this._rtNormalDepth, renderer, camera);
        gl.readPixels(0, 0, this._rtNormalDepth.getWidth(), this._rtNormalDepth.getHeight(), gl.RGBA, gl.FLOAT, this._normalDepthBuffer);
    };
    SnappingApprox.prototype.render = function (renderer, camera) {
        if (this._rendering) {
            renderer.drawGizmo(this._rtDefault, this._dot, camera);
        }
    };
    SnappingApprox.prototype.setRenderingEdgeEnabled = function (enabled) {
        this._rendering = enabled;
    };
    return SnappingApprox;
}());
/* harmony default export */ __webpack_exports__["default"] = (SnappingApprox);


/***/ }),

/***/ "./08ui/tool/SpiralOrder.ts":
/*!**********************************!*\
  !*** ./08ui/tool/SpiralOrder.ts ***!
  \**********************************/
/*! exports provided: SPIRAL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPIRAL", function() { return SPIRAL; });
var SPIRAL = [
    [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1], [2, -1], [2, 0],
    [2, 1], [2, 2], [1, 2], [0, 2], [-1, 2], [-2, 2], [-2, 1], [-2, 0], [-2, -1], [-2, -2],
    [-1, -2], [0, -2], [1, -2], [2, -2], [3, -2], [3, -1], [3, 0], [3, 1], [3, 2], [3, 3],
    [2, 3], [1, 3], [0, 3], [-1, 3], [-2, 3], [-3, 3], [-3, 2], [-3, 1], [-3, 0], [-3, -1],
    [-3, -2], [-3, -3], [-2, -3], [-1, -3], [0, -3], [1, -3], [2, -3], [3, -3], [4, -3], [4, -2],
    [4, -1], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [3, 4], [2, 4], [1, 4], [0, 4],
    [-1, 4], [-2, 4], [-3, 4], [-4, 4], [-4, 3], [-4, 2], [-4, 1], [-4, 0], [-4, -1], [-4, -2],
    [-4, -3], [-4, -4], [-3, -4], [-2, -4], [-1, -4], [0, -4], [1, -4], [2, -4], [3, -4], [4, -4],
    [5, -4], [5, -3], [5, -2], [5, -1], [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5],
    [4, 5], [3, 5], [2, 5], [1, 5], [0, 5], [-1, 5], [-2, 5], [-3, 5], [-4, 5], [-5, 5],
    [-5, 4], [-5, 3], [-5, 2], [-5, 1], [-5, 0], [-5, -1], [-5, -2], [-5, -3], [-5, -4], [-5, -5],
    [-4, -5], [-3, -5], [-2, -5], [-1, -5], [0, -5], [1, -5], [2, -5], [3, -5], [4, -5], [5, -5],
    [6, -5], [6, -4], [6, -3], [6, -2], [6, -1], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4],
    [6, 5], [6, 6], [5, 6], [4, 6], [3, 6], [2, 6], [1, 6], [0, 6], [-1, 6], [-2, 6],
    [-3, 6], [-4, 6], [-5, 6], [-6, 6], [-6, 5], [-6, 4], [-6, 3], [-6, 2], [-6, 1], [-6, 0],
    [-6, -1], [-6, -2], [-6, -3], [-6, -4], [-6, -5], [-6, -6], [-5, -6], [-4, -6], [-3, -6], [-2, -6],
    [-1, -6], [0, -6], [1, -6], [2, -6], [3, -6], [4, -6], [5, -6], [6, -6], [7, -6], [7, -5],
    [7, -4], [7, -3], [7, -2], [7, -1], [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5],
    [7, 6], [7, 7], [6, 7], [5, 7], [4, 7], [3, 7], [2, 7], [1, 7], [0, 7], [-1, 7],
    [-2, 7], [-3, 7], [-4, 7], [-5, 7], [-6, 7], [-7, 7], [-7, 6], [-7, 5], [-7, 4], [-7, 3],
    [-7, 2], [-7, 1], [-7, 0], [-7, -1], [-7, -2], [-7, -3], [-7, -4], [-7, -5], [-7, -6], [-7, -7],
    [-6, -7], [-5, -7], [-4, -7], [-3, -7], [-2, -7], [-1, -7], [0, -7], [1, -7], [2, -7], [3, -7],
    [4, -7], [5, -7], [6, -7], [7, -7], [8, -7], [8, -6], [8, -5], [8, -4], [8, -3], [8, -2],
    [8, -1], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8],
    [7, 8], [6, 8], [5, 8], [4, 8], [3, 8], [2, 8], [1, 8], [0, 8], [-1, 8], [-2, 8],
    [-3, 8], [-4, 8], [-5, 8], [-6, 8], [-7, 8], [-8, 8], [-8, 7], [-8, 6], [-8, 5], [-8, 4],
    [-8, 3], [-8, 2], [-8, 1], [-8, 0], [-8, -1], [-8, -2], [-8, -3], [-8, -4], [-8, -5], [-8, -6],
    [-8, -7], [-8, -8], [-7, -8], [-6, -8], [-5, -8], [-4, -8], [-3, -8], [-2, -8], [-1, -8], [0, -8],
    [1, -8], [2, -8], [3, -8], [4, -8], [5, -8], [6, -8], [7, -8], [8, -8], [9, -8], [9, -7],
    [9, -6], [9, -5], [9, -4], [9, -3], [9, -2], [9, -1], [9, 0], [9, 1], [9, 2], [9, 3],
    [9, 4], [9, 5], [9, 6], [9, 7], [9, 8], [9, 9], [8, 9], [7, 9], [6, 9], [5, 9],
    [4, 9], [3, 9], [2, 9], [1, 9], [0, 9], [-1, 9], [-2, 9], [-3, 9], [-4, 9], [-5, 9],
    [-6, 9], [-7, 9], [-8, 9], [-9, 9], [-9, 8], [-9, 7], [-9, 6], [-9, 5], [-9, 4], [-9, 3],
    [-9, 2], [-9, 1], [-9, 0], [-9, -1], [-9, -2], [-9, -3], [-9, -4], [-9, -5], [-9, -6], [-9, -7],
    [-9, -8], [-9, -9], [-8, -9], [-7, -9], [-6, -9], [-5, -9], [-4, -9], [-3, -9], [-2, -9], [-1, -9],
    [0, -9], [1, -9], [2, -9], [3, -9], [4, -9], [5, -9], [6, -9], [7, -9], [8, -9], [9, -9],
    [10, -9], [10, -8], [10, -7], [10, -6], [10, -5], [10, -4], [10, -3], [10, -2], [10, -1], [10, 0],
    [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6], [10, 7], [10, 8], [10, 9], [10, 10],
    [9, 10], [8, 10], [7, 10], [6, 10], [5, 10], [4, 10], [3, 10], [2, 10], [1, 10], [0, 10],
    [-1, 10], [-2, 10], [-3, 10], [-4, 10], [-5, 10], [-6, 10], [-7, 10], [-8, 10], [-9, 10], [-10, 10],
    [-10, 9], [-10, 8], [-10, 7], [-10, 6], [-10, 5], [-10, 4], [-10, 3], [-10, 2], [-10, 1], [-10, 0],
    [-10, -1], [-10, -2], [-10, -3], [-10, -4], [-10, -5], [-10, -6], [-10, -7], [-10, -8], [-10, -9], [-10, -10],
    [-9, -10], [-8, -10], [-7, -10], [-6, -10], [-5, -10], [-4, -10], [-3, -10], [-2, -10], [-1, -10], [0, -10],
    [1, -10], [2, -10], [3, -10], [4, -10], [5, -10], [6, -10], [7, -10], [8, -10], [9, -10], [10, -10],
    [11, -10], [11, -9], [11, -8], [11, -7], [11, -6], [11, -5], [11, -4], [11, -3], [11, -2], [11, -1],
    [11, 0], [11, 1], [11, 2], [11, 3], [11, 4], [11, 5], [11, 6], [11, 7], [11, 8], [11, 9],
    [11, 10], [11, 11], [10, 11], [9, 11], [8, 11], [7, 11], [6, 11], [5, 11], [4, 11], [3, 11],
    [2, 11], [1, 11], [0, 11], [-1, 11], [-2, 11], [-3, 11], [-4, 11], [-5, 11], [-6, 11], [-7, 11],
    [-8, 11], [-9, 11], [-10, 11], [-11, 11], [-11, 10], [-11, 9], [-11, 8], [-11, 7], [-11, 6], [-11, 5],
    [-11, 4], [-11, 3], [-11, 2], [-11, 1], [-11, 0], [-11, -1], [-11, -2], [-11, -3], [-11, -4], [-11, -5],
    [-11, -6], [-11, -7], [-11, -8], [-11, -9], [-11, -10], [-11, -11], [-10, -11], [-9, -11], [-8, -11], [-7, -11],
    [-6, -11], [-5, -11], [-4, -11], [-3, -11], [-2, -11], [-1, -11], [0, -11], [1, -11], [2, -11], [3, -11],
    [4, -11], [5, -11], [6, -11], [7, -11], [8, -11], [9, -11], [10, -11], [11, -11]
];


/***/ }),

/***/ "./08ui/tool/Tool.ts":
/*!***************************!*\
  !*** ./08ui/tool/Tool.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");


/**
 * @hidden
 */
var Tool = /** @class */ (function () {
    function Tool(name, renderable, viewer) {
        this.name = name;
        this._viewer = viewer;
        if (viewer) {
            this._scene = viewer.getScene().core;
            this._camera = viewer.getCamera().core;
            this._resourceManager = viewer.getResourceManager();
            this._renderer = viewer.getRenderer();
        }
        else {
            this._scene = null;
            this._camera = null;
            this._resourceManager = null;
            this._renderer = null;
        }
        this._renderable = renderable;
        this._renderTargets = [];
        this._interactive = true;
        this._enabled = false;
    }
    Tool.prototype.destroy = function () {
        this.name = null;
        delete this.name;
        this._viewer = null;
        delete this._viewer;
        this._scene = null;
        delete this._scene;
        this._camera = null;
        delete this._camera;
        this._renderer = null;
        delete this._renderer;
        this._resourceManager = null;
        delete this._resourceManager;
        for (var i = 0; i < this._renderTargets.length; i++) {
            this._renderTargets[i].destroy();
        }
        this._renderTargets = null;
        delete this._renderTargets;
    };
    Tool.prototype.doesSupportMobile = function (isMobile) {
        return false;
    };
    Tool.prototype.doesSupport3D = function (is3D) {
        return false;
    };
    Tool.prototype.isEnabled = function () {
        return this._enabled;
    };
    Tool.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
    };
    Tool.prototype.setInteractive = function (enabled) {
        this._interactive = enabled;
    };
    Tool.prototype.isInteractive = function () {
        return this._interactive && this._enabled;
    };
    Tool.prototype.addInput = function (input) {
    };
    Tool.prototype.resize = function (width, height) {
        for (var i = 0; i < this._renderTargets.length; i++) {
            this._renderTargets[i].resize(width, height);
        }
    };
    Tool.prototype.render = function () {
    };
    // Get the window render target that renders to
    Tool.prototype._getRenderTarget = function (option) {
        if (this._renderable && this._viewer) {
            var rtName = this._viewer.getRenderScene().getRenderTarget().getName();
            var rt = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_1__["default"](rtName, this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, option || {});
            this._renderTargets.push(rt);
            return rt;
        }
        return null;
    };
    return Tool;
}());
/* harmony default export */ __webpack_exports__["default"] = (Tool);


/***/ }),

/***/ "./08ui/tool/TransformGizmo.ts":
/*!*************************************!*\
  !*** ./08ui/tool/TransformGizmo.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../00utility/m3d_math.js */ "./00utility/m3d_math.js");
/* harmony import */ var _02resource_m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../02resource/m3d_geometric_shape.js */ "./02resource/m3d_geometric_shape.js");
/* harmony import */ var _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo.js */ "./03scene/drawables/m3d_gizmo.js");
/* harmony import */ var _PickQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PickQuery */ "./08ui/tool/PickQuery.ts");
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tool */ "./08ui/tool/Tool.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var COLORS = {
    "axis-x": vec4.fromValues(1, 0, 0, 1),
    "axis-y": vec4.fromValues(0, 1, 0, 1),
    "axis-z": vec4.fromValues(0, 0, 1, 1),
    "picked": vec4.fromValues(1, 1, 0, 1)
};
var move_transform = mat4.create();
var mouse_move_translation = [0, 0, 0];
var TransformGizmo = /** @class */ (function (_super) {
    __extends(TransformGizmo, _super);
    function TransformGizmo(viewer) {
        var _this = _super.call(this, "TransformGizmo", true, viewer) || this;
        _this._renderTarget = _this._getRenderTarget();
        _this._picked = null;
        _this._translation = [0, 0, 0];
        _this._previousTranslation = [0, 0, 0];
        _this._drawables = [];
        return _this;
    }
    TransformGizmo.prototype.destroy = function () {
        if (this._drawables.length > 0) {
            this._drawables[0].destroy();
            this._drawables[1].destroy();
            this._drawables[2].destroy();
        }
        this._drawables = null;
        delete this._drawables;
        if (this._pickQuery) {
            this._pickQuery.destroy();
            this._pickQuery = null;
            delete this._pickQuery;
        }
        this._translation = null;
        delete this._translation;
        this._previousTranslation = null;
        delete this._previousTranslation;
    };
    ;
    TransformGizmo.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
        // Put the gizmo at the lower corner of the scene's bbox.
        if (this._enabled) {
            if (this._drawables.length === 0) {
                this._createGizmo();
                this._pickQuery = new _PickQuery__WEBPACK_IMPORTED_MODULE_3__["default"](this._scene, this._resourceManager);
            }
            this._translation[0] = this._scene.bbox[0];
            this._translation[1] = this._scene.bbox[1];
            this._translation[2] = this._scene.bbox[2];
            this._previousTranslation[0] = this._translation[0];
            this._previousTranslation[1] = this._translation[1];
            this._previousTranslation[2] = this._translation[2];
            this._move();
        }
    };
    TransformGizmo.prototype.render = function () {
        if (!this._enabled) {
            return;
        }
        this._renderer.drawGizmo(this._renderTarget, this._drawables[0], this._camera);
        this._renderer.drawGizmo(this._renderTarget, this._drawables[1], this._camera);
        this._renderer.drawGizmo(this._renderTarget, this._drawables[2], this._camera);
    };
    TransformGizmo.prototype.addInput = function (input) {
        if (input.name === "mouse") {
            input.addMouseDownListener(this._onMouseDown.bind(this));
            input.addMouseMoveListener(this._onMouseMove.bind(this));
        }
        else if (input.name === "touch") {
            //input.addTouchMoveListener(this._onTouchMove.bind(this));
            //input.addTouchStartListener(this._onTouchStart.bind(this));
        }
    };
    TransformGizmo.prototype.doesSupportMobile = function (isMobile) {
        return true;
    };
    TransformGizmo.prototype.doesSupport3D = function (is3D) {
        return true;
    };
    TransformGizmo.prototype._onMouseDown = function (mouse) {
        return false;
    };
    TransformGizmo.prototype._onMouseMove = function (mouse) {
        if (!this._enabled) {
            return false;
        }
        if (mouse.pressed) {
            if (this._picked) {
                this._updateTranslation(mouse);
                this._move();
                mouse_move_translation[0] = this._translation[0] - this._previousTranslation[0];
                mouse_move_translation[1] = this._translation[1] - this._previousTranslation[1];
                mouse_move_translation[2] = this._translation[2] - this._previousTranslation[2];
                this._previousTranslation[0] = this._translation[0];
                this._previousTranslation[1] = this._translation[1];
                this._previousTranslation[2] = this._translation[2];
                this._scene.terrain.translate(mouse_move_translation[0], mouse_move_translation[1], mouse_move_translation[2]);
                this._scene.updateBBox();
                this._viewer.invalidate();
                this._viewer.getEventEmitter().emit("TransformGizmo-Move");
                return true;
            }
        }
        else {
            var picked = this._pickQuery.pickDrawable(mouse.x, mouse.y, this._renderer, this._camera, this._drawables);
            if (picked !== this._picked) {
                // Restore the previously picked axis color.
                if (this._picked) {
                    this._picked.setColor(COLORS[this._picked.name]);
                }
                this._picked = picked;
                // Highlight the picked axis.
                if (this._picked) {
                    this._picked.setColor(COLORS["picked"]);
                }
            }
        }
        return false;
    };
    // Move the gizmo to position
    TransformGizmo.prototype._move = function () {
        // Transform the gizmo to position.
        var m = move_transform;
        m[12] = this._translation[0];
        m[13] = this._translation[1];
        m[14] = this._translation[2];
        this._drawables[0].transform.set(m);
        this._drawables[1].transform.set(m);
        this._drawables[2].transform.set(m);
    };
    // Update the gizmo position
    TransformGizmo.prototype._updateTranslation = function (mouse) {
        var p0 = this._camera.unproject(mouse.x, mouse.y);
        var p1 = vec3.fromValues(p0[0], p0[1], p0[2]);
        p0 = this._camera.unproject(mouse.x - mouse.dx, mouse.y - mouse.dy);
        var p2 = vec3.fromValues(p0[0], p0[1], p0[2]);
        vec3.sub(p1, p1, p2);
        switch (this._picked.name) {
            case "axis-x":
                if (p1[0] !== 0) {
                    this._translation[0] += p1[0];
                }
                break;
            case "axis-y":
                if (p1[1] !== 0) {
                    this._translation[1] += p1[1];
                }
                break;
            case "axis-z":
                if (p1[2] !== 0) {
                    this._translation[2] += p1[2];
                }
                break;
        }
        ;
    };
    TransformGizmo.prototype.setPosition = function (x, y, z) {
        this._translation[0] = x;
        this._translation[1] = y;
        this._translation[2] = z;
    };
    TransformGizmo.prototype._createGizmo = function () {
        var arrowScale = _00utility_m3d_math_js__WEBPACK_IMPORTED_MODULE_0__["default"].aabb.length(this._scene.bbox) * 0.05;
        // axis-X
        var axisX = this._resourceManager.getMesh("transformX");
        var axisXGeomShape = new _02resource_m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        axisXGeomShape.createArrow(0.1 * arrowScale, 1 * arrowScale);
        axisXGeomShape.rotate(0, Math.PI / 2, 0);
        axisX.createArrow(axisXGeomShape);
        // axis-Y
        var axisY = this._resourceManager.getMesh("transformY");
        var axisYGeomShape = new _02resource_m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        axisYGeomShape.createArrow(0.1 * arrowScale, 1 * arrowScale);
        axisYGeomShape.rotate(-Math.PI / 2, 0, 0);
        axisY.createArrow(axisYGeomShape);
        // axis-Z
        var axisZ = this._resourceManager.getMesh("transformZ");
        var axisZGeomShape = new _02resource_m3d_geometric_shape_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        axisZGeomShape.createArrow(0.1 * arrowScale, 1 * arrowScale);
        axisZ.createArrow(axisZGeomShape);
        this._drawables = new Array(3);
        this._drawables[0] = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__["default"]("axis-x", axisX, this._resourceManager);
        this._drawables[0].transform.identity = false;
        this._drawables[0].setColor(COLORS["axis-x"]);
        this._drawables[1] = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__["default"]("axis-y", axisY, this._resourceManager);
        this._drawables[1].transform.identity = false;
        this._drawables[1].setColor(COLORS["axis-y"]);
        this._drawables[2] = new _03scene_drawables_m3d_gizmo_js__WEBPACK_IMPORTED_MODULE_2__["default"]("axis-z", axisZ, this._resourceManager);
        this._drawables[2].transform.identity = false;
        this._drawables[2].setColor(COLORS["axis-z"]);
    };
    return TransformGizmo;
}(_Tool__WEBPACK_IMPORTED_MODULE_4__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (TransformGizmo);


/***/ }),

/***/ "./08ui/tool/assets.ts":
/*!*****************************!*\
  !*** ./08ui/tool/assets.ts ***!
  \*****************************/
/*! exports provided: DASH_LINE_TEXTURE_IMAGE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DASH_LINE_TEXTURE_IMAGE", function() { return DASH_LINE_TEXTURE_IMAGE; });
var DASH_LINE_TEXTURE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAdSURBVHjaYgwNDWWAgVWrVsHZTAw4AAAAAP//AwB4HgMBuHqXXgAAAABJRU5ErkJggg==";


/***/ }),

/***/ "./08ui/tool/m3d_line.js":
/*!*******************************!*\
  !*** ./08ui/tool/m3d_line.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_drawables_m3d_gizmo2d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/drawables/m3d_gizmo2d.js */ "./03scene/drawables/m3d_gizmo2d.js");
//
// m3d_measure.js
// The measure gizmo
//
// Copyright Modelo XX - 2017, All rights reserved.


/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    function MyLine(name, resourceManager, color, isDashed) {
        this._dashed = isDashed;
        this._lineWidth = Math.floor(3 * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var mesh = resourceManager.getMesh("line_mesh_" + name);
        mesh.createSolidQuad();
        this._drawable = new _03scene_drawables_m3d_gizmo2d_js__WEBPACK_IMPORTED_MODULE_1__["default"]("line_drawable_" + name, mesh, resourceManager);
        this._drawable.setColor(color);
        this._drawable.setTransparent(0.0);
        if (!this._dashed) {
            this._vertices = new Float32Array(12);
            this._indices = new Uint8Array(6);
            this._indices[0] = 0;
            this._indices[1] = 1;
            this._indices[2] = 2;
            this._indices[3] = 2;
            this._indices[4] = 3;
            this._indices[5] = 0;
        }
        else {
            this._vertices = new Float32Array(240); //20  quads
            this._indices = new Uint8Array(120);
            for (var i = 0; i < 20; ++i) {
                this._indices[0 + i * 6] = 0 + i * 4;
                this._indices[1 + i * 6] = 1 + i * 4;
                this._indices[2 + i * 6] = 2 + i * 4;
                this._indices[3 + i * 6] = 2 + i * 4;
                this._indices[4 + i * 6] = 3 + i * 4;
                this._indices[5 + i * 6] = 0 + i * 4;
            }
        }
        for (var i = 0; i < this._vertices.length; ++i) {
            this._vertices[i] = -1000000;
        }
        this._drawable.mesh.update(this._vertices, this._indices, gl.UNSIGNED_BYTE);
    }
    ;
    MyLine.prototype.render = function (renderTarget, renderer, camera) {
        renderer.drawDrawable(renderTarget, this._drawable, camera, null, null, null, false);
    };
    MyLine.prototype._addQuad = function (sx, sy, ex, ey, offset) {
        var w = ex - sx;
        var h = ey - sy;
        var angle = Math.atan2(w, h);
        var sign = Math.sign(w * h) || 1;
        var yh = Math.sin(angle) * this._lineWidth * 0.5 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * sign;
        var xh = Math.cos(angle) * this._lineWidth * 0.5 / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * sign;
        //Set to -1 to 1, the quad range
        sx = sx / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
        ex = ex / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width * 2.0 - 1.0;
        sy = sy / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 2.0 - 1.0;
        ey = ey / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height * 2.0 - 1.0;
        this._vertices[0 + offset] = sx - xh;
        this._vertices[1 + offset] = sy + yh;
        this._vertices[3 + offset] = sx + xh;
        this._vertices[4 + offset] = sy - yh;
        this._vertices[6 + offset] = ex + xh;
        this._vertices[7 + offset] = ey - yh;
        this._vertices[9 + offset] = ex - xh;
        this._vertices[10 + offset] = ey + yh;
        this._vertices[2 + offset] = 0.0;
        this._vertices[5 + offset] = 0.0;
        this._vertices[8 + offset] = 0.0;
        this._vertices[11 + offset] = 0.0;
    };
    MyLine.prototype.updateVertices = function (startX, startY, endX, endY) {
        var sx = startX;
        var ex = endX;
        var sy = startY;
        var ey = endY;
        sx = sx * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        sy = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - sy * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        ex = ex * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        ey = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height - 1 - ey * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio;
        var w = ex - sx;
        var h = ey - sy;
        if (this._dashed) {
            for (var i = 0; i < 20; i++) {
                var subSx = sx + w / 39 * 2 * i;
                var subSy = sy + h / 39 * 2 * i;
                var subEx = subSx + w / 39;
                var subEy = subSy + h / 39;
                //pixel pos
                this._addQuad(subSx, subSy, subEx, subEy, i * 12);
            }
        }
        else {
            this._addQuad(sx, sy, ex, ey, 0);
        }
        this._drawable.mesh.update(this._vertices, this._indices, gl.UNSIGNED_BYTE);
    };
    MyLine.prototype.setLineWidth = function (width) {
        this._lineWidth = Math.floor(Math.min(width, 1) * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
    };
    MyLine.prototype.destroy = function () {
        this._drawable.destroy();
        this._vertices = null;
        this._indices = null;
    };
    return MyLine;
})());


/***/ }),

/***/ "./10api/Auth.ts":
/*!***********************!*\
  !*** ./10api/Auth.ts ***!
  \***********************/
/*! exports provided: signIn, signOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signIn", function() { return signIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signOut", function() { return signOut; });
/* harmony import */ var _utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/client */ "./10api/utils/client/index.ts");

/**
 * Sign in Modelo with applicationToken and returns an session token if success. The session token will be valid in 1 week by default.
 * @param {string} applicationToken The application token is obtained by admin page. Check the programming guide.
 * @param {object} options The authentication options.
 * @param {function} onSuccess The callback when succeed. The callback will accept a sessionToken which will be used as the access token to backend for other APIs.
 * @param {function} onFail The callback when fail. The errmsg records the failure error message.
*/
function signIn(applicationToken, 
// options:SignInOption, 
onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["signIn"](applicationToken, { expireSeconds: 0 })
        .then(function () { return onSuccess(); })
        .catch(function (e) { return onFail(e.message); });
}
/**
* Sign out Modelo and expire the session token obtained in {@link signIn}.
* @param {string} sessionToken The session token returned in {@link signIn}
* @param {function} onSuccess The callback when succeed.
* @param {function} onFail The callback when fail.
*/
function signOut(onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["signOut"]()
        .then(function () { return onSuccess(); })
        .catch(function (e) { return onFail(e.message); });
}


/***/ }),

/***/ "./10api/BIM.ts":
/*!**********************!*\
  !*** ./10api/BIM.ts ***!
  \**********************/
/*! exports provided: queryElementBIM, updateElementBIM, searchElementsByBIM, queryBIMTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryElementBIM", function() { return queryElementBIM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateElementBIM", function() { return updateElementBIM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "searchElementsByBIM", function() { return searchElementsByBIM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryBIMTree", function() { return queryBIMTree; });
/* harmony import */ var _utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/client */ "./10api/utils/client/index.ts");
/**
 * @fileoverview bim.ts - The model BIM data
 * @author Modelo, Inc
 * @version 0.0.1
 *
 * Copyright Modelo XX - 2018, All rights reserved.
 */

/**
 * Query the bim data of element
 * @param modelId
 * @param elementId
 * @param onSuccess
 * @param onFail
 */
function queryElementBIM(modelId, elementId, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["getElementProperties"](modelId, elementId)
        .then(function (properties) { return onSuccess(properties); })
        .catch(function (e) { return onFail(e.message); });
}
/**
 * @param modelId
 * @param elementId
 * @param onSuccess
 * @param onFail
 */
function updateElementBIM(modelId, elementId, property, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["updateElementProperty"](modelId, elementId, property)
        .then(function () { return onSuccess(); })
        .catch(function (e) { return onFail(e.message); });
}
/**
 * Search elements with certain bim properties
 * @param sessionToken
 * @param modelId
 * @param onSuccess
 * @param onFail
 */
function searchElementsByBIM(sessionToken, modelId, condition, onSuccess, onFail) {
}
/**
 * Query the bim information, i.e., the bim tree of the model
 */
function queryBIMTree(modelId, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["getBimTree"](modelId)
        .then(function (bimData) { return onSuccess(bimData); })
        .catch(function (e) { return onFail(e.message); });
}


/***/ }),

/***/ "./10api/EventEmitter.ts":
/*!*******************************!*\
  !*** ./10api/EventEmitter.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.events = {};
    }
    EventEmitter.prototype.emit = function (evtName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _args = Array.prototype.slice.call(arguments, 1);
        if (this.events[evtName]) {
            this.events[evtName].forEach(function (event) { return event.apply(null, _args); });
        }
    };
    EventEmitter.prototype.on = function (evtName, func) {
        var _this = this;
        if (!this.events[evtName]) {
            this.events[evtName] = [];
        }
        this.events[evtName].push(func);
        return function () {
            _this.events[evtName] = _this.events[evtName].filter(function (f) { return f !== func; });
        };
    };
    EventEmitter.prototype.clear = function () {
        this.events = {};
    };
    return EventEmitter;
}());
/* harmony default export */ __webpack_exports__["default"] = (EventEmitter);


/***/ }),

/***/ "./10api/Utils.ts":
/*!************************!*\
  !*** ./10api/Utils.ts ***!
  \************************/
/*! exports provided: isSupportWebGL, isSupportWebGL2, ViewAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupportWebGL", function() { return isSupportWebGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupportWebGL2", function() { return isSupportWebGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewAngle", function() { return ViewAngle; });
/**
 * Check if the current platform supports WebGL 1.0.
 * @param doc The current document HTML5 DOM
 * @returns true or false to indicate if WebGL 1.0 is supported.
 */
function isSupportWebGL(doc) {
    var canvas = doc.createElement("canvas");
    var canvasContext = WebGLUtils.setupWebGL(canvas, { webgl2: false });
    var ret = (canvasContext !== null);
    // TODO: ensure we destroyed the context and canvas DOM.
    return ret;
}
/**
 * Check if the current platform supports WebGL 2.0.
 * @param doc The current document HTML5 DOM
 * @returns true or false to indicate if WebGL 2.0 is supported.
 */
function isSupportWebGL2(doc) {
    var canvas = doc.createElement("canvas");
    var canvasContext = WebGLUtils.setupWebGL(canvas, { webgl2: true });
    if (!canvasContext) {
        return false;
    }
    var version = canvasContext.getParameter(canvasContext.VERSION);
    var ret = (version.match("WebGL 2.0") !== null);
    // TODO: ensure we destroyed the context and canvas DOM.
    return ret;
}
var ViewAngle;
(function (ViewAngle) {
    ViewAngle[ViewAngle["FRONT"] = 0] = "FRONT";
    ViewAngle[ViewAngle["BACK"] = 1] = "BACK";
    ViewAngle[ViewAngle["LEFT"] = 2] = "LEFT";
    ViewAngle[ViewAngle["RIGHT"] = 3] = "RIGHT";
    ViewAngle[ViewAngle["TOP"] = 4] = "TOP";
    ViewAngle[ViewAngle["BOTTOM"] = 5] = "BOTTOM";
    ViewAngle[ViewAngle["WORLD"] = 6] = "WORLD";
})(ViewAngle || (ViewAngle = {}));
;


/***/ }),

/***/ "./10api/Version.ts":
/*!**************************!*\
  !*** ./10api/Version.ts ***!
  \**************************/
/*! exports provided: VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
var VERSION = "1.1.0";


/***/ }),

/***/ "./10api/Viewer.ts":
/*!*************************!*\
  !*** ./10api/Viewer.ts ***!
  \*************************/
/*! exports provided: State, Viewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewer", function() { return Viewer; });
/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resize-observer-polyfill */ "../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_hwinfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../00utility/m3d_hwinfo.js */ "./00utility/m3d_hwinfo.js");
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventEmitter */ "./10api/EventEmitter.ts");
/**
 * @fileoverview viewer.ts - the base class of viewer.
 * @author Modelo, Inc
 * @version 0.0.1
 *
 * Copyright Modelo XX - 2018, All rights reserved.
 */




/**
 * The runtime state of canvas.
 */
var State;
(function (State) {
    State[State["INITIALIZED"] = -1] = "INITIALIZED";
    State[State["UNINITIALIZED"] = -2] = "UNINITIALIZED";
    State[State["RENDERING"] = -3] = "RENDERING";
    State[State["INITIALIZED_PAUSED"] = -4] = "INITIALIZED_PAUSED";
    State[State["RENDERING_PAUSED"] = -5] = "RENDERING_PAUSED";
})(State || (State = {}));
/**
 * @hidden
 * The viewer is the render that displays either 2D or 3D content. It requires a HTML5 canvas DOM
 * to draw.
 */
var Viewer = /** @class */ (function () {
    /**
     * Constructor a viewer.
     */
    function Viewer(containerId, config) {
        if (config === void 0) { config = { isMobile: false }; }
        var _this = this;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].state = State.UNINITIALIZED;
        this._canvasId = 'ModeloCanvas';
        this._container = document.getElementById(containerId);
        if (!this._container) {
            throw Error("The container '" + containerId + "' doesn't exist.");
        }
        if (this._container.clientHeight === 0) {
            throw Error("The container '" + containerId + "' should have height");
        }
        // check existing canvas
        this._canvas = document.getElementById(this._canvasId);
        if (this._canvas) {
            throw Error("A viewer has already been created in container '" + this._canvas.parentElement.id + "'. Please call viewer.destroy() first.");
        }
        // start with new canvas
        this._canvas = document.createElement('canvas');
        this._canvas.id = this._canvasId;
        this._container.appendChild(this._canvas);
        this._canvas.oncontextmenu = function () {
            return false;
        };
        // Setup the size of the context.
        var width = this._container.clientWidth;
        var height = this._container.clientHeight;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].devicePixelRatio = window.devicePixelRatio || 1;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].width = Math.floor(width * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].devicePixelRatio);
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].height = Math.floor(height * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].devicePixelRatio);
        // hidpi support
        // let canvas drawing scale with pixel ratio
        // let css control container pixel
        this._canvas.width = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].width;
        this._canvas.height = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].height;
        this._canvas.style.width = width + 'px';
        this._canvas.style.height = height + 'px';
        var hwInfo = new _00utility_m3d_hwinfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].littleEndian = hwInfo.littleEndian;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].gpuMemory = Math.round(hwInfo.vramSize * 0.5);
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].browserName = hwInfo.browserName;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].browserVersion = hwInfo.browserVersion;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].isMobile = config.isMobile;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].Promise = Promise;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].frontendCallbacks = {
            getPromiseLibrary: function () {
                return Promise;
            }
        };
        this._eventEmitter = new _EventEmitter__WEBPACK_IMPORTED_MODULE_3__["default"]();
        this._inputs = [];
        //var hasTouchEvents = "ontouchstart" in window;
        //if (hasTouchEvents) {
        //    this.addInput(new View.Touch());
        //}
        this._tools = [];
        this._ro = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_0__["default"](function (entries) {
            entries.forEach(function (entry) {
                var _a = entry.contentRect, width = _a.width, height = _a.height;
                _this.resize(width, height);
            });
        });
        this._ro.observe(this._container);
        // Initialize the state
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].state = State.INITIALIZED;
    }
    /**
     * Callback when the canvas get resized.
     */
    Viewer.prototype.resize = function (width, height) {
        width = width || 1;
        height = height || 1;
        var actualWidth = Math.floor(width * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].devicePixelRatio);
        var actualHeight = Math.floor(height * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].devicePixelRatio);
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].width = actualWidth;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].height = actualHeight;
        this._canvas.width = actualWidth;
        this._canvas.height = actualHeight;
        this._canvas.style.width = width + 'px';
        this._canvas.style.height = height + 'px';
    };
    /**
     * Stop rendering, destroy the viewer and release all internal resources.
     */
    Viewer.prototype.destroy = function () {
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].state === State.UNINITIALIZED) {
            return;
        }
        this._ro.unobserve(this._container);
        this._ro = null;
        delete this._ro;
        this._inputs.forEach(function (input) {
            input.destroy();
        });
        this._inputs = null;
        delete this._inputs;
        this._tools.forEach(function (tool) {
            tool.destroy();
        });
        this._tools = null;
        delete this._tools;
        this._eventEmitter = null;
        delete this._eventEmitter;
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].state = State.UNINITIALIZED;
        this._canvas.remove();
        this._canvas = null;
        delete this._canvas;
        this._container = null;
        delete this._container;
        console.log("%cThe viewer gets destroyed", "font-weight:bold;");
    };
    /**
     * Unload the model in current viewer.
     */
    Viewer.prototype.clearScene = function () {
    };
    /**
     * Create an empty scene instead of loading from a model file.
     */
    Viewer.prototype.createScene = function (onSuccess) {
    };
    /**
     * Pause the current rendering.
     */
    Viewer.prototype.pause = function () {
    };
    /**
     * Resume the rendering.
     */
    Viewer.prototype.resume = function () {
    };
    /**
     * Invalidate the current rendering and refresh it again.
     */
    Viewer.prototype.invalidate = function () {
    };
    /**
     * Add an input method to this viewer, e.g., mouse.
     * @param input - Must be the instance of Modelo.Input that is compatible with current platform.
     * @returns - the input id in this viewer. -1 is returned if it fails to add this input.
     */
    Viewer.prototype.addInput = function (input) {
        if (!input.isAvailable(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].isMobile)) {
            console.warn(input.name + " is not supported on current platform.");
            return -1;
        }
        for (var i = 0; i < this._inputs.length; i++) {
            if (this._inputs[i].name === input.name) {
                return -1;
            }
        }
        input.setEnabled(true);
        var id = this._inputs.length;
        this._inputs.push(input);
        return id;
    };
    /**
     * Remove the input method from this viewer.
     * @param id - the id of the input.
     */
    Viewer.prototype.removeInput = function (id) {
        var input = this._inputs[id];
        if (id >= 0 && id < this._inputs.length) {
            this._inputs.slice(id, 1);
        }
        input.destroy();
        // FIXME: do we need to remove the input from the tools which
        // listen to it?
    };
    Viewer.prototype.getInput = function (id) {
        if (id >= 0 && id < this._inputs.length) {
            return this._inputs[id];
        }
        return null;
    };
    /**
     * Add an tool to this viewer.
     * @param tool - The tool to be added to the viewer.
     * @returns - The tool object and null if tool already exists.
     */
    Viewer.prototype.addTool = function (tool) {
        if (!tool.doesSupportMobile(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_1__["default"].isMobile)) {
            return null;
        }
        // Check if existed.
        for (var i = 0; i < this._tools.length; i++) {
            if (this._tools[i].name === tool.name) {
                return null;
            }
        }
        // Bind the existing input to this tool.
        for (var i = 0; i < this._inputs.length; i++) {
            tool.addInput(this._inputs[i]);
        }
        this._tools.push(tool);
        return tool;
    };
    /**
     * Get the tool instance by name.
     * @param name - The name of effect.
     */
    Viewer.prototype.getTool = function (name) {
        for (var i = 0; i < this._tools.length; i++) {
            if (this._tools[i].name === name) {
                return this._tools[i];
            }
        }
        return null;
    };
    /**
     * Remove the tool instance by its name.
     * @param name - The name of effect.
     */
    Viewer.prototype.removeTool = function (name) {
        for (var i = 0; i < this._tools.length; i++) {
            if (this._tools[i].name === name) {
                var tool = this._tools[i];
                tool.destroy();
                this._tools.slice(i, 1);
                break;
            }
        }
    };
    /**
     * Return the canvas DOM.
     * @returns {Object} - The canvas DOM.
     */
    Viewer.prototype.getCanvas = function () {
        return this._canvas;
    };
    Viewer.prototype.getEventEmitter = function () {
        return this._eventEmitter;
    };
    ;
    return Viewer;
}());



/***/ }),

/***/ "./10api/Viewer360.ts":
/*!****************************!*\
  !*** ./10api/Viewer360.ts ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../03scene/drawables/m3d_skybox.js */ "./03scene/drawables/m3d_skybox.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_morphing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../03scene/camera/m3d_camera_animator_morphing.js */ "./03scene/camera/m3d_camera_animator_morphing.js");
/* harmony import */ var _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../04renderer/pipeline/RenderTarget */ "./04renderer/pipeline/RenderTarget.ts");
/* harmony import */ var _07loadsave_Load360__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../07loadsave/Load360 */ "./07loadsave/Load360.ts");
/* harmony import */ var _view_Camera360__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./view/Camera360 */ "./10api/view/Camera360.ts");
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Viewer */ "./10api/Viewer.ts");
/* harmony import */ var _Viewer3D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Viewer3D */ "./10api/Viewer3D.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var Viewer360 = /** @class */ (function (_super) {
    __extends(Viewer360, _super);
    function Viewer360(containerId, config) {
        var _this = _super.call(this, containerId, config) || this;
        _this._data = {};
        _this._skyboxes = [];
        _this._renderTarget = null; // The render target
        _this._viewDirection = vec3.create();
        _this._current = 0;
        _this._currentAssetId = "";
        _this._camera = new _view_Camera360__WEBPACK_IMPORTED_MODULE_5__["default"](_this, _this._eventEmitter);
        _this._renderTarget = new _04renderer_pipeline_RenderTarget__WEBPACK_IMPORTED_MODULE_3__["default"]("default", _this._resourceManager, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height, { blend: true, depthTest: false });
        _this._skyboxes[0] = new _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__["default"](_this._resourceManager, "left_0");
        _this._skyboxes[0].setMode(_03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__["default"].SKYBOX_CUBEMAP);
        _this._skyboxes[1] = new _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__["default"](_this._resourceManager, "left_1");
        _this._skyboxes[1].setMode(_03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_1__["default"].SKYBOX_CUBEMAP);
        return _this;
    }
    Viewer360.prototype.destroy = function () {
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_6__["State"].UNINITIALIZED) {
            return;
        }
        this.pause();
        this._renderTarget.destroy();
        this._renderTarget = null;
        delete this._renderTarget;
        this._data = null;
        delete this._data;
        this._skyboxes[0].destroy();
        this._skyboxes[1].destroy();
        this._skyboxes = null;
        delete this._skyboxes;
        // Call super destroy function
        _super.prototype.destroy.call(this);
    };
    Viewer360.prototype._detectIndicator = function (camera, threshold) {
        if (threshold === void 0) { threshold = 0.607; }
        vec3.set(this._viewDirection, -camera.viewMatrix[2], -camera.viewMatrix[6], -camera.viewMatrix[10]);
        if (!this._data[this._currentAssetId]) {
            return;
        }
        var retIndicators = [];
        for (var i = 0; i < this._data[this._currentAssetId].toAssets.length; i++) {
            if (!this._data[this._currentAssetId].ready) {
                continue;
            }
            var toAsset = this._data[this._currentAssetId].toAssets[i];
            var direction = vec3.clone(toAsset.position);
            vec3.normalize(direction, direction);
            var angle = vec3.dot(direction, this._viewDirection);
            var screenPosition = camera.project(toAsset.position);
            if (toAsset.type === "panorama") {
                retIndicators.push({
                    assetId: toAsset.assetId,
                    name: this._data[toAsset.assetId].name,
                    screenPosition: [screenPosition[0], screenPosition[1]],
                    //change the threshold from 30 degree to 45
                    visible: (angle > threshold && screenPosition[2]) ? true : false
                });
            }
            else { //annotaion
                retIndicators.push({
                    annotation: toAsset,
                    screenPosition: [screenPosition[0], screenPosition[1]],
                    //change the threshold from 30 degree to 45
                    visible: (angle > threshold && screenPosition[2]) ? true : false
                });
            }
        }
        //Send both the indicator's info and the camera's view direction for the frontend to
        //add angles on the minimap
        this._eventEmitter.emit("updatePanoramaIndicator", retIndicators);
    };
    ;
    Viewer360.prototype.switchPanorama = function (assetId, cameraInfo) {
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _Viewer__WEBPACK_IMPORTED_MODULE_6__["State"].INITIALIZED;
        this._resetScene(cameraInfo);
        this._currentAssetId = assetId;
        this._skyboxes[this._current].setImage(this._data[this._currentAssetId].images);
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _Viewer__WEBPACK_IMPORTED_MODULE_6__["State"].RENDERING;
    };
    Viewer360.prototype.moveTo = function (position) {
        var camera = this._camera;
        camera.moveTo(this._current, position);
    };
    Viewer360.prototype.loadModel = function (data, initialTransform, onSuccess, onFail, onProgress) {
        var _this = this;
        this._data = data;
        var loader = new _07loadsave_Load360__WEBPACK_IMPORTED_MODULE_4__["default"](this._data);
        loader.load(null, {}, 
        // phase 1
        function (sceneData) {
            for (var assetId in _this._data) {
                if (_this._data[assetId].ready) {
                    _this._currentAssetId = assetId;
                    _this._skyboxes[0].setImage(_this._data[assetId].images);
                    break;
                }
            }
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _Viewer__WEBPACK_IMPORTED_MODULE_6__["State"].RENDERING;
        }, 
        // phase 2
        function (modelId) {
            _this.invalidate();
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _Viewer__WEBPACK_IMPORTED_MODULE_6__["State"].RENDERING;
            onSuccess(modelId);
        }, 
        // progress
        function (per) {
            onProgress(per);
        }).catch(function (err) {
            onFail(err);
        });
    };
    Viewer360.prototype.clearScene = function () {
        console.warn('clearScene() Not implemented!');
    };
    Viewer360.prototype._resetScene = function (startView) {
        var camera = this._camera;
        camera.transit(this._current, startView);
        this._current = 1 - this._current;
    };
    Viewer360.prototype._drawScene = function () {
        var camera = this._camera;
        if (camera._cores[this._current].animator instanceof _03scene_camera_m3d_camera_animator_morphing_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            this._renderer.drawSkybox(this._renderTarget, this._skyboxes[1 - this._current], camera._cores[1 - this._current]);
            this._renderer.endFrame();
            this._renderer.beginFrame();
            this._skyboxes[this._current].setTransparency(1 - camera._cores[this._current].animator.getProgress());
        }
        else {
            this._detectIndicator(camera._cores[this._current]);
        }
        this._renderer.drawSkybox(this._renderTarget, this._skyboxes[this._current], camera._cores[this._current]);
    };
    Viewer360.prototype._update = function (forceRender) {
        if (forceRender === void 0) { forceRender = false; }
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state !== _Viewer__WEBPACK_IMPORTED_MODULE_6__["State"].RENDERING) {
            return;
        }
        this._camera.update();
        this._renderer.beginFrame();
        this._drawScene();
        this._renderer.endFrame();
    };
    return Viewer360;
}(_Viewer3D__WEBPACK_IMPORTED_MODULE_7__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Viewer360);


/***/ }),

/***/ "./10api/Viewer3D.ts":
/*!***************************!*\
  !*** ./10api/Viewer3D.ts ***!
  \***************************/
/*! exports provided: defaultGLConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultGLConfig", function() { return defaultGLConfig; });
/* harmony import */ var _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../m3d_globals.js */ "./m3d_globals.js");
/* harmony import */ var _00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../00utility/m3d_utils.js */ "./00utility/m3d_utils.js");
/* harmony import */ var _01wrapper_m3d_wgl_release_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../01wrapper/m3d_wgl.release.js */ "./01wrapper/m3d_wgl.release.js");
/* harmony import */ var _02resource_m3d_resource_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../02resource/m3d_resource_manager.js */ "./02resource/m3d_resource_manager.js");
/* harmony import */ var _03scene_m3d_model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../03scene/m3d_model.js */ "./03scene/m3d_model.js");
/* harmony import */ var _04renderer_pipeline_m3d_renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../04renderer/pipeline/m3d_renderer.js */ "./04renderer/pipeline/m3d_renderer.js");
/* harmony import */ var _04renderer_pipeline_RenderScenePR__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../04renderer/pipeline/RenderScenePR */ "./04renderer/pipeline/RenderScenePR.ts");
/* harmony import */ var _07loadsave_LoadScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../07loadsave/LoadScene */ "./07loadsave/LoadScene.ts");
/* harmony import */ var _08ui_tool_Snapping__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../08ui/tool/Snapping */ "./08ui/tool/Snapping.ts");
/* harmony import */ var _08ui_tool_SnappingApprox__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../08ui/tool/SnappingApprox */ "./08ui/tool/SnappingApprox.ts");
/* harmony import */ var _view_Scene3D__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./view/Scene3D */ "./10api/view/Scene3D.ts");
/* harmony import */ var _view_Camera__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./view/Camera */ "./10api/view/Camera.ts");
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Viewer */ "./10api/Viewer.ts");
/* harmony import */ var _utils_model_downloader__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/model/downloader */ "./10api/utils/model/downloader.ts");
/* harmony import */ var _Version__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Version */ "./10api/Version.ts");
/* harmony import */ var _04renderer_volumeRenderer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../04renderer/volumeRenderer */ "./04renderer/volumeRenderer.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};















//import TextureViewer            from "../08ui/debug/TextureViewer";

var defaultGLConfig = {
    isMobile: false,
    alpha: false,
    stencil: false,
    samples: 4
};
var Viewer3D = /** @class */ (function (_super) {
    __extends(Viewer3D, _super);
    //private _textureViewer: TextureViewer;
    /**
     * Constructor a 3D viewer.
     * @param containerId {string} A HTML div DOM id.
     * @param config {Object} Check out Viewer3DConfig
     */
    function Viewer3D(containerId, config) {
        var _this = _super.call(this, containerId, config) || this;
        console.log("%cmodeloapi version: " + _Version__WEBPACK_IMPORTED_MODULE_14__["VERSION"], "font-weight:bold;");
        // Set up OpenGL context
        _this._setupGL(__assign({}, defaultGLConfig, config));
        // Initialize core modules
        _this._resourceManager = new _02resource_m3d_resource_manager_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
        _this._renderer = new _04renderer_pipeline_m3d_renderer_js__WEBPACK_IMPORTED_MODULE_5__["default"](_this._resourceManager);
        _this._scene = new _view_Scene3D__WEBPACK_IMPORTED_MODULE_10__["default"](_this);
        _this._camera = new _view_Camera__WEBPACK_IMPORTED_MODULE_11__["default"](_this);
        _this._volumeRenderer = new _04renderer_volumeRenderer__WEBPACK_IMPORTED_MODULE_15__["default"](_this, _this._resourceManager);
        _this._renderScene = new _04renderer_pipeline_RenderScenePR__WEBPACK_IMPORTED_MODULE_6__["default"](_this._scene.core, _this._camera.core, _this._resourceManager, _this._renderer, _this._volumeRenderer);
        _this._snapping = null;
        // The animation (window update) function.
        _this._animationFn = _this._initAnimationFrame.bind(_this);
        // Register the webgl context lost events
        _this._onContextLostFn = null;
        _this._onContextRestoreFn = null;
        _this._canvas.addEventListener("webglcontextlost", _this._onGLContextLost.bind(_this), false);
        _this._canvas.addEventListener("webglcontextrestored", _this._onGLContextRestore.bind(_this), false);
        _this._animationId = window.requestAnimationFrame(_this._animationFn);
        return _this;
        // FIXME: debugging only
        //this._textureViewer = new TextureViewer(this._resourceManager);
        //this._textureViewer.setEnabled(true);
        //this._textureViewer.setSize(300, 300);
    }
    /**
     * Stop rendering, destroy the viewer and release all internal resources.
     */
    Viewer3D.prototype.destroy = function () {
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].UNINITIALIZED) {
            return;
        }
        this.pause();
        // Unregister the events.
        this._canvas.removeEventListener("webglcontextlost", this._onGLContextLost.bind(this), false);
        this._canvas.removeEventListener("webglcontextrestored", this._onGLContextRestore.bind(this), false);
        // Destroy core modules.
        this._renderScene.destroy();
        this._renderScene = null;
        delete this._renderScene;
        this._renderer.destroy();
        this._renderer = null;
        delete this._renderer;
        this._scene.destroy();
        this._scene = null;
        delete this._scene;
        this._resourceManager.destroy();
        this._resourceManager = null;
        delete this._resourceManager;
        this._camera.destroy();
        this._camera = null;
        delete this._camera;
        if (this._snapping) {
            this._snapping.destroy();
            this._snapping = null;
            delete this._snapping;
        }
        // Release GL context
        this._destroyGL();
        // Call super destroy function
        _super.prototype.destroy.call(this);
    };
    /**
     * Invalidate the current rendering and refresh it again.
     *
     */
    Viewer3D.prototype.invalidate = function () {
        this._renderer.invalidate();
        this._renderScene.refreshRendering();
        _super.prototype.invalidate.call(this);
    };
    /**
     * Callback when canvas gets resized.
     */
    Viewer3D.prototype.resize = function (width, height) {
        _super.prototype.resize.call(this, width, height);
        this._camera.resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        this._renderScene.resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        if (this._snapping !== null) {
            this._snapping.resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        }
        for (var i = 0; i < this._tools.length; i++) {
            this._tools[i].resize(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width, _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height);
        }
        this.invalidate();
    };
    /**
     * Load a model into current viewer. When loading done, it will trigger
     * onSuccess callback. The loading will fail if there is already a model
     * loaded in current renderer. In this case, users should call unload first.
     * @param modelId
     * @param onSuccess
     * @param onProgressive
     * @param onFail
     * @
     */
    Viewer3D.prototype.loadModel = function (modelId, initialTransform, onSuccess, onFail, onProgress) {
        this._load(modelId, initialTransform, onSuccess, onFail, onProgress);
    };
    /**
     * Load a terrain model into current viewer.
     */
    Viewer3D.prototype.loadTerrain = function (terrainId, initialTransform, onSuccess, onFail, onProgress) {
        var _this = this;
        if (this._scene.core.terrain) {
            onFail("There is already a model in scene. Please unload it first.");
        }
        else {
            this._load(terrainId, initialTransform, function () {
                onSuccess(terrainId);
                // The loader will returns when it loads the coarsest level.
                // We need to continue load the other levels.
                _this._load(terrainId, initialTransform, function () { }, function () { }, function () { });
            }, onFail, onProgress);
        }
    };
    /**
     * Unload the current scene.
     */
    Viewer3D.prototype.clearScene = function () {
        this._scene.core.clear();
        this._renderer.invalidate();
        this._resourceManager.clear();
    };
    /**
     * Create an empty scene instead of loading from a model file.
     */
    Viewer3D.prototype.createScene = function (onSuccess) {
        this._scene.core.model = new _03scene_m3d_model_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this._scene.core.model.source = "untitled.m3d";
        this._renderScene.onSceneChanged();
        this._camera.core.setCullingEnabled(true);
        _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame = 1; // start counting frames
        this.invalidate();
        this._requestAnimationFrame();
        console.log("%cAn empty scene created.", "font-weight:bold;");
        onSuccess(this._scene);
    };
    /**
     * Load a model into current viewer using file promises.
     */
    Viewer3D.prototype._load = function (fileId, initialTransform, onSuccess, onFail, onProgress) {
        var _this = this;
        // FIXME: this long ugly string of model Id is for compatibility of local DAM.
        var useLocalServer = fileId === "8888";
        if (!initialTransform || initialTransform.length === 0) {
            initialTransform = [1.0, 0.0, 0.0, 0.0, 0.0];
        }
        if (useLocalServer) {
            this._load1(fileId, initialTransform, {}, onSuccess, onFail, onProgress);
        }
        else {
            Object(_utils_model_downloader__WEBPACK_IMPORTED_MODULE_13__["generatePromises"])(fileId)
                .then(function (filePromises) {
                _this._load1(fileId, initialTransform, filePromises, onSuccess, onFail, onProgress);
            })
                .catch(function (e) { return onFail(e.message); });
        }
    };
    Viewer3D.prototype._load1 = function (fileId, initialTransform, filePromises, onSuccess, onFail, onProgress) {
        var _this = this;
        var loader = new _07loadsave_LoadScene__WEBPACK_IMPORTED_MODULE_7__["default"](this._scene.core, this._camera.core, this._resourceManager, this._renderScene);
        loader
            .load(fileId, initialTransform, filePromises, 
        // phase 1
        function (sceneData) {
            // If the model is small, we start rendering during loading.
            // MOD-6873, if the model is too big, we have disabled the
            // rendering during loading.
            if (sceneData.nodes < 100000 && sceneData.byteLength < 100000) {
                _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING;
            }
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame = 1; // start counting frames
        }, 
        // phase 2
        function (modelId) {
            _this._renderScene.optimize();
            _this.invalidate();
            _this._camera.core.setCullingEnabled(true);
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING;
            onSuccess(modelId);
        }, 
        // progress
        function (per) {
            onProgress(per);
        })
            .catch(function (err) {
            onFail(err);
        });
    };
    /**
     * @ignore
     * Cancel the refresh window event
     * @param {integer} animationId - the animation ID
     * @return {undefined}
     */
    Viewer3D.prototype._cancelAnimationFrame = function () {
        window.cancelAnimationFrame(this._animationId);
        this._animationId = -1;
    };
    /**
     * @ignore
     * Init the refresh window event and force rendering once
     * @param {integer} animationId - the animation ID
     * @return {undefined}
     */
    Viewer3D.prototype._initAnimationFrame = function () {
        this._update(true);
        this._animationFn = this._requestAnimationFrame.bind(this);
        this._animationId = window.requestAnimationFrame(this._animationFn);
    };
    /**
     * @ignore
     * Start the refresh window event
     * @param {DOM} canvas - the canvas DOM
     */
    Viewer3D.prototype._requestAnimationFrame = function () {
        this._update();
        this._animationId = window.requestAnimationFrame(this._animationFn);
    };
    /**
     * Update the rendering
     */
    Viewer3D.prototype._update = function (forceRender) {
        if (forceRender === void 0) { forceRender = false; }
        // When the screen (tab) is hidden, we don't need to run update function.
        if (!forceRender && _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state !== _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING) {
            return;
        }
        // On iOS, the canvas resize will be effective immediately in the follow case
        //
        // resize to new size -> draw -> resize to original size.
        //
        // So we need to defer the resizing to next frame.
        //if (Globals.isMobile && (this._resizeWidth || this._resizeHeight)) {
        //    if (!this._canResize) {
        //        this._canResize = true;
        //        return;
        //    }
        //    this.resize(this._resizeWidth, this._resizeHeight);
        //    this._resizeWidth  = null;
        //    this._resizeHeight = null;
        //    this._canResize    = false;
        //}
        //// Trigger the callback at the first time rendering stops
        //if (this.initialRotateCompletedCallback && this._lazyRendering && !this._sceneCamera.updated && this._needUpdate < 0.001) {
        //    this.initialRotateCompletedCallback();
        //    this._stateManager.onSceneChanged();
        //    this.initialRotateCompletedCallback = null;
        //}
        // Update the camera since last frame by inputs, e.g., touch, mouse.
        if (this._camera.update()) {
            this._renderScene.refreshRendering(1);
        }
        this._renderer.beginFrame();
        // When any tool is ready to render, we should disable progressive rendering.
        var hasTools = false;
        this._tools.forEach(function (tool) {
            hasTools = hasTools || tool.isInteractive();
        });
        var drawn = this._renderScene.draw(hasTools); // return if something gets drawn
        if (hasTools) {
            this._tools.forEach(function (tool) {
                tool.render();
            });
        }
        // Present to the window the offline FB gets updated.
        if (drawn) {
            this._renderer.present(this._renderScene.getRenderTarget().getFramebuffer()); // FIXME: combine it into endFrame
        }
        this._renderer.endFrame();
        if (drawn) {
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].frame++;
        }
    };
    /**
     * Pause the current rendering.
     */
    Viewer3D.prototype.pause = function () {
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].INITIALIZED || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING) {
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].INITIALIZED ? _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].INITIALIZED_PAUSED : _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING_PAUSED;
            this._resourceManager.discard(true);
            this._cancelAnimationFrame();
        }
        _super.prototype.pause.call(this);
    };
    /**
     * Resume the rendering.
     */
    Viewer3D.prototype.resume = function () {
        if (_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].INITIALIZED_PAUSED || _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING_PAUSED) {
            this._resourceManager.restore(true);
            _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].state === _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].INITIALIZED_PAUSED ? _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].INITIALIZED : _Viewer__WEBPACK_IMPORTED_MODULE_12__["State"].RENDERING;
        }
        this.invalidate();
        this._requestAnimationFrame();
        _super.prototype.resume.call(this);
    };
    /**
     * Capture current frame of the canvas to the image with specified width and height
     * @param width - The width of screencapture in pixels
     * @param height - Ditto
     * @param bgColor - The background color of dumped image.
     */
    Viewer3D.prototype.dumpScreen = function (width, height, bgColor) {
        if (bgColor === void 0) { bgColor = [0.96, 0.96, 0.96, 1.0]; }
        // Save the current states
        var oldBgColor = this._scene.core.background.getColor();
        // If both width and height are left empty, we use the current canvas size.
        if (!width && !height) {
            width = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
            height = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height;
        }
        else if (!height) {
            // If height is null, we keep the aspect ratio.
            height = width * _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width;
        }
        // Resize the canvas size and camera.
        var oldWidth = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].width / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var oldHeight = Math.floor(_m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].height / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var newWidth = Math.floor(width / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        var newHeight = Math.floor(height / _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].devicePixelRatio);
        // Render the scene
        this.setBackgroundColor(bgColor);
        if (newWidth !== oldWidth || newHeight !== oldHeight) {
            this.resize(newWidth, newHeight);
        }
        else {
            this.invalidate();
        }
        this._renderScene.drawHD();
        // Restore render states.
        this.setBackgroundColor(oldBgColor);
        var thumbnail = this._canvas.toDataURL("image/jpg");
        // Restore the canvas size.
        if (newWidth !== oldWidth || newHeight !== oldHeight) {
            this.resize(oldWidth, oldHeight);
        }
        else {
            this.invalidate();
        }
        return thumbnail;
    };
    // /**
    //  * Pick an element.
    //  * @param x {number} - The cursor position in window coordinate, i.e., the origin is on left top corner.
    //  * @param y {number} - Ditto.
    //  * @param multiselect {boolean} - When true, we don't clear the current selected elements.
    //  * @returns {number} - The ID of element that intersection with cursor. Return -1 if no element intersects.
    //  */
    // public pickElement(x:number, y:number, multiselect:boolean) : number {
    //     return -1;
    // }
    // /**
    //  * Move camera close to elements.
    //  */
    // public focusElements(elementIds:Array<number>) : void {
    // }
    /**
     * Set the height of light
     * @param angle - ranges in [0, pi/2]. pi/2 when light is at north polar.
     */
    Viewer3D.prototype.setLightingLatitude = function (angle) {
        this._scene.core.setLightingLatitude(angle);
        this._renderScene.updateShadow(true);
        this.invalidate();
    };
    /**
     * Set the direction of light
     * @param angle - ranges in [0, pi*2]. 0 when light is at east.
     */
    Viewer3D.prototype.setLightingLongitude = function (angle) {
        this._scene.core.setLightingLongitude(angle);
        this._renderScene.updateShadow(true);
        this.invalidate();
    };
    /**
     * Change the lighting intensity
     * @param intensity {number} - A value between 0 and 1. 0 means blind dark and 1 is the brightest.
     */
    Viewer3D.prototype.setLightingIntensity = function (intensity) {
        this._scene.core.setLightingIntensity(intensity);
        this.invalidate();
    };
    Viewer3D.prototype.setRenderingLinesEnabled = function (enabled) {
        this._renderScene.setLineRendering(enabled);
        this.invalidate();
    };
    /**
     * Set the intensity of specular light
     * @param {float} intensity - the intensity of specular light, ranging from 0 (dim) to 1 (bright)
     */
    Viewer3D.prototype.setSpecularIntensity = function (intensity) {
        this._scene.core.setLightingIntensity(intensity);
        this._scene.core.setSpecularShinness(200 - intensity * 160);
    };
    /**
     * Turn on/off specular light
     * @param {boolean} enabled - enable the specular light
     */
    Viewer3D.prototype.setSpecularEnabled = function (enabled) {
        //this._renderScene.setSpecularEnabled(enabled);
        this.invalidate();
    };
    /**
     * Turn on/off the shadow
     * @param {boolean} enabled - true for shadow on.
     */
    Viewer3D.prototype.setShadowEnabled = function (enabled) {
        this._renderScene.setShadowEnabled(enabled);
        this.invalidate();
    };
    /**
     * Add an input method to this viewer, e.g., mouse.
     * @param input - Must be the instance of Modelo.Input that is compatible with current platform.
     * @returns - true if added successfully.
     */
    Viewer3D.prototype.addInput = function (input) {
        var id = _super.prototype.addInput.call(this, input);
        this._camera.addInput(input);
        return id;
    };
    /**
     * When mouse is attached to this viewer, return the mouse object.
     * @return {Object} - The attached mouse object.
     */
    Viewer3D.prototype.getMouse = function () {
        for (var i = 0; i < this._inputs.length; i++) {
            if (this._inputs[i].name === "mouse") {
                return this._inputs[i];
            }
        }
        return null;
    };
    Viewer3D.prototype.getKeyboard = function () {
        for (var i = 0; i < this._inputs.length; i++) {
            if (this._inputs[i].name === "keyboard") {
                return this._inputs[i];
            }
        }
        return null;
    };
    Viewer3D.prototype._setupGL = function (config) {
        // TODO: enable WebGL2 for webvr Globals.webvr
        var isMobile = config.isMobile, alpha = config.alpha, stencil = config.stencil, samples = config.samples;
        var browserName = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].browserName;
        var browserVersion = _m3d_globals_js__WEBPACK_IMPORTED_MODULE_0__["default"].browserVersion;
        var useWebGL2 = false;
        if (browserName === "chrome" && parseInt(browserVersion) >= 63) {
            useWebGL2 = true;
        }
        var useVAO = true;
        if (browserName === "chrome" && browserVersion === "62") {
            // We have disable VAO for this buggy Chrome version
            useVAO = false;
        }
        // gl is defined in global name space.
        gl = Object(_01wrapper_m3d_wgl_release_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this._canvas, {
            depth: true,
            alpha: alpha,
            //premultipliedalpha  : false,
            samples: samples,
            stencil: stencil,
            preserveDrawingBuffer: true,
            vao: useVAO,
            instancing: false,
            webgl2: useWebGL2
        });
        if (gl !== null) {
            var glversion = gl.isWebGL2 ? "2.0" : "1.0";
            console.group("A WebGL " + glversion + " context created");
            console.log("  color: RGBA, depth: enabled, stencil: disabled");
            console.log("  VAO: " + (useVAO ? "enabled" : "disabled"));
            console.log("  Instancing: " + (gl.instancingExtension ? "enabled" : "disabled"));
            console.groupEnd();
        }
    };
    Viewer3D.prototype._destroyGL = function () {
        var ext = gl.getExtension("WEBGL_lose_context");
        if (ext !== null) {
            ext.loseContext();
        }
    };
    /**
     * Set the background color of the viewer.
     * @param {Array<number>} color - The RGB of the background color
     */
    Viewer3D.prototype.setBackgroundColor = function (color) {
        this._scene.core.background.setColor(color);
        this.invalidate();
    };
    /**
     * Set the background image of the viewer
     * @param {object} image - an HTML image DOM.
     */
    Viewer3D.prototype.setBackgroundImage = function (image) {
        if (image) {
            if (!_00utility_m3d_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArray(image) && (image.tagName.toLowerCase() !== "img" || image.complete !== true)) {
                console.log("setBackgroundImage requires a valid <img> object.");
                return;
            }
        }
        this._scene.core.background.setImages(image);
        this.invalidate();
    };
    /**
     * The background image tiling mode.
     * @param {enumerate} mode - either SKYBOX_WALLPAPER or SKYBOX_SKYDOME. In
     *   WALLPAPER mode, the background is a static image. In SKYDOME mode, it is like
     *   skydome and background will rotate with the scene model.
     */
    Viewer3D.prototype.setBackgroundMode = function (mode) {
        this._scene.core.background.setMode(mode);
        this.invalidate();
    };
    /**
     * Get the scene.
     * @return the scene object of this viewer.
     */
    Viewer3D.prototype.getScene = function () {
        return this._scene;
    };
    Viewer3D.prototype.getSnapping = function () {
        if (this._snapping === null) {
            if (gl.isWebGL2 && this.getScene().hasContours()) {
                this._snapping = new _08ui_tool_Snapping__WEBPACK_IMPORTED_MODULE_8__["default"](this._scene.core, this._camera.core, this._resourceManager);
            }
            else {
                this._snapping = new _08ui_tool_SnappingApprox__WEBPACK_IMPORTED_MODULE_9__["default"](this._scene.core, this._camera.core, this._resourceManager);
                this._snapping.setSnappingRadius(8);
            }
        }
        return this._snapping;
    };
    /**
     * @hidden
     */
    Viewer3D.prototype.getResourceManager = function () {
        return this._resourceManager;
    };
    /**
     * @hidden
     */
    Viewer3D.prototype.getRenderer = function () {
        return this._renderer;
    };
    /**
     * @hidden
     */
    Viewer3D.prototype.getRenderScene = function () {
        return this._renderScene;
    };
    /**
     * Get the camera of the scene
     * @return the camera object of the viewer.
     */
    Viewer3D.prototype.getCamera = function () {
        return this._camera;
    };
    /**
     * If lazy rendering is on, the rendering stops when camera stops. It saves
     * the CPU cycles. Moreover, only under lazy rendering mode, we have ambient
     * shadow, fine shadow and better AA.
     */
    Viewer3D.prototype.setLazyRenderingEnabled = function (enabled) {
        this._renderScene.setProgressiveRenderingEnabled(enabled);
    };
    Viewer3D.prototype._onGLContextLost = function () {
        this._cancelAnimationFrame();
        if (this._onContextLostFn) {
            this._onContextLostFn();
        }
    };
    Viewer3D.prototype._onGLContextRestore = function () {
        if (this._onContextRestoreFn) {
            this._onContextRestoreFn();
        }
    };
    Viewer3D.prototype.setContextLostCbk = function (cbk) {
        this._onContextLostFn = cbk;
    };
    Viewer3D.prototype.setContextRestoreCbk = function (cbk) {
        this._onContextRestoreFn = cbk;
    };
    /**
     * Enable the culling when rotation. When it is enabled, some elements will be hidden during
     * camera aniatmion to accelerate the rendering. This cull policy is based on the knowledge
     * of the scene which is why it is called smart culling.
     * @param {boolean} enabled - Enabled or disable the culling.
     */
    Viewer3D.prototype.setSmartCullingEnabled = function (enabled) {
        this._renderScene.setSmartCullingEnabled(enabled);
    };
    /**
     * If the culling is enabled.
     * @returns {boolean} - True for yes.
     */
    Viewer3D.prototype.isSmartCullingEnabled = function () {
        return this._renderScene.isSmartCullingEnabled();
    };
    Viewer3D.prototype.setEffectEnabled = function (effect, enabled) {
        this._renderScene.setEffectEnabled(effect, enabled);
        this.invalidate();
    };
    Viewer3D.prototype.setEffectParameter = function (effect, name, value) {
        this._renderScene.getEffect(effect).setParameter(name, value);
        this.invalidate();
    };
    Viewer3D.prototype.isEffectEnabled = function (effect) {
        return this._renderScene.isEffectEnabled(effect);
    };
    /**
     * Set all elements to the same color. Note that this change only take effects
     * temporarily at this session. It does not change the scene data so that the
     * color setting is not preserved next time.
     * @param color The new color.
     */
    Viewer3D.prototype.setOverrideColor = function (color) {
        //this._renderScene.setProgressiveRenderingEnabled(false);
        //this._renderScene.setOverridedMaterial(color);
        this.invalidate();
    };
    /**
     * Create volume rendering in certain location.
     * @param matrix The matrix of the volume. if it's identity the volume is a unit cube centered at (0.5, 0.5, 0.5).
     * @param dfTextureUrl The texture of distacne field(2048 * 2048).
     * @param floorTextureUrl The texutre of floor data. Each color in it indicates a unit.
     * @param colorMapUrl The color map use in volume rendering.
     * @param populationData The population data.
     */
    Viewer3D.prototype.createVolumeRendering = function (matrix, dfTextureUrl, floorTextureUrl, colorMapUrl, populationData) {
        this._volumeRenderer.create(matrix, dfTextureUrl, floorTextureUrl, colorMapUrl, populationData);
        this.invalidate();
    };
    /**
     * @param enable Ture if you want it to be enabled.
     */
    Viewer3D.prototype.setVolumeRenderingEnabled = function (enable) {
        this._volumeRenderer.setEnable(enable);
        this.invalidate();
    };
    /**
     * update the population data of volume rendering.
     * @param populationData
     */
    Viewer3D.prototype.updateVolumeData = function (populationData) {
        this._volumeRenderer.updateVolumeData(populationData);
        this.invalidate();
    };
    return Viewer3D;
}(_Viewer__WEBPACK_IMPORTED_MODULE_12__["Viewer"]));
/* harmony default export */ __webpack_exports__["default"] = (Viewer3D);


/***/ }),

/***/ "./10api/config.ts":
/*!*************************!*\
  !*** ./10api/config.ts ***!
  \*************************/
/*! exports provided: setConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConfig", function() { return setConfig; });
var config = {
    endpoint: ""
};
var setConfig = function (newConfig) {
    config.endpoint = newConfig.endpoint;
};
/* harmony default export */ __webpack_exports__["default"] = (config);


/***/ }),

/***/ "./10api/graphql/AddCombinedModel.gql":
/*!********************************************!*\
  !*** ./10api/graphql/AddCombinedModel.gql ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"AddCombinedModel"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"name"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelIds"}},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"addCombinedModel"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"folderId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}}},{"kind":"Argument","name":{"kind":"Name","value":"name"},"value":{"kind":"Variable","name":{"kind":"Name","value":"name"}}},{"kind":"Argument","name":{"kind":"Name","value":"modelIds"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelIds"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"status"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":197}};
    doc.loc.source = {"body":"mutation AddCombinedModel($folderId: Int!, $name: String!, $modelIds: [Id]!) {\r\n    addCombinedModel(folderId: $folderId, name: $name, modelIds: $modelIds) {\r\n        id\r\n        status\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["AddCombinedModel"] = oneQuery(doc, "AddCombinedModel");
        


/***/ }),

/***/ "./10api/graphql/AddModelComment.gql":
/*!*******************************************!*\
  !*** ./10api/graphql/AddModelComment.gql ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"AddModelComment"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"message"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"plainText"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"bimdata"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"camera"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"addModelComment"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"message"},"value":{"kind":"Variable","name":{"kind":"Name","value":"message"}}},{"kind":"Argument","name":{"kind":"Name","value":"plainText"},"value":{"kind":"Variable","name":{"kind":"Name","value":"plainText"}}},{"kind":"Argument","name":{"kind":"Name","value":"bimdata"},"value":{"kind":"Variable","name":{"kind":"Name","value":"bimdata"}}},{"kind":"Argument","name":{"kind":"Name","value":"camera"},"value":{"kind":"Variable","name":{"kind":"Name","value":"camera"}}},{"kind":"Argument","name":{"kind":"Name","value":"modelId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"bimdata"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"camera"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"modelId"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"message"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"plainText"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"createdAt"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":383}};
    doc.loc.source = {"body":"mutation AddModelComment($message: String!, $plainText: String!, $bimdata: String, $camera: String, $modelId: Id) {\r\n    addModelComment(message: $message, plainText: $plainText, bimdata: $bimdata, camera: $camera, modelId: $modelId) {\r\n        id\r\n        bimdata\r\n        camera\r\n        modelId\r\n        message\r\n        plainText\r\n        createdAt\r\n        updatedAt\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["AddModelComment"] = oneQuery(doc, "AddModelComment");
        


/***/ }),

/***/ "./10api/graphql/AddSliceModel.gql":
/*!*****************************************!*\
  !*** ./10api/graphql/AddSliceModel.gql ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"AddSliceModel"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"name"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"query"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"isTerrain"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Boolean"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sliceModel"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"name"},"value":{"kind":"Variable","name":{"kind":"Name","value":"name"}}},{"kind":"Argument","name":{"kind":"Name","value":"folderId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}}},{"kind":"Argument","name":{"kind":"Name","value":"query"},"value":{"kind":"Variable","name":{"kind":"Name","value":"query"}}},{"kind":"Argument","name":{"kind":"Name","value":"isTerrain"},"value":{"kind":"Variable","name":{"kind":"Name","value":"isTerrain"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"name"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"folderId"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":224}};
    doc.loc.source = {"body":"mutation AddSliceModel($name: String!, $folderId: Int, $query: String!, $isTerrain: Boolean) {\r\n  sliceModel(name: $name, folderId: $folderId, query: $query, isTerrain: $isTerrain) {\r\n    id\r\n    name\r\n    folderId\r\n  }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["AddSliceModel"] = oneQuery(doc, "AddSliceModel");
        


/***/ }),

/***/ "./10api/graphql/DeleteModel.gql":
/*!***************************************!*\
  !*** ./10api/graphql/DeleteModel.gql ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"DeleteModel"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deleteModel"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}}],"directives":[]}]}}],"loc":{"start":0,"end":71}};
    doc.loc.source = {"body":"mutation DeleteModel($modelId: Id!) {\r\n  deleteModel(id: $modelId)\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["DeleteModel"] = oneQuery(doc, "DeleteModel");
        


/***/ }),

/***/ "./10api/graphql/DeleteModelComment.gql":
/*!**********************************************!*\
  !*** ./10api/graphql/DeleteModelComment.gql ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"DeleteModelComment"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deleteModelComment"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"directives":[]}]}}],"loc":{"start":0,"end":78}};
    doc.loc.source = {"body":"mutation DeleteModelComment($id: Int!) {\r\n    deleteModelComment(id: $id)\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["DeleteModelComment"] = oneQuery(doc, "DeleteModelComment");
        


/***/ }),

/***/ "./10api/graphql/GetElementProperties.gql":
/*!************************************************!*\
  !*** ./10api/graphql/GetElementProperties.gql ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetElementProperties"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"docAndCatId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"elementId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"elementProperties"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"docAndCatId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"docAndCatId"}}},{"kind":"Argument","name":{"kind":"Name","value":"modelId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}},{"kind":"Argument","name":{"kind":"Name","value":"elementId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"elementId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"property"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"strValue"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"numValue"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":241}};
    doc.loc.source = {"body":"query GetElementProperties($docAndCatId: Int!, $modelId: Id!, $elementId: Int!) {\r\n    elementProperties(docAndCatId: $docAndCatId, modelId: $modelId, elementId: $elementId) {\r\n        property\r\n        strValue\r\n        numValue\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["GetElementProperties"] = oneQuery(doc, "GetElementProperties");
        


/***/ }),

/***/ "./10api/graphql/GetModel.gql":
/*!************************************!*\
  !*** ./10api/graphql/GetModel.gql ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetModel"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"model"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ModelInfo"},"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"versionedModels"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ModelInfo"},"directives":[]}]}}]}}]}}],"loc":{"start":0,"end":185}};
    doc.loc.source = {"body":"#import \"./ModelInfo.gql\"\r\n\r\nquery GetModel($modelId: Id!) {\r\n    model(id: $modelId) {\r\n        ...ModelInfo\r\n        versionedModels {\r\n            ...ModelInfo\r\n        }\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  doc.definitions = doc.definitions.concat(unique(__webpack_require__(/*! ./ModelInfo.gql */ "./10api/graphql/ModelInfo.gql").definitions));


    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["GetModel"] = oneQuery(doc, "GetModel");
        


/***/ }),

/***/ "./10api/graphql/GetModelComments.gql":
/*!********************************************!*\
  !*** ./10api/graphql/GetModelComments.gql ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetModelComments"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"modelComments"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"modelId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"bimdata"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"camera"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"modelId"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"message"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"plainText"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"createdAt"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":192}};
    doc.loc.source = {"body":"query GetModelComments($modelId:  Id!) {\r\n  modelComments(modelId: $modelId) {\r\n    id\r\n    bimdata\r\n    camera\r\n    modelId\r\n    message\r\n    plainText\r\n    createdAt\r\n    updatedAt\r\n  }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["GetModelComments"] = oneQuery(doc, "GetModelComments");
        


/***/ }),

/***/ "./10api/graphql/GetModelFiles.gql":
/*!*****************************************!*\
  !*** ./10api/graphql/GetModelFiles.gql ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetModelFiles"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"model"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"downloadUrls"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"filename"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"url"},"arguments":[],"directives":[]}]}},{"kind":"Field","name":{"kind":"Name","value":"convertedUrls"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"filename"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"url"},"arguments":[],"directives":[]}]}}]}}]}}],"loc":{"start":0,"end":236}};
    doc.loc.source = {"body":"query GetModelFiles($modelId: Id!) {\r\n    model(id: $modelId) {\r\n        id\r\n        downloadUrls {\r\n            filename\r\n            url\r\n        }\r\n        convertedUrls {\r\n            filename\r\n            url\r\n        }\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["GetModelFiles"] = oneQuery(doc, "GetModelFiles");
        


/***/ }),

/***/ "./10api/graphql/GetModelFolder.gql":
/*!******************************************!*\
  !*** ./10api/graphql/GetModelFolder.gql ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetModelFolder"},"variableDefinitions":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"user"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"projects"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"modelFolder"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]}]}}]}}]}}]}}],"loc":{"start":0,"end":155}};
    doc.loc.source = {"body":"query GetModelFolder {\r\n    user {\r\n        projects {\r\n            id\r\n            modelFolder {\r\n                id\r\n            }\r\n        }\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["GetModelFolder"] = oneQuery(doc, "GetModelFolder");
        


/***/ }),

/***/ "./10api/graphql/ModelInfo.gql":
/*!*************************************!*\
  !*** ./10api/graphql/ModelInfo.gql ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ModelInfo"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Model"}},"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"folderId"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"targetModelId"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"type"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"name"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"status"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"version"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"createdBy"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"username"},"arguments":[],"directives":[]}]}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"downloadUrls"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"filename"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"url"},"arguments":[],"directives":[]}]}},{"kind":"Field","name":{"kind":"Name","value":"convertedUrls"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"filename"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"url"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":321}};
    doc.loc.source = {"body":"fragment ModelInfo on Model {\r\n    id\r\n    folderId\r\n    targetModelId\r\n    type\r\n    name\r\n    status\r\n    version\r\n    createdBy {\r\n        id\r\n        username\r\n    }\r\n    createdAt\r\n    updatedAt\r\n    downloadUrls {\r\n        filename\r\n        url\r\n    }\r\n    convertedUrls {\r\n        filename\r\n        url\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

      module.exports = doc;
    


/***/ }),

/***/ "./10api/graphql/UpdateElementProperty.gql":
/*!*************************************************!*\
  !*** ./10api/graphql/UpdateElementProperty.gql ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateElementProperty"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"docAndCatId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"elementId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"property"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"strValue"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"numValue"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updatePropertyValue"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"modelId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}},{"kind":"Argument","name":{"kind":"Name","value":"docAndCatId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"docAndCatId"}}},{"kind":"Argument","name":{"kind":"Name","value":"elementId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"elementId"}}},{"kind":"Argument","name":{"kind":"Name","value":"property"},"value":{"kind":"Variable","name":{"kind":"Name","value":"property"}}},{"kind":"Argument","name":{"kind":"Name","value":"strValue"},"value":{"kind":"Variable","name":{"kind":"Name","value":"strValue"}}},{"kind":"Argument","name":{"kind":"Name","value":"numValue"},"value":{"kind":"Variable","name":{"kind":"Name","value":"numValue"}}}],"directives":[]}]}}],"loc":{"start":0,"end":388}};
    doc.loc.source = {"body":"mutation UpdateElementProperty(\r\n    $modelId: Id!\r\n    $docAndCatId: Int!\r\n    $elementId: Int!\r\n    $property: String!\r\n    $strValue: String\r\n    $numValue: Float\r\n) {\r\n    updatePropertyValue(\r\n        modelId: $modelId\r\n        docAndCatId: $docAndCatId\r\n        elementId: $elementId\r\n        property: $property\r\n        strValue: $strValue\r\n        numValue: $numValue\r\n    )\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["UpdateElementProperty"] = oneQuery(doc, "UpdateElementProperty");
        


/***/ }),

/***/ "./10api/graphql/UpdateModel.gql":
/*!***************************************!*\
  !*** ./10api/graphql/UpdateModel.gql ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateModel"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"name"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateModel"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}},{"kind":"Argument","name":{"kind":"Name","value":"name"},"value":{"kind":"Variable","name":{"kind":"Name","value":"name"}}},{"kind":"Argument","name":{"kind":"Name","value":"folderId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":159}};
    doc.loc.source = {"body":"mutation UpdateModel($modelId: Id!, $name: String, $folderId: Int) {\r\n    updateModel(id: $modelId, name: $name, folderId: $folderId) {\r\n        id\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["UpdateModel"] = oneQuery(doc, "UpdateModel");
        


/***/ }),

/***/ "./10api/graphql/UpdateModelComment.gql":
/*!**********************************************!*\
  !*** ./10api/graphql/UpdateModelComment.gql ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateModelComment"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"message"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"plainText"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateModelComment"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}},{"kind":"Argument","name":{"kind":"Name","value":"message"},"value":{"kind":"Variable","name":{"kind":"Name","value":"message"}}},{"kind":"Argument","name":{"kind":"Name","value":"plainText"},"value":{"kind":"Variable","name":{"kind":"Name","value":"plainText"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"bimdata"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"camera"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"modelId"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"message"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"plainText"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"createdAt"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":305}};
    doc.loc.source = {"body":"mutation UpdateModelComment($id: Int!, $message: String!, $plainText: String!) {\r\n    updateModelComment(id: $id, message: $message, plainText: $plainText) {\r\n        id\r\n        bimdata\r\n        camera\r\n        modelId\r\n        message\r\n        plainText\r\n        createdAt\r\n        updatedAt\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["UpdateModelComment"] = oneQuery(doc, "UpdateModelComment");
        


/***/ }),

/***/ "./10api/graphql/UploadModel.gql":
/*!***************************************!*\
  !*** ./10api/graphql/UploadModel.gql ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UploadModel"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"name"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"filenames"}},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"cvtOptions"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"uploadModel"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"folderId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"folderId"}}},{"kind":"Argument","name":{"kind":"Name","value":"name"},"value":{"kind":"Variable","name":{"kind":"Name","value":"name"}}},{"kind":"Argument","name":{"kind":"Name","value":"filenames"},"value":{"kind":"Variable","name":{"kind":"Name","value":"filenames"}}},{"kind":"Argument","name":{"kind":"Name","value":"cvtOptions"},"value":{"kind":"Variable","name":{"kind":"Name","value":"cvtOptions"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"uploadUrls"},"arguments":[],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"filename"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"url"},"arguments":[],"directives":[]}]}}]}}]}}],"loc":{"start":0,"end":296}};
    doc.loc.source = {"body":"mutation UploadModel($folderId: Int!, $name: String!, $filenames: [String]!, $cvtOptions: String) {\r\n    uploadModel(folderId: $folderId, name: $name, filenames: $filenames, cvtOptions: $cvtOptions) {\r\n        id\r\n        uploadUrls {\r\n            filename\r\n            url\r\n        }\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["UploadModel"] = oneQuery(doc, "UploadModel");
        


/***/ }),

/***/ "./10api/graphql/UploadModelSuccess.gql":
/*!**********************************************!*\
  !*** ./10api/graphql/UploadModelSuccess.gql ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    var doc = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UploadModelSuccess"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Id"}}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"uploadModelSuccess"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"modelId"}}}],"directives":[],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"folderId"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"name"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"status"},"arguments":[],"directives":[]},{"kind":"Field","name":{"kind":"Name","value":"filenames"},"arguments":[],"directives":[]}]}}]}}],"loc":{"start":0,"end":175}};
    doc.loc.source = {"body":"mutation UploadModelSuccess($modelId: Id!) {\r\n    uploadModelSuccess(id: $modelId) {\r\n        id\r\n        folderId\r\n        name\r\n        status\r\n        filenames\r\n    }\r\n}\r\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};
  

    var names = {};
    function unique(defs) {
      return defs.filter(
        function(def) {
          if (def.kind !== 'FragmentDefinition') return true;
          var name = def.name.value
          if (names[name]) {
            return false;
          } else {
            names[name] = true;
            return true;
          }
        }
      )
    }
  

    // Collect any fragment/type references from a node, adding them to the refs Set
    function collectFragmentReferences(node, refs) {
      if (node.kind === "FragmentSpread") {
        refs.add(node.name.value);
      } else if (node.kind === "VariableDefinition") {
        var type = node.type;
        if (type.kind === "NamedType") {
          refs.add(type.name.value);
        }
      }

      if (node.selectionSet) {
        node.selectionSet.selections.forEach(function(selection) {
          collectFragmentReferences(selection, refs);
        });
      }

      if (node.variableDefinitions) {
        node.variableDefinitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }

      if (node.definitions) {
        node.definitions.forEach(function(def) {
          collectFragmentReferences(def, refs);
        });
      }
    }

    var definitionRefs = {};
    (function extractReferences() {
      doc.definitions.forEach(function(def) {
        if (def.name) {
          var refs = new Set();
          collectFragmentReferences(def, refs);
          definitionRefs[def.name.value] = refs;
        }
      });
    })();

    function findOperation(doc, name) {
      for (var i = 0; i < doc.definitions.length; i++) {
        var element = doc.definitions[i];
        if (element.name && element.name.value == name) {
          return element;
        }
      }
    }

    function oneQuery(doc, operationName) {
      // Copy the DocumentNode, but clear out the definitions
      var newDoc = {
        kind: doc.kind,
        definitions: [findOperation(doc, operationName)]
      };
      if (doc.hasOwnProperty("loc")) {
        newDoc.loc = doc.loc;
      }

      // Now, for the operation we're running, find any fragments referenced by
      // it or the fragments it references
      var opRefs = definitionRefs[operationName] || new Set();
      var allRefs = new Set();
      var newRefs = new Set(opRefs);
      while (newRefs.size > 0) {
        var prevRefs = newRefs;
        newRefs = new Set();

        prevRefs.forEach(function(refName) {
          if (!allRefs.has(refName)) {
            allRefs.add(refName);
            var childRefs = definitionRefs[refName] || new Set();
            childRefs.forEach(function(childRef) {
              newRefs.add(childRef);
            });
          }
        });
      }

      allRefs.forEach(function(refName) {
        var op = findOperation(doc, refName);
        if (op) {
          newDoc.definitions.push(op);
        }
      });

      return newDoc;
    }

    module.exports = doc;
    
        module.exports["UploadModelSuccess"] = oneQuery(doc, "UploadModelSuccess");
        


/***/ }),

/***/ "./10api/model/Comment.ts":
/*!********************************!*\
  !*** ./10api/model/Comment.ts ***!
  \********************************/
/*! exports provided: createComment, deleteComment, updateComment, getComments, activateComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createComment", function() { return createComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteComment", function() { return deleteComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateComment", function() { return updateComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComments", function() { return getComments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activateComment", function() { return activateComment; });
/* harmony import */ var _utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/client */ "./10api/utils/client/index.ts");
/* harmony import */ var _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../08ui/tool/Comment */ "./08ui/tool/Comment.ts");
/**
 * @fileoverview comment.ts - The model comment. It contains a subject, a message, a camera dump and some associated user data.
 * @author Modelo, Inc
 * @version 0.0.1
 *
 * Copyright Modelo XX - 2018, All rights reserved.
 */


function createComment(modelId, subject, text, userData, onSuccess, onFail, viewer, x, y) {
    var commentRenderData = null;
    if (viewer) {
        var commentTool = viewer.getTool("Comment");
        if (!commentTool) {
            commentTool = viewer.addTool(new _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_1__["default"](viewer));
        }
        commentRenderData = commentTool.create(x, y);
    }
    var renderData = JSON.stringify(commentRenderData);
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["addModelComment"](modelId, subject, text, renderData, userData)
        .then(function (commentId) {
        if (viewer) {
            var commentTool = viewer.getTool("Comment");
            if (!commentTool) {
                commentTool = viewer.addTool(new _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_1__["default"](viewer));
            }
            var comment1 = {
                'id': commentId,
                'renderData': renderData
            };
            commentTool.addComment(comment1);
        }
        onSuccess(commentId);
    })
        .catch(function (e) { return onFail(e.message); });
}
function deleteComment(commentId, onSuccess, onFail, viewer) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["deleteModelComment"](commentId)
        .then(function (commentId) {
        onSuccess(commentId);
        if (viewer) {
            var commentTool = viewer.getTool("Comment");
            if (!commentTool) {
                commentTool = viewer.addTool(new _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_1__["default"](viewer));
            }
            commentTool.deleteComment(commentId);
            commentTool.setEnabled(true);
        }
    })
        .catch(function (e) { return onFail(e.message); });
}
function updateComment(commentId, subject, message, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["updateModelComment"](commentId, subject, message)
        .then(function (commentId) { return onSuccess(commentId); })
        .catch(function (e) { return onFail(e.message); });
}
function getComments(modelId, onSuccess, onFail, viewer) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["getModelComments"](modelId)
        .then(function (comments) {
        var decodedComments = comments.map(function (comment) {
            return {
                "id": comment.id,
                "subject": comment.plainText,
                "message": comment.message,
                "renderData": JSON.parse(comment.camera),
                "userData": comment.bimdata,
                "createdAt": comment.createdAt
            };
        });
        if (viewer) {
            var commentTool = viewer.getTool("Comment");
            if (!commentTool) {
                commentTool = viewer.addTool(new _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_1__["default"](viewer));
            }
            commentTool.setComments(decodedComments);
            commentTool.setEnabled(true);
        }
        onSuccess(decodedComments);
    })
        .catch(function (e) { return onFail(e.message); });
}
function activateComment(comment, viewer) {
    if (comment["renderData"]) {
        var commentTool = viewer.getTool("Comment");
        if (!commentTool) {
            commentTool = viewer.addTool(new _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_1__["default"](viewer));
        }
        commentTool.activate(comment.id);
        commentTool.setEnabled(true);
    }
    else {
        console.warn("Corrupted comment data.");
    }
}


/***/ }),

/***/ "./10api/model/Model.ts":
/*!******************************!*\
  !*** ./10api/model/Model.ts ***!
  \******************************/
/*! exports provided: query, remove, update, upload, merge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "query", function() { return query; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upload", function() { return upload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony import */ var _utils_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/client */ "./10api/utils/client/index.ts");

/**
    * Get information of the model with given id.
    * @param {string} modelId
    * @param {function} onSuccess
    * @param {function} onFail
    */
function query(modelId, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["getModel"](modelId)
        .then(function (model) { return onSuccess(model); })
        .catch(function (e) { return onFail(e.message); });
}
/**
    * Remove a model from its project and folder.
    * @param {string} modelId
    * @param {string} onSuccess
    * @param {string} onFail
    */
function remove(modelId, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["deleteModel"](modelId)
        .then(function () { return onSuccess(modelId); })
        .catch(function (e) { return onFail && onFail(e.message); });
}
/**
* Update the information of a model including name, description, created date and so on.
* @param {string} projectId
* @param {Information} information The new project information, e.g., name.
* @param {function} onSuccess
* @param {function} onFail
*/
function update(modelId, name, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["updateModel"](modelId, name)
        .then(function () { return onSuccess(modelId); })
        .catch(function (e) { return onFail(e.message); });
}
/**
    * Upload a model.
    * @param modelId
    */
function upload(file, onSuccess, onProgress, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["uploadModel"](file, onProgress)
        .then(function (modelId) { return onSuccess(modelId); })
        .catch(function (e) { return onFail && onFail(e.message); });
}
function merge(name, modelIds, onSuccess, onFail) {
    _utils_client__WEBPACK_IMPORTED_MODULE_0__["mergeModel"](name, modelIds)
        .then(function (modelId) { return onSuccess(modelId); })
        .catch(function (e) { return onFail && onFail(e.message); });
}
// export function combine(
//     name: string,
//     modelIds: string[],
//     onSuccess: (combinedModelId: number) => void,
//     onFail: (errmsg: string) => void
// ) {
//     client
//         .combineModel(name, modelIds)
//         .then(combinedModel => {
//             onSuccess(combinedModel.id);
//         })
//         .catch((e: Error) => onFail && onFail(e.message));
// }


/***/ }),

/***/ "./10api/model/index.ts":
/*!******************************!*\
  !*** ./10api/model/index.ts ***!
  \******************************/
/*! exports provided: query, remove, update, upload, merge, createComment, deleteComment, updateComment, getComments, activateComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model */ "./10api/model/Model.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "query", function() { return _Model__WEBPACK_IMPORTED_MODULE_0__["query"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return _Model__WEBPACK_IMPORTED_MODULE_0__["remove"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "update", function() { return _Model__WEBPACK_IMPORTED_MODULE_0__["update"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "upload", function() { return _Model__WEBPACK_IMPORTED_MODULE_0__["upload"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _Model__WEBPACK_IMPORTED_MODULE_0__["merge"]; });

/* harmony import */ var _Comment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Comment */ "./10api/model/Comment.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createComment", function() { return _Comment__WEBPACK_IMPORTED_MODULE_1__["createComment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deleteComment", function() { return _Comment__WEBPACK_IMPORTED_MODULE_1__["deleteComment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "updateComment", function() { return _Comment__WEBPACK_IMPORTED_MODULE_1__["updateComment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getComments", function() { return _Comment__WEBPACK_IMPORTED_MODULE_1__["getComments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "activateComment", function() { return _Comment__WEBPACK_IMPORTED_MODULE_1__["activateComment"]; });





/***/ }),

/***/ "./10api/modeloAPI.ts":
/*!****************************!*\
  !*** ./10api/modeloAPI.ts ***!
  \****************************/
/*! exports provided: Auth, Model, BIM, View, isSupportWebGL, isSupportWebGL2, init */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View", function() { return View; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony import */ var _types_graphql_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/graphql/types */ "./10api/types/graphql/types.ts");
/* harmony import */ var _types_graphql_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_types_graphql_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _view_MaterialBasic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view/MaterialBasic */ "./10api/view/MaterialBasic.ts");
/* harmony import */ var _view_Drawable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view/Drawable */ "./10api/view/Drawable.ts");
/* harmony import */ var _view_GeometryCube__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view/GeometryCube */ "./10api/view/GeometryCube.ts");
/* harmony import */ var _08ui_input_Mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../08ui/input/Mouse */ "./08ui/input/Mouse.ts");
/* harmony import */ var _08ui_input_Keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../08ui/input/Keyboard */ "./08ui/input/Keyboard.ts");
/* harmony import */ var _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../03scene/drawables/m3d_skybox.js */ "./03scene/drawables/m3d_skybox.js");
/* harmony import */ var _Viewer3D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Viewer3D */ "./10api/Viewer3D.ts");
/* harmony import */ var _Viewer360__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Viewer360 */ "./10api/Viewer360.ts");
/* harmony import */ var _Viewer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Viewer */ "./10api/Viewer.ts");
/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Auth */ "./10api/Auth.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Auth", function() { return _Auth__WEBPACK_IMPORTED_MODULE_10__; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./config */ "./10api/config.ts");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./model */ "./10api/model/index.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Model", function() { return _model__WEBPACK_IMPORTED_MODULE_12__; });
/* harmony import */ var _BIM__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./BIM */ "./10api/BIM.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "BIM", function() { return _BIM__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Utils */ "./10api/Utils.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSupportWebGL", function() { return _Utils__WEBPACK_IMPORTED_MODULE_14__["isSupportWebGL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSupportWebGL2", function() { return _Utils__WEBPACK_IMPORTED_MODULE_14__["isSupportWebGL2"]; });

/* harmony import */ var _08ui_tool_Section__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../08ui/tool/Section */ "./08ui/tool/Section.ts");
/* harmony import */ var _08ui_tool_MagnifyGlass__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../08ui/tool/MagnifyGlass */ "./08ui/tool/MagnifyGlass.ts");
/* harmony import */ var _08ui_tool_SelectElements__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../08ui/tool/SelectElements */ "./08ui/tool/SelectElements.ts");
/* harmony import */ var _08ui_tool_CameraManipulator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../08ui/tool/CameraManipulator */ "./08ui/tool/CameraManipulator.ts");
/* harmony import */ var _08ui_tool_InAppNavigation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../08ui/tool/InAppNavigation */ "./08ui/tool/InAppNavigation.ts");
/* harmony import */ var _08ui_tool_TransformGizmo__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../08ui/tool/TransformGizmo */ "./08ui/tool/TransformGizmo.ts");
/* harmony import */ var _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../08ui/tool/Comment */ "./08ui/tool/Comment.ts");
/* harmony import */ var _08ui_tool_SelectModel__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../08ui/tool/SelectModel */ "./08ui/tool/SelectModel.ts");
/* harmony import */ var _08ui_tool_MeasureLines__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../08ui/tool/MeasureLines */ "./08ui/tool/MeasureLines.ts");
/* harmony import */ var _08ui_tool_MeasureLine__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../08ui/tool/MeasureLine */ "./08ui/tool/MeasureLine.ts");
/* harmony import */ var _08ui_tool_MeasureLineStrip__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../08ui/tool/MeasureLineStrip */ "./08ui/tool/MeasureLineStrip.ts");
/* harmony import */ var _08ui_tool_MeasureLineFan__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../08ui/tool/MeasureLineFan */ "./08ui/tool/MeasureLineFan.ts");
/* harmony import */ var _08ui_tool_MeasureAngle__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../08ui/tool/MeasureAngle */ "./08ui/tool/MeasureAngle.ts");
/* harmony import */ var _08ui_tool_MeasureArea__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../08ui/tool/MeasureArea */ "./08ui/tool/MeasureArea.ts");
/**
 * @hidden
 */

/**
 * @ignore
 */






/**
 * @ignore
 */



/**
 * @ignore
 */


var init = function (newConfig) {
    Object(_config__WEBPACK_IMPORTED_MODULE_11__["setConfig"])(newConfig);
};
/**
 * @ignore
 */

/**
 * @ignore
 */

/**
 * @ignore
 */

/**
 * @ignore
 */














/**
 * @hidden
 */
var Tool = {
    MeasureLines: _08ui_tool_MeasureLines__WEBPACK_IMPORTED_MODULE_23__["default"],
    MeasureLine: _08ui_tool_MeasureLine__WEBPACK_IMPORTED_MODULE_24__["default"],
    MeasureLineStrip: _08ui_tool_MeasureLineStrip__WEBPACK_IMPORTED_MODULE_25__["default"],
    MeasureLineFan: _08ui_tool_MeasureLineFan__WEBPACK_IMPORTED_MODULE_26__["default"],
    MeasureAngle: _08ui_tool_MeasureAngle__WEBPACK_IMPORTED_MODULE_27__["default"],
    MeasureArea: _08ui_tool_MeasureArea__WEBPACK_IMPORTED_MODULE_28__["default"],
    Section: _08ui_tool_Section__WEBPACK_IMPORTED_MODULE_15__["default"],
    MagnifyGlass: _08ui_tool_MagnifyGlass__WEBPACK_IMPORTED_MODULE_16__["default"],
    SelectElements: _08ui_tool_SelectElements__WEBPACK_IMPORTED_MODULE_17__["default"],
    CameraManipulator: _08ui_tool_CameraManipulator__WEBPACK_IMPORTED_MODULE_18__["default"],
    InAppNavigation: _08ui_tool_InAppNavigation__WEBPACK_IMPORTED_MODULE_19__["default"],
    TransformGizmo: _08ui_tool_TransformGizmo__WEBPACK_IMPORTED_MODULE_20__["default"],
    Comment: _08ui_tool_Comment__WEBPACK_IMPORTED_MODULE_21__["default"],
    SelectModel: _08ui_tool_SelectModel__WEBPACK_IMPORTED_MODULE_22__["default"]
};
/**
 * hidden
 */
var Input = {
    Mouse: _08ui_input_Mouse__WEBPACK_IMPORTED_MODULE_4__["default"],
    Keyboard: _08ui_input_Keyboard__WEBPACK_IMPORTED_MODULE_5__["default"],
};
/**
 * hidden
 */
var Scene3D = {
    MaterialBasic: _view_MaterialBasic__WEBPACK_IMPORTED_MODULE_1__["default"],
    GeometryCube: _view_GeometryCube__WEBPACK_IMPORTED_MODULE_3__["default"],
    Drawable: _view_Drawable__WEBPACK_IMPORTED_MODULE_2__["default"],
};
/**
 * hidden
 */
var View = {
    State: _Viewer__WEBPACK_IMPORTED_MODULE_9__["State"],
    ViewAngle: _Utils__WEBPACK_IMPORTED_MODULE_14__["ViewAngle"],
    Viewer3D: _Viewer3D__WEBPACK_IMPORTED_MODULE_7__["default"],
    Viewer360: _Viewer360__WEBPACK_IMPORTED_MODULE_8__["default"],
    Scene3D: Scene3D,
    Input: Input,
    Tool: Tool,
    BACKGROUND_SOLIDCOLOR: _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_6__["default"].SKYBOX_SOLIDCOLOR,
    BACKGROUND_WALLPAPER: _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_6__["default"].SKYBOX_WALLPAPER,
    BACKGROUND_EQUIRECTANGLE: _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_6__["default"].SKYBOX_EQUIRECTANGLE,
    BACKGROUND_CUBEMAP: _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_6__["default"].SKYBOX_CUBEMAP,
    BACKGROUND_WALLPAPER_TILED: _03scene_drawables_m3d_skybox_js__WEBPACK_IMPORTED_MODULE_6__["default"].SKYBOX_WALLPAPER_TILED
};
/**
 * @hidden
 */



/***/ }),

/***/ "./10api/types/graphql/types.ts":
/*!**************************************!*\
  !*** ./10api/types/graphql/types.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @hidden */
var GQL;
(function (GQL) {
    /** @hidden */
    var AssetType;
    (function (AssetType) {
        AssetType["wbs"] = "wbs";
        AssetType["img"] = "img";
        AssetType["file"] = "file";
        AssetType["dwg"] = "dwg";
    })(AssetType = GQL.AssetType || (GQL.AssetType = {}));
    /** @hidden */
    var TaskPriority;
    (function (TaskPriority) {
        TaskPriority["urgent"] = "urgent";
        TaskPriority["critical"] = "critical";
        TaskPriority["normal"] = "normal";
    })(TaskPriority = GQL.TaskPriority || (GQL.TaskPriority = {}));
    /** @hidden */
    var TaskCommentType;
    (function (TaskCommentType) {
        TaskCommentType["img"] = "img";
        TaskCommentType["txt"] = "txt";
    })(TaskCommentType = GQL.TaskCommentType || (GQL.TaskCommentType = {}));
    /** @hidden */
    var IssuePriority;
    (function (IssuePriority) {
        IssuePriority["urgent"] = "urgent";
        IssuePriority["critical"] = "critical";
        IssuePriority["normal"] = "normal";
    })(IssuePriority = GQL.IssuePriority || (GQL.IssuePriority = {}));
    /** @hidden */
    var IssueStatus;
    (function (IssueStatus) {
        IssueStatus["open"] = "open";
        IssueStatus["inProgress"] = "inProgress";
        IssueStatus["resolved"] = "resolved";
        IssueStatus["bot"] = "bot";
    })(IssueStatus = GQL.IssueStatus || (GQL.IssueStatus = {}));
    /** @hidden */
    var ModelType;
    (function (ModelType) {
        ModelType["normal"] = "normal";
        ModelType["versioned"] = "versioned";
        ModelType["partial"] = "partial";
    })(ModelType = GQL.ModelType || (GQL.ModelType = {}));
    /** @hidden */
    var ModelStatus;
    (function (ModelStatus) {
        ModelStatus["ERROR"] = "ERROR";
        ModelStatus["INIT"] = "INIT";
        ModelStatus["UPLOADED"] = "UPLOADED";
        ModelStatus["CONVERTED"] = "CONVERTED";
    })(ModelStatus = GQL.ModelStatus || (GQL.ModelStatus = {}));
    /** @hidden */
    var SelectionType;
    (function (SelectionType) {
        SelectionType["elementId"] = "elementId";
        SelectionType["type"] = "type";
        SelectionType["family"] = "family";
        SelectionType["category"] = "category";
        SelectionType["level"] = "level";
    })(SelectionType = GQL.SelectionType || (GQL.SelectionType = {}));
    /** @hidden */
    var AssetStatus;
    (function (AssetStatus) {
        AssetStatus["ERROR"] = "ERROR";
        AssetStatus["INIT"] = "INIT";
        AssetStatus["UPLOADED"] = "UPLOADED";
        AssetStatus["CONVERTED"] = "CONVERTED";
    })(AssetStatus = GQL.AssetStatus || (GQL.AssetStatus = {}));
    /** @hidden */
    var WechatMessageType;
    (function (WechatMessageType) {
        WechatMessageType["txt"] = "txt";
        WechatMessageType["img"] = "img";
        WechatMessageType["file"] = "file";
    })(WechatMessageType = GQL.WechatMessageType || (GQL.WechatMessageType = {}));
})(GQL || (GQL = {}));
window.GQL = GQL;


/***/ }),

/***/ "./10api/utils/IBimTree.ts":
/*!*********************************!*\
  !*** ./10api/utils/IBimTree.ts ***!
  \*********************************/
/*! exports provided: BimTreeNodeType, TypesInfoBySpaces, normaliseBimTextTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BimTreeNodeType", function() { return BimTreeNodeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypesInfoBySpaces", function() { return TypesInfoBySpaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normaliseBimTextTree", function() { return normaliseBimTextTree; });
var BimTreeNodeType;
(function (BimTreeNodeType) {
    BimTreeNodeType["Family"] = "family";
    BimTreeNodeType["Level"] = "level";
    BimTreeNodeType["Element"] = "element";
    BimTreeNodeType["Category"] = "category";
    BimTreeNodeType["Type"] = "type";
    BimTreeNodeType["File"] = "file";
})(BimTreeNodeType || (BimTreeNodeType = {}));
var TypesInfoBySpaces = [
    { type: BimTreeNodeType.File, idLabel: "modelId", container: "models" },
    { type: BimTreeNodeType.Level, idLabel: "levelId", container: "levels" },
    { type: BimTreeNodeType.Category, idLabel: "categoryId", container: "categories" },
    { type: BimTreeNodeType.Family, idLabel: "familyId", container: "families" },
    { type: BimTreeNodeType.Type, idLabel: "typeId", container: "types" },
    { type: BimTreeNodeType.Element, idLabel: "elementId", container: "elements" }
];
function normaliseBimTextTree(modelId, models, reference, 
// TODO remove useElementIdAsId in the future
options) {
    if (options === void 0) { 
    // TODO remove useElementIdAsId in the future
    options = {
        parseProps: false,
        useElementIdAsId: false,
        onlyDocNames: false,
        ignoreElements: false,
        modelId: null,
        docModelId: null,
        prependModelId: false
    }; }
    // parse reference data
    var referenceLines = reference.split("\n").splice(1);
    var referenceData = {};
    referenceLines.forEach(function (l) {
        var _a = l.split(","), index = _a[0], docId = _a[1], cat = _a[2];
        if (docId && cat) {
            referenceData[docId + "-" + cat.trim()] = index;
        }
    });
    var idCnt = 1;
    var indexCnt = 1;
    var prependId = options.prependModelId ? options.modelId + "+" : "";
    var parseProps = !!options.parseProps;
    var useElementIdAsId = !!options.useElementIdAsId;
    var newBimData = {
        elements: {},
        types: {},
        families: {},
        levels: {},
        models: {},
        categories: {}
    };
    var lines = models.split("\n");
    var lastElementsByIndex = [null, null, null, null, null];
    if (options.onlyDocNames) {
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (line.length === 0 || line.charAt(0) === " ")
                continue;
            var _a = lines[0].match(/(.*)\((\d)\)$/), name_1 = _a[0], docName = _a[1], docId = _a[2];
            newBimData.models[prependId + docId] = {
                type: BimTreeNodeType.File,
                index: 0,
                id: prependId + docId,
                name: "",
                childrenNum: 0,
                isTerrain: true,
                levels: [],
                pathName: name_1 + "(" + docId + ")"
            };
        }
        return newBimData;
    }
    lines.forEach(function (bimNodeName) {
        var typeIndex = 0;
        while (bimNodeName.charAt(0) === " " && bimNodeName.length > 0) {
            typeIndex++;
            bimNodeName = bimNodeName.substr(1);
        }
        // weird bug caused by bim.txt containing secret chars
        bimNodeName = bimNodeName.trim();
        var typeInfo = TypesInfoBySpaces[typeIndex];
        var node = {
            type: typeInfo.type,
            index: indexCnt++,
            id: prependId + typeInfo.idLabel + "-" + idCnt++,
            name: bimNodeName || "undefined",
            pathName: bimNodeName || "",
            childrenNum: 0
        };
        if (typeInfo.type === BimTreeNodeType.File) {
            if (!bimNodeName) {
                return;
            }
            bimNodeName = bimNodeName.slice(0, -1);
            var lastParen = bimNodeName.lastIndexOf("(");
            if (lastParen !== -1) {
                var docId = bimNodeName.substring(lastParen + 1);
                node.id = prependId + docId;
                node.docId = docId;
                node.name = bimNodeName.substring(0, lastParen);
                node.originModelId = options.docModelId ? parseInt(options.docModelId[docId]) : options.modelId;
                node.pathName = node.name + "(" + node.docId + ")";
            }
            else {
                throw new Error("Not a valid bim.txt");
            }
        }
        if (typeInfo.type === BimTreeNodeType.Element) {
            if (options.ignoreElements) {
                return;
            }
            node.modelId = modelId;
            node.props = "{}";
            var model = lastElementsByIndex[0];
            var cat = lastElementsByIndex[2];
            node.docAndCatId = parseInt(referenceData[model.docId + "-" + cat.name]);
            node.docId = model.docId;
            if (useElementIdAsId) {
                node.id = prependId + (model.docId + "/" + bimNodeName);
            }
            node.elementId = "" + bimNodeName;
        }
        else {
            var chileType = TypesInfoBySpaces[typeIndex + 1];
            node[chileType.container] = [];
        }
        if (typeInfo.type !== BimTreeNodeType.File) {
            var parentType = TypesInfoBySpaces[typeIndex - 1];
            var parent_1 = lastElementsByIndex[typeIndex - 1];
            parent_1[typeInfo.container].push(node.id);
            parent_1.childrenNum += 1;
            node[parentType.idLabel] = parent_1.id;
        }
        if (typeInfo.type === BimTreeNodeType.Family) {
            node.levelId = lastElementsByIndex[1].id;
        }
        lastElementsByIndex[typeIndex] = node;
        newBimData[typeInfo.container][node.id] = node;
    });
    return newBimData;
}


/***/ }),

/***/ "./10api/utils/client/BIMProperty.ts":
/*!*******************************************!*\
  !*** ./10api/utils/client/BIMProperty.ts ***!
  \*******************************************/
/*! exports provided: getElementProperties, updateElementProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElementProperties", function() { return getElementProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateElementProperty", function() { return updateElementProperty; });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ "./10api/utils/model/index.ts");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ "./10api/utils/client/model.ts");
/* harmony import */ var _BIMTree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BIMTree */ "./10api/utils/client/BIMTree.ts");
/* harmony import */ var _graphql_GetElementProperties_gql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../graphql/GetElementProperties.gql */ "./10api/graphql/GetElementProperties.gql");
/* harmony import */ var _graphql_GetElementProperties_gql__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_graphql_GetElementProperties_gql__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _graphql_UpdateElementProperty_gql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../graphql/UpdateElementProperty.gql */ "./10api/graphql/UpdateElementProperty.gql");
/* harmony import */ var _graphql_UpdateElementProperty_gql__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_graphql_UpdateElementProperty_gql__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _propertyGroups_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../propertyGroups.json */ "./10api/utils/propertyGroups.json");
var _propertyGroups_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../propertyGroups.json */ "./10api/utils/propertyGroups.json", 1);
/* harmony import */ var _gqlClient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gqlClient */ "./10api/utils/client/gqlClient.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = undefined;







var getElementProperties = function (modelId, elementId) { return __awaiter(_this, void 0, void 0, function () {
    var BIMTree, model, unitJSON, unitData, element, units, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Object(_BIMTree__WEBPACK_IMPORTED_MODULE_2__["getBimTree"])(modelId)];
            case 1:
                BIMTree = _a.sent();
                return [4 /*yield*/, Object(_model__WEBPACK_IMPORTED_MODULE_1__["getModelFiles"])(modelId)];
            case 2:
                model = _a.sent();
                unitJSON = model.convertedUrls.filter(function (f) { return f.filename === "unit.json"; })[0];
                if (!unitJSON) {
                    throw Error("this model does not contain unit.json");
                }
                return [4 /*yield*/, Object(_model__WEBPACK_IMPORTED_MODULE_0__["downloadFile"])(modelId, unitJSON)];
            case 3:
                unitData = (_a.sent()).data;
                element = Object.keys(BIMTree.elements)
                    .map(function (k) { return BIMTree.elements[k]; })
                    .filter(function (ele) { return ele.elementId === elementId + ""; })[0];
                units = unitData[element.docId];
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_6__["getGQLClient"])().query({
                        query: _graphql_GetElementProperties_gql__WEBPACK_IMPORTED_MODULE_3___default.a,
                        variables: {
                            modelId: modelId,
                            docAndCatId: element.docAndCatId,
                            elementId: elementId
                        }
                    })];
            case 4:
                data = (_a.sent()).data;
                return [2 /*return*/, data.elementProperties.map(function (prop) {
                        var property = prop.property, numValue = prop.numValue, strValue = prop.strValue;
                        var _a = property.split("@"), key = _a[0], groupKey = _a[1];
                        var group = _propertyGroups_json__WEBPACK_IMPORTED_MODULE_5__[groupKey];
                        return {
                            key: key,
                            group: group,
                            groupKey: parseInt(groupKey),
                            strValue: strValue,
                            numValue: numValue,
                            unit: units[key] || null
                        };
                    })];
        }
    });
}); };
var updateElementProperty = function (modelId, elementId, property) { return __awaiter(_this, void 0, void 0, function () {
    var BIMTree, element;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Object(_BIMTree__WEBPACK_IMPORTED_MODULE_2__["getBimTree"])(modelId)];
            case 1:
                BIMTree = _a.sent();
                element = Object.keys(BIMTree.elements)
                    .map(function (k) { return BIMTree.elements[k]; })
                    .filter(function (ele) { return ele.elementId === elementId + ""; })[0];
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_6__["getGQLClient"])().mutate({
                        mutation: _graphql_UpdateElementProperty_gql__WEBPACK_IMPORTED_MODULE_4___default.a,
                        variables: {
                            modelId: modelId,
                            docAndCatId: element.docAndCatId,
                            elementId: elementId,
                            property: property.name + "@" + property.groupKey,
                            strValue: property.strValue,
                            numValue: property.numValue
                        }
                    })];
            case 2:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };


/***/ }),

/***/ "./10api/utils/client/BIMTree.ts":
/*!***************************************!*\
  !*** ./10api/utils/client/BIMTree.ts ***!
  \***************************************/
/*! exports provided: getBimTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBimTree", function() { return getBimTree; });
/* harmony import */ var _IBimTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../IBimTree */ "./10api/utils/IBimTree.ts");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ "./10api/utils/client/model.ts");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model */ "./10api/utils/model/index.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var cache = {};
function getBimTree(modelId) {
    return __awaiter(this, void 0, void 0, function () {
        var model, bimTxt, referenceCsv, docModelIdFile, docModelId, _a, data, reference, bimData;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (cache[modelId]) {
                        return [2 /*return*/, cache[modelId]];
                    }
                    return [4 /*yield*/, Object(_model__WEBPACK_IMPORTED_MODULE_1__["getModelFiles"])(modelId)];
                case 1:
                    model = _b.sent();
                    bimTxt = model.convertedUrls.filter(function (f) { return f.filename === "bim.txt"; })[0];
                    if (!bimTxt) {
                        throw new Error("this model does not contain bim tree information");
                    }
                    referenceCsv = model.convertedUrls.filter(function (f) { return f.filename === "reference.csv"; })[0];
                    if (!referenceCsv) {
                        throw new Error("this model does not contain reference.csv");
                    }
                    docModelIdFile = model.convertedUrls.find(function (file) { return file.filename === "docModelId.json"; });
                    if (!docModelIdFile) return [3 /*break*/, 3];
                    return [4 /*yield*/, Object(_model__WEBPACK_IMPORTED_MODULE_2__["downloadFile"])(modelId, docModelIdFile)];
                case 2:
                    _a = (_b.sent()).data;
                    return [3 /*break*/, 4];
                case 3:
                    _a = null;
                    _b.label = 4;
                case 4:
                    docModelId = _a;
                    return [4 /*yield*/, Object(_model__WEBPACK_IMPORTED_MODULE_2__["downloadFile"])(modelId, bimTxt)];
                case 5:
                    data = (_b.sent()).data;
                    return [4 /*yield*/, Object(_model__WEBPACK_IMPORTED_MODULE_2__["downloadFile"])(modelId, referenceCsv)];
                case 6:
                    reference = (_b.sent()).data;
                    bimData = Object(_IBimTree__WEBPACK_IMPORTED_MODULE_0__["normaliseBimTextTree"])(modelId, data, reference, {
                        useElementIdAsId: true,
                        docModelId: docModelId,
                        modelId: modelId
                    });
                    cache[modelId] = bimData;
                    return [2 /*return*/, bimData];
            }
        });
    });
}


/***/ }),

/***/ "./10api/utils/client/auth.ts":
/*!************************************!*\
  !*** ./10api/utils/client/auth.ts ***!
  \************************************/
/*! exports provided: signIn, signOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signIn", function() { return signIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signOut", function() { return signOut; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./10api/config.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = undefined;


function decodeToken(token) {
    return decodeURIComponent(escape(window.atob(token)));
}
var signIn = function (applicationToken, options) { return __awaiter(_this, void 0, void 0, function () {
    var decodedToken, _a, username, password, res;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!_config__WEBPACK_IMPORTED_MODULE_1__["default"].endpoint) {
                    throw Error("ModeloAPI needs to be initialized first. Call Modelo.init().");
                }
                decodedToken = decodeToken(applicationToken);
                _a = decodedToken.split(","), username = _a[0], password = _a[1];
                return [4 /*yield*/, axios__WEBPACK_IMPORTED_MODULE_0___default.a.post(_config__WEBPACK_IMPORTED_MODULE_1__["default"].endpoint + "/login", { username: username, password: password })];
            case 1:
                res = _b.sent();
                localStorage.setItem("token", res.data.token);
                return [2 /*return*/];
        }
    });
}); };
var signOut = function () { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        localStorage.removeItem("token");
        return [2 /*return*/];
    });
}); };


/***/ }),

/***/ "./10api/utils/client/comment.ts":
/*!***************************************!*\
  !*** ./10api/utils/client/comment.ts ***!
  \***************************************/
/*! exports provided: getModelComments, deleteModelComment, addModelComment, updateModelComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModelComments", function() { return getModelComments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteModelComment", function() { return deleteModelComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addModelComment", function() { return addModelComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateModelComment", function() { return updateModelComment; });
/* harmony import */ var _graphql_GetModelComments_gql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../graphql/GetModelComments.gql */ "./10api/graphql/GetModelComments.gql");
/* harmony import */ var _graphql_GetModelComments_gql__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_graphql_GetModelComments_gql__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _graphql_DeleteModelComment_gql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../graphql/DeleteModelComment.gql */ "./10api/graphql/DeleteModelComment.gql");
/* harmony import */ var _graphql_DeleteModelComment_gql__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_graphql_DeleteModelComment_gql__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _graphql_UpdateModelComment_gql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graphql/UpdateModelComment.gql */ "./10api/graphql/UpdateModelComment.gql");
/* harmony import */ var _graphql_UpdateModelComment_gql__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_graphql_UpdateModelComment_gql__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _graphql_AddModelComment_gql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../graphql/AddModelComment.gql */ "./10api/graphql/AddModelComment.gql");
/* harmony import */ var _graphql_AddModelComment_gql__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_graphql_AddModelComment_gql__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _gqlClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gqlClient */ "./10api/utils/client/gqlClient.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = undefined;





var getModelComments = function (modelId) { return __awaiter(_this, void 0, void 0, function () {
    var _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_4__["getGQLClient"])().query({
                    query: _graphql_GetModelComments_gql__WEBPACK_IMPORTED_MODULE_0___default.a,
                    variables: {
                        modelId: modelId
                    }
                })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (!data.modelComments) {
                    throw Error("model " + modelId + " does not exist");
                }
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, data.modelComments];
        }
    });
}); };
var deleteModelComment = function (id) { return __awaiter(_this, void 0, void 0, function () {
    var _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_4__["getGQLClient"])().mutate({
                    mutation: _graphql_DeleteModelComment_gql__WEBPACK_IMPORTED_MODULE_1___default.a,
                    variables: {
                        id: id
                    }
                })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (!data) {
                    throw Error("comment " + id + " does not exist");
                }
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, id];
        }
    });
}); };
var addModelComment = function (modelId, subject, message, renderData, userData) { return __awaiter(_this, void 0, void 0, function () {
    var plainText, camera, bimdata, _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                plainText = subject;
                camera = renderData;
                bimdata = userData;
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_4__["getGQLClient"])().mutate({
                        mutation: _graphql_AddModelComment_gql__WEBPACK_IMPORTED_MODULE_3___default.a,
                        variables: {
                            message: message,
                            plainText: plainText,
                            bimdata: bimdata,
                            camera: camera,
                            modelId: modelId,
                        }
                    })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (!data) {
                    throw Error("model " + modelId + " does not exist");
                }
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, data.addModelComment.id];
        }
    });
}); };
var updateModelComment = function (id, subject, message) { return __awaiter(_this, void 0, void 0, function () {
    var plainText, _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                plainText = subject;
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_4__["getGQLClient"])().mutate({
                        mutation: _graphql_UpdateModelComment_gql__WEBPACK_IMPORTED_MODULE_2___default.a,
                        variables: {
                            id: id,
                            message: message,
                            plainText: plainText,
                        }
                    })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (!data) {
                    throw Error("comment " + id + " does not exist");
                }
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, id];
        }
    });
}); };


/***/ }),

/***/ "./10api/utils/client/folder.ts":
/*!**************************************!*\
  !*** ./10api/utils/client/folder.ts ***!
  \**************************************/
/*! exports provided: getModelFolder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModelFolder", function() { return getModelFolder; });
/* harmony import */ var _gqlClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gqlClient */ "./10api/utils/client/gqlClient.ts");
/* harmony import */ var _graphql_GetModelFolder_gql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../graphql/GetModelFolder.gql */ "./10api/graphql/GetModelFolder.gql");
/* harmony import */ var _graphql_GetModelFolder_gql__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_graphql_GetModelFolder_gql__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = undefined;


var getModelFolder = function () { return __awaiter(_this, void 0, void 0, function () {
    var _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_0__["getGQLClient"])().query({
                    query: _graphql_GetModelFolder_gql__WEBPACK_IMPORTED_MODULE_1___default.a,
                    variables: {}
                })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, data.user.projects[0].modelFolder];
        }
    });
}); };


/***/ }),

/***/ "./10api/utils/client/gqlClient.ts":
/*!*****************************************!*\
  !*** ./10api/utils/client/gqlClient.ts ***!
  \*****************************************/
/*! exports provided: getGQLClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGQLClient", function() { return getGQLClient; });
/* harmony import */ var apollo_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-client */ "./node_modules/apollo-client/index.js");
/* harmony import */ var apollo_link_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-link-http */ "./node_modules/apollo-link-http/lib/index.js");
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/index.js");
/* harmony import */ var apollo_cache_inmemory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! apollo-cache-inmemory */ "./node_modules/apollo-cache-inmemory/lib/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./10api/config.ts");





var cache = {};
var getGQLClient = function () {
    if (!_config__WEBPACK_IMPORTED_MODULE_4__["default"].endpoint) {
        throw Error("ModeloAPI needs to be initialized first. Call Modelo.init().");
    }
    if (cache["gqlClient"]) {
        return cache["gqlClient"];
    }
    var link = new apollo_link_http__WEBPACK_IMPORTED_MODULE_1__["HttpLink"]({ uri: _config__WEBPACK_IMPORTED_MODULE_4__["default"].endpoint + "/graphql" });
    var auth = new apollo_link__WEBPACK_IMPORTED_MODULE_2__["ApolloLink"](function (operation, forward) {
        operation.setContext({
            headers: {
                "x-access-token": localStorage.getItem("token")
            }
        });
        return forward(operation);
    });
    var client = new apollo_client__WEBPACK_IMPORTED_MODULE_0__["ApolloClient"]({
        link: Object(apollo_link__WEBPACK_IMPORTED_MODULE_2__["concat"])(auth, link),
        cache: new apollo_cache_inmemory__WEBPACK_IMPORTED_MODULE_3__["InMemoryCache"](),
        defaultOptions: {
            watchQuery: {
                fetchPolicy: "cache-and-network",
                errorPolicy: "all"
            },
            query: {
                fetchPolicy: "network-only",
                errorPolicy: "all"
            },
            mutate: {
                errorPolicy: "all"
            }
        }
    });
    cache["gqlClient"] = client;
    return client;
};
//export default new ApolloClient({
//    link: concat(auth, link),
//    cache: new InMemoryCache(),
//    defaultOptions: {
//        watchQuery: {
//            fetchPolicy: "cache-and-network",
//            errorPolicy: "all"
//        },
//        query: {
//            fetchPolicy: "network-only",
//            errorPolicy: "all"
//        },
//        mutate: {
//            errorPolicy: "all"
//        }
//    }
//});


/***/ }),

/***/ "./10api/utils/client/index.ts":
/*!*************************************!*\
  !*** ./10api/utils/client/index.ts ***!
  \*************************************/
/*! exports provided: getModel, getModelFiles, deleteModel, uploadModel, updateModel, combineModel, sliceModel, mergeModel, signIn, signOut, getElementProperties, updateElementProperty, getBimTree, getModelFolder, getModelComments, deleteModelComment, addModelComment, updateModelComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ "./10api/utils/client/model.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["getModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModelFiles", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["getModelFiles"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deleteModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["deleteModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uploadModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["uploadModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "updateModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["updateModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["combineModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sliceModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["sliceModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeModel", function() { return _model__WEBPACK_IMPORTED_MODULE_0__["mergeModel"]; });

/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./auth */ "./10api/utils/client/auth.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "signIn", function() { return _auth__WEBPACK_IMPORTED_MODULE_1__["signIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "signOut", function() { return _auth__WEBPACK_IMPORTED_MODULE_1__["signOut"]; });

/* harmony import */ var _BIMProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BIMProperty */ "./10api/utils/client/BIMProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getElementProperties", function() { return _BIMProperty__WEBPACK_IMPORTED_MODULE_2__["getElementProperties"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "updateElementProperty", function() { return _BIMProperty__WEBPACK_IMPORTED_MODULE_2__["updateElementProperty"]; });

/* harmony import */ var _BIMTree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BIMTree */ "./10api/utils/client/BIMTree.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBimTree", function() { return _BIMTree__WEBPACK_IMPORTED_MODULE_3__["getBimTree"]; });

/* harmony import */ var _folder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./folder */ "./10api/utils/client/folder.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModelFolder", function() { return _folder__WEBPACK_IMPORTED_MODULE_4__["getModelFolder"]; });

/* harmony import */ var _comment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./comment */ "./10api/utils/client/comment.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModelComments", function() { return _comment__WEBPACK_IMPORTED_MODULE_5__["getModelComments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deleteModelComment", function() { return _comment__WEBPACK_IMPORTED_MODULE_5__["deleteModelComment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addModelComment", function() { return _comment__WEBPACK_IMPORTED_MODULE_5__["addModelComment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "updateModelComment", function() { return _comment__WEBPACK_IMPORTED_MODULE_5__["updateModelComment"]; });









/***/ }),

/***/ "./10api/utils/client/model.ts":
/*!*************************************!*\
  !*** ./10api/utils/client/model.ts ***!
  \*************************************/
/*! exports provided: getModel, getModelFiles, deleteModel, uploadModel, updateModel, combineModel, sliceModel, mergeModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModel", function() { return getModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModelFiles", function() { return getModelFiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteModel", function() { return deleteModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadModel", function() { return uploadModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateModel", function() { return updateModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineModel", function() { return combineModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sliceModel", function() { return sliceModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeModel", function() { return mergeModel; });
/* harmony import */ var _graphql_GetModel_gql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../graphql/GetModel.gql */ "./10api/graphql/GetModel.gql");
/* harmony import */ var _graphql_GetModel_gql__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_graphql_GetModel_gql__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _graphql_GetModelFiles_gql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../graphql/GetModelFiles.gql */ "./10api/graphql/GetModelFiles.gql");
/* harmony import */ var _graphql_GetModelFiles_gql__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_graphql_GetModelFiles_gql__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _graphql_DeleteModel_gql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graphql/DeleteModel.gql */ "./10api/graphql/DeleteModel.gql");
/* harmony import */ var _graphql_DeleteModel_gql__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_graphql_DeleteModel_gql__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _graphql_UploadModel_gql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../graphql/UploadModel.gql */ "./10api/graphql/UploadModel.gql");
/* harmony import */ var _graphql_UploadModel_gql__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_graphql_UploadModel_gql__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _graphql_UploadModelSuccess_gql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../graphql/UploadModelSuccess.gql */ "./10api/graphql/UploadModelSuccess.gql");
/* harmony import */ var _graphql_UploadModelSuccess_gql__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_graphql_UploadModelSuccess_gql__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _graphql_UpdateModel_gql__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../graphql/UpdateModel.gql */ "./10api/graphql/UpdateModel.gql");
/* harmony import */ var _graphql_UpdateModel_gql__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_graphql_UpdateModel_gql__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _graphql_AddCombinedModel_gql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../graphql/AddCombinedModel.gql */ "./10api/graphql/AddCombinedModel.gql");
/* harmony import */ var _graphql_AddCombinedModel_gql__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_graphql_AddCombinedModel_gql__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _graphql_AddSliceModel_gql__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../graphql/AddSliceModel.gql */ "./10api/graphql/AddSliceModel.gql");
/* harmony import */ var _graphql_AddSliceModel_gql__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_graphql_AddSliceModel_gql__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _gqlClient__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gqlClient */ "./10api/utils/client/gqlClient.ts");
/* harmony import */ var _folder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./folder */ "./10api/utils/client/folder.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = undefined;











var getModel = function (modelId) { return __awaiter(_this, void 0, void 0, function () {
    var _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().query({
                    query: _graphql_GetModel_gql__WEBPACK_IMPORTED_MODULE_0___default.a,
                    variables: {
                        modelId: modelId
                    }
                })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (!data.model) {
                    throw Error("model does not exist");
                }
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, data.model];
        }
    });
}); };
var getModelFiles = function (modelId) { return __awaiter(_this, void 0, void 0, function () {
    var _a, data, errors;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().query({
                    query: _graphql_GetModelFiles_gql__WEBPACK_IMPORTED_MODULE_1___default.a,
                    variables: {
                        modelId: modelId
                    }
                })];
            case 1:
                _a = _b.sent(), data = _a.data, errors = _a.errors;
                if (!data.model) {
                    throw Error("model does not exist");
                }
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, data.model];
        }
    });
}); };
var deleteModel = function (modelId) { return __awaiter(_this, void 0, void 0, function () {
    var errors;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().mutate({
                    mutation: _graphql_DeleteModel_gql__WEBPACK_IMPORTED_MODULE_2___default.a,
                    variables: {
                        modelId: modelId
                    },
                    errorPolicy: "all"
                })];
            case 1:
                errors = (_a.sent()).errors;
                if (errors) {
                    throw Error(errors[0].message);
                }
                return [2 /*return*/, modelId];
        }
    });
}); };
var uploadModel = function (file, onProgress) { return __awaiter(_this, void 0, void 0, function () {
    var modelFolder, uploadModelData, _a, id, uploadUrls, uploadModelSuccessData;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, Object(_folder__WEBPACK_IMPORTED_MODULE_10__["getModelFolder"])()];
            case 1:
                modelFolder = _b.sent();
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().mutate({
                        mutation: _graphql_UploadModel_gql__WEBPACK_IMPORTED_MODULE_3___default.a,
                        variables: {
                            folderId: modelFolder.id,
                            name: file.name,
                            filenames: [file.name],
                            // TODO cvtOptions
                            cvtOptions: false ? undefined : ""
                        }
                    })];
            case 2:
                uploadModelData = (_b.sent()).data;
                _a = uploadModelData.uploadModel, id = _a.id, uploadUrls = _a.uploadUrls;
                return [4 /*yield*/, axios__WEBPACK_IMPORTED_MODULE_8___default.a.put(uploadUrls[0].url, file, {
                        onUploadProgress: function (e) {
                            var progress = e.loaded / e.total;
                            onProgress(progress);
                        }
                    })];
            case 3:
                _b.sent();
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().mutate({
                        mutation: _graphql_UploadModelSuccess_gql__WEBPACK_IMPORTED_MODULE_4___default.a,
                        variables: {
                            modelId: id
                        }
                    })];
            case 4:
                uploadModelSuccessData = (_b.sent()).data;
                return [2 /*return*/, uploadModelSuccessData.uploadModelSuccess.id];
        }
    });
}); };
var updateModel = function (modelId, name) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().mutate({
                    mutation: _graphql_UpdateModel_gql__WEBPACK_IMPORTED_MODULE_5___default.a,
                    variables: {
                        modelId: modelId,
                        name: name
                    }
                })];
            case 1:
                _a.sent();
                return [2 /*return*/, modelId];
        }
    });
}); };
var combineModel = function (name, modelIds) { return __awaiter(_this, void 0, void 0, function () {
    var modelFolder, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Object(_folder__WEBPACK_IMPORTED_MODULE_10__["getModelFolder"])()];
            case 1:
                modelFolder = _a.sent();
                if (modelIds.length !== 2) {
                    throw Error("combined model requires two models");
                }
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().mutate({
                        mutation: _graphql_AddCombinedModel_gql__WEBPACK_IMPORTED_MODULE_6___default.a,
                        variables: {
                            folderId: modelFolder.id,
                            name: name,
                            modelIds: modelIds
                        }
                    })];
            case 2:
                data = (_a.sent()).data;
                return [2 /*return*/, data.addCombinedModel];
        }
    });
}); };
var sliceModel = function (name, query) { return __awaiter(_this, void 0, void 0, function () {
    var modelFolder, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Object(_folder__WEBPACK_IMPORTED_MODULE_10__["getModelFolder"])()];
            case 1:
                modelFolder = _a.sent();
                return [4 /*yield*/, Object(_gqlClient__WEBPACK_IMPORTED_MODULE_9__["getGQLClient"])().mutate({
                        mutation: _graphql_AddSliceModel_gql__WEBPACK_IMPORTED_MODULE_7___default.a,
                        variables: {
                            name: name,
                            query: query,
                            folderId: modelFolder.id
                        }
                    })];
            case 2:
                data = (_a.sent()).data;
                return [2 /*return*/, data.sliceModel.id];
        }
    });
}); };
var mergeModel = function (name, modelIds) { return __awaiter(_this, void 0, void 0, function () {
    var query;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (modelIds.length < 2) {
                    throw Error("merge model requires at least 2 models");
                }
                query = {
                    modelFragments: modelIds.map(function (modelId) { return ({ modelId: modelId, tree: "*" }); })
                };
                return [4 /*yield*/, sliceModel(name, JSON.stringify(query, null, 0))];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };


/***/ }),

/***/ "./10api/utils/measure.ts":
/*!********************************!*\
  !*** ./10api/utils/measure.ts ***!
  \********************************/
/*! exports provided: createAnchorPoint, createOverlays, updateAnchorPoint, createAnchorValue, updateAnchorValue, getCenterPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAnchorPoint", function() { return createAnchorPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOverlays", function() { return createOverlays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateAnchorPoint", function() { return updateAnchorPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAnchorValue", function() { return createAnchorValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateAnchorValue", function() { return updateAnchorValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenterPoint", function() { return getCenterPoint; });
function createAnchorPoint(color) {
    if (color === void 0) { color = "#6092e2"; }
    var anchor = document.createElement("div");
    anchor.style.width = "16px";
    anchor.style.width = "16px";
    anchor.style.height = "16px";
    anchor.style.borderRadius = "100%";
    anchor.style.pointerEvents = "none";
    anchor.style.backgroundColor = color;
    anchor.style.position = "absolute";
    anchor.style.top = "-8px";
    anchor.style.left = "-10px";
    anchor.style.transform = "translate(0, 0)";
    anchor.style.borderWidth = "3px";
    anchor.style.display = "none";
    anchor.style.borderColor = color;
    return anchor;
}
function createOverlays() {
    var overlays = document.createElement("div");
    overlays.style.position = "relative";
    overlays.style.left = '0px';
    overlays.style.top = '-100%';
    overlays.style.width = '100%';
    overlays.style.height = '100%';
    overlays.style.pointerEvents = "none";
    overlays.style.overflow = "hidden";
    return overlays;
}
function updateAnchorPoint(anchor, update) {
    if (update) {
        anchor.style.display = "block";
        anchor.style.transform = "translate(" + update.pos[0] + "px, " + update.pos[1] + "px)";
        if (typeof update.isSnapped === "boolean") {
            if (update.isSnapped) {
                anchor.style.backgroundColor = "transparent";
                anchor.style.border = "3px solid #f75223";
            }
            else {
                anchor.style.backgroundColor = "#f75223";
            }
        }
    }
    else {
        anchor.style.display = "none";
    }
}
function createAnchorValue(color) {
    if (color === void 0) { color = "red"; }
    var anchor = document.createElement("div");
    anchor.style.fontSize = "14px";
    anchor.style.lineHeight = '14px';
    anchor.style.height = '14px';
    anchor.style.width = '60px';
    anchor.style.pointerEvents = "none";
    anchor.style.position = "absolute";
    anchor.style.color = color;
    anchor.style.transformOrigin = 'center';
    anchor.style.left = '0';
    anchor.style.top = '-7px';
    anchor.style.padding = '0 10px';
    return anchor;
}
function updateAnchorValue(anchor, update) {
    if (update) {
        if (update.pos) {
            anchor.style.display = "block";
            anchor.style.transform = "translate(" + update.pos[0] + "px, " + update.pos[1] + "px)";
        }
        else {
            anchor.style.display = "none";
        }
        if (update.value) {
            anchor.innerText = update.value;
        }
        if (update.color) {
            anchor.style.color = update.color;
        }
    }
    else {
        anchor.style.display = "none";
    }
}
var getCenterPoint = function (pointA, pointB) {
    return [(pointA[0] + pointB[0]) / 2, (pointA[1] + pointB[1]) / 2, (pointA[2] + pointB[2]) / 2];
};


/***/ }),

/***/ "./10api/utils/model/downloader.ts":
/*!*****************************************!*\
  !*** ./10api/utils/model/downloader.ts ***!
  \*****************************************/
/*! exports provided: generatePromises, downloadFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generatePromises", function() { return generatePromises; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony import */ var _localStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localStorage */ "./10api/utils/model/localStorage.ts");
/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../client */ "./10api/utils/client/index.ts");
var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var fileTypes = {
    bin: {
        mime: "application/octet-binary",
        responseType: "arraybuffer",
        type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].ArrayBuffer
    },
    xml: { mime: "application/xml", responseType: "text", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].XML },
    json: { mime: "application/json", responseType: "json", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].JSON },
    txt: { mime: "text/plain", responseType: "text", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Text },
    csv: { mime: "text/plain", responseType: "text", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Text },
    jpeg: { mime: "image/jpg", responseType: "blob", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Image },
    jpg: { mime: "image/jpg", responseType: "blob", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Image },
    png: { mime: "image/png", responseType: "blob", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Image },
    gif: { mime: "image/gif", responseType: "blob", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Image },
    bmp: { mime: "image/bmp", responseType: "blob", type: _localStorage__WEBPACK_IMPORTED_MODULE_0__["FileTypes"].Image }
};
function generatePromises(modelId) {
    return __awaiter(this, void 0, void 0, function () {
        var model, convertedFiles, promises;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Object(_client__WEBPACK_IMPORTED_MODULE_1__["getModel"])(modelId)];
                case 1:
                    model = _a.sent();
                    if (!model) {
                        throw Error("model does not exist");
                    }
                    convertedFiles = model.convertedUrls;
                    promises = {};
                    convertedFiles = convertedFiles.map(function (file) { return (__assign({}, file, { filename: file.filename.lastIndexOf(".gz") >= 0 ? file.filename.replace(".gz", "") : file.filename })); });
                    convertedFiles.forEach(function (file) {
                        var progressEvents = [];
                        var cancel;
                        var isCancelled = false;
                        var progressFn = function (progressEvt) {
                            if (isCancelled) {
                                return;
                            }
                            progressEvents.forEach(function (progressEvent) {
                                progressEvent(progressEvt);
                            });
                        };
                        var cancelPromise = new Promise(function (resolve, reject) {
                            cancel = function () {
                                isCancelled = true;
                                resolve();
                            };
                        });
                        promises[file.filename] = {
                            progressEvents: progressEvents,
                            progressFn: progressFn,
                            cancel: cancel,
                            filename: file.filename,
                            downloadFile: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    if (isCancelled) {
                                        return [2 /*return*/];
                                    }
                                    return [2 /*return*/, _downloadFile(modelId, file, progressFn, cancelPromise)];
                                });
                            }); },
                            onProgress: function (func) {
                                progressEvents.push(func);
                            }
                        };
                    });
                    return [2 /*return*/, promises];
            }
        });
    });
}
function downloadFile(modelId, file) {
    return _downloadFile(modelId, file, function () { });
}
function _downloadFile(modelId, file, progressFn, cancelFn) {
    return __awaiter(this, void 0, void 0, function () {
        var type, fileContents, event;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    type = getFileTypeInfo(file.filename);
                    return [4 /*yield*/, Object(_localStorage__WEBPACK_IMPORTED_MODULE_0__["openFile"])("model-" + modelId + "/" + file.filename, type)];
                case 1:
                    fileContents = _a.sent();
                    if (!!fileContents) return [3 /*break*/, 3];
                    return [4 /*yield*/, downloadBinary(type, file.url, progressFn, cancelFn)];
                case 2:
                    fileContents = (_a.sent()).data;
                    //console.group("model files");
                    ///* tslint:disable:no-floating-promises */
                    Object(_localStorage__WEBPACK_IMPORTED_MODULE_0__["saveFile"])(fileContents, type, "model-" + modelId + "/" + file.filename).then(function () {
                        //    console.log(file.filename + " saved");
                    });
                    return [3 /*break*/, 4];
                case 3:
                    event = new ProgressEvent("mesh");
                    // event.loaded = event.total = fileContents.byteLength;
                    progressFn({
                        loaded: fileContents.byteLength,
                        total: fileContents.byteLength
                    });
                    _a.label = 4;
                case 4:
                    if (type.responseType !== "blob") {
                        return [2 /*return*/, { data: fileContents }];
                    }
                    return [2 /*return*/, processImage(fileContents, file.filename)];
            }
        });
    });
}
function getFileTypeInfo(filename) {
    var fileExtension = filename.split(".").pop() || "";
    return fileTypes[fileExtension.toLowerCase()];
}
function processImage(blob, filename) {
    return __awaiter(this, void 0, void 0, function () {
        var urlCreator, imageUrl;
        return __generator(this, function (_a) {
            urlCreator = window.URL || window.webkitURL;
            imageUrl = urlCreator.createObjectURL(blob);
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var image = new Image();
                    image.name = filename;
                    image.src = imageUrl;
                    image.crossOrigin = "";
                    image.onload = function () { return resolve(image); };
                    image.onerror = function (error) {
                        reject("error downloading image:" + filename);
                    };
                })];
        });
    });
}
function downloadBinary(type, url, progressFn, cancelFn) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // fetch doesn't support progress so need to xhr
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    xhr.responseType = type.responseType;
                    xhr.onload = function () {
                        if (xhr.status === 200 || xhr.status === 206) {
                            resolve({ data: xhr.response });
                        }
                        else {
                            reject();
                        }
                    };
                    xhr.onprogress = function (eventData) {
                        progressFn(eventData);
                    };
                    xhr.onerror = function (error) {
                        reject(error);
                    };
                    cancelFn &&
                        cancelFn.then(function () {
                            xhr.abort();
                        });
                    xhr.send();
                })];
        });
    });
}


/***/ }),

/***/ "./10api/utils/model/index.ts":
/*!************************************!*\
  !*** ./10api/utils/model/index.ts ***!
  \************************************/
/*! exports provided: generatePromises, downloadFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _downloader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./downloader */ "./10api/utils/model/downloader.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generatePromises", function() { return _downloader__WEBPACK_IMPORTED_MODULE_0__["generatePromises"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return _downloader__WEBPACK_IMPORTED_MODULE_0__["downloadFile"]; });




/***/ }),

/***/ "./10api/utils/model/localStorage.ts":
/*!*******************************************!*\
  !*** ./10api/utils/model/localStorage.ts ***!
  \*******************************************/
/*! exports provided: FileTypes, openFile, saveFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileTypes", function() { return FileTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openFile", function() { return openFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveFile", function() { return saveFile; });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var FileTypes;
(function (FileTypes) {
    FileTypes["Text"] = "text";
    FileTypes["ArrayBuffer"] = "arraybuffer";
    FileTypes["Image"] = "blob";
    FileTypes["JSON"] = "json";
    FileTypes["XML"] = "text";
})(FileTypes || (FileTypes = {}));
var isSupported = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
var ONE_GIG = 1073741824;
var storageLimits = {
    temporary: ONE_GIG
};
function readFileFromDisk(type, fileObject) {
    return __awaiter(this, void 0, void 0, function () {
        var reader;
        return __generator(this, function (_a) {
            reader = new FileReader();
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    reader.onloadend = function () {
                        if (reader.result !== undefined || reader.result !== null) {
                            resolve(reader.result);
                        }
                        else {
                            reject(reader.error);
                        }
                    };
                    switch (type.type) {
                        case FileTypes.JSON:
                        case FileTypes.XML:
                            reader.readAsText(fileObject);
                            break;
                        case FileTypes.ArrayBuffer:
                        case FileTypes.Image:
                            reader.readAsArrayBuffer(fileObject);
                            break;
                        default:
                            throw new Error("File has no type");
                    }
                })];
        });
    });
}
function getFileSystem() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    if (isSupported) {
                        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
                        window.requestFileSystem(window.TEMPORARY, storageLimits.temporary, resolve, reject);
                    }
                    else {
                        reject("FILESYSTEM_NOT_SUPPORTED");
                    }
                })];
        });
    });
}
function getDirectoryEntry(directory, create) {
    return __awaiter(this, void 0, void 0, function () {
        var options;
        return __generator(this, function (_a) {
            options = { create: create };
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    getFileSystem()
                        .then(function (fileSystem) { return fileSystem.root.getDirectory(directory, options, resolve, reject); })
                        .catch(reject);
                })];
        });
    });
}
function getFileEntry(directory, create, fileName) {
    return __awaiter(this, void 0, void 0, function () {
        var options;
        return __generator(this, function (_a) {
            options = { create: create };
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    getDirectoryEntry(directory, create)
                        .then(function (dirEntry) { return dirEntry.getFile(fileName, options, resolve, reject); })
                        .catch(reject);
                })];
        });
    });
}
function transformFilePath(path) {
    var fileName = path.split("/").pop() || "";
    var directory = path.replace(fileName, "");
    return { directory: directory, fileName: fileName };
}
function openFile(path, type) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, _openFile(path, type)
                    .then(function (data) {
                    return data;
                })
                    .catch(function (err) {
                    return null;
                })];
        });
    });
}
function _openFile(path, type) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, directory, fileName, fileEntry, file, fileContents;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = transformFilePath(path), directory = _a.directory, fileName = _a.fileName;
                    return [4 /*yield*/, getFileEntry(directory, false, fileName)];
                case 1:
                    fileEntry = _b.sent();
                    return [4 /*yield*/, new Promise(function (resolve, reject) { return fileEntry.file(resolve, reject); })];
                case 2:
                    file = _b.sent();
                    if (file.size === 0) {
                        throw new Error("FILE_SIZE_ZERO");
                    }
                    return [4 /*yield*/, readFileFromDisk(type, file)];
                case 3:
                    fileContents = _b.sent();
                    if (type.type === FileTypes.Image) {
                        return [2 /*return*/, new Blob([fileContents], { type: type.mime })];
                    }
                    else if (type.type === FileTypes.JSON) {
                        return [2 /*return*/, JSON.parse(fileContents)];
                    }
                    else {
                        return [2 /*return*/, fileContents];
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function saveFile(file, fileType, path) {
    return __awaiter(this, void 0, void 0, function () {
        var blob, fileContents;
        return __generator(this, function (_a) {
            if (fileType.type === FileTypes.JSON) {
                fileContents = JSON.stringify(file);
                blob = new Blob([fileContents], { type: fileType.mime });
            }
            else if (fileType.type === FileTypes.Image) {
                blob = file;
            }
            else {
                blob = new Blob([file], { type: fileType.mime });
            }
            return [2 /*return*/, saveBlob(path, blob, false)];
        });
    });
}
function saveBlob(path, blob, isPersistent) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, directory, fileName, fileEntry, fileWriter;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = transformFilePath(path), directory = _a.directory, fileName = _a.fileName;
                    return [4 /*yield*/, getFileEntry(directory, true, fileName)];
                case 1:
                    fileEntry = _b.sent();
                    return [4 /*yield*/, new Promise(function (resolve) { return fileEntry.createWriter(resolve); })];
                case 2:
                    fileWriter = _b.sent();
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            fileWriter.onerror = function (error) { return reject(); };
                            fileWriter.onwriteend = function () { return resolve(); };
                            fileWriter.write(blob);
                        })];
            }
        });
    });
}


/***/ }),

/***/ "./10api/utils/propertyGroups.json":
/*!*****************************************!*\
  !*** ./10api/utils/propertyGroups.json ***!
  \*****************************************/
/*! exports provided: 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 125, 126, 688, 888, -1, default */
/***/ (function(module) {

module.exports = {"0":"PG_IDENTITY_DATA","1":"PG_GEOMETRY","3":"PG_CONSTRUCTION","4":"PG_GRAPHICS","5":"PG_MATERIALS","6":"PG_UNDERLAY","7":"PG_STAIR_TREADS","8":"PG_STAIR_RISERS","9":"PG_STAIR_STRINGERS","10":"PG_ELECTRICAL","11":"PG_PLUMBING","12":"PG_STRUCTURAL","13":"PG_MECHANICAL","14":"PG_PHASING","19":"PG_CONSTRAINTS","20":"PG_PATTERN","21":"PG_VIEW_EXTENTS","22":"PG_VIEW_CAMERA","23":"PG_TEXT","24":"PG_ELECTRICAL_LIGHTING","25":"PG_ELECTRICAL_LOADS","26":"PG_MECHANICAL_LOADS","27":"PG_MECHANICAL_AIRFLOW","28":"PG_STRUCTURAL_ANALYSIS","29":"PG_ENERGY_ANALYSIS","30":"PG_AELECTRICAL","31":"PG_IFC","33":"PG_CURTAIN_GRID_VERT","34":"PG_CURTAIN_GRID_1","35":"PG_CURTAIN_GRID_HORIZ","36":"PG_CURTAIN_GRID_2","37":"PG_CURTAIN_MULLION_VERT","38":"PG_CURTAIN_MULLION_1","39":"PG_CURTAIN_MULLION_HORIZ","40":"PG_CURTAIN_MULLION_2","41":"PG_CURTAIN_GRID","43":"PG_REBAR_SYSTEM_LAYERS","44":"PG_REBAR_ARRAY","45":"PG_ANALYTICAL_MODEL","46":"PG_TRANSLATION_IN","47":"PG_ROTATION_ABOUT","48":"PG_FIRE_PROTECTION","49":"PG_TITLE","50":"PG_TRUSS_FAMILY_VERT_WEB","51":"PG_TRUSS_FAMILY_DIAG_WEB","52":"PG_TRUSS_FAMILY_TOP_CHORD","53":"PG_TRUSS_FAMILY_BOTTOM_CHORD","54":"PG_PROFILE","55":"PG_PROFILE_1","56":"PG_PROFILE_2","57":"PG_GREEN_BUILDING","58":"PG_PATTERN_APPLICATION","59":"PG_LIGHT_PHOTOMETRICS","60":"PG_SLAB_SHAPE_EDIT","61":"PG_ANALYSIS_RESULTS","62":"PG_DISPLAY","63":"PG_CURTAIN_GRID_U","64":"PG_CURTAIN_GRID_V","65":"PG_ADSK_MODEL_PROPERTIES","66":"PG_AREA","67":"PG_CONCEPTUAL_ENERGY_DATA","68":"PG_FITTING","69":"PG_ENERGY_ANALYSIS_DETAILED_AND_CONCEPTUAL_MODELS","70":"PG_ENERGY_ANALYSIS_DETAILED_MODEL","71":"PG_ENERGY_ANALYSIS_CONCEPTUAL_MODEL","72":"PG_FLEXIBLE","73":"PG_GENERAL","74":"PG_ELECTRICAL_CIRCUITING","75":"PG_DATA","76":"PG_CONCEPTUAL_ENERGY_DATA_BUILDING_SERVICES","77":"PG_RAILING_SYSTEM_FAMILY_TOP_RAIL","78":"PG_RAILING_SYSTEM_FAMILY_HANDRAILS","79":"PG_RAILING_SYSTEM_FAMILY_SEGMENT_PATTERN","80":"PG_RAILING_SYSTEM_SEGMENT_PATTERN_REPEAT","81":"PG_RAILING_SYSTEM_SEGMENT_PATTERN_REMAINDER","82":"PG_RAILING_SYSTEM_SEGMENT_POSTS","83":"PG_RAILING_SYSTEM_SEGMENT_U_GRID","84":"PG_RAILING_SYSTEM_SEGMENT_V_GRID","85":"PG_SUPPORT","86":"PG_VISIBILITY","87":"PG_OVERALL_LEGEND","88":"PG_INSULATION","89":"PG_LINING","90":"PG_SYSTEMTYPE_RISEDROP","91":"PG_ANALYTICAL_ALIGNMENT","92":"PG_ANALYTICAL_PROPERTIES","93":"PG_NODES","94":"PG_LENGTH","95":"PG_SPLIT_PROFILE_DIMENSIONS","96":"PG_STAIRS_CALCULATOR_RULES","97":"PG_STAIRS_TREADS_RISERS","98":"PG_TERMINTATION","99":"PG_RAILING_SYSTEM_SECONDARY_FAMILY_HANDRAILS","100":"PG_STAIRS_OPEN_END_CONNECTION","101":"PG_STAIRS_SUPPORTS","102":"PG_STAIRS_WINDERS","103":"PG_CONTINUOUSRAIL_BEGIN_BOTTOM_EXTENSION","104":"PG_CONTINUOUSRAIL_END_TOP_EXTENSION","105":"PG_SEGMENTS_FITTINGS","106":"PG_DIVISION_GEOMETRY","107":"PG_GEOMETRY_POSITIONING","108":"PG_REFERENCE","110":"PG_FABRICATION_PRODUCT_DATA","111":"PG_FORCES","112":"PG_MOMENTS","113":"PG_PRIMARY_END","114":"PG_SECONDARY_END","116":"PG_RELEASES_MEMBER_FORCES","117":"PG_ENERGY_ANALYSIS_ADVANCED","118":"PG_COUPLER_ARRAY","119":"PG_ENERGY_ANALYSIS_BUILDING_DATA","120":"PG_ENERGY_ANALYSIS_ROOM_SPACE_DATA","121":"PG_ENERGY_ANALYSIS_BLDG_CONS_MTL_THERMAL_PROPS","125":"PG_STRUCTURAL_SECTION_GEOMETRY","126":"PG_GEO_LOCATION","688":"MODELO_PROPERTIES","888":"MODELO_CONNECTED_DATA","-1":"INVALID"};

/***/ }),

/***/ "./10api/view/Camera.ts":
/*!******************************!*\
  !*** ./10api/view/Camera.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/camera/m3d_scene_camera.js */ "./03scene/camera/m3d_scene_camera.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils */ "./10api/Utils.ts");
/* harmony import */ var _08ui_tool_CameraManipulator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../08ui/tool/CameraManipulator */ "./08ui/tool/CameraManipulator.ts");



var Camera = /** @class */ (function () {
    function Camera(viewer) {
        this._viewer = viewer;
        if (this._viewer) {
            this._scene = viewer.getScene();
        }
        else {
            this._scene = null;
        }
        this._manipulator = null; // FIXME: can't initialize manipulator here as viewer.Camera is not initilaized
        if (this._scene) {
            this.core = new _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._scene.core);
        }
        else {
            this.core = new _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"](null);
        }
    }
    Camera.prototype.destroy = function () {
        this.core.destroy();
        this.core = null;
        delete this.core;
        if (this._manipulator) {
            this._manipulator.destroy();
            this._manipulator = null;
            delete this._manipulator;
        }
        if (this._viewer) {
            this._viewer = null;
            delete this._viewer;
        }
        this._scene = null;
        delete this._scene;
    };
    Camera.prototype.update = function () {
        return this.core.update();
    };
    /**
     * Set the field of view value of scene camera.
     * @param fov the filed of view in angle
     */
    Camera.prototype.setFov = function (fov) {
        this.core.setTargetFov(fov);
        if (this._viewer) {
            this._viewer.invalidate();
        }
    };
    /**
     * Switch between 1st person view and 3rd person view.
     * @param enabled true for 1st person view and false for 3rd person view.
     */
    Camera.prototype.setFirstPersonViewEnabled = function (enabled) {
        this.core.setFirstPerson(enabled);
    };
    /**
     * Is current view a first person view?
     * @returns true for yes.
     */
    Camera.prototype.isFirstPersonViewEnabled = function () {
        return this.core.isFirstPerson();
    };
    /**
     * Enable the restricted view
     * @param {boolean} enabled - true for yes
     */
    Camera.prototype.setRestrictedViewEnabled = function (enabled) {
        this.core.setFirstPerson(enabled);
        this._manipulator.setRestrictedViewEnabled(enabled);
    };
    /**
     * Check if it is a restricted view
     * @return {boolean} - true if current camera is in restricted view.
     */
    Camera.prototype.isRestrictedViewEnabled = function () {
        return this.core.isFirstPerson() && this._manipulator.isRestrictedViewEnabled();
    };
    /**
     * Switch to certain view
     */
    Camera.prototype.switchToView = function (view) {
        var VIEW_ANGLES = [
            [0, Math.PI * -0.5],
            [0, Math.PI * 0.5],
            [0, Math.PI],
            [0, 0],
            [Math.PI * 0.49999, -Math.PI * 0.49999],
            [Math.PI * -0.49999, -Math.PI * 0.49999],
        ];
        var angle = null;
        if (view >= _Utils__WEBPACK_IMPORTED_MODULE_1__["ViewAngle"].FRONT && view <= _Utils__WEBPACK_IMPORTED_MODULE_1__["ViewAngle"].BOTTOM) {
            angle = VIEW_ANGLES[view];
            this.core.reset(false);
            this.core.rotateTo(angle[0], angle[1]);
        }
        else {
            // World view.
            this.core.setFirstPerson(false);
            this.core.setPerspective(true);
            this.core.reset(false);
        }
    };
    /**
     * Set the camera sensitivity, e.g., pan speed.
     * @param options it is a collection of sensitivity values.
     * {
     *   "panSpeed": 0,
     *   "zoomSpeed": 0,
     * }
     */
    Camera.prototype.setSensitivity = function (options) {
        this._manipulator.setInputSensitivity(options);
    };
    /**
     * @hidden
     */
    Camera.prototype.addInput = function (input) {
        if (!this._manipulator) {
            this._manipulator = new _08ui_tool_CameraManipulator__WEBPACK_IMPORTED_MODULE_2__["default"](this._viewer);
        }
        this._manipulator.addInput(input);
    };
    Camera.prototype.resize = function (width, height) {
        this.core.resize(width, height);
        this.core.update();
    };
    /**
     * Convert to perspective projection while keeping the projection result of current frame.
     */
    Camera.prototype.transformToPerspective = function () {
        this.core.transformOrthogonalToPerspective();
        if (this._viewer) {
            this._viewer.invalidate();
        }
    };
    /**
     * Convert to orthogonal projection while keeping the projection result of current frame.
     */
    Camera.prototype.transformToOrthogonal = function () {
        this.core.transformPerspectiveToOrthogonal();
        if (this._viewer) {
            this._viewer.invalidate();
        }
    };
    /**
     * Return the current scene camera data.
     * @return the internal stats of current camera.
     */
    Camera.prototype.getData = function () {
        return this.core.dump();
    };
    Camera.prototype.setData = function (data) {
        this.core.restore(data);
    };
    Camera.prototype.switchToWorldView = function () {
        this._manipulator.switchToWorldView();
    };
    return Camera;
}());
/* harmony default export */ __webpack_exports__["default"] = (Camera);


/***/ }),

/***/ "./10api/view/Camera360.ts":
/*!*********************************!*\
  !*** ./10api/view/Camera360.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/camera/m3d_scene_camera.js */ "./03scene/camera/m3d_scene_camera.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_morphing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_morphing.js */ "./03scene/camera/m3d_camera_animator_morphing.js");
/* harmony import */ var _03scene_camera_m3d_camera_animator_panorama_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../03scene/camera/m3d_camera_animator_panorama.js */ "./03scene/camera/m3d_camera_animator_panorama.js");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Camera */ "./10api/view/Camera.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var Camera360 = /** @class */ (function (_super) {
    __extends(Camera360, _super);
    function Camera360(viewer, eventEmitter) {
        var _this = _super.call(this, viewer) || this;
        _this._cores = new Array(2);
        _this._cores[0] = new _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"](null);
        _this._cores[1] = new _03scene_camera_m3d_scene_camera_js__WEBPACK_IMPORTED_MODULE_0__["default"](null);
        _this._cores[0].setFirstPerson(true);
        vec3.set(_this._cores[0].eye, 0, 0, 0);
        _this._cores[1].setFirstPerson(true);
        vec3.set(_this._cores[0].eye, 0, 0, 0);
        _this._fov = 78.0;
        _this._FOV_CHANGE_SPEED = 0.3;
        // FIXME: should not touch private members of SceneCamera
        _this._cores[0].setTargetFov(_this._fov);
        _this._cores[0]._targetPhi = 0;
        _this._cores[0]._targetTheta = 0;
        _this._animators = new Array(2);
        // For the morphing between two panoramas we need
        // to adjust each camera's fov value, that's why
        // we need two cameras
        _this._animators[0] = new _03scene_camera_m3d_camera_animator_morphing_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this._animators[1] = new _03scene_camera_m3d_camera_animator_morphing_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        _this._eventEmitter = eventEmitter;
        _this._transition = new _03scene_camera_m3d_camera_animator_panorama_js__WEBPACK_IMPORTED_MODULE_2__["default"](_this._eventEmitter);
        _this._transition.setTransitionSpeed(80);
        return _this;
    }
    Camera360.prototype.destroy = function () {
        this._cores[0].destroy();
        this._cores[1].destroy();
        this._cores = null;
        delete this._cores;
        this._animators[0].destroy();
        this._animators[1].destroy();
        this._animators = null;
        delete this._animators;
        this._transition.destroy();
        this._transition = null;
        delete this._transition;
        _super.prototype.destroy.call(this);
    };
    Camera360.prototype.setFov = function (fov) {
        this._cores[0].setTargetFov(fov);
        this._cores[1].setTargetFov(fov);
        if (this._viewer) {
            this._viewer.invalidate();
        }
    };
    Camera360.prototype.resize = function (width, height) {
        this._cores[0].resize(width, height);
        this._cores[0].update();
        this._cores[1].resize(width, height);
        this._cores[1].update();
    };
    Camera360.prototype.update = function () {
        var ret1 = this._cores[0].update();
        var ret2 = this._cores[1].update();
        return ret1 || ret2;
    };
    Camera360.prototype.addInput = function (input) {
        var _this = this;
        _super.prototype.addInput.call(this, input);
        // Initialize manipulator
        this._manipulator.setCamera(this._cores[0]);
        this._manipulator.setPanoramaEnabled(true);
        if (input.name === "mouse") {
            var mouse_1 = input;
            // Intercept the mouse wheeling event to change the fov.
            mouse_1.addMouseWheelListener(function (mouse) {
                var delta = -mouse.delta * _this._FOV_CHANGE_SPEED;
                _this._fov += delta;
                if (_this._fov > 180.0) {
                    _this._fov = 179.99999;
                }
                if (_this._fov < 0) {
                    _this._fov = 0.001;
                }
                _this._cores[0].setTargetFov(_this._fov);
                _this._cores[1].setTargetFov(_this._fov);
                return true;
            });
        }
    };
    Camera360.prototype.transit = function (currentCameraIndex, nextCameraInfo) {
        var currentCamera = this._cores[currentCameraIndex];
        var nextCamera = this._cores[1 - currentCameraIndex];
        var currentAnimator = this._animators[currentCameraIndex];
        var nextAnimator = this._animators[1 - currentCameraIndex];
        currentAnimator.attach(currentCamera);
        currentAnimator.start(null, null, null, 10.0);
        nextAnimator.attach(nextCamera);
        if (nextCameraInfo) {
            // FIXME: can't understand this piece of code.
            nextCamera._targetFov = nextCamera._fov = nextCameraInfo.fov;
            nextCamera._targetPhi = nextCamera._phi = nextCameraInfo.phi;
            nextCamera._targetTheta = nextCamera._theta = nextCameraInfo.theta;
            nextAnimator.start(null, null, 140, nextCameraInfo.fov);
        }
        else {
            nextAnimator.start(currentCamera._phi, currentCamera._theta, 140, nextCamera._targetFov);
        }
        this._manipulator.setCamera(nextCamera);
    };
    Camera360.prototype.moveTo = function (currentCameraIndex, position) {
        this._transition.attach(this._cores[currentCameraIndex]);
        this._transition.start(position);
    };
    return Camera360;
}(_Camera__WEBPACK_IMPORTED_MODULE_3__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Camera360);


/***/ }),

/***/ "./10api/view/Drawable.ts":
/*!********************************!*\
  !*** ./10api/view/Drawable.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_drawables_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/drawables/m3d_drawable.js */ "./03scene/drawables/m3d_drawable.js");

var Drawable = /** @class */ (function () {
    function Drawable(name, mesh, material) {
        // FIXME: bbox
        this.core = new _03scene_drawables_m3d_drawable_js__WEBPACK_IMPORTED_MODULE_0__["default"](name, mesh.core, null, null, material.core, null, [-1, -1, -1, 1, 1, 1]);
    }
    Drawable.prototype.setPosition = function (x, y, z) {
        this.core.setTranslation(x, y, z);
    };
    Drawable.prototype.setRotation = function (rx, ry, rz) {
        console.error("not implemented!");
    };
    Drawable.prototype.setSize = function (width, height, depth) {
        this.core.setScaling(width, height, depth);
    };
    return Drawable;
}());
/* harmony default export */ __webpack_exports__["default"] = (Drawable);


/***/ }),

/***/ "./10api/view/GeometryCube.ts":
/*!************************************!*\
  !*** ./10api/view/GeometryCube.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var GeometryCube = /** @class */ (function () {
    function GeometryCube(resourceManager) {
        this.core = resourceManager.getMesh("cube");
        this.core.createSolidCube();
    }
    return GeometryCube;
}());
/* harmony default export */ __webpack_exports__["default"] = (GeometryCube);


/***/ }),

/***/ "./10api/view/MaterialBasic.ts":
/*!*************************************!*\
  !*** ./10api/view/MaterialBasic.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_materials_m3d_material_basic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/materials/m3d_material_basic.js */ "./03scene/materials/m3d_material_basic.js");

/**
 * A basic material with only RGB color and a transparent value.
 */
var MaterialBasic = /** @class */ (function () {
    function MaterialBasic(resourceManager, color, transparent) {
        this._color = color || [1.0, 0.0, 0.0];
        this._transparent = transparent | 1.0;
        this.core = new _03scene_materials_m3d_material_basic_js__WEBPACK_IMPORTED_MODULE_0__["default"]("basic");
    }
    return MaterialBasic;
}());
/* harmony default export */ __webpack_exports__["default"] = (MaterialBasic);


/***/ }),

/***/ "./10api/view/Scene.ts":
/*!*****************************!*\
  !*** ./10api/view/Scene.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @hidden
 * The Scene is about the scene data loaded into current viewer plus
 * runtime rendering setting.
 */
var Scene = /** @class */ (function () {
    function Scene(viewer) {
    }
    Scene.prototype.destroy = function () {
    };
    return Scene;
}());
/* harmony default export */ __webpack_exports__["default"] = (Scene);


/***/ }),

/***/ "./10api/view/Scene3D.ts":
/*!*******************************!*\
  !*** ./10api/view/Scene3D.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _03scene_m3d_scene_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../03scene/m3d_scene.js */ "./03scene/m3d_scene.js");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Scene */ "./10api/view/Scene.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Scene3D = /** @class */ (function (_super) {
    __extends(Scene3D, _super);
    function Scene3D(viewer) {
        var _this = _super.call(this, viewer) || this;
        _this.core = new _03scene_m3d_scene_js__WEBPACK_IMPORTED_MODULE_0__["default"](viewer.getResourceManager());
        _this._viewer = viewer;
        return _this;
    }
    Scene3D.prototype.addDrawable = function (drawable) {
        this.core.model.drawables.push(drawable.core);
        // Update the current scene bbox when section is not enabled.
        //if (!this._canvas.isSectionEnabled()) {
        //    this._canvas._scene.clipping.initialize(this._canvas._scene.bbox);
        //    this._canvas._section.updateGeometry(this._canvas._renderer);
        //}
        this._viewer._renderScene.onSceneChanged();
        this._viewer.invalidate();
        //this.onShadowChanged(true);
    };
    Scene3D.prototype.getLayers = function () {
        return this.core.layers;
    };
    /**
     * Set the visibilities of layers
     * @param {array} layers - the indices of layers needs to be changed.
     */
    Scene3D.prototype.setLayersVisible = function (layers, visible) {
        var changed = this.core.setLayersVisible(layers, visible);
        if (changed) {
            //this._onLayerChanged();
            this._viewer.invalidate();
        }
    };
    /**
     * Set the elements' visibility.
     * @param elementNames {Array<string>} - An array of element names.
     * @param color {Array<number>} - true to show and false to hide. Set it to null to restore elements to their original color.
     */
    Scene3D.prototype.setElementsColor = function (elementNames, color) {
        if (!color) {
            this.core.restoreElementsColor(elementNames);
        }
        else {
            this.core.setElementsColor(elementNames, color);
        }
        this._viewer.invalidate();
    };
    /**
     * Change the transparency value of elements.
     * @param elementNames
     * @param transparency
     */
    //public setElementsTransparency(elementNames:Array<number>, transparency:number) : void {
    //}
    /**
     * Set the visibility of elements.
     * @param elementNames
     * @param visible
     */
    Scene3D.prototype.setElementsVisibility = function (elementNames, visible) {
        this.core.setElementsVisibility(elementNames, visible);
        this._viewer.invalidate();
    };
    Scene3D.prototype.isElementVisible = function (elementName) {
        return this.core.isElementVisible(elementName);
    };
    /**
     * Return all elements' names.
     * @return {Array<string>} - The names of all elements in the scene.
     */
    Scene3D.prototype.getElementsNames = function () {
        var names = [];
        for (var i = 0; i < this.core.models.length; i++) {
            var model = this.core.models[i];
            for (var elementName in model.graph.elements) {
                names.push(elementName);
            }
        }
        return names;
    };
    Scene3D.prototype.getElementBBox = function (elementName) {
        return this.core.getElementBBox(elementName);
    };
    /**
     * Get the element name, i.e., doc name + element id with element
     * index in this cene.
     * @return {string} - The element name.
     */
    Scene3D.prototype.getElementName = function (elementIndex) {
        for (var i = 0; i < this.core.models.length; i++) {
            var model = this.core.models[i];
            for (var elementName in model.graph.elements) {
                if (elementIndex-- === 0) {
                    return elementName;
                }
            }
        }
        return "";
    };
    Scene3D.prototype.setModelVisiblity = function (modelId, visible) {
        var idx = this.core.models.findIndex(function (model) {
            return model.id == modelId;
        });
        if (idx != -1) {
            var model = this.core.models[idx];
            this.setElementsVisibility(Object.keys(model.graph.elements), visible);
        }
        else {
            console.warn("no model named " + modelId + " is found.");
        }
        this._viewer.invalidate();
    };
    Scene3D.prototype.setTerrainVisibility = function (visible) {
        this.core.setTerrainVisibility(visible);
        this._viewer.invalidate();
    };
    /**
     * Get the number of elements inside this scene.
     * @return {number} - The number of elements.
     */
    Scene3D.prototype.getElementsNumber = function () {
        var num = 0;
        for (var i = 0; i < this.core.models.length; i++) {
            var model = this.core.models[i];
            num += model.graph.elementsNum;
        }
        return num;
    };
    /**
     * Whether this scene contains any contour lines.
     * @return {boolean}
     */
    Scene3D.prototype.hasContours = function () {
        return this.core.hasProfileLines;
    };
    /**
     * Whether this contain any lines
     * @return {boolean}
     */
    Scene3D.prototype.hasLines = function () {
        return this.core.hasCurveOrLine;
    };
    /**
     * Whether this scene contain any surfaces.
     */
    Scene3D.prototype.hasSurfaces = function () {
        return true;
    };
    /**
     * Whether this scene has any BIM data.
     * @return {boolean} true for yes.
     */
    Scene3D.prototype.hasBIM = function () {
        return this.core.model.hasBIM();
    };
    /**
     * Get the current scene's clipping data.
     * @return the current clipping status. If current clipping is disabled, it returns zero. Otherwise, it returns
     * {"planes": 6 clipping planes, "points": 8 clipping vertices}.
     */
    Scene3D.prototype.getClippingData = function () {
        if (this.core.clipping.isEnabled()) {
            return {
                planes: this.core.clipping.getClippingPlanes(true),
                points: this.core.clipping.getClippingPoints(true)
            };
        }
        return null;
    };
    /**
     * Get the transform of the terrain.
     * @return {Array<number>} - [angle, scaling, x, y, z]
     */
    Scene3D.prototype.getTerrainTransform = function () {
        if (this.core.terrain) {
            var angle = this.core.terrain.getRotation();
            var translation = this.core.terrain.getTranslation();
            var scaling = this.core.terrain.getScaling();
            return [scaling, angle, translation[0], translation[1], translation[2]];
        }
        return null;
    };
    Scene3D.prototype.setTerrainScaling = function (scaling) {
        if (this.core.terrain) {
            this.core.terrain.setScaling(scaling);
            this.core.updateBBox();
            this._viewer.invalidate();
        }
    };
    Scene3D.prototype.setTerrainTranslation = function (x, y, z) {
        if (this.core.terrain) {
            this.core.terrain.setTranslation(x, y, z);
            this.core.updateBBox();
            this._viewer.invalidate();
        }
    };
    Scene3D.prototype.setTerrainRotation = function (angle) {
        if (this.core.terrain) {
            this.core.terrain.setRotation(angle);
            this.core.updateBBox();
            this._viewer.invalidate();
        }
    };
    Scene3D.prototype.getModelTransform = function (modelId) {
        if (this.core.models && modelId < this.core.models.length) {
            var model = this.core.models[modelId];
            var angle = model.getRotation();
            var translation = model.getTranslation();
            return [1.0, angle, translation[0], translation[1], translation[2]];
        }
    };
    Scene3D.prototype.translateModel = function (modelId, dx, dy, dz) {
        if (this.core.models && modelId < this.core.models.length) {
            var model = this.core.models[modelId];
            model.translate(dx, dy, dz);
            this.core.updateBBox();
            this._viewer.invalidate();
        }
    };
    // Rotate the model with angle in radians round line given by axis (the direction) and point on the
    // line. The rotation direction is righ-hand (ccw).
    Scene3D.prototype.rotateModel = function (modelId, angle, axis, point) {
        if (this.core.models && modelId < this.core.models.length) {
            var model = this.core.models[modelId];
            model.rotate(angle, axis, point);
            this.core.updateBBox();
            this._viewer.invalidate();
        }
    };
    return Scene3D;
}(_Scene__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (Scene3D);


/***/ }),

/***/ "./m3d_errors.js":
/*!***********************!*\
  !*** ./m3d_errors.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_errors.js
// The error code of Error. Referred by frontend
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var Error = {};
    Error.ERROR_NO = 0;
    Error.ERROR_INCOMPATIBLE_MODEL_FILE_VERSION = 10001;
    Error.ERROR_INSUFFICIENT_RESOURCE = 10002;
    Error.ERROR_ARRAY_BUFFER_WRONG_LENGTH = 10003;
    Error.error = Error.ERROR_NO;
    Error.getErrorMessage = function (err) {
        switch (err) {
            case Error.ERROR_NO:
                return "no error";
            case Error.ERROR_INCOMPATIBLE_MODEL_FILE_VERSION:
                return "Incompatible model file version.";
            case Error.ERROR_INSUFFICIENT_RESOURCE:
                return "Insufficient resources";
            case Error.ERROR_ARRAY_BUFFER_WRONG_LENGTH:
                return "Invalid/courrpted model data";
        }
    };
    return Error;
})());


/***/ }),

/***/ "./m3d_globals.js":
/*!************************!*\
  !*** ./m3d_globals.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// m3d_globals.js
// The global variables
//
// Copyright Modelo XX - 2017, All rights reserved.
/* harmony default export */ __webpack_exports__["default"] = ((function () {
    "use strict";
    var globals = {};
    globals.width = 1;
    globals.height = 1;
    globals.isMobile = false;
    globals.devicePixelRatio = 1.0;
    globals.littleEndian = true;
    globals.gpuMemory = 256; // in MB
    globals.frame = -1; // the current frame ID
    globals.browserName = "";
    globals.browserVersion = "";
    globals.bim = false; // If BIM information exists
    globals.state = -2; // FIXME: should refer to View.State.UNINITIALIZED
    // DO NOT REMOVE OR CHANGE STRING "CACHE_BUSTER_HOOK"
    // Used by build step to bust cache for shaders and web workers.
    globals.cacheBuster = "CACHE_BUSTER_HOOK";
    globals.Promise = null;
    globals.useStagedMesh = false;
    //
    // Configurations
    //
    globals.webvr = false;
    globals.profiling = false; // Turn on culling profiling and other rendering stats
    globals.compressScene = false; // Compress the scene geometry
    globals.maxInstances = 1000; // The maximum instanced draw.
    return globals;
})());


/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/depTrackingCache.js":
/*!********************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/depTrackingCache.js ***!
  \********************************************************************/
/*! exports provided: DepTrackingCache, defaultNormalizedCacheFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepTrackingCache", function() { return DepTrackingCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultNormalizedCacheFactory", function() { return defaultNormalizedCacheFactory; });
/* harmony import */ var _optimism__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./optimism */ "./node_modules/apollo-cache-inmemory/lib/optimism.js");

var hasOwn = Object.prototype.hasOwnProperty;
var DepTrackingCache = (function () {
    function DepTrackingCache(data) {
        if (data === void 0) { data = Object.create(null); }
        var _this = this;
        this.data = data;
        this.depend = Object(_optimism__WEBPACK_IMPORTED_MODULE_0__["wrap"])(function (dataId) { return _this.data[dataId]; }, {
            disposable: true,
            makeCacheKey: function (dataId) {
                return dataId;
            }
        });
    }
    DepTrackingCache.prototype.toObject = function () {
        return this.data;
    };
    DepTrackingCache.prototype.get = function (dataId) {
        this.depend(dataId);
        return this.data[dataId];
    };
    DepTrackingCache.prototype.set = function (dataId, value) {
        var oldValue = this.data[dataId];
        if (value !== oldValue) {
            this.data[dataId] = value;
            this.depend.dirty(dataId);
        }
    };
    DepTrackingCache.prototype.delete = function (dataId) {
        if (hasOwn.call(this.data, dataId)) {
            delete this.data[dataId];
            this.depend.dirty(dataId);
        }
    };
    DepTrackingCache.prototype.clear = function () {
        this.replace(null);
    };
    DepTrackingCache.prototype.replace = function (newData) {
        var _this = this;
        if (newData) {
            Object.keys(newData).forEach(function (dataId) {
                _this.set(dataId, newData[dataId]);
            });
            Object.keys(this.data).forEach(function (dataId) {
                if (!hasOwn.call(newData, dataId)) {
                    _this.delete(dataId);
                }
            });
        }
        else {
            Object.keys(this.data).forEach(function (dataId) {
                _this.delete(dataId);
            });
        }
    };
    return DepTrackingCache;
}());

function defaultNormalizedCacheFactory(seed) {
    return new DepTrackingCache(seed);
}
//# sourceMappingURL=depTrackingCache.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/fixPolyfills.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/fixPolyfills.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var frozen = {};
var frozenTestMap = new Map();
if (typeof Object.freeze === 'function') {
    Object.freeze(frozen);
}
try {
    frozenTestMap.set(frozen, frozen).delete(frozen);
}
catch (_a) {
    var wrap = function (method) {
        return method && (function (obj) {
            try {
                frozenTestMap.set(obj, obj).delete(obj);
            }
            finally {
                return method.call(Object, obj);
            }
        });
    };
    Object.freeze = wrap(Object.freeze);
    Object.seal = wrap(Object.seal);
    Object.preventExtensions = wrap(Object.preventExtensions);
}
//# sourceMappingURL=fixPolyfills.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/fragmentMatcher.js":
/*!*******************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/fragmentMatcher.js ***!
  \*******************************************************************/
/*! exports provided: HeuristicFragmentMatcher, IntrospectionFragmentMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeuristicFragmentMatcher", function() { return HeuristicFragmentMatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntrospectionFragmentMatcher", function() { return IntrospectionFragmentMatcher; });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");

var haveWarned = false;
var HeuristicFragmentMatcher = (function () {
    function HeuristicFragmentMatcher() {
    }
    HeuristicFragmentMatcher.prototype.ensureReady = function () {
        return Promise.resolve();
    };
    HeuristicFragmentMatcher.prototype.canBypassInit = function () {
        return true;
    };
    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
        var obj = context.store.get(idValue.id);
        if (!obj && idValue.id === 'ROOT_QUERY') {
            return true;
        }
        if (!obj) {
            return false;
        }
        if (!obj.__typename) {
            if (!haveWarned) {
                console.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
                console.warn('Could not find __typename on Fragment ', typeCondition, obj);
                console.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " +
                    "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
                if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isTest"])()) {
                    haveWarned = true;
                }
            }
            return 'heuristic';
        }
        if (obj.__typename === typeCondition) {
            return true;
        }
        Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["warnOnceInDevelopment"])('You are using the simple (heuristic) fragment matcher, but your ' +
            'queries contain union or interface types. Apollo Client will not be ' +
            'able to accurately map fragments. To make this error go away, use ' +
            'the `IntrospectionFragmentMatcher` as described in the docs: ' +
            'https://www.apollographql.com/docs/react/recipes/fragment-matching.html', 'error');
        return 'heuristic';
    };
    return HeuristicFragmentMatcher;
}());

var IntrospectionFragmentMatcher = (function () {
    function IntrospectionFragmentMatcher(options) {
        if (options && options.introspectionQueryResultData) {
            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
            this.isReady = true;
        }
        else {
            this.isReady = false;
        }
        this.match = this.match.bind(this);
    }
    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
        if (!this.isReady) {
            throw new Error('FragmentMatcher.match() was called before FragmentMatcher.init()');
        }
        var obj = context.store.get(idValue.id);
        if (!obj) {
            return false;
        }
        if (!obj.__typename) {
            throw new Error("Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
        }
        if (obj.__typename === typeCondition) {
            return true;
        }
        var implementingTypes = this.possibleTypesMap[typeCondition];
        if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {
            return true;
        }
        return false;
    };
    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {
        var typeMap = {};
        introspectionResultData.__schema.types.forEach(function (type) {
            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });
            }
        });
        return typeMap;
    };
    return IntrospectionFragmentMatcher;
}());

//# sourceMappingURL=fragmentMatcher.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/inMemoryCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/inMemoryCache.js ***!
  \*****************************************************************/
/*! exports provided: defaultDataIdFromObject, InMemoryCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultDataIdFromObject", function() { return defaultDataIdFromObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InMemoryCache", function() { return InMemoryCache; });
/* harmony import */ var _fixPolyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fixPolyfills */ "./node_modules/apollo-cache-inmemory/lib/fixPolyfills.js");
/* harmony import */ var _fixPolyfills__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fixPolyfills__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var apollo_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-cache */ "./node_modules/apollo-cache/lib/index.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _fragmentMatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragmentMatcher */ "./node_modules/apollo-cache-inmemory/lib/fragmentMatcher.js");
/* harmony import */ var _readFromStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./readFromStore */ "./node_modules/apollo-cache-inmemory/lib/readFromStore.js");
/* harmony import */ var _writeToStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./writeToStore */ "./node_modules/apollo-cache-inmemory/lib/writeToStore.js");
/* harmony import */ var _depTrackingCache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./depTrackingCache */ "./node_modules/apollo-cache-inmemory/lib/depTrackingCache.js");
/* harmony import */ var _optimism__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./optimism */ "./node_modules/apollo-cache-inmemory/lib/optimism.js");
/* harmony import */ var _recordingCache__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./recordingCache */ "./node_modules/apollo-cache-inmemory/lib/recordingCache.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};









var defaultConfig = {
    fragmentMatcher: new _fragmentMatcher__WEBPACK_IMPORTED_MODULE_3__["HeuristicFragmentMatcher"](),
    dataIdFromObject: defaultDataIdFromObject,
    addTypename: true,
};
function defaultDataIdFromObject(result) {
    if (result.__typename) {
        if (result.id !== undefined) {
            return result.__typename + ":" + result.id;
        }
        if (result._id !== undefined) {
            return result.__typename + ":" + result._id;
        }
    }
    return null;
}
var InMemoryCache = (function (_super) {
    __extends(InMemoryCache, _super);
    function InMemoryCache(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        _this.optimistic = [];
        _this.watches = new Set();
        _this.typenameDocumentCache = new Map();
        _this.cacheKeyRoot = new _optimism__WEBPACK_IMPORTED_MODULE_7__["CacheKeyNode"]();
        _this.silenceBroadcast = false;
        _this.config = __assign({}, defaultConfig, config);
        if (_this.config.customResolvers) {
            console.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');
            _this.config.cacheRedirects = _this.config.customResolvers;
        }
        if (_this.config.cacheResolvers) {
            console.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');
            _this.config.cacheRedirects = _this.config.cacheResolvers;
        }
        _this.addTypename = _this.config.addTypename;
        _this.data = Object(_depTrackingCache__WEBPACK_IMPORTED_MODULE_6__["defaultNormalizedCacheFactory"])();
        _this.storeReader = new _readFromStore__WEBPACK_IMPORTED_MODULE_4__["StoreReader"](_this.cacheKeyRoot);
        _this.storeWriter = new _writeToStore__WEBPACK_IMPORTED_MODULE_5__["StoreWriter"]();
        var cache = _this;
        var maybeBroadcastWatch = cache.maybeBroadcastWatch;
        _this.maybeBroadcastWatch = Object(_optimism__WEBPACK_IMPORTED_MODULE_7__["wrap"])(function (c) {
            return maybeBroadcastWatch.call(_this, c);
        }, {
            makeCacheKey: function (c) {
                if (c.optimistic && cache.optimistic.length > 0) {
                    return;
                }
                if (c.previousResult) {
                    return;
                }
                if (cache.data instanceof _depTrackingCache__WEBPACK_IMPORTED_MODULE_6__["DepTrackingCache"]) {
                    return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
                }
            }
        });
        return _this;
    }
    InMemoryCache.prototype.restore = function (data) {
        if (data)
            this.data.replace(data);
        return this;
    };
    InMemoryCache.prototype.extract = function (optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        if (optimistic && this.optimistic.length > 0) {
            var patches = this.optimistic.map(function (opt) { return opt.data; });
            return Object.assign.apply(Object, [{}, this.data.toObject()].concat(patches));
        }
        return this.data.toObject();
    };
    InMemoryCache.prototype.read = function (query) {
        if (query.rootId && this.data.get(query.rootId) === undefined) {
            return null;
        }
        var store = (query.optimistic && this.optimistic.length)
            ? Object(_depTrackingCache__WEBPACK_IMPORTED_MODULE_6__["defaultNormalizedCacheFactory"])(this.extract(true))
            : this.data;
        return this.storeReader.readQueryFromStore({
            store: store,
            query: this.transformDocument(query.query),
            variables: query.variables,
            rootId: query.rootId,
            fragmentMatcherFunction: this.config.fragmentMatcher.match,
            previousResult: query.previousResult,
            config: this.config,
        });
    };
    InMemoryCache.prototype.write = function (write) {
        this.storeWriter.writeResultToStore({
            dataId: write.dataId,
            result: write.result,
            variables: write.variables,
            document: this.transformDocument(write.query),
            store: this.data,
            dataIdFromObject: this.config.dataIdFromObject,
            fragmentMatcherFunction: this.config.fragmentMatcher.match,
        });
        this.broadcastWatches();
    };
    InMemoryCache.prototype.diff = function (query) {
        var store = (query.optimistic && this.optimistic.length)
            ? Object(_depTrackingCache__WEBPACK_IMPORTED_MODULE_6__["defaultNormalizedCacheFactory"])(this.extract(true))
            : this.data;
        return this.storeReader.diffQueryAgainstStore({
            store: store,
            query: this.transformDocument(query.query),
            variables: query.variables,
            returnPartialData: query.returnPartialData,
            previousResult: query.previousResult,
            fragmentMatcherFunction: this.config.fragmentMatcher.match,
            config: this.config,
        });
    };
    InMemoryCache.prototype.watch = function (watch) {
        var _this = this;
        this.watches.add(watch);
        return function () {
            _this.watches.delete(watch);
        };
    };
    InMemoryCache.prototype.evict = function (query) {
        throw new Error("eviction is not implemented on InMemory Cache");
    };
    InMemoryCache.prototype.reset = function () {
        this.data.clear();
        this.broadcastWatches();
        return Promise.resolve();
    };
    InMemoryCache.prototype.removeOptimistic = function (id) {
        var _this = this;
        var toPerform = this.optimistic.filter(function (item) { return item.id !== id; });
        this.optimistic = [];
        toPerform.forEach(function (change) {
            _this.recordOptimisticTransaction(change.transaction, change.id);
        });
        this.broadcastWatches();
    };
    InMemoryCache.prototype.performTransaction = function (transaction) {
        var alreadySilenced = this.silenceBroadcast;
        this.silenceBroadcast = true;
        transaction(this);
        if (!alreadySilenced) {
            this.silenceBroadcast = false;
        }
        this.broadcastWatches();
    };
    InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
        var _this = this;
        this.silenceBroadcast = true;
        var patch = Object(_recordingCache__WEBPACK_IMPORTED_MODULE_8__["record"])(this.extract(true), function (recordingCache) {
            var dataCache = _this.data;
            _this.data = recordingCache;
            _this.performTransaction(transaction);
            _this.data = dataCache;
        });
        this.optimistic.push({
            id: id,
            transaction: transaction,
            data: patch,
        });
        this.silenceBroadcast = false;
        this.broadcastWatches();
    };
    InMemoryCache.prototype.transformDocument = function (document) {
        if (this.addTypename) {
            var result = this.typenameDocumentCache.get(document);
            if (!result) {
                this.typenameDocumentCache.set(document, (result = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_2__["addTypenameToDocument"])(document)));
            }
            return result;
        }
        return document;
    };
    InMemoryCache.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.read({
            query: options.query,
            variables: options.variables,
            optimistic: optimistic,
        });
    };
    InMemoryCache.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.read({
            query: this.transformDocument(Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_2__["getFragmentQueryDocument"])(options.fragment, options.fragmentName)),
            variables: options.variables,
            rootId: options.id,
            optimistic: optimistic,
        });
    };
    InMemoryCache.prototype.writeQuery = function (options) {
        this.write({
            dataId: 'ROOT_QUERY',
            result: options.data,
            query: this.transformDocument(options.query),
            variables: options.variables,
        });
    };
    InMemoryCache.prototype.writeFragment = function (options) {
        this.write({
            dataId: options.id,
            result: options.data,
            query: this.transformDocument(Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_2__["getFragmentQueryDocument"])(options.fragment, options.fragmentName)),
            variables: options.variables,
        });
    };
    InMemoryCache.prototype.broadcastWatches = function () {
        var _this = this;
        if (!this.silenceBroadcast) {
            var optimistic_1 = this.optimistic.length > 0;
            this.watches.forEach(function (c) {
                _this.maybeBroadcastWatch(c);
                if (optimistic_1) {
                    _this.maybeBroadcastWatch.dirty(c);
                }
            });
        }
    };
    InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
        var previousResult = c.previousResult && c.previousResult();
        var newData = this.diff({
            query: c.query,
            variables: c.variables,
            previousResult: previousResult,
            optimistic: c.optimistic,
        });
        if (previousResult &&
            previousResult === newData.result) {
            return;
        }
        c.callback(newData);
    };
    return InMemoryCache;
}(apollo_cache__WEBPACK_IMPORTED_MODULE_1__["ApolloCache"]));

//# sourceMappingURL=inMemoryCache.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/index.js ***!
  \*********************************************************/
/*! exports provided: InMemoryCache, defaultDataIdFromObject, StoreReader, assertIdValue, WriteError, enhanceErrorWithDocument, StoreWriter, HeuristicFragmentMatcher, IntrospectionFragmentMatcher, ObjectCache, defaultNormalizedCacheFactory, RecordingCache, record */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _inMemoryCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inMemoryCache */ "./node_modules/apollo-cache-inmemory/lib/inMemoryCache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InMemoryCache", function() { return _inMemoryCache__WEBPACK_IMPORTED_MODULE_0__["InMemoryCache"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultDataIdFromObject", function() { return _inMemoryCache__WEBPACK_IMPORTED_MODULE_0__["defaultDataIdFromObject"]; });

/* harmony import */ var _readFromStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./readFromStore */ "./node_modules/apollo-cache-inmemory/lib/readFromStore.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StoreReader", function() { return _readFromStore__WEBPACK_IMPORTED_MODULE_1__["StoreReader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertIdValue", function() { return _readFromStore__WEBPACK_IMPORTED_MODULE_1__["assertIdValue"]; });

/* harmony import */ var _writeToStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./writeToStore */ "./node_modules/apollo-cache-inmemory/lib/writeToStore.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WriteError", function() { return _writeToStore__WEBPACK_IMPORTED_MODULE_2__["WriteError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enhanceErrorWithDocument", function() { return _writeToStore__WEBPACK_IMPORTED_MODULE_2__["enhanceErrorWithDocument"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StoreWriter", function() { return _writeToStore__WEBPACK_IMPORTED_MODULE_2__["StoreWriter"]; });

/* harmony import */ var _fragmentMatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragmentMatcher */ "./node_modules/apollo-cache-inmemory/lib/fragmentMatcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HeuristicFragmentMatcher", function() { return _fragmentMatcher__WEBPACK_IMPORTED_MODULE_3__["HeuristicFragmentMatcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntrospectionFragmentMatcher", function() { return _fragmentMatcher__WEBPACK_IMPORTED_MODULE_3__["IntrospectionFragmentMatcher"]; });

/* harmony import */ var _objectCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./objectCache */ "./node_modules/apollo-cache-inmemory/lib/objectCache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectCache", function() { return _objectCache__WEBPACK_IMPORTED_MODULE_4__["ObjectCache"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultNormalizedCacheFactory", function() { return _objectCache__WEBPACK_IMPORTED_MODULE_4__["defaultNormalizedCacheFactory"]; });

/* harmony import */ var _recordingCache__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./recordingCache */ "./node_modules/apollo-cache-inmemory/lib/recordingCache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecordingCache", function() { return _recordingCache__WEBPACK_IMPORTED_MODULE_5__["RecordingCache"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "record", function() { return _recordingCache__WEBPACK_IMPORTED_MODULE_5__["record"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/objectCache.js":
/*!***************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/objectCache.js ***!
  \***************************************************************/
/*! exports provided: ObjectCache, defaultNormalizedCacheFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectCache", function() { return ObjectCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultNormalizedCacheFactory", function() { return defaultNormalizedCacheFactory; });
var ObjectCache = (function () {
    function ObjectCache(data) {
        if (data === void 0) { data = Object.create(null); }
        this.data = data;
    }
    ObjectCache.prototype.toObject = function () {
        return this.data;
    };
    ObjectCache.prototype.get = function (dataId) {
        return this.data[dataId];
    };
    ObjectCache.prototype.set = function (dataId, value) {
        this.data[dataId] = value;
    };
    ObjectCache.prototype.delete = function (dataId) {
        this.data[dataId] = undefined;
    };
    ObjectCache.prototype.clear = function () {
        this.data = Object.create(null);
    };
    ObjectCache.prototype.replace = function (newData) {
        this.data = newData || Object.create(null);
    };
    return ObjectCache;
}());

function defaultNormalizedCacheFactory(seed) {
    return new ObjectCache(seed);
}
//# sourceMappingURL=objectCache.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/optimism.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/optimism.js ***!
  \************************************************************/
/*! exports provided: wrap, CacheKeyNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CacheKeyNode", function() { return CacheKeyNode; });
var wrap = __webpack_require__(/*! optimism */ "./node_modules/optimism/lib/index.js").wrap;

var CacheKeyNode = (function () {
    function CacheKeyNode() {
        this.children = null;
        this.key = null;
    }
    CacheKeyNode.prototype.lookup = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return this.lookupArray(args);
    };
    CacheKeyNode.prototype.lookupArray = function (array) {
        var node = this;
        array.forEach(function (value) {
            node = node.getOrCreate(value);
        });
        return node.key || (node.key = Object.create(null));
    };
    CacheKeyNode.prototype.getOrCreate = function (value) {
        var map = this.children || (this.children = new Map);
        return map.get(value) || map.set(value, new CacheKeyNode()).get(value);
    };
    return CacheKeyNode;
}());

//# sourceMappingURL=optimism.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/queryKeyMaker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/queryKeyMaker.js ***!
  \*****************************************************************/
/*! exports provided: QueryKeyMaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryKeyMaker", function() { return QueryKeyMaker; });
/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql/language/visitor */ "./node_modules/graphql/language/visitor.js");
/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var CIRCULAR = Object.create(null);
var objToStr = Object.prototype.toString;
var QueryKeyMaker = (function () {
    function QueryKeyMaker(cacheKeyRoot) {
        this.cacheKeyRoot = cacheKeyRoot;
        this.perQueryKeyMakers = new Map();
    }
    QueryKeyMaker.prototype.forQuery = function (document) {
        if (!this.perQueryKeyMakers.has(document)) {
            this.perQueryKeyMakers.set(document, new PerQueryKeyMaker(this.cacheKeyRoot, document));
        }
        return this.perQueryKeyMakers.get(document);
    };
    return QueryKeyMaker;
}());

var PerQueryKeyMaker = (function () {
    function PerQueryKeyMaker(cacheKeyRoot, query) {
        this.cacheKeyRoot = cacheKeyRoot;
        this.query = query;
        this.cache = new Map;
        this.lookupArray = this.cacheMethod(this.lookupArray);
        this.lookupObject = this.cacheMethod(this.lookupObject);
        this.lookupFragmentSpread = this.cacheMethod(this.lookupFragmentSpread);
    }
    PerQueryKeyMaker.prototype.cacheMethod = function (method) {
        var _this = this;
        return function (value) {
            if (_this.cache.has(value)) {
                var cached = _this.cache.get(value);
                if (cached === CIRCULAR) {
                    throw new Error("QueryKeyMaker cannot handle circular query structures");
                }
                return cached;
            }
            _this.cache.set(value, CIRCULAR);
            try {
                var result = method.call(_this, value);
                _this.cache.set(value, result);
                return result;
            }
            catch (e) {
                _this.cache.delete(value);
                throw e;
            }
        };
    };
    PerQueryKeyMaker.prototype.lookupQuery = function (document) {
        return this.lookupObject(document);
    };
    PerQueryKeyMaker.prototype.lookupSelectionSet = function (selectionSet) {
        return this.lookupObject(selectionSet);
    };
    PerQueryKeyMaker.prototype.lookupFragmentSpread = function (fragmentSpread) {
        var name = fragmentSpread.name.value;
        var fragment = null;
        this.query.definitions.some(function (definition) {
            if (definition.kind === "FragmentDefinition" &&
                definition.name.value === name) {
                fragment = definition;
                return true;
            }
        });
        return this.lookupObject(__assign({}, fragmentSpread, { fragment: fragment }));
    };
    PerQueryKeyMaker.prototype.lookupAny = function (value) {
        if (Array.isArray(value)) {
            return this.lookupArray(value);
        }
        if (typeof value === "object" && value !== null) {
            if (value.kind === "FragmentSpread") {
                return this.lookupFragmentSpread(value);
            }
            return this.lookupObject(value);
        }
        return value;
    };
    PerQueryKeyMaker.prototype.lookupArray = function (array) {
        var elements = array.map(this.lookupAny, this);
        return this.cacheKeyRoot.lookup(objToStr.call(array), this.cacheKeyRoot.lookupArray(elements));
    };
    PerQueryKeyMaker.prototype.lookupObject = function (object) {
        var _this = this;
        var keys = safeSortedKeys(object);
        var values = keys.map(function (key) { return _this.lookupAny(object[key]); });
        return this.cacheKeyRoot.lookup(objToStr.call(object), this.cacheKeyRoot.lookupArray(keys), this.cacheKeyRoot.lookupArray(values));
    };
    return PerQueryKeyMaker;
}());
var queryKeyMap = Object.create(null);
Object.keys(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__["QueryDocumentKeys"]).forEach(function (parentKind) {
    var childKeys = queryKeyMap[parentKind] = Object.create(null);
    graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__["QueryDocumentKeys"][parentKind].forEach(function (childKey) {
        childKeys[childKey] = true;
    });
    if (parentKind === "FragmentSpread") {
        childKeys["fragment"] = true;
    }
});
function safeSortedKeys(object) {
    var keys = Object.keys(object);
    var keyCount = keys.length;
    var knownKeys = typeof object.kind === "string" && queryKeyMap[object.kind];
    var target = 0;
    for (var source = target; source < keyCount; ++source) {
        var key = keys[source];
        var value = object[key];
        var isObjectOrArray = value !== null && typeof value === "object";
        if (!isObjectOrArray || !knownKeys || knownKeys[key] === true) {
            keys[target++] = key;
        }
    }
    keys.length = target;
    return keys.sort();
}
//# sourceMappingURL=queryKeyMaker.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/readFromStore.js":
/*!*****************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/readFromStore.js ***!
  \*****************************************************************/
/*! exports provided: StoreReader, assertIdValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoreReader", function() { return StoreReader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertIdValue", function() { return assertIdValue; });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _optimism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./optimism */ "./node_modules/apollo-cache-inmemory/lib/optimism.js");
/* harmony import */ var _depTrackingCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./depTrackingCache */ "./node_modules/apollo-cache-inmemory/lib/depTrackingCache.js");
/* harmony import */ var _queryKeyMaker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./queryKeyMaker */ "./node_modules/apollo-cache-inmemory/lib/queryKeyMaker.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




var StoreReader = (function () {
    function StoreReader(cacheKeyRoot) {
        if (cacheKeyRoot === void 0) { cacheKeyRoot = new _optimism__WEBPACK_IMPORTED_MODULE_1__["CacheKeyNode"]; }
        var _this = this;
        this.cacheKeyRoot = cacheKeyRoot;
        var reader = this;
        var executeStoreQuery = reader.executeStoreQuery, executeSelectionSet = reader.executeSelectionSet;
        reader.keyMaker = new _queryKeyMaker__WEBPACK_IMPORTED_MODULE_3__["QueryKeyMaker"](cacheKeyRoot);
        this.executeStoreQuery = Object(_optimism__WEBPACK_IMPORTED_MODULE_1__["wrap"])(function (options) {
            return executeStoreQuery.call(_this, options);
        }, {
            makeCacheKey: function (_a) {
                var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;
                if (contextValue.store instanceof _depTrackingCache__WEBPACK_IMPORTED_MODULE_2__["DepTrackingCache"]) {
                    return reader.cacheKeyRoot.lookup(reader.keyMaker.forQuery(query).lookupQuery(query), contextValue.store, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
                }
            }
        });
        this.executeSelectionSet = Object(_optimism__WEBPACK_IMPORTED_MODULE_1__["wrap"])(function (options) {
            return executeSelectionSet.call(_this, options);
        }, {
            makeCacheKey: function (_a) {
                var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
                if (execContext.contextValue.store instanceof _depTrackingCache__WEBPACK_IMPORTED_MODULE_2__["DepTrackingCache"]) {
                    return reader.cacheKeyRoot.lookup(reader.keyMaker.forQuery(execContext.query).lookupSelectionSet(selectionSet), execContext.contextValue.store, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
                }
            }
        });
    }
    StoreReader.prototype.readQueryFromStore = function (options) {
        var optsPatch = { returnPartialData: false };
        return this.diffQueryAgainstStore(__assign({}, options, optsPatch)).result;
    };
    StoreReader.prototype.diffQueryAgainstStore = function (_a) {
        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;
        var queryDefinition = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getQueryDefinition"])(query);
        variables = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getDefaultValues"])(queryDefinition), variables);
        var context = {
            store: store,
            dataIdFromObject: (config && config.dataIdFromObject) || null,
            cacheRedirects: (config && config.cacheRedirects) || {},
        };
        var execResult = this.executeStoreQuery({
            query: query,
            rootValue: {
                type: 'id',
                id: rootId,
                generated: true,
                typename: 'Query',
            },
            contextValue: context,
            variableValues: variables,
            fragmentMatcher: fragmentMatcherFunction,
        });
        var hasMissingFields = execResult.missing && execResult.missing.length > 0;
        if (hasMissingFields && !returnPartialData) {
            execResult.missing.forEach(function (info) {
                if (info.tolerable)
                    return;
                throw new Error("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
            });
        }
        if (previousResult) {
            if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(previousResult, execResult.result)) {
                execResult.result = previousResult;
            }
        }
        return {
            result: execResult.result,
            complete: !hasMissingFields,
        };
    };
    StoreReader.prototype.executeStoreQuery = function (_a) {
        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
        var mainDefinition = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getMainDefinition"])(query);
        var fragments = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getFragmentDefinitions"])(query);
        var fragmentMap = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["createFragmentMap"])(fragments);
        var execContext = {
            query: query,
            fragmentMap: fragmentMap,
            contextValue: contextValue,
            variableValues: variableValues,
            fragmentMatcher: fragmentMatcher,
        };
        return this.executeSelectionSet({
            selectionSet: mainDefinition.selectionSet,
            rootValue: rootValue,
            execContext: execContext,
        });
    };
    StoreReader.prototype.executeSelectionSet = function (_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
        var finalResult = {
            result: {},
        };
        var object = contextValue.store.get(rootValue.id);
        var typename = (object && object.__typename) ||
            (rootValue.id === 'ROOT_QUERY' && 'Query') ||
            void 0;
        function handleMissing(result) {
            var _a;
            if (result.missing) {
                finalResult.missing = finalResult.missing || [];
                (_a = finalResult.missing).push.apply(_a, result.missing);
            }
            return result.result;
        }
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["shouldInclude"])(selection, variables)) {
                return;
            }
            if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isField"])(selection)) {
                var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));
                if (typeof fieldResult !== 'undefined') {
                    merge(finalResult.result, (_a = {},
                        _a[Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["resultKeyNameFromField"])(selection)] = fieldResult,
                        _a));
                }
            }
            else {
                var fragment = void 0;
                if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isInlineFragment"])(selection)) {
                    fragment = selection;
                }
                else {
                    fragment = fragmentMap[selection.name.value];
                    if (!fragment) {
                        throw new Error("No fragment named " + selection.name.value);
                    }
                }
                var typeCondition = fragment.typeCondition.name.value;
                var match = execContext.fragmentMatcher(rootValue, typeCondition, contextValue);
                if (match) {
                    var fragmentExecResult = _this.executeSelectionSet({
                        selectionSet: fragment.selectionSet,
                        rootValue: rootValue,
                        execContext: execContext,
                    });
                    if (match === 'heuristic' && fragmentExecResult.missing) {
                        fragmentExecResult = __assign({}, fragmentExecResult, { missing: fragmentExecResult.missing.map(function (info) {
                                return __assign({}, info, { tolerable: true });
                            }) });
                    }
                    merge(finalResult.result, handleMissing(fragmentExecResult));
                }
            }
        });
        return finalResult;
    };
    StoreReader.prototype.executeField = function (object, typename, field, execContext) {
        var variables = execContext.variableValues, contextValue = execContext.contextValue;
        var fieldName = field.name.value;
        var args = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["argumentsObjectFromField"])(field, variables);
        var info = {
            resultKey: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["resultKeyNameFromField"])(field),
            directives: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getDirectiveInfoFromField"])(field, variables),
        };
        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);
        if (!field.selectionSet) {
            return readStoreResult;
        }
        if (readStoreResult.result == null) {
            return readStoreResult;
        }
        function handleMissing(res) {
            var missing = null;
            if (readStoreResult.missing) {
                missing = missing || [];
                missing.push.apply(missing, readStoreResult.missing);
            }
            if (res.missing) {
                missing = missing || [];
                missing.push.apply(missing, res.missing);
            }
            return {
                result: res.result,
                missing: missing,
            };
        }
        if (Array.isArray(readStoreResult.result)) {
            return handleMissing(this.executeSubSelectedArray(field, readStoreResult.result, execContext));
        }
        return handleMissing(this.executeSelectionSet({
            selectionSet: field.selectionSet,
            rootValue: readStoreResult.result,
            execContext: execContext,
        }));
    };
    StoreReader.prototype.executeSubSelectedArray = function (field, result, execContext) {
        var _this = this;
        var missing = null;
        function handleMissing(childResult) {
            if (childResult.missing) {
                missing = missing || [];
                missing.push.apply(missing, childResult.missing);
            }
            return childResult.result;
        }
        result = result.map(function (item) {
            if (item === null) {
                return null;
            }
            if (Array.isArray(item)) {
                return handleMissing(_this.executeSubSelectedArray(field, item, execContext));
            }
            return handleMissing(_this.executeSelectionSet({
                selectionSet: field.selectionSet,
                rootValue: item,
                execContext: execContext,
            }));
        });
        return { result: result, missing: missing };
    };
    return StoreReader;
}());

function defaultFragmentMatcher() {
    return true;
}
function assertIdValue(idValue) {
    if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isIdValue"])(idValue)) {
        throw new Error("Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.");
    }
}
function readStoreResolver(object, typename, fieldName, args, context, _a) {
    var resultKey = _a.resultKey, directives = _a.directives;
    var storeKeyName = fieldName;
    if (args || directives) {
        storeKeyName = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getStoreKeyName"])(storeKeyName, args, directives);
    }
    var fieldValue = void 0;
    if (object) {
        fieldValue = object[storeKeyName];
        if (typeof fieldValue === 'undefined' &&
            context.cacheRedirects &&
            typeof typename === 'string') {
            var type = context.cacheRedirects[typename];
            if (type) {
                var resolver = type[fieldName];
                if (resolver) {
                    fieldValue = resolver(object, args, {
                        getCacheKey: function (storeObj) {
                            return Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["toIdValue"])({
                                id: context.dataIdFromObject(storeObj),
                                typename: storeObj.__typename,
                            });
                        },
                    });
                }
            }
        }
    }
    if (typeof fieldValue === 'undefined') {
        return {
            result: fieldValue,
            missing: [{
                    object: object,
                    fieldName: storeKeyName,
                    tolerable: false,
                }],
        };
    }
    if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isJsonValue"])(fieldValue)) {
        fieldValue = fieldValue.json;
    }
    return {
        result: fieldValue,
    };
}
var hasOwn = Object.prototype.hasOwnProperty;
function merge(target, source) {
    if (source !== null && typeof source === 'object' &&
        source !== target) {
        if (Object.isExtensible && !Object.isExtensible(target)) {
            target = __assign({}, target);
        }
        Object.keys(source).forEach(function (sourceKey) {
            var sourceVal = source[sourceKey];
            if (!hasOwn.call(target, sourceKey)) {
                target[sourceKey] = sourceVal;
            }
            else {
                target[sourceKey] = merge(target[sourceKey], sourceVal);
            }
        });
    }
    return target;
}
//# sourceMappingURL=readFromStore.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/recordingCache.js":
/*!******************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/recordingCache.js ***!
  \******************************************************************/
/*! exports provided: RecordingCache, record */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RecordingCache", function() { return RecordingCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "record", function() { return record; });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var RecordingCache = (function () {
    function RecordingCache(data) {
        if (data === void 0) { data = {}; }
        this.data = data;
        this.recordedData = {};
    }
    RecordingCache.prototype.record = function (transaction) {
        transaction(this);
        var recordedData = this.recordedData;
        this.recordedData = {};
        return recordedData;
    };
    RecordingCache.prototype.toObject = function () {
        return __assign({}, this.data, this.recordedData);
    };
    RecordingCache.prototype.get = function (dataId) {
        if (this.recordedData.hasOwnProperty(dataId)) {
            return this.recordedData[dataId];
        }
        return this.data[dataId];
    };
    RecordingCache.prototype.set = function (dataId, value) {
        if (this.get(dataId) !== value) {
            this.recordedData[dataId] = value;
        }
    };
    RecordingCache.prototype.delete = function (dataId) {
        this.recordedData[dataId] = undefined;
    };
    RecordingCache.prototype.clear = function () {
        var _this = this;
        Object.keys(this.data).forEach(function (dataId) { return _this.delete(dataId); });
        this.recordedData = {};
    };
    RecordingCache.prototype.replace = function (newData) {
        this.clear();
        this.recordedData = __assign({}, newData);
    };
    return RecordingCache;
}());

function record(startingState, transaction) {
    var recordingCache = new RecordingCache(startingState);
    return recordingCache.record(transaction);
}
//# sourceMappingURL=recordingCache.js.map

/***/ }),

/***/ "./node_modules/apollo-cache-inmemory/lib/writeToStore.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-cache-inmemory/lib/writeToStore.js ***!
  \****************************************************************/
/*! exports provided: WriteError, enhanceErrorWithDocument, StoreWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WriteError", function() { return WriteError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enhanceErrorWithDocument", function() { return enhanceErrorWithDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoreWriter", function() { return StoreWriter; });
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _objectCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectCache */ "./node_modules/apollo-cache-inmemory/lib/objectCache.js");
/* harmony import */ var _depTrackingCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./depTrackingCache */ "./node_modules/apollo-cache-inmemory/lib/depTrackingCache.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




var WriteError = (function (_super) {
    __extends(WriteError, _super);
    function WriteError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'WriteError';
        return _this;
    }
    return WriteError;
}(Error));

function enhanceErrorWithDocument(error, document) {
    var enhancedError = new WriteError("Error writing result to store for query:\n " + Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"])(document));
    enhancedError.message += '\n' + error.message;
    enhancedError.stack = error.stack;
    return enhancedError;
}
var StoreWriter = (function () {
    function StoreWriter() {
    }
    StoreWriter.prototype.writeQueryToStore = function (_a) {
        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? Object(_depTrackingCache__WEBPACK_IMPORTED_MODULE_3__["defaultNormalizedCacheFactory"])() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
        return this.writeResultToStore({
            dataId: 'ROOT_QUERY',
            result: result,
            document: query,
            store: store,
            variables: variables,
            dataIdFromObject: dataIdFromObject,
            fragmentMatcherFunction: fragmentMatcherFunction,
        });
    };
    StoreWriter.prototype.writeResultToStore = function (_a) {
        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? Object(_depTrackingCache__WEBPACK_IMPORTED_MODULE_3__["defaultNormalizedCacheFactory"])() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
        var operationDefinition = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["getOperationDefinition"])(document);
        try {
            return this.writeSelectionSetToStore({
                result: result,
                dataId: dataId,
                selectionSet: operationDefinition.selectionSet,
                context: {
                    store: store,
                    processedData: {},
                    variables: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["assign"])({}, Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["getDefaultValues"])(operationDefinition), variables),
                    dataIdFromObject: dataIdFromObject,
                    fragmentMap: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["createFragmentMap"])(Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["getFragmentDefinitions"])(document)),
                    fragmentMatcherFunction: fragmentMatcherFunction,
                },
            });
        }
        catch (e) {
            throw enhanceErrorWithDocument(e, document);
        }
    };
    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
        var _this = this;
        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;
        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;
        selectionSet.selections.forEach(function (selection) {
            if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["shouldInclude"])(selection, variables)) {
                return;
            }
            if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isField"])(selection)) {
                var resultFieldKey = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["resultKeyNameFromField"])(selection);
                var value = result[resultFieldKey];
                if (typeof value !== 'undefined') {
                    _this.writeFieldToStore({
                        dataId: dataId,
                        value: value,
                        field: selection,
                        context: context,
                    });
                }
                else {
                    var isDefered = selection.directives &&
                        selection.directives.length &&
                        selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });
                    if (!isDefered && context.fragmentMatcherFunction) {
                        if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isProduction"])()) {
                            console.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
                        }
                    }
                }
            }
            else {
                var fragment = void 0;
                if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isInlineFragment"])(selection)) {
                    fragment = selection;
                }
                else {
                    fragment = (fragmentMap || {})[selection.name.value];
                    if (!fragment) {
                        throw new Error("No fragment named " + selection.name.value + ".");
                    }
                }
                var matches = true;
                if (context.fragmentMatcherFunction && fragment.typeCondition) {
                    var idValue = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["toIdValue"])({ id: 'self', typename: undefined });
                    var fakeContext = {
                        store: new _objectCache__WEBPACK_IMPORTED_MODULE_2__["ObjectCache"]({ self: result }),
                        cacheRedirects: {},
                    };
                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);
                    if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isProduction"])() && match === 'heuristic') {
                        console.error('WARNING: heuristic fragment matching going on!');
                    }
                    matches = !!match;
                }
                if (matches) {
                    _this.writeSelectionSetToStore({
                        result: result,
                        selectionSet: fragment.selectionSet,
                        dataId: dataId,
                        context: context,
                    });
                }
            }
        });
        return store;
    };
    StoreWriter.prototype.writeFieldToStore = function (_a) {
        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;
        var _b;
        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;
        var storeValue;
        var storeObject;
        var storeFieldName = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["storeKeyNameFromField"])(field, variables);
        if (!field.selectionSet || value === null) {
            storeValue =
                value != null && typeof value === 'object'
                    ?
                        { type: 'json', json: value }
                    :
                        value;
        }
        else if (Array.isArray(value)) {
            var generatedId = dataId + "." + storeFieldName;
            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
        }
        else {
            var valueDataId = dataId + "." + storeFieldName;
            var generated = true;
            if (!isGeneratedId(valueDataId)) {
                valueDataId = '$' + valueDataId;
            }
            if (dataIdFromObject) {
                var semanticId = dataIdFromObject(value);
                if (semanticId && isGeneratedId(semanticId)) {
                    throw new Error('IDs returned by dataIdFromObject cannot begin with the "$" character.');
                }
                if (semanticId ||
                    (typeof semanticId === 'number' && semanticId === 0)) {
                    valueDataId = semanticId;
                    generated = false;
                }
            }
            if (!isDataProcessed(valueDataId, field, context.processedData)) {
                this.writeSelectionSetToStore({
                    dataId: valueDataId,
                    result: value,
                    selectionSet: field.selectionSet,
                    context: context,
                });
            }
            var typename = value.__typename;
            storeValue = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["toIdValue"])({ id: valueDataId, typename: typename }, generated);
            storeObject = store.get(dataId);
            var escapedId = storeObject && storeObject[storeFieldName];
            if (escapedId !== storeValue && Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isIdValue"])(escapedId)) {
                var hadTypename = escapedId.typename !== undefined;
                var hasTypename = typename !== undefined;
                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
                if (generated && !escapedId.generated && !typenameChanged) {
                    throw new Error("Store error: the application attempted to write an object with no provided id" +
                        (" but the store already contains an id of " + escapedId.id + " for this object. The selectionSet") +
                        " that was trying to be written is:\n" +
                        Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"])(field));
                }
                if (hadTypename && !hasTypename) {
                    throw new Error("Store error: the application attempted to write an object with no provided typename" +
                        (" but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet") +
                        " that was trying to be written is:\n" +
                        Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"])(field));
                }
                if (escapedId.generated) {
                    if (typenameChanged) {
                        if (!generated) {
                            store.delete(escapedId.id);
                        }
                    }
                    else {
                        mergeWithGenerated(escapedId.id, storeValue.id, store);
                    }
                }
            }
        }
        storeObject = store.get(dataId);
        if (!storeObject || !Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(storeValue, storeObject[storeFieldName])) {
            store.set(dataId, __assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));
        }
    };
    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
        var _this = this;
        return value.map(function (item, index) {
            if (item === null) {
                return null;
            }
            var itemDataId = generatedId + "." + index;
            if (Array.isArray(item)) {
                return _this.processArrayValue(item, itemDataId, selectionSet, context);
            }
            var generated = true;
            if (context.dataIdFromObject) {
                var semanticId = context.dataIdFromObject(item);
                if (semanticId) {
                    itemDataId = semanticId;
                    generated = false;
                }
            }
            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
                _this.writeSelectionSetToStore({
                    dataId: itemDataId,
                    result: item,
                    selectionSet: selectionSet,
                    context: context,
                });
            }
            return Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["toIdValue"])({ id: itemDataId, typename: item.__typename }, generated);
        });
    };
    return StoreWriter;
}());

function isGeneratedId(id) {
    return id[0] === '$';
}
function mergeWithGenerated(generatedKey, realKey, cache) {
    if (generatedKey === realKey) {
        return false;
    }
    var generated = cache.get(generatedKey);
    var real = cache.get(realKey);
    var madeChanges = false;
    Object.keys(generated).forEach(function (key) {
        var value = generated[key];
        var realValue = real[key];
        if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isIdValue"])(value) &&
            isGeneratedId(value.id) &&
            Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isIdValue"])(realValue) &&
            !Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(value, realValue) &&
            mergeWithGenerated(value.id, realValue.id, cache)) {
            madeChanges = true;
        }
    });
    cache.delete(generatedKey);
    var newRealValue = __assign({}, generated, real);
    if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(newRealValue, real)) {
        return madeChanges;
    }
    cache.set(realKey, newRealValue);
    return true;
}
function isDataProcessed(dataId, field, processedData) {
    if (!processedData) {
        return false;
    }
    if (processedData[dataId]) {
        if (processedData[dataId].indexOf(field) >= 0) {
            return true;
        }
        else {
            processedData[dataId].push(field);
        }
    }
    else {
        processedData[dataId] = [field];
    }
    return false;
}
//# sourceMappingURL=writeToStore.js.map

/***/ }),

/***/ "./node_modules/apollo-cache/lib/cache.js":
/*!************************************************!*\
  !*** ./node_modules/apollo-cache/lib/cache.js ***!
  \************************************************/
/*! exports provided: ApolloCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApolloCache", function() { return ApolloCache; });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/apollo-cache/lib/utils.js");


var ApolloCache = (function () {
    function ApolloCache() {
    }
    ApolloCache.prototype.transformDocument = function (document) {
        return document;
    };
    ApolloCache.prototype.transformForLink = function (document) {
        return document;
    };
    ApolloCache.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.read({
            query: options.query,
            variables: options.variables,
            optimistic: optimistic,
        });
    };
    ApolloCache.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.read({
            query: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getFragmentQueryDocument"])(options.fragment, options.fragmentName),
            variables: options.variables,
            rootId: options.id,
            optimistic: optimistic,
        });
    };
    ApolloCache.prototype.writeQuery = function (options) {
        this.write({
            dataId: 'ROOT_QUERY',
            result: options.data,
            query: options.query,
            variables: options.variables,
        });
    };
    ApolloCache.prototype.writeFragment = function (options) {
        this.write({
            dataId: options.id,
            result: options.data,
            variables: options.variables,
            query: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getFragmentQueryDocument"])(options.fragment, options.fragmentName),
        });
    };
    ApolloCache.prototype.writeData = function (_a) {
        var id = _a.id, data = _a.data;
        if (typeof id !== 'undefined') {
            var typenameResult = null;
            try {
                typenameResult = this.read({
                    rootId: id,
                    optimistic: false,
                    query: _utils__WEBPACK_IMPORTED_MODULE_1__["justTypenameQuery"],
                });
            }
            catch (e) {
            }
            var __typename = (typenameResult && typenameResult.__typename) || '__ClientData';
            var dataToWrite = Object.assign({ __typename: __typename }, data);
            this.writeFragment({
                id: id,
                fragment: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["fragmentFromPojo"])(dataToWrite, __typename),
                data: dataToWrite,
            });
        }
        else {
            this.writeQuery({ query: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["queryFromPojo"])(data), data: data });
        }
    };
    return ApolloCache;
}());

//# sourceMappingURL=cache.js.map

/***/ }),

/***/ "./node_modules/apollo-cache/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/apollo-cache/lib/index.js ***!
  \************************************************/
/*! exports provided: ApolloCache, Cache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ "./node_modules/apollo-cache/lib/cache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApolloCache", function() { return _cache__WEBPACK_IMPORTED_MODULE_0__["ApolloCache"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/apollo-cache/lib/types/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Cache"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-cache/lib/types/Cache.js":
/*!******************************************************!*\
  !*** ./node_modules/apollo-cache/lib/types/Cache.js ***!
  \******************************************************/
/*! exports provided: Cache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
var Cache;
(function (Cache) {
})(Cache || (Cache = {}));
//# sourceMappingURL=Cache.js.map

/***/ }),

/***/ "./node_modules/apollo-cache/lib/types/index.js":
/*!******************************************************!*\
  !*** ./node_modules/apollo-cache/lib/types/index.js ***!
  \******************************************************/
/*! exports provided: Cache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache */ "./node_modules/apollo-cache/lib/types/Cache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return _Cache__WEBPACK_IMPORTED_MODULE_0__["Cache"]; });


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-cache/lib/utils.js":
/*!************************************************!*\
  !*** ./node_modules/apollo-cache/lib/utils.js ***!
  \************************************************/
/*! exports provided: queryFromPojo, fragmentFromPojo, justTypenameQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryFromPojo", function() { return queryFromPojo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentFromPojo", function() { return fragmentFromPojo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "justTypenameQuery", function() { return justTypenameQuery; });
function queryFromPojo(obj) {
    var op = {
        kind: 'OperationDefinition',
        operation: 'query',
        name: {
            kind: 'Name',
            value: 'GeneratedClientQuery',
        },
        selectionSet: selectionSetFromObj(obj),
    };
    var out = {
        kind: 'Document',
        definitions: [op],
    };
    return out;
}
function fragmentFromPojo(obj, typename) {
    var frag = {
        kind: 'FragmentDefinition',
        typeCondition: {
            kind: 'NamedType',
            name: {
                kind: 'Name',
                value: typename || '__FakeType',
            },
        },
        name: {
            kind: 'Name',
            value: 'GeneratedClientQuery',
        },
        selectionSet: selectionSetFromObj(obj),
    };
    var out = {
        kind: 'Document',
        definitions: [frag],
    };
    return out;
}
function selectionSetFromObj(obj) {
    if (typeof obj === 'number' ||
        typeof obj === 'boolean' ||
        typeof obj === 'string' ||
        typeof obj === 'undefined' ||
        obj === null) {
        return null;
    }
    if (Array.isArray(obj)) {
        return selectionSetFromObj(obj[0]);
    }
    var selections = [];
    Object.keys(obj).forEach(function (key) {
        var field = {
            kind: 'Field',
            name: {
                kind: 'Name',
                value: key,
            },
        };
        var nestedSelSet = selectionSetFromObj(obj[key]);
        if (nestedSelSet) {
            field.selectionSet = nestedSelSet;
        }
        selections.push(field);
    });
    var selectionSet = {
        kind: 'SelectionSet',
        selections: selections,
    };
    return selectionSet;
}
var justTypenameQuery = {
    kind: 'Document',
    definitions: [
        {
            kind: 'OperationDefinition',
            operation: 'query',
            name: null,
            variableDefinitions: null,
            directives: [],
            selectionSet: {
                kind: 'SelectionSet',
                selections: [
                    {
                        kind: 'Field',
                        alias: null,
                        name: {
                            kind: 'Name',
                            value: '__typename',
                        },
                        arguments: [],
                        directives: [],
                        selectionSet: null,
                    },
                ],
            },
        },
    ],
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/apollo-client/ApolloClient.js":
/*!****************************************************!*\
  !*** ./node_modules/apollo-client/ApolloClient.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/index.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _core_QueryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/QueryManager */ "./node_modules/apollo-client/core/QueryManager.js");
/* harmony import */ var _data_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data/store */ "./node_modules/apollo-client/data/store.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./version */ "./node_modules/apollo-client/version.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_version__WEBPACK_IMPORTED_MODULE_4__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};





var hasSuggestedDevtools = false;
var supportedDirectives = new apollo_link__WEBPACK_IMPORTED_MODULE_0__["ApolloLink"](function (operation, forward) {
    operation.query = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["removeConnectionDirectiveFromDocument"])(operation.query);
    return forward(operation);
});
var ApolloClient = (function () {
    function ApolloClient(options) {
        var _this = this;
        this.defaultOptions = {};
        this.resetStoreCallbacks = [];
        var link = options.link, cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions = options.defaultOptions;
        if (!link || !cache) {
            throw new Error("\n        In order to initialize Apollo Client, you must specify link & cache properties on the config object.\n        This is part of the required upgrade when migrating from Apollo Client 1.0 to Apollo Client 2.0.\n        For more information, please visit:\n          https://www.apollographql.com/docs/react/basics/setup.html\n        to help you get started.\n      ");
        }
        this.link = supportedDirectives.concat(link);
        this.cache = cache;
        this.store = new _data_store__WEBPACK_IMPORTED_MODULE_3__["DataStore"](cache);
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.ssrMode = ssrMode;
        this.defaultOptions = defaultOptions || {};
        if (ssrForceFetchDelay) {
            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        var defaultConnectToDevTools = !Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isProduction"])() &&
            typeof window !== 'undefined' &&
            !window.__APOLLO_CLIENT__;
        if (typeof connectToDevTools === 'undefined'
            ? defaultConnectToDevTools
            : connectToDevTools && typeof window !== 'undefined') {
            window.__APOLLO_CLIENT__ = this;
        }
        if (!hasSuggestedDevtools && !Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isProduction"])()) {
            hasSuggestedDevtools = true;
            if (typeof window !== 'undefined' &&
                window.document &&
                window.top === window.self) {
                if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                    if (window.navigator &&
                        window.navigator.userAgent.indexOf('Chrome') > -1) {
                        console.debug('Download the Apollo DevTools ' +
                            'for a better development experience: ' +
                            'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
                    }
                }
            }
        }
        this.version = _version__WEBPACK_IMPORTED_MODULE_4__["version"];
    }
    ApolloClient.prototype.watchQuery = function (options) {
        if (this.defaultOptions.watchQuery) {
            options = __assign({}, this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches &&
            (options.fetchPolicy === 'network-only' ||
                options.fetchPolicy === 'cache-and-network')) {
            options = __assign({}, options, { fetchPolicy: 'cache-first' });
        }
        return this.initQueryManager().watchQuery(options);
    };
    ApolloClient.prototype.query = function (options) {
        if (this.defaultOptions.query) {
            options = __assign({}, this.defaultOptions.query, options);
        }
        if (options.fetchPolicy === 'cache-and-network') {
            throw new Error('cache-and-network fetchPolicy can only be used with watchQuery');
        }
        if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
            options = __assign({}, options, { fetchPolicy: 'cache-first' });
        }
        return this.initQueryManager().query(options);
    };
    ApolloClient.prototype.mutate = function (options) {
        if (this.defaultOptions.mutate) {
            options = __assign({}, this.defaultOptions.mutate, options);
        }
        return this.initQueryManager().mutate(options);
    };
    ApolloClient.prototype.subscribe = function (options) {
        return this.initQueryManager().startGraphQLSubscription(options);
    };
    ApolloClient.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.initProxy().readQuery(options, optimistic);
    };
    ApolloClient.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.initProxy().readFragment(options, optimistic);
    };
    ApolloClient.prototype.writeQuery = function (options) {
        var result = this.initProxy().writeQuery(options);
        this.initQueryManager().broadcastQueries();
        return result;
    };
    ApolloClient.prototype.writeFragment = function (options) {
        var result = this.initProxy().writeFragment(options);
        this.initQueryManager().broadcastQueries();
        return result;
    };
    ApolloClient.prototype.writeData = function (options) {
        var result = this.initProxy().writeData(options);
        this.initQueryManager().broadcastQueries();
        return result;
    };
    ApolloClient.prototype.__actionHookForDevTools = function (cb) {
        this.devToolsHookCb = cb;
    };
    ApolloClient.prototype.__requestRaw = function (payload) {
        return Object(apollo_link__WEBPACK_IMPORTED_MODULE_0__["execute"])(this.link, payload);
    };
    ApolloClient.prototype.initQueryManager = function () {
        var _this = this;
        if (!this.queryManager) {
            this.queryManager = new _core_QueryManager__WEBPACK_IMPORTED_MODULE_2__["QueryManager"]({
                link: this.link,
                store: this.store,
                queryDeduplication: this.queryDeduplication,
                ssrMode: this.ssrMode,
                onBroadcast: function () {
                    if (_this.devToolsHookCb) {
                        _this.devToolsHookCb({
                            action: {},
                            state: {
                                queries: _this.queryManager
                                    ? _this.queryManager.queryStore.getStore()
                                    : {},
                                mutations: _this.queryManager
                                    ? _this.queryManager.mutationStore.getStore()
                                    : {},
                            },
                            dataWithOptimisticResults: _this.cache.extract(true),
                        });
                    }
                },
            });
        }
        return this.queryManager;
    };
    ApolloClient.prototype.resetStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            return _this.queryManager
                ? _this.queryManager.clearStore()
                : Promise.resolve(null);
        })
            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })
            .then(function () {
            return _this.queryManager && _this.queryManager.reFetchObservableQueries
                ? _this.queryManager.reFetchObservableQueries()
                : Promise.resolve(null);
        });
    };
    ApolloClient.prototype.clearStore = function () {
        var queryManager = this.queryManager;
        return Promise.resolve().then(function () { return (queryManager ? queryManager.clearStore() : Promise.resolve(null)); });
    };
    ApolloClient.prototype.onResetStore = function (cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function () {
            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
        return this.queryManager
            ? this.queryManager.reFetchObservableQueries(includeStandby)
            : Promise.resolve(null);
    };
    ApolloClient.prototype.extract = function (optimistic) {
        return this.initProxy().extract(optimistic);
    };
    ApolloClient.prototype.restore = function (serializedState) {
        return this.initProxy().restore(serializedState);
    };
    ApolloClient.prototype.initProxy = function () {
        if (!this.proxy) {
            this.initQueryManager();
            this.proxy = this.cache;
        }
        return this.proxy;
    };
    return ApolloClient;
}());
/* harmony default export */ __webpack_exports__["default"] = (ApolloClient);
//# sourceMappingURL=ApolloClient.js.map

/***/ }),

/***/ "./node_modules/apollo-client/core/ObservableQuery.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-client/core/ObservableQuery.js ***!
  \************************************************************/
/*! exports provided: hasError, ObservableQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasError", function() { return hasError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObservableQuery", function() { return ObservableQuery; });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _networkStatus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./networkStatus */ "./node_modules/apollo-client/core/networkStatus.js");
/* harmony import */ var _util_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Observable */ "./node_modules/apollo-client/util/Observable.js");
/* harmony import */ var _errors_ApolloError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/ApolloError */ "./node_modules/apollo-client/errors/ApolloError.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./node_modules/apollo-client/core/types.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};





var hasError = function (storeValue, policy) {
    if (policy === void 0) { policy = 'none'; }
    return storeValue &&
        ((storeValue.graphQLErrors &&
            storeValue.graphQLErrors.length > 0 &&
            policy === 'none') ||
            storeValue.networkError);
};
var ObservableQuery = (function (_super) {
    __extends(ObservableQuery, _super);
    function ObservableQuery(_a) {
        var scheduler = _a.scheduler, options = _a.options, _b = _a.shouldSubscribe, shouldSubscribe = _b === void 0 ? true : _b;
        var _this = _super.call(this, function (observer) {
            return _this.onSubscribe(observer);
        }) || this;
        _this.isCurrentlyPolling = false;
        _this.isTornDown = false;
        _this.options = options;
        _this.variables = options.variables || {};
        _this.queryId = scheduler.queryManager.generateQueryId();
        _this.shouldSubscribe = shouldSubscribe;
        _this.scheduler = scheduler;
        _this.queryManager = scheduler.queryManager;
        _this.observers = [];
        _this.subscriptionHandles = [];
        return _this;
    }
    ObservableQuery.prototype.result = function () {
        var that = this;
        return new Promise(function (resolve, reject) {
            var subscription;
            var observer = {
                next: function (result) {
                    resolve(result);
                    if (!that.observers.some(function (obs) { return obs !== observer; })) {
                        that.queryManager.removeQuery(that.queryId);
                    }
                    setTimeout(function () {
                        subscription.unsubscribe();
                    }, 0);
                },
                error: function (error) {
                    reject(error);
                },
            };
            subscription = that.subscribe(observer);
        });
    };
    ObservableQuery.prototype.currentResult = function () {
        if (this.isTornDown) {
            return {
                data: this.lastError ? {} : this.lastResult ? this.lastResult.data : {},
                error: this.lastError,
                loading: false,
                networkStatus: _networkStatus__WEBPACK_IMPORTED_MODULE_1__["NetworkStatus"].error,
            };
        }
        var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
        if (hasError(queryStoreValue, this.options.errorPolicy)) {
            return {
                data: {},
                loading: false,
                networkStatus: queryStoreValue.networkStatus,
                error: new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_3__["ApolloError"]({
                    graphQLErrors: queryStoreValue.graphQLErrors,
                    networkError: queryStoreValue.networkError,
                }),
            };
        }
        var _a = this.queryManager.getCurrentQueryResult(this), data = _a.data, partial = _a.partial;
        var queryLoading = !queryStoreValue ||
            queryStoreValue.networkStatus === _networkStatus__WEBPACK_IMPORTED_MODULE_1__["NetworkStatus"].loading;
        var loading = (this.options.fetchPolicy === 'network-only' && queryLoading) ||
            (partial && this.options.fetchPolicy !== 'cache-only');
        var networkStatus;
        if (queryStoreValue) {
            networkStatus = queryStoreValue.networkStatus;
        }
        else {
            networkStatus = loading ? _networkStatus__WEBPACK_IMPORTED_MODULE_1__["NetworkStatus"].loading : _networkStatus__WEBPACK_IMPORTED_MODULE_1__["NetworkStatus"].ready;
        }
        var result = {
            data: data,
            loading: Object(_networkStatus__WEBPACK_IMPORTED_MODULE_1__["isNetworkRequestInFlight"])(networkStatus),
            networkStatus: networkStatus,
        };
        if (queryStoreValue &&
            queryStoreValue.graphQLErrors &&
            this.options.errorPolicy === 'all') {
            result.errors = queryStoreValue.graphQLErrors;
        }
        if (!partial) {
            var stale = false;
            this.lastResult = __assign({}, result, { stale: stale });
        }
        return __assign({}, result, { partial: partial });
    };
    ObservableQuery.prototype.getLastResult = function () {
        return this.lastResult;
    };
    ObservableQuery.prototype.getLastError = function () {
        return this.lastError;
    };
    ObservableQuery.prototype.resetLastResults = function () {
        delete this.lastResult;
        delete this.lastError;
        this.isTornDown = false;
    };
    ObservableQuery.prototype.refetch = function (variables) {
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === 'cache-only') {
            return Promise.reject(new Error('cache-only fetchPolicy option should not be used together with query refetch.'));
        }
        if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(this.variables, variables)) {
            this.variables = Object.assign({}, this.variables, variables);
        }
        if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(this.options.variables, this.variables)) {
            this.options.variables = Object.assign({}, this.options.variables, this.variables);
        }
        var isNetworkFetchPolicy = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
        var combinedOptions = __assign({}, this.options, { fetchPolicy: isNetworkFetchPolicy ? fetchPolicy : 'network-only' });
        return this.queryManager
            .fetchQuery(this.queryId, combinedOptions, _types__WEBPACK_IMPORTED_MODULE_4__["FetchType"].refetch)
            .then(function (result) { return result; });
    };
    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
        var _this = this;
        if (!fetchMoreOptions.updateQuery) {
            throw new Error('updateQuery option is required. This function defines how to update the query data with the new results.');
        }
        var combinedOptions;
        return Promise.resolve()
            .then(function () {
            var qid = _this.queryManager.generateQueryId();
            if (fetchMoreOptions.query) {
                combinedOptions = fetchMoreOptions;
            }
            else {
                combinedOptions = __assign({}, _this.options, fetchMoreOptions, { variables: Object.assign({}, _this.variables, fetchMoreOptions.variables) });
            }
            combinedOptions.fetchPolicy = 'network-only';
            return _this.queryManager.fetchQuery(qid, combinedOptions, _types__WEBPACK_IMPORTED_MODULE_4__["FetchType"].normal, _this.queryId);
        })
            .then(function (fetchMoreResult) {
            _this.updateQuery(function (previousResult) {
                return fetchMoreOptions.updateQuery(previousResult, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables,
                });
            });
            return fetchMoreResult;
        });
    };
    ObservableQuery.prototype.subscribeToMore = function (options) {
        var _this = this;
        var subscription = this.queryManager
            .startGraphQLSubscription({
            query: options.document,
            variables: options.variables,
        })
            .subscribe({
            next: function (subscriptionData) {
                if (options.updateQuery) {
                    _this.updateQuery(function (previous, _a) {
                        var variables = _a.variables;
                        return options.updateQuery(previous, {
                            subscriptionData: subscriptionData,
                            variables: variables,
                        });
                    });
                }
            },
            error: function (err) {
                if (options.onError) {
                    options.onError(err);
                    return;
                }
                console.error('Unhandled GraphQL subscription error', err);
            },
        });
        this.subscriptionHandles.push(subscription);
        return function () {
            var i = _this.subscriptionHandles.indexOf(subscription);
            if (i >= 0) {
                _this.subscriptionHandles.splice(i, 1);
                subscription.unsubscribe();
            }
        };
    };
    ObservableQuery.prototype.setOptions = function (opts) {
        var oldOptions = this.options;
        this.options = Object.assign({}, this.options, opts);
        if (opts.pollInterval) {
            this.startPolling(opts.pollInterval);
        }
        else if (opts.pollInterval === 0) {
            this.stopPolling();
        }
        var tryFetch = (oldOptions.fetchPolicy !== 'network-only' &&
            opts.fetchPolicy === 'network-only') ||
            (oldOptions.fetchPolicy === 'cache-only' &&
                opts.fetchPolicy !== 'cache-only') ||
            (oldOptions.fetchPolicy === 'standby' &&
                opts.fetchPolicy !== 'standby') ||
            false;
        return this.setVariables(this.options.variables, tryFetch, opts.fetchResults);
    };
    ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
        if (tryFetch === void 0) { tryFetch = false; }
        if (fetchResults === void 0) { fetchResults = true; }
        this.isTornDown = false;
        var newVariables = variables ? variables : this.variables;
        if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(newVariables, this.variables) && !tryFetch) {
            if (this.observers.length === 0 || !fetchResults) {
                return new Promise(function (resolve) { return resolve(); });
            }
            return this.result();
        }
        else {
            this.variables = newVariables;
            this.options.variables = newVariables;
            if (this.observers.length === 0) {
                return new Promise(function (resolve) { return resolve(); });
            }
            return this.queryManager
                .fetchQuery(this.queryId, __assign({}, this.options, { variables: this.variables }))
                .then(function (result) { return result; });
        }
    };
    ObservableQuery.prototype.updateQuery = function (mapFn) {
        var _a = this.queryManager.getQueryWithPreviousResult(this.queryId), previousResult = _a.previousResult, variables = _a.variables, document = _a.document;
        var newResult = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["tryFunctionOrLogError"])(function () {
            return mapFn(previousResult, { variables: variables });
        });
        if (newResult) {
            this.queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
            this.queryManager.broadcastQueries();
        }
    };
    ObservableQuery.prototype.stopPolling = function () {
        if (this.isCurrentlyPolling) {
            this.scheduler.stopPollingQuery(this.queryId);
            this.options.pollInterval = undefined;
            this.isCurrentlyPolling = false;
        }
    };
    ObservableQuery.prototype.startPolling = function (pollInterval) {
        if (this.options.fetchPolicy === 'cache-first' ||
            this.options.fetchPolicy === 'cache-only') {
            throw new Error('Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
        }
        if (this.isCurrentlyPolling) {
            this.scheduler.stopPollingQuery(this.queryId);
            this.isCurrentlyPolling = false;
        }
        this.options.pollInterval = pollInterval;
        this.isCurrentlyPolling = true;
        this.scheduler.startPollingQuery(this.options, this.queryId);
    };
    ObservableQuery.prototype.onSubscribe = function (observer) {
        var _this = this;
        if (observer._subscription &&
            observer._subscription._observer &&
            !observer._subscription._observer.error) {
            observer._subscription._observer.error = function (error) {
                console.error('Unhandled error', error.message, error.stack);
            };
        }
        this.observers.push(observer);
        if (observer.next && this.lastResult)
            observer.next(this.lastResult);
        if (observer.error && this.lastError)
            observer.error(this.lastError);
        if (this.observers.length === 1)
            this.setUpQuery();
        return function () {
            _this.observers = _this.observers.filter(function (obs) { return obs !== observer; });
            if (_this.observers.length === 0) {
                _this.tearDownQuery();
            }
        };
    };
    ObservableQuery.prototype.setUpQuery = function () {
        var _this = this;
        if (this.shouldSubscribe) {
            this.queryManager.addObservableQuery(this.queryId, this);
        }
        if (!!this.options.pollInterval) {
            if (this.options.fetchPolicy === 'cache-first' ||
                this.options.fetchPolicy === 'cache-only') {
                throw new Error('Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
            }
            this.isCurrentlyPolling = true;
            this.scheduler.startPollingQuery(this.options, this.queryId);
        }
        var observer = {
            next: function (result) {
                _this.lastResult = result;
                _this.observers.forEach(function (obs) { return obs.next && obs.next(result); });
            },
            error: function (error) {
                _this.lastError = error;
                _this.observers.forEach(function (obs) { return obs.error && obs.error(error); });
            },
        };
        this.queryManager.startQuery(this.queryId, this.options, this.queryManager.queryListenerForObserver(this.queryId, this.options, observer));
    };
    ObservableQuery.prototype.tearDownQuery = function () {
        this.isTornDown = true;
        if (this.isCurrentlyPolling) {
            this.scheduler.stopPollingQuery(this.queryId);
            this.isCurrentlyPolling = false;
        }
        this.subscriptionHandles.forEach(function (sub) { return sub.unsubscribe(); });
        this.subscriptionHandles = [];
        this.queryManager.removeObservableQuery(this.queryId);
        this.queryManager.stopQuery(this.queryId);
        this.observers = [];
    };
    return ObservableQuery;
}(_util_Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"]));

//# sourceMappingURL=ObservableQuery.js.map

/***/ }),

/***/ "./node_modules/apollo-client/core/QueryManager.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-client/core/QueryManager.js ***!
  \*********************************************************/
/*! exports provided: QueryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryManager", function() { return QueryManager; });
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/index.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var apollo_link_dedup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! apollo-link-dedup */ "./node_modules/apollo-link-dedup/lib/index.js");
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _scheduler_scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scheduler/scheduler */ "./node_modules/apollo-client/scheduler/scheduler.js");
/* harmony import */ var _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/ApolloError */ "./node_modules/apollo-client/errors/ApolloError.js");
/* harmony import */ var _util_Observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Observable */ "./node_modules/apollo-client/util/Observable.js");
/* harmony import */ var _data_mutations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/mutations */ "./node_modules/apollo-client/data/mutations.js");
/* harmony import */ var _data_queries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../data/queries */ "./node_modules/apollo-client/data/queries.js");
/* harmony import */ var _ObservableQuery__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ObservableQuery */ "./node_modules/apollo-client/core/ObservableQuery.js");
/* harmony import */ var _networkStatus__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./networkStatus */ "./node_modules/apollo-client/core/networkStatus.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types */ "./node_modules/apollo-client/core/types.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};













var defaultQueryInfo = {
    listeners: [],
    invalidated: false,
    document: null,
    newData: null,
    lastRequestId: null,
    observableQuery: null,
    subscriptions: [],
};
var QueryManager = (function () {
    function QueryManager(_a) {
        var link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, store = _a.store, _c = _a.onBroadcast, onBroadcast = _c === void 0 ? function () { return undefined; } : _c, _d = _a.ssrMode, ssrMode = _d === void 0 ? false : _d;
        this.mutationStore = new _data_mutations__WEBPACK_IMPORTED_MODULE_7__["MutationStore"]();
        this.queryStore = new _data_queries__WEBPACK_IMPORTED_MODULE_8__["QueryStore"]();
        this.idCounter = 1;
        this.queries = new Map();
        this.fetchQueryPromises = new Map();
        this.queryIdsByName = {};
        this.link = link;
        this.deduplicator = apollo_link__WEBPACK_IMPORTED_MODULE_0__["ApolloLink"].from([new apollo_link_dedup__WEBPACK_IMPORTED_MODULE_2__["DedupLink"](), link]);
        this.queryDeduplication = queryDeduplication;
        this.dataStore = store;
        this.onBroadcast = onBroadcast;
        this.scheduler = new _scheduler_scheduler__WEBPACK_IMPORTED_MODULE_4__["QueryScheduler"]({ queryManager: this, ssrMode: ssrMode });
    }
    QueryManager.prototype.mutate = function (_a) {
        var _this = this;
        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueriesByName = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? 'none' : _d, fetchPolicy = _a.fetchPolicy, _e = _a.context, context = _e === void 0 ? {} : _e;
        if (!mutation) {
            throw new Error('mutation option is required. You must specify your GraphQL document in the mutation option.');
        }
        if (fetchPolicy && fetchPolicy !== 'no-cache') {
            throw new Error("fetchPolicy for mutations currently only supports the 'no-cache' policy");
        }
        var mutationId = this.generateQueryId();
        var cache = this.dataStore.getCache();
        (mutation = cache.transformDocument(mutation)),
            (variables = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getDefaultValues"])(Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getMutationDefinition"])(mutation)), variables));
        var mutationString = Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__["print"])(mutation);
        this.setQuery(mutationId, function () { return ({ document: mutation }); });
        var generateUpdateQueriesInfo = function () {
            var ret = {};
            if (updateQueriesByName) {
                Object.keys(updateQueriesByName).forEach(function (queryName) {
                    return (_this.queryIdsByName[queryName] || []).forEach(function (queryId) {
                        ret[queryId] = {
                            updater: updateQueriesByName[queryName],
                            query: _this.queryStore.get(queryId),
                        };
                    });
                });
            }
            return ret;
        };
        this.mutationStore.initMutation(mutationId, mutationString, variables);
        this.dataStore.markMutationInit({
            mutationId: mutationId,
            document: mutation,
            variables: variables || {},
            updateQueries: generateUpdateQueriesInfo(),
            update: updateWithProxyFn,
            optimisticResponse: optimisticResponse,
        });
        this.broadcastQueries();
        return new Promise(function (resolve, reject) {
            var storeResult;
            var error;
            var operation = _this.buildOperationForLink(mutation, variables, __assign({}, context, { optimisticResponse: optimisticResponse }));
            var completeMutation = function () { return __awaiter(_this, void 0, void 0, function () {
                var refetchQueryPromises, _i, refetchQueries_1, refetchQuery, promise, queryOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (error) {
                                this.mutationStore.markMutationError(mutationId, error);
                            }
                            this.dataStore.markMutationComplete({
                                mutationId: mutationId,
                                optimisticResponse: optimisticResponse,
                            });
                            this.broadcastQueries();
                            if (error) {
                                throw error;
                            }
                            if (typeof refetchQueries === 'function') {
                                refetchQueries = refetchQueries(storeResult);
                            }
                            refetchQueryPromises = [];
                            for (_i = 0, refetchQueries_1 = refetchQueries; _i < refetchQueries_1.length; _i++) {
                                refetchQuery = refetchQueries_1[_i];
                                if (typeof refetchQuery === 'string') {
                                    promise = this.refetchQueryByName(refetchQuery);
                                    if (promise) {
                                        refetchQueryPromises.push(promise);
                                    }
                                    continue;
                                }
                                queryOptions = {
                                    query: refetchQuery.query,
                                    variables: refetchQuery.variables,
                                    fetchPolicy: 'network-only',
                                };
                                if (refetchQuery.context) {
                                    queryOptions.context = refetchQuery.context;
                                }
                                refetchQueryPromises.push(this.query(queryOptions));
                            }
                            if (!awaitRefetchQueries) return [3, 2];
                            return [4, Promise.all(refetchQueryPromises)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            this.setQuery(mutationId, function () { return ({ document: undefined }); });
                            if (errorPolicy === 'ignore' &&
                                storeResult &&
                                Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["graphQLResultHasError"])(storeResult)) {
                                delete storeResult.errors;
                            }
                            return [2, storeResult];
                    }
                });
            }); };
            Object(apollo_link__WEBPACK_IMPORTED_MODULE_0__["execute"])(_this.link, operation).subscribe({
                next: function (result) {
                    if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["graphQLResultHasError"])(result) && errorPolicy === 'none') {
                        error = new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({
                            graphQLErrors: result.errors,
                        });
                        return;
                    }
                    _this.mutationStore.markMutationResult(mutationId);
                    if (fetchPolicy !== 'no-cache') {
                        _this.dataStore.markMutationResult({
                            mutationId: mutationId,
                            result: result,
                            document: mutation,
                            variables: variables || {},
                            updateQueries: generateUpdateQueriesInfo(),
                            update: updateWithProxyFn,
                        });
                    }
                    storeResult = result;
                },
                error: function (err) {
                    _this.mutationStore.markMutationError(mutationId, err);
                    _this.dataStore.markMutationComplete({
                        mutationId: mutationId,
                        optimisticResponse: optimisticResponse,
                    });
                    _this.broadcastQueries();
                    _this.setQuery(mutationId, function () { return ({ document: undefined }); });
                    reject(new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({
                        networkError: err,
                    }));
                },
                complete: function () { return completeMutation().then(resolve, reject); },
            });
        });
    };
    QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
        var _this = this;
        var _a = options.variables, variables = _a === void 0 ? {} : _a, _b = options.metadata, metadata = _b === void 0 ? null : _b, _c = options.fetchPolicy, fetchPolicy = _c === void 0 ? 'cache-first' : _c;
        var cache = this.dataStore.getCache();
        var query = cache.transformDocument(options.query);
        var storeResult;
        var needToFetch = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
        if (fetchType !== _types__WEBPACK_IMPORTED_MODULE_11__["FetchType"].refetch &&
            fetchPolicy !== 'network-only' &&
            fetchPolicy !== 'no-cache') {
            var _d = this.dataStore.getCache().diff({
                query: query,
                variables: variables,
                returnPartialData: true,
                optimistic: false,
            }), complete = _d.complete, result = _d.result;
            needToFetch = !complete || fetchPolicy === 'cache-and-network';
            storeResult = result;
        }
        var shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
        if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["hasDirectives"])(['live'], query))
            shouldFetch = true;
        var requestId = this.generateRequestId();
        var cancel = this.updateQueryWatch(queryId, query, options);
        this.setQuery(queryId, function () { return ({
            document: query,
            lastRequestId: requestId,
            invalidated: true,
            cancel: cancel,
        }); });
        this.invalidate(true, fetchMoreForQueryId);
        this.queryStore.initQuery({
            queryId: queryId,
            document: query,
            storePreviousVariables: shouldFetch,
            variables: variables,
            isPoll: fetchType === _types__WEBPACK_IMPORTED_MODULE_11__["FetchType"].poll,
            isRefetch: fetchType === _types__WEBPACK_IMPORTED_MODULE_11__["FetchType"].refetch,
            metadata: metadata,
            fetchMoreForQueryId: fetchMoreForQueryId,
        });
        this.broadcastQueries();
        var shouldDispatchClientResult = !shouldFetch || fetchPolicy === 'cache-and-network';
        if (shouldDispatchClientResult) {
            this.queryStore.markQueryResultClient(queryId, !shouldFetch);
            this.invalidate(true, queryId, fetchMoreForQueryId);
            this.broadcastQueries();
        }
        if (shouldFetch) {
            var networkResult = this.fetchRequest({
                requestId: requestId,
                queryId: queryId,
                document: query,
                options: options,
                fetchMoreForQueryId: fetchMoreForQueryId,
            }).catch(function (error) {
                if (Object(_errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["isApolloError"])(error)) {
                    throw error;
                }
                else {
                    var lastRequestId = _this.getQuery(queryId).lastRequestId;
                    if (requestId >= (lastRequestId || 1)) {
                        _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);
                        _this.invalidate(true, queryId, fetchMoreForQueryId);
                        _this.broadcastQueries();
                    }
                    _this.removeFetchQueryPromise(requestId);
                    throw new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({ networkError: error });
                }
            });
            if (fetchPolicy !== 'cache-and-network') {
                return networkResult;
            }
            else {
                networkResult.catch(function () { });
            }
        }
        return Promise.resolve({ data: storeResult });
    };
    QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
        var _this = this;
        var previouslyHadError = false;
        return function (queryStoreValue, newData) {
            _this.invalidate(false, queryId);
            if (!queryStoreValue)
                return;
            var observableQuery = _this.getQuery(queryId).observableQuery;
            var fetchPolicy = observableQuery
                ? observableQuery.options.fetchPolicy
                : options.fetchPolicy;
            if (fetchPolicy === 'standby')
                return;
            var errorPolicy = observableQuery
                ? observableQuery.options.errorPolicy
                : options.errorPolicy;
            var lastResult = observableQuery
                ? observableQuery.getLastResult()
                : null;
            var lastError = observableQuery ? observableQuery.getLastError() : null;
            var shouldNotifyIfLoading = (!newData && queryStoreValue.previousVariables != null) ||
                fetchPolicy === 'cache-only' ||
                fetchPolicy === 'cache-and-network';
            var networkStatusChanged = Boolean(lastResult &&
                queryStoreValue.networkStatus !== lastResult.networkStatus);
            var errorStatusChanged = errorPolicy &&
                (lastError && lastError.graphQLErrors) !==
                    queryStoreValue.graphQLErrors &&
                errorPolicy !== 'none';
            if (!Object(_networkStatus__WEBPACK_IMPORTED_MODULE_10__["isNetworkRequestInFlight"])(queryStoreValue.networkStatus) ||
                (networkStatusChanged && options.notifyOnNetworkStatusChange) ||
                shouldNotifyIfLoading) {
                if (((!errorPolicy || errorPolicy === 'none') &&
                    queryStoreValue.graphQLErrors &&
                    queryStoreValue.graphQLErrors.length > 0) ||
                    queryStoreValue.networkError) {
                    var apolloError_1 = new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({
                        graphQLErrors: queryStoreValue.graphQLErrors,
                        networkError: queryStoreValue.networkError,
                    });
                    previouslyHadError = true;
                    if (observer.error) {
                        try {
                            observer.error(apolloError_1);
                        }
                        catch (e) {
                            setTimeout(function () {
                                throw e;
                            }, 0);
                        }
                    }
                    else {
                        setTimeout(function () {
                            throw apolloError_1;
                        }, 0);
                        if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["isProduction"])()) {
                            console.info('An unhandled error was thrown because no error handler is registered ' +
                                'for the query ' +
                                Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_1__["print"])(queryStoreValue.document));
                        }
                    }
                    return;
                }
                try {
                    var data = void 0;
                    var isMissing = void 0;
                    if (newData) {
                        if (fetchPolicy !== 'no-cache') {
                            _this.setQuery(queryId, function () { return ({ newData: null }); });
                        }
                        data = newData.result;
                        isMissing = !newData.complete || false;
                    }
                    else {
                        if (lastResult && lastResult.data && !errorStatusChanged) {
                            data = lastResult.data;
                            isMissing = false;
                        }
                        else {
                            var document_1 = _this.getQuery(queryId).document;
                            var readResult = _this.dataStore.getCache().diff({
                                query: document_1,
                                variables: queryStoreValue.previousVariables ||
                                    queryStoreValue.variables,
                                optimistic: true,
                            });
                            data = readResult.result;
                            isMissing = !readResult.complete;
                        }
                    }
                    var resultFromStore = void 0;
                    if (isMissing && fetchPolicy !== 'cache-only') {
                        resultFromStore = {
                            data: lastResult && lastResult.data,
                            loading: Object(_networkStatus__WEBPACK_IMPORTED_MODULE_10__["isNetworkRequestInFlight"])(queryStoreValue.networkStatus),
                            networkStatus: queryStoreValue.networkStatus,
                            stale: true,
                        };
                    }
                    else {
                        resultFromStore = {
                            data: data,
                            loading: Object(_networkStatus__WEBPACK_IMPORTED_MODULE_10__["isNetworkRequestInFlight"])(queryStoreValue.networkStatus),
                            networkStatus: queryStoreValue.networkStatus,
                            stale: false,
                        };
                    }
                    if (errorPolicy === 'all' &&
                        queryStoreValue.graphQLErrors &&
                        queryStoreValue.graphQLErrors.length > 0) {
                        resultFromStore.errors = queryStoreValue.graphQLErrors;
                    }
                    if (observer.next) {
                        var isDifferentResult = !(lastResult &&
                            resultFromStore &&
                            lastResult.networkStatus === resultFromStore.networkStatus &&
                            lastResult.stale === resultFromStore.stale &&
                            lastResult.data === resultFromStore.data);
                        if (isDifferentResult || previouslyHadError) {
                            try {
                                observer.next(resultFromStore);
                            }
                            catch (e) {
                                setTimeout(function () {
                                    throw e;
                                }, 0);
                            }
                        }
                    }
                    previouslyHadError = false;
                }
                catch (error) {
                    previouslyHadError = true;
                    if (observer.error)
                        observer.error(new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({ networkError: error }));
                    return;
                }
            }
        };
    };
    QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
        if (shouldSubscribe === void 0) { shouldSubscribe = true; }
        if (options.fetchPolicy === 'standby') {
            throw new Error('client.watchQuery cannot be called with fetchPolicy set to "standby"');
        }
        var queryDefinition = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getQueryDefinition"])(options.query);
        if (queryDefinition.variableDefinitions &&
            queryDefinition.variableDefinitions.length) {
            var defaultValues = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getDefaultValues"])(queryDefinition);
            options.variables = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, defaultValues, options.variables);
        }
        if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
            options.notifyOnNetworkStatusChange = false;
        }
        var transformedOptions = __assign({}, options);
        return new _ObservableQuery__WEBPACK_IMPORTED_MODULE_9__["ObservableQuery"]({
            scheduler: this.scheduler,
            options: transformedOptions,
            shouldSubscribe: shouldSubscribe,
        });
    };
    QueryManager.prototype.query = function (options) {
        var _this = this;
        if (!options.query) {
            throw new Error('query option is required. You must specify your GraphQL document ' +
                'in the query option.');
        }
        if (options.query.kind !== 'Document') {
            throw new Error('You must wrap the query string in a "gql" tag.');
        }
        if (options.returnPartialData) {
            throw new Error('returnPartialData option only supported on watchQuery.');
        }
        if (options.pollInterval) {
            throw new Error('pollInterval option only supported on watchQuery.');
        }
        var requestId = this.idCounter;
        return new Promise(function (resolve, reject) {
            _this.addFetchQueryPromise(requestId, resolve, reject);
            return _this.watchQuery(options, false)
                .result()
                .then(function (result) {
                _this.removeFetchQueryPromise(requestId);
                resolve(result);
            })
                .catch(function (error) {
                _this.removeFetchQueryPromise(requestId);
                reject(error);
            });
        });
    };
    QueryManager.prototype.generateQueryId = function () {
        var queryId = this.idCounter.toString();
        this.idCounter++;
        return queryId;
    };
    QueryManager.prototype.stopQueryInStore = function (queryId) {
        this.queryStore.stopQuery(queryId);
        this.invalidate(true, queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.addQueryListener = function (queryId, listener) {
        this.setQuery(queryId, function (_a) {
            var _b = _a.listeners, listeners = _b === void 0 ? [] : _b;
            return ({
                listeners: listeners.concat([listener]),
                invalidate: false,
            });
        });
    };
    QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
        var _this = this;
        var cancel = this.getQuery(queryId).cancel;
        if (cancel)
            cancel();
        var previousResult = function () {
            var previousResult = null;
            var observableQuery = _this.getQuery(queryId).observableQuery;
            if (observableQuery) {
                var lastResult = observableQuery.getLastResult();
                if (lastResult) {
                    previousResult = lastResult.data;
                }
            }
            return previousResult;
        };
        return this.dataStore.getCache().watch({
            query: document,
            variables: options.variables,
            optimistic: true,
            previousResult: previousResult,
            callback: function (newData) {
                _this.setQuery(queryId, function () { return ({ invalidated: true, newData: newData }); });
            },
        });
    };
    QueryManager.prototype.addFetchQueryPromise = function (requestId, resolve, reject) {
        this.fetchQueryPromises.set(requestId.toString(), {
            resolve: resolve,
            reject: reject,
        });
    };
    QueryManager.prototype.removeFetchQueryPromise = function (requestId) {
        this.fetchQueryPromises.delete(requestId.toString());
    };
    QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
        this.setQuery(queryId, function () { return ({ observableQuery: observableQuery }); });
        var queryDef = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getQueryDefinition"])(observableQuery.options.query);
        if (queryDef.name && queryDef.name.value) {
            var queryName = queryDef.name.value;
            this.queryIdsByName[queryName] = this.queryIdsByName[queryName] || [];
            this.queryIdsByName[queryName].push(observableQuery.queryId);
        }
    };
    QueryManager.prototype.removeObservableQuery = function (queryId) {
        var _a = this.getQuery(queryId), observableQuery = _a.observableQuery, cancel = _a.cancel;
        if (cancel)
            cancel();
        if (!observableQuery)
            return;
        var definition = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getQueryDefinition"])(observableQuery.options.query);
        var queryName = definition.name ? definition.name.value : null;
        this.setQuery(queryId, function () { return ({ observableQuery: null }); });
        if (queryName) {
            this.queryIdsByName[queryName] = this.queryIdsByName[queryName].filter(function (val) {
                return !(observableQuery.queryId === val);
            });
        }
    };
    QueryManager.prototype.clearStore = function () {
        this.fetchQueryPromises.forEach(function (_a) {
            var reject = _a.reject;
            reject(new Error('Store reset while query was in flight(not completed in link chain)'));
        });
        var resetIds = [];
        this.queries.forEach(function (_a, queryId) {
            var observableQuery = _a.observableQuery;
            if (observableQuery)
                resetIds.push(queryId);
        });
        this.queryStore.reset(resetIds);
        this.mutationStore.reset();
        var reset = this.dataStore.reset();
        return reset;
    };
    QueryManager.prototype.resetStore = function () {
        var _this = this;
        return this.clearStore().then(function () {
            return _this.reFetchObservableQueries();
        });
    };
    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
        var observableQueryPromises = this.getObservableQueryPromises(includeStandby);
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
    };
    QueryManager.prototype.startQuery = function (queryId, options, listener) {
        this.addQueryListener(queryId, listener);
        this.fetchQuery(queryId, options)
            .catch(function () { return undefined; });
        return queryId;
    };
    QueryManager.prototype.startGraphQLSubscription = function (options) {
        var _this = this;
        var query = options.query;
        var isCacheEnabled = !(options.fetchPolicy && options.fetchPolicy === 'no-cache');
        var cache = this.dataStore.getCache();
        var transformedDoc = cache.transformDocument(query);
        var variables = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getDefaultValues"])(Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getOperationDefinition"])(query)), options.variables);
        var sub;
        var observers = [];
        return new _util_Observable__WEBPACK_IMPORTED_MODULE_6__["Observable"](function (observer) {
            observers.push(observer);
            if (observers.length === 1) {
                var handler = {
                    next: function (result) {
                        if (isCacheEnabled) {
                            _this.dataStore.markSubscriptionResult(result, transformedDoc, variables);
                            _this.broadcastQueries();
                        }
                        observers.forEach(function (obs) {
                            if (Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["graphQLResultHasError"])(result) && obs.error) {
                                obs.error(new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({
                                    graphQLErrors: result.errors,
                                }));
                            }
                            else if (obs.next) {
                                obs.next(result);
                            }
                        });
                    },
                    error: function (error) {
                        observers.forEach(function (obs) {
                            if (obs.error) {
                                obs.error(error);
                            }
                        });
                    },
                };
                var operation = _this.buildOperationForLink(transformedDoc, variables);
                sub = Object(apollo_link__WEBPACK_IMPORTED_MODULE_0__["execute"])(_this.link, operation).subscribe(handler);
            }
            return function () {
                observers = observers.filter(function (obs) { return obs !== observer; });
                if (observers.length === 0 && sub) {
                    sub.unsubscribe();
                }
            };
        });
    };
    QueryManager.prototype.stopQuery = function (queryId) {
        this.stopQueryInStore(queryId);
        this.removeQuery(queryId);
    };
    QueryManager.prototype.removeQuery = function (queryId) {
        var subscriptions = this.getQuery(queryId).subscriptions;
        subscriptions.forEach(function (x) { return x.unsubscribe(); });
        this.queries.delete(queryId);
    };
    QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
        if (optimistic === void 0) { optimistic = true; }
        var _a = observableQuery.options, variables = _a.variables, query = _a.query;
        var lastResult = observableQuery.getLastResult();
        var newData = this.getQuery(observableQuery.queryId).newData;
        if (newData) {
            return { data: newData.result, partial: false };
        }
        else {
            try {
                var data = this.dataStore.getCache().read({
                    query: query,
                    variables: variables,
                    previousResult: lastResult ? lastResult.data : undefined,
                    optimistic: optimistic,
                });
                return { data: data, partial: false };
            }
            catch (e) {
                return { data: {}, partial: true };
            }
        }
    };
    QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
        var observableQuery;
        if (typeof queryIdOrObservable === 'string') {
            var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
            if (!foundObserveableQuery) {
                throw new Error("ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
            }
            observableQuery = foundObserveableQuery;
        }
        else {
            observableQuery = queryIdOrObservable;
        }
        var _a = observableQuery.options, variables = _a.variables, query = _a.query;
        var data = this.getCurrentQueryResult(observableQuery, false).data;
        return {
            previousResult: data,
            variables: variables,
            document: query,
        };
    };
    QueryManager.prototype.broadcastQueries = function () {
        var _this = this;
        this.onBroadcast();
        this.queries.forEach(function (info, id) {
            if (!info.invalidated || !info.listeners)
                return;
            info.listeners
                .filter(function (x) { return !!x; })
                .forEach(function (listener) {
                listener(_this.queryStore.get(id), info.newData);
            });
        });
    };
    QueryManager.prototype.getObservableQueryPromises = function (includeStandby) {
        var _this = this;
        var observableQueryPromises = [];
        this.queries.forEach(function (_a, queryId) {
            var observableQuery = _a.observableQuery;
            if (!observableQuery)
                return;
            var fetchPolicy = observableQuery.options.fetchPolicy;
            observableQuery.resetLastResults();
            if (fetchPolicy !== 'cache-only' &&
                (includeStandby || fetchPolicy !== 'standby')) {
                observableQueryPromises.push(observableQuery.refetch());
            }
            _this.setQuery(queryId, function () { return ({ newData: null }); });
            _this.invalidate(true, queryId);
        });
        return observableQueryPromises;
    };
    QueryManager.prototype.fetchRequest = function (_a) {
        var _this = this;
        var requestId = _a.requestId, queryId = _a.queryId, document = _a.document, options = _a.options, fetchMoreForQueryId = _a.fetchMoreForQueryId;
        var variables = options.variables, context = options.context, _b = options.errorPolicy, errorPolicy = _b === void 0 ? 'none' : _b, fetchPolicy = options.fetchPolicy;
        var operation = this.buildOperationForLink(document, variables, __assign({}, context, { forceFetch: !this.queryDeduplication }));
        var resultFromStore;
        var errorsFromStore;
        return new Promise(function (resolve, reject) {
            _this.addFetchQueryPromise(requestId, resolve, reject);
            var subscription = Object(apollo_link__WEBPACK_IMPORTED_MODULE_0__["execute"])(_this.deduplicator, operation).subscribe({
                next: function (result) {
                    var lastRequestId = _this.getQuery(queryId).lastRequestId;
                    if (requestId >= (lastRequestId || 1)) {
                        if (fetchPolicy !== 'no-cache') {
                            try {
                                _this.dataStore.markQueryResult(result, document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
                            }
                            catch (e) {
                                reject(e);
                                return;
                            }
                        }
                        else {
                            _this.setQuery(queryId, function () { return ({
                                newData: { result: result.data, complete: true },
                            }); });
                        }
                        _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);
                        _this.invalidate(true, queryId, fetchMoreForQueryId);
                        _this.broadcastQueries();
                    }
                    if (result.errors && errorPolicy === 'none') {
                        reject(new _errors_ApolloError__WEBPACK_IMPORTED_MODULE_5__["ApolloError"]({
                            graphQLErrors: result.errors,
                        }));
                        return;
                    }
                    else if (errorPolicy === 'all') {
                        errorsFromStore = result.errors;
                    }
                    if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
                        resultFromStore = result.data;
                    }
                    else {
                        try {
                            resultFromStore = _this.dataStore.getCache().read({
                                variables: variables,
                                query: document,
                                optimistic: false,
                            });
                        }
                        catch (e) { }
                    }
                },
                error: function (error) {
                    _this.removeFetchQueryPromise(requestId);
                    _this.setQuery(queryId, function (_a) {
                        var subscriptions = _a.subscriptions;
                        return ({
                            subscriptions: subscriptions.filter(function (x) { return x !== subscription; }),
                        });
                    });
                    reject(error);
                },
                complete: function () {
                    _this.removeFetchQueryPromise(requestId);
                    _this.setQuery(queryId, function (_a) {
                        var subscriptions = _a.subscriptions;
                        return ({
                            subscriptions: subscriptions.filter(function (x) { return x !== subscription; }),
                        });
                    });
                    resolve({
                        data: resultFromStore,
                        errors: errorsFromStore,
                        loading: false,
                        networkStatus: _networkStatus__WEBPACK_IMPORTED_MODULE_10__["NetworkStatus"].ready,
                        stale: false,
                    });
                },
            });
            _this.setQuery(queryId, function (_a) {
                var subscriptions = _a.subscriptions;
                return ({
                    subscriptions: subscriptions.concat([subscription]),
                });
            });
        });
    };
    QueryManager.prototype.refetchQueryByName = function (queryName) {
        var _this = this;
        var refetchedQueries = this.queryIdsByName[queryName];
        if (refetchedQueries === undefined)
            return;
        return Promise.all(refetchedQueries
            .map(function (id) { return _this.getQuery(id).observableQuery; })
            .filter(function (x) { return !!x; })
            .map(function (x) { return x.refetch(); }));
    };
    QueryManager.prototype.generateRequestId = function () {
        var requestId = this.idCounter;
        this.idCounter++;
        return requestId;
    };
    QueryManager.prototype.getQuery = function (queryId) {
        return this.queries.get(queryId) || __assign({}, defaultQueryInfo);
    };
    QueryManager.prototype.setQuery = function (queryId, updater) {
        var prev = this.getQuery(queryId);
        var newInfo = __assign({}, prev, updater(prev));
        this.queries.set(queryId, newInfo);
    };
    QueryManager.prototype.invalidate = function (invalidated, queryId, fetchMoreForQueryId) {
        if (queryId)
            this.setQuery(queryId, function () { return ({ invalidated: invalidated }); });
        if (fetchMoreForQueryId) {
            this.setQuery(fetchMoreForQueryId, function () { return ({ invalidated: invalidated }); });
        }
    };
    QueryManager.prototype.buildOperationForLink = function (document, variables, extraContext) {
        var cache = this.dataStore.getCache();
        return {
            query: cache.transformForLink
                ? cache.transformForLink(document)
                : document,
            variables: variables,
            operationName: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["getOperationName"])(document) || undefined,
            context: __assign({}, extraContext, { cache: cache, getCacheKey: function (obj) {
                    if (cache.config) {
                        return cache.config.dataIdFromObject(obj);
                    }
                    else {
                        throw new Error('To use context.getCacheKey, you need to use a cache that has a configurable dataIdFromObject, like apollo-cache-inmemory.');
                    }
                } }),
        };
    };
    return QueryManager;
}());

//# sourceMappingURL=QueryManager.js.map

/***/ }),

/***/ "./node_modules/apollo-client/core/networkStatus.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-client/core/networkStatus.js ***!
  \**********************************************************/
/*! exports provided: NetworkStatus, isNetworkRequestInFlight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetworkStatus", function() { return NetworkStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNetworkRequestInFlight", function() { return isNetworkRequestInFlight; });
var NetworkStatus;
(function (NetworkStatus) {
    NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
    NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
    NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
    NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
    NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
    NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
    NetworkStatus[NetworkStatus["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
    return networkStatus < 7;
}
//# sourceMappingURL=networkStatus.js.map

/***/ }),

/***/ "./node_modules/apollo-client/core/types.js":
/*!**************************************************!*\
  !*** ./node_modules/apollo-client/core/types.js ***!
  \**************************************************/
/*! exports provided: FetchType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchType", function() { return FetchType; });
var FetchType;
(function (FetchType) {
    FetchType[FetchType["normal"] = 1] = "normal";
    FetchType[FetchType["refetch"] = 2] = "refetch";
    FetchType[FetchType["poll"] = 3] = "poll";
})(FetchType || (FetchType = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/apollo-client/data/mutations.js":
/*!******************************************************!*\
  !*** ./node_modules/apollo-client/data/mutations.js ***!
  \******************************************************/
/*! exports provided: MutationStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutationStore", function() { return MutationStore; });
var MutationStore = (function () {
    function MutationStore() {
        this.store = {};
    }
    MutationStore.prototype.getStore = function () {
        return this.store;
    };
    MutationStore.prototype.get = function (mutationId) {
        return this.store[mutationId];
    };
    MutationStore.prototype.initMutation = function (mutationId, mutationString, variables) {
        this.store[mutationId] = {
            mutationString: mutationString,
            variables: variables || {},
            loading: true,
            error: null,
        };
    };
    MutationStore.prototype.markMutationError = function (mutationId, error) {
        var mutation = this.store[mutationId];
        if (!mutation) {
            return;
        }
        mutation.loading = false;
        mutation.error = error;
    };
    MutationStore.prototype.markMutationResult = function (mutationId) {
        var mutation = this.store[mutationId];
        if (!mutation) {
            return;
        }
        mutation.loading = false;
        mutation.error = null;
    };
    MutationStore.prototype.reset = function () {
        this.store = {};
    };
    return MutationStore;
}());

//# sourceMappingURL=mutations.js.map

/***/ }),

/***/ "./node_modules/apollo-client/data/queries.js":
/*!****************************************************!*\
  !*** ./node_modules/apollo-client/data/queries.js ***!
  \****************************************************/
/*! exports provided: QueryStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryStore", function() { return QueryStore; });
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/networkStatus */ "./node_modules/apollo-client/core/networkStatus.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var QueryStore = (function () {
    function QueryStore() {
        this.store = {};
    }
    QueryStore.prototype.getStore = function () {
        return this.store;
    };
    QueryStore.prototype.get = function (queryId) {
        return this.store[queryId];
    };
    QueryStore.prototype.initQuery = function (query) {
        var previousQuery = this.store[query.queryId];
        if (previousQuery &&
            previousQuery.document !== query.document &&
            Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"])(previousQuery.document) !== Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"])(query.document)) {
            throw new Error('Internal Error: may not update existing query string in store');
        }
        var isSetVariables = false;
        var previousVariables = null;
        if (query.storePreviousVariables &&
            previousQuery &&
            previousQuery.networkStatus !== _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].loading) {
            if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(previousQuery.variables, query.variables)) {
                isSetVariables = true;
                previousVariables = previousQuery.variables;
            }
        }
        var networkStatus;
        if (isSetVariables) {
            networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].setVariables;
        }
        else if (query.isPoll) {
            networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].poll;
        }
        else if (query.isRefetch) {
            networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].refetch;
        }
        else {
            networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].loading;
        }
        var graphQLErrors = [];
        if (previousQuery && previousQuery.graphQLErrors) {
            graphQLErrors = previousQuery.graphQLErrors;
        }
        this.store[query.queryId] = {
            document: query.document,
            variables: query.variables,
            previousVariables: previousVariables,
            networkError: null,
            graphQLErrors: graphQLErrors,
            networkStatus: networkStatus,
            metadata: query.metadata,
        };
        if (typeof query.fetchMoreForQueryId === 'string' &&
            this.store[query.fetchMoreForQueryId]) {
            this.store[query.fetchMoreForQueryId].networkStatus =
                _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].fetchMore;
        }
    };
    QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
        if (!this.store[queryId])
            return;
        this.store[queryId].networkError = null;
        this.store[queryId].graphQLErrors =
            result.errors && result.errors.length ? result.errors : [];
        this.store[queryId].previousVariables = null;
        this.store[queryId].networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].ready;
        if (typeof fetchMoreForQueryId === 'string' &&
            this.store[fetchMoreForQueryId]) {
            this.store[fetchMoreForQueryId].networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].ready;
        }
    };
    QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
        if (!this.store[queryId])
            return;
        this.store[queryId].networkError = error;
        this.store[queryId].networkStatus = _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].error;
        if (typeof fetchMoreForQueryId === 'string') {
            this.markQueryResultClient(fetchMoreForQueryId, true);
        }
    };
    QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
        if (!this.store[queryId])
            return;
        this.store[queryId].networkError = null;
        this.store[queryId].previousVariables = null;
        this.store[queryId].networkStatus = complete
            ? _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].ready
            : _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].loading;
    };
    QueryStore.prototype.stopQuery = function (queryId) {
        delete this.store[queryId];
    };
    QueryStore.prototype.reset = function (observableQueryIds) {
        var _this = this;
        this.store = Object.keys(this.store)
            .filter(function (queryId) {
            return observableQueryIds.indexOf(queryId) > -1;
        })
            .reduce(function (res, key) {
            res[key] = __assign({}, _this.store[key], { networkStatus: _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].loading });
            return res;
        }, {});
    };
    return QueryStore;
}());

//# sourceMappingURL=queries.js.map

/***/ }),

/***/ "./node_modules/apollo-client/data/store.js":
/*!**************************************************!*\
  !*** ./node_modules/apollo-client/data/store.js ***!
  \**************************************************/
/*! exports provided: DataStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStore", function() { return DataStore; });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");

var DataStore = (function () {
    function DataStore(initialCache) {
        this.cache = initialCache;
    }
    DataStore.prototype.getCache = function () {
        return this.cache;
    };
    DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
        if (ignoreErrors === void 0) { ignoreErrors = false; }
        var writeWithErrors = !Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["graphQLResultHasError"])(result);
        if (ignoreErrors && Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["graphQLResultHasError"])(result) && result.data) {
            writeWithErrors = true;
        }
        if (!fetchMoreForQueryId && writeWithErrors) {
            this.cache.write({
                result: result.data,
                dataId: 'ROOT_QUERY',
                query: document,
                variables: variables,
            });
        }
    };
    DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
        if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["graphQLResultHasError"])(result)) {
            this.cache.write({
                result: result.data,
                dataId: 'ROOT_SUBSCRIPTION',
                query: document,
                variables: variables,
            });
        }
    };
    DataStore.prototype.markMutationInit = function (mutation) {
        var _this = this;
        if (mutation.optimisticResponse) {
            var optimistic_1;
            if (typeof mutation.optimisticResponse === 'function') {
                optimistic_1 = mutation.optimisticResponse(mutation.variables);
            }
            else {
                optimistic_1 = mutation.optimisticResponse;
            }
            var changeFn_1 = function () {
                _this.markMutationResult({
                    mutationId: mutation.mutationId,
                    result: { data: optimistic_1 },
                    document: mutation.document,
                    variables: mutation.variables,
                    updateQueries: mutation.updateQueries,
                    update: mutation.update,
                });
            };
            this.cache.recordOptimisticTransaction(function (c) {
                var orig = _this.cache;
                _this.cache = c;
                try {
                    changeFn_1();
                }
                finally {
                    _this.cache = orig;
                }
            }, mutation.mutationId);
        }
    };
    DataStore.prototype.markMutationResult = function (mutation) {
        var _this = this;
        if (!Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["graphQLResultHasError"])(mutation.result)) {
            var cacheWrites_1 = [];
            cacheWrites_1.push({
                result: mutation.result.data,
                dataId: 'ROOT_MUTATION',
                query: mutation.document,
                variables: mutation.variables,
            });
            if (mutation.updateQueries) {
                Object.keys(mutation.updateQueries)
                    .filter(function (id) { return mutation.updateQueries[id]; })
                    .forEach(function (queryId) {
                    var _a = mutation.updateQueries[queryId], query = _a.query, updater = _a.updater;
                    var _b = _this.cache.diff({
                        query: query.document,
                        variables: query.variables,
                        returnPartialData: true,
                        optimistic: false,
                    }), currentQueryResult = _b.result, complete = _b.complete;
                    if (!complete) {
                        return;
                    }
                    var nextQueryResult = Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["tryFunctionOrLogError"])(function () {
                        return updater(currentQueryResult, {
                            mutationResult: mutation.result,
                            queryName: Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getOperationName"])(query.document) || undefined,
                            queryVariables: query.variables,
                        });
                    });
                    if (nextQueryResult) {
                        cacheWrites_1.push({
                            result: nextQueryResult,
                            dataId: 'ROOT_QUERY',
                            query: query.document,
                            variables: query.variables,
                        });
                    }
                });
            }
            this.cache.performTransaction(function (c) {
                cacheWrites_1.forEach(function (write) { return c.write(write); });
            });
            var update_1 = mutation.update;
            if (update_1) {
                this.cache.performTransaction(function (c) {
                    Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["tryFunctionOrLogError"])(function () { return update_1(c, mutation.result); });
                });
            }
        }
    };
    DataStore.prototype.markMutationComplete = function (_a) {
        var mutationId = _a.mutationId, optimisticResponse = _a.optimisticResponse;
        if (!optimisticResponse)
            return;
        this.cache.removeOptimistic(mutationId);
    };
    DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
        this.cache.write({
            result: newResult,
            dataId: 'ROOT_QUERY',
            variables: variables,
            query: document,
        });
    };
    DataStore.prototype.reset = function () {
        return this.cache.reset();
    };
    return DataStore;
}());

//# sourceMappingURL=store.js.map

/***/ }),

/***/ "./node_modules/apollo-client/errors/ApolloError.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-client/errors/ApolloError.js ***!
  \**********************************************************/
/*! exports provided: isApolloError, ApolloError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isApolloError", function() { return isApolloError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApolloError", function() { return ApolloError; });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function isApolloError(err) {
    return err.hasOwnProperty('graphQLErrors');
}
var generateErrorMessage = function (err) {
    var message = '';
    if (Array.isArray(err.graphQLErrors) && err.graphQLErrors.length !== 0) {
        err.graphQLErrors.forEach(function (graphQLError) {
            var errorMessage = graphQLError
                ? graphQLError.message
                : 'Error message not found.';
            message += "GraphQL error: " + errorMessage + "\n";
        });
    }
    if (err.networkError) {
        message += 'Network error: ' + err.networkError.message + '\n';
    }
    message = message.replace(/\n$/, '');
    return message;
};
var ApolloError = (function (_super) {
    __extends(ApolloError, _super);
    function ApolloError(_a) {
        var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.graphQLErrors = graphQLErrors || [];
        _this.networkError = networkError || null;
        if (!errorMessage) {
            _this.message = generateErrorMessage(_this);
        }
        else {
            _this.message = errorMessage;
        }
        _this.extraInfo = extraInfo;
        _this.__proto__ = ApolloError.prototype;
        return _this;
    }
    return ApolloError;
}(Error));

//# sourceMappingURL=ApolloError.js.map

/***/ }),

/***/ "./node_modules/apollo-client/index.js":
/*!*********************************************!*\
  !*** ./node_modules/apollo-client/index.js ***!
  \*********************************************/
/*! exports provided: printAST, ObservableQuery, NetworkStatus, ApolloError, ApolloClient, default, FetchType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "printAST", function() { return graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"]; });

/* harmony import */ var _core_ObservableQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ObservableQuery */ "./node_modules/apollo-client/core/ObservableQuery.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObservableQuery", function() { return _core_ObservableQuery__WEBPACK_IMPORTED_MODULE_1__["ObservableQuery"]; });

/* harmony import */ var _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/networkStatus */ "./node_modules/apollo-client/core/networkStatus.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NetworkStatus", function() { return _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"]; });

/* harmony import */ var _core_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/types */ "./node_modules/apollo-client/core/types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FetchType", function() { return _core_types__WEBPACK_IMPORTED_MODULE_3__["FetchType"]; });

/* harmony import */ var _errors_ApolloError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors/ApolloError */ "./node_modules/apollo-client/errors/ApolloError.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApolloError", function() { return _errors_ApolloError__WEBPACK_IMPORTED_MODULE_4__["ApolloError"]; });

/* harmony import */ var _ApolloClient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ApolloClient */ "./node_modules/apollo-client/ApolloClient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApolloClient", function() { return _ApolloClient__WEBPACK_IMPORTED_MODULE_5__["default"]; });








/* harmony default export */ __webpack_exports__["default"] = (_ApolloClient__WEBPACK_IMPORTED_MODULE_5__["default"]);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-client/scheduler/scheduler.js":
/*!***********************************************************!*\
  !*** ./node_modules/apollo-client/scheduler/scheduler.js ***!
  \***********************************************************/
/*! exports provided: QueryScheduler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryScheduler", function() { return QueryScheduler; });
/* harmony import */ var _core_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/types */ "./node_modules/apollo-client/core/types.js");
/* harmony import */ var _core_ObservableQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ObservableQuery */ "./node_modules/apollo-client/core/ObservableQuery.js");
/* harmony import */ var _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/networkStatus */ "./node_modules/apollo-client/core/networkStatus.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



var QueryScheduler = (function () {
    function QueryScheduler(_a) {
        var queryManager = _a.queryManager, ssrMode = _a.ssrMode;
        this.inFlightQueries = {};
        this.registeredQueries = {};
        this.intervalQueries = {};
        this.pollingTimers = {};
        this.ssrMode = false;
        this.queryManager = queryManager;
        this.ssrMode = ssrMode || false;
    }
    QueryScheduler.prototype.checkInFlight = function (queryId) {
        var query = this.queryManager.queryStore.get(queryId);
        return (query &&
            query.networkStatus !== _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].ready &&
            query.networkStatus !== _core_networkStatus__WEBPACK_IMPORTED_MODULE_2__["NetworkStatus"].error);
    };
    QueryScheduler.prototype.fetchQuery = function (queryId, options, fetchType) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.queryManager
                .fetchQuery(queryId, options, fetchType)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                reject(error);
            });
        });
    };
    QueryScheduler.prototype.startPollingQuery = function (options, queryId, listener) {
        if (!options.pollInterval) {
            throw new Error('Attempted to start a polling query without a polling interval.');
        }
        if (this.ssrMode)
            return queryId;
        this.registeredQueries[queryId] = options;
        if (listener) {
            this.queryManager.addQueryListener(queryId, listener);
        }
        this.addQueryOnInterval(queryId, options);
        return queryId;
    };
    QueryScheduler.prototype.stopPollingQuery = function (queryId) {
        delete this.registeredQueries[queryId];
    };
    QueryScheduler.prototype.fetchQueriesOnInterval = function (interval) {
        var _this = this;
        this.intervalQueries[interval] = this.intervalQueries[interval].filter(function (queryId) {
            if (!(_this.registeredQueries.hasOwnProperty(queryId) &&
                _this.registeredQueries[queryId].pollInterval === interval)) {
                return false;
            }
            if (_this.checkInFlight(queryId)) {
                return true;
            }
            var queryOptions = _this.registeredQueries[queryId];
            var pollingOptions = __assign({}, queryOptions);
            pollingOptions.fetchPolicy = 'network-only';
            _this.fetchQuery(queryId, pollingOptions, _core_types__WEBPACK_IMPORTED_MODULE_0__["FetchType"].poll).catch(function () { });
            return true;
        });
        if (this.intervalQueries[interval].length === 0) {
            clearInterval(this.pollingTimers[interval]);
            delete this.intervalQueries[interval];
        }
    };
    QueryScheduler.prototype.addQueryOnInterval = function (queryId, queryOptions) {
        var _this = this;
        var interval = queryOptions.pollInterval;
        if (!interval) {
            throw new Error("A poll interval is required to start polling query with id '" + queryId + "'.");
        }
        if (this.intervalQueries.hasOwnProperty(interval.toString()) &&
            this.intervalQueries[interval].length > 0) {
            this.intervalQueries[interval].push(queryId);
        }
        else {
            this.intervalQueries[interval] = [queryId];
            this.pollingTimers[interval] = setInterval(function () {
                _this.fetchQueriesOnInterval(interval);
            }, interval);
        }
    };
    QueryScheduler.prototype.registerPollingQuery = function (queryOptions) {
        if (!queryOptions.pollInterval) {
            throw new Error('Attempted to register a non-polling query with the scheduler.');
        }
        return new _core_ObservableQuery__WEBPACK_IMPORTED_MODULE_1__["ObservableQuery"]({
            scheduler: this,
            options: queryOptions,
        });
    };
    return QueryScheduler;
}());

//# sourceMappingURL=scheduler.js.map

/***/ }),

/***/ "./node_modules/apollo-client/util/Observable.js":
/*!*******************************************************!*\
  !*** ./node_modules/apollo-client/util/Observable.js ***!
  \*******************************************************/
/*! exports provided: Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/index.js");
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Observable = (function (_super) {
    __extends(Observable, _super);
    function Observable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Observable.prototype[symbol_observable__WEBPACK_IMPORTED_MODULE_1__["default"]] = function () {
        return this;
    };
    Observable.prototype['@@observable'] = function () {
        return this;
    };
    return Observable;
}(apollo_link__WEBPACK_IMPORTED_MODULE_0__["Observable"]));

//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/apollo-client/version.js":
/*!***********************************************!*\
  !*** ./node_modules/apollo-client/version.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.version = "2.4.2"

/***/ }),

/***/ "./node_modules/apollo-link-dedup/lib/dedupLink.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-link-dedup/lib/dedupLink.js ***!
  \*********************************************************/
/*! exports provided: DedupLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DedupLink", function() { return DedupLink; });
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/index.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/*
 * Expects context to contain the forceFetch field if no dedup
 */
var DedupLink = /** @class */ (function (_super) {
    __extends(DedupLink, _super);
    function DedupLink() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.inFlightRequestObservables = new Map();
        _this.subscribers = new Map();
        return _this;
    }
    DedupLink.prototype.request = function (operation, forward) {
        var _this = this;
        // sometimes we might not want to deduplicate a request, for example when we want to force fetch it.
        if (operation.getContext().forceFetch) {
            return forward(operation);
        }
        var key = operation.toKey();
        var cleanup = function (operationKey) {
            _this.inFlightRequestObservables.delete(operationKey);
            var prev = _this.subscribers.get(operationKey);
            return prev;
        };
        if (!this.inFlightRequestObservables.get(key)) {
            // this is a new request, i.e. we haven't deduplicated it yet
            // call the next link
            var singleObserver_1 = forward(operation);
            var subscription_1;
            var sharedObserver = new apollo_link__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (observer) {
                // this will still be called by each subscriber regardless of
                // deduplication status
                var prev = _this.subscribers.get(key);
                if (!prev)
                    prev = { next: [], error: [], complete: [] };
                _this.subscribers.set(key, {
                    next: prev.next.concat([observer.next.bind(observer)]),
                    error: prev.error.concat([observer.error.bind(observer)]),
                    complete: prev.complete.concat([observer.complete.bind(observer)]),
                });
                if (!subscription_1) {
                    subscription_1 = singleObserver_1.subscribe({
                        next: function (result) {
                            var previous = cleanup(key);
                            _this.subscribers.delete(key);
                            if (previous) {
                                previous.next.forEach(function (next) { return next(result); });
                                previous.complete.forEach(function (complete) { return complete(); });
                            }
                        },
                        error: function (error) {
                            var previous = cleanup(key);
                            _this.subscribers.delete(key);
                            if (previous)
                                previous.error.forEach(function (err) { return err(error); });
                        },
                    });
                }
                return function () {
                    if (subscription_1)
                        subscription_1.unsubscribe();
                    _this.inFlightRequestObservables.delete(key);
                };
            });
            this.inFlightRequestObservables.set(key, sharedObserver);
        }
        // return shared Observable
        return this.inFlightRequestObservables.get(key);
    };
    return DedupLink;
}(apollo_link__WEBPACK_IMPORTED_MODULE_0__["ApolloLink"]));

//# sourceMappingURL=dedupLink.js.map

/***/ }),

/***/ "./node_modules/apollo-link-dedup/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/apollo-link-dedup/lib/index.js ***!
  \*****************************************************/
/*! exports provided: DedupLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dedupLink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dedupLink */ "./node_modules/apollo-link-dedup/lib/dedupLink.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DedupLink", function() { return _dedupLink__WEBPACK_IMPORTED_MODULE_0__["DedupLink"]; });


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-link-http-common/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/apollo-link-http-common/lib/index.js ***!
  \***********************************************************/
/*! exports provided: fallbackHttpConfig, throwServerError, parseAndCheckHttpResponse, checkFetcher, createSignalIfSupported, selectHttpOptionsAndBody, serializeFetchParameter, selectURI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fallbackHttpConfig", function() { return fallbackHttpConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwServerError", function() { return throwServerError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseAndCheckHttpResponse", function() { return parseAndCheckHttpResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFetcher", function() { return checkFetcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSignalIfSupported", function() { return createSignalIfSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectHttpOptionsAndBody", function() { return selectHttpOptionsAndBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeFetchParameter", function() { return serializeFetchParameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectURI", function() { return selectURI; });
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false,
};
var defaultHeaders = {
    // headers are case insensitive (https://stackoverflow.com/a/5259004)
    accept: '*/*',
    'content-type': 'application/json',
};
var defaultOptions = {
    method: 'POST',
};
var fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions,
};
var throwServerError = function (response, result, message) {
    var error = new Error(message);
    error.response = response;
    error.statusCode = response.status;
    error.result = result;
    throw error;
};
//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>
var parseAndCheckHttpResponse = function (operations) { return function (response) {
    return (response
        .text()
        .then(function (bodyText) {
        try {
            return JSON.parse(bodyText);
        }
        catch (err) {
            var parseError = err;
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            return Promise.reject(parseError);
        }
    })
        //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult
        .then(function (result) {
        if (response.status >= 300) {
            //Network error
            throwServerError(response, result, "Response not successful: Received status code " + response.status);
        }
        //TODO should really error per response in a Batch based on properties
        //    - could be done in a validation link
        if (!Array.isArray(result) &&
            !result.hasOwnProperty('data') &&
            !result.hasOwnProperty('errors')) {
            //Data error
            throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations)
                ? operations.map(function (op) { return op.operationName; })
                : operations.operationName) + "'.");
        }
        return result;
    }));
}; };
var checkFetcher = function (fetcher) {
    if (!fetcher && typeof fetch === 'undefined') {
        var library = 'unfetch';
        if (typeof window === 'undefined')
            library = 'node-fetch';
        throw new Error("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
    }
};
var createSignalIfSupported = function () {
    if (typeof AbortController === 'undefined')
        return { controller: false, signal: false };
    var controller = new AbortController();
    var signal = controller.signal;
    return { controller: controller, signal: signal };
};
var selectHttpOptionsAndBody = function (operation, fallbackConfig) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
    }
    var options = __assign({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
    var http = fallbackConfig.http;
    /*
     * use the rest of the configs to populate the options
     * configs later in the list will overwrite earlier fields
     */
    configs.forEach(function (config) {
        options = __assign({}, options, config.options, { headers: __assign({}, options.headers, config.headers) });
        if (config.credentials)
            options.credentials = config.credentials;
        http = __assign({}, http, config.http);
    });
    //The body depends on the http options
    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName: operationName, variables: variables };
    if (http.includeExtensions)
        body.extensions = extensions;
    // not sending the query (i.e persisted queries)
    if (http.includeQuery)
        body.query = Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_0__["print"])(query);
    return {
        options: options,
        body: body,
    };
};
var serializeFetchParameter = function (p, label) {
    var serialized;
    try {
        serialized = JSON.stringify(p);
    }
    catch (e) {
        var parseError = new Error("Network request failed. " + label + " is not serializable: " + e.message);
        parseError.parseError = e;
        throw parseError;
    }
    return serialized;
};
//selects "/graphql" by default
var selectURI = function (operation, fallbackURI) {
    var context = operation.getContext();
    var contextURI = context.uri;
    if (contextURI) {
        return contextURI;
    }
    else if (typeof fallbackURI === 'function') {
        return fallbackURI(operation);
    }
    else {
        return fallbackURI || '/graphql';
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-link-http/lib/httpLink.js":
/*!*******************************************************!*\
  !*** ./node_modules/apollo-link-http/lib/httpLink.js ***!
  \*******************************************************/
/*! exports provided: createHttpLink, HttpLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHttpLink", function() { return createHttpLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpLink", function() { return HttpLink; });
/* harmony import */ var apollo_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-link */ "./node_modules/apollo-link/lib/index.js");
/* harmony import */ var apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! apollo-link-http-common */ "./node_modules/apollo-link-http-common/lib/index.js");
/* tslint:disable */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};


var createHttpLink = function (linkOptions) {
    if (linkOptions === void 0) { linkOptions = {}; }
    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, 
    // use default global fetch is nothing passed in
    fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = __rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]);
    // dev warnings to ensure fetch is present
    Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["checkFetcher"])(fetcher);
    //fetcher is set here rather than the destructuring to ensure fetch is
    //declared before referencing it. Reference in the destructuring would cause
    //a ReferenceError
    if (!fetcher) {
        fetcher = fetch;
    }
    var linkConfig = {
        http: { includeExtensions: includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers,
    };
    return new apollo_link__WEBPACK_IMPORTED_MODULE_0__["ApolloLink"](function (operation) {
        var chosenURI = Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["selectURI"])(operation, uri);
        var context = operation.getContext();
        var contextConfig = {
            http: context.http,
            options: context.fetchOptions,
            credentials: context.credentials,
            headers: context.headers,
        };
        //uses fallback, link, and then context to build options
        var _a = Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["selectHttpOptionsAndBody"])(operation, apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["fallbackHttpConfig"], linkConfig, contextConfig), options = _a.options, body = _a.body;
        var controller;
        if (!options.signal) {
            var _b = Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["createSignalIfSupported"])(), _controller = _b.controller, signal = _b.signal;
            controller = _controller;
            if (controller)
                options.signal = signal;
        }
        // If requested, set method to GET if there are no mutations.
        var definitionIsMutation = function (d) {
            return d.kind === 'OperationDefinition' && d.operation === 'mutation';
        };
        if (useGETForQueries &&
            !operation.query.definitions.some(definitionIsMutation)) {
            options.method = 'GET';
        }
        if (options.method === 'GET') {
            var _c = rewriteURIForGET(chosenURI, body), newURI = _c.newURI, parseError = _c.parseError;
            if (parseError) {
                return Object(apollo_link__WEBPACK_IMPORTED_MODULE_0__["fromError"])(parseError);
            }
            chosenURI = newURI;
        }
        else {
            try {
                options.body = Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["serializeFetchParameter"])(body, 'Payload');
            }
            catch (parseError) {
                return Object(apollo_link__WEBPACK_IMPORTED_MODULE_0__["fromError"])(parseError);
            }
        }
        return new apollo_link__WEBPACK_IMPORTED_MODULE_0__["Observable"](function (observer) {
            fetcher(chosenURI, options)
                .then(function (response) {
                operation.setContext({ response: response });
                return response;
            })
                .then(Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["parseAndCheckHttpResponse"])(operation))
                .then(function (result) {
                // we have data and can send it to back up the link chain
                observer.next(result);
                observer.complete();
                return result;
            })
                .catch(function (err) {
                // fetch was cancelled so its already been cleaned up in the unsubscribe
                if (err.name === 'AbortError')
                    return;
                // if it is a network error, BUT there is graphql result info
                // fire the next observer before calling error
                // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`
                // to pass to UI
                // this should only happen if we *also* have data as part of the response key per
                // the spec
                if (err.result && err.result.errors && err.result.data) {
                    // if we dont' call next, the UI can only show networkError because AC didn't
                    // get andy graphqlErrors
                    // this is graphql execution result info (i.e errors and possibly data)
                    // this is because there is no formal spec how errors should translate to
                    // http status codes. So an auth error (401) could have both data
                    // from a public field, errors from a private field, and a status of 401
                    // {
                    //  user { // this will have errors
                    //    firstName
                    //  }
                    //  products { // this is public so will have data
                    //    cost
                    //  }
                    // }
                    //
                    // the result of above *could* look like this:
                    // {
                    //   data: { products: [{ cost: "$10" }] },
                    //   errors: [{
                    //      message: 'your session has timed out',
                    //      path: []
                    //   }]
                    // }
                    // status code of above would be a 401
                    // in the UI you want to show data where you can, errors as data where you can
                    // and use correct http status codes
                    observer.next(err.result);
                }
                observer.error(err);
            });
            return function () {
                // XXX support canceling this request
                // https://developers.google.com/web/updates/2017/09/abortable-fetch
                if (controller)
                    controller.abort();
            };
        });
    });
};
// For GET operations, returns the given URI rewritten with parameters, or a
// parse error.
function rewriteURIForGET(chosenURI, body) {
    // Implement the standard HTTP GET serialization, plus 'extensions'. Note
    // the extra level of JSON serialization!
    var queryParams = [];
    var addQueryParam = function (key, value) {
        queryParams.push(key + "=" + encodeURIComponent(value));
    };
    if ('query' in body) {
        addQueryParam('query', body.query);
    }
    if (body.operationName) {
        addQueryParam('operationName', body.operationName);
    }
    if (body.variables) {
        var serializedVariables = void 0;
        try {
            serializedVariables = Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["serializeFetchParameter"])(body.variables, 'Variables map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('variables', serializedVariables);
    }
    if (body.extensions) {
        var serializedExtensions = void 0;
        try {
            serializedExtensions = Object(apollo_link_http_common__WEBPACK_IMPORTED_MODULE_1__["serializeFetchParameter"])(body.extensions, 'Extensions map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('extensions', serializedExtensions);
    }
    // Reconstruct the URI with added query params.
    // XXX This assumes that the URI is well-formed and that it doesn't
    //     already contain any of these query params. We could instead use the
    //     URL API and take a polyfill (whatwg-url@6) for older browsers that
    //     don't support URLSearchParams. Note that some browsers (and
    //     versions of whatwg-url) support URL but not URLSearchParams!
    var fragment = '', preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf('#');
    if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
    return { newURI: newURI };
}
var HttpLink = /** @class */ (function (_super) {
    __extends(HttpLink, _super);
    function HttpLink(opts) {
        return _super.call(this, createHttpLink(opts).request) || this;
    }
    return HttpLink;
}(apollo_link__WEBPACK_IMPORTED_MODULE_0__["ApolloLink"]));

//# sourceMappingURL=httpLink.js.map

/***/ }),

/***/ "./node_modules/apollo-link-http/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/apollo-link-http/lib/index.js ***!
  \****************************************************/
/*! exports provided: createHttpLink, HttpLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _httpLink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./httpLink */ "./node_modules/apollo-link-http/lib/httpLink.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createHttpLink", function() { return _httpLink__WEBPACK_IMPORTED_MODULE_0__["createHttpLink"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpLink", function() { return _httpLink__WEBPACK_IMPORTED_MODULE_0__["HttpLink"]; });


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-link/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/apollo-link/lib/index.js ***!
  \***********************************************/
/*! exports provided: createOperation, makePromise, toPromise, fromPromise, fromError, Observable, empty, from, split, concat, ApolloLink, execute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./link */ "./node_modules/apollo-link/lib/link.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return _link__WEBPACK_IMPORTED_MODULE_0__["empty"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "from", function() { return _link__WEBPACK_IMPORTED_MODULE_0__["from"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _link__WEBPACK_IMPORTED_MODULE_0__["split"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _link__WEBPACK_IMPORTED_MODULE_0__["concat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ApolloLink", function() { return _link__WEBPACK_IMPORTED_MODULE_0__["ApolloLink"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "execute", function() { return _link__WEBPACK_IMPORTED_MODULE_0__["execute"]; });

/* harmony import */ var _linkUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linkUtils */ "./node_modules/apollo-link/lib/linkUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createOperation", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__["createOperation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makePromise", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__["makePromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPromise", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__["toPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromPromise", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__["fromPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromError", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__["fromError"]; });

/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zen-observable-ts */ "./node_modules/zen-observable-ts/lib/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return zen_observable_ts__WEBPACK_IMPORTED_MODULE_2__["default"]; });





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-link/lib/link.js":
/*!**********************************************!*\
  !*** ./node_modules/apollo-link/lib/link.js ***!
  \**********************************************/
/*! exports provided: empty, from, split, concat, ApolloLink, execute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "from", function() { return from; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApolloLink", function() { return ApolloLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "execute", function() { return execute; });
/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zen-observable-ts */ "./node_modules/zen-observable-ts/lib/index.js");
/* harmony import */ var _linkUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linkUtils */ "./node_modules/apollo-link/lib/linkUtils.js");


var passthrough = function (op, forward) { return (forward ? forward(op) : zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of()); };
var toLink = function (handler) {
    return typeof handler === 'function' ? new ApolloLink(handler) : handler;
};
var empty = function () {
    return new ApolloLink(function (op, forward) { return zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of(); });
};
var from = function (links) {
    if (links.length === 0)
        return empty();
    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
};
var split = function (test, left, right) {
    if (right === void 0) { right = new ApolloLink(passthrough); }
    var leftLink = toLink(left);
    var rightLink = toLink(right);
    if (Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["isTerminating"])(leftLink) && Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["isTerminating"])(rightLink)) {
        return new ApolloLink(function (operation) {
            return test(operation)
                ? leftLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of()
                : rightLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of();
        });
    }
    else {
        return new ApolloLink(function (operation, forward) {
            return test(operation)
                ? leftLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of()
                : rightLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of();
        });
    }
};
// join two Links together
var concat = function (first, second) {
    var firstLink = toLink(first);
    if (Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["isTerminating"])(firstLink)) {
        console.warn(new _linkUtils__WEBPACK_IMPORTED_MODULE_1__["LinkError"]("You are calling concat on a terminating link, which will have no effect", firstLink));
        return firstLink;
    }
    var nextLink = toLink(second);
    if (Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["isTerminating"])(nextLink)) {
        return new ApolloLink(function (operation) {
            return firstLink.request(operation, function (op) { return nextLink.request(op) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of(); }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of();
        });
    }
    else {
        return new ApolloLink(function (operation, forward) {
            return (firstLink.request(operation, function (op) {
                return nextLink.request(op, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of();
            }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of());
        });
    }
};
var ApolloLink = /** @class */ (function () {
    function ApolloLink(request) {
        if (request)
            this.request = request;
    }
    ApolloLink.prototype.split = function (test, left, right) {
        if (right === void 0) { right = new ApolloLink(passthrough); }
        return this.concat(split(test, left, right));
    };
    ApolloLink.prototype.concat = function (next) {
        return concat(this, next);
    };
    ApolloLink.prototype.request = function (operation, forward) {
        throw new Error('request is not implemented');
    };
    ApolloLink.empty = empty;
    ApolloLink.from = from;
    ApolloLink.split = split;
    ApolloLink.execute = execute;
    return ApolloLink;
}());

function execute(link, operation) {
    return (link.request(Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["createOperation"])(operation.context, Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["transformOperation"])(Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__["validateOperation"])(operation)))) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["default"].of());
}
//# sourceMappingURL=link.js.map

/***/ }),

/***/ "./node_modules/apollo-link/lib/linkUtils.js":
/*!***************************************************!*\
  !*** ./node_modules/apollo-link/lib/linkUtils.js ***!
  \***************************************************/
/*! exports provided: validateOperation, LinkError, isTerminating, toPromise, makePromise, fromPromise, fromError, transformOperation, createOperation, getKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateOperation", function() { return validateOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkError", function() { return LinkError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTerminating", function() { return isTerminating; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPromise", function() { return toPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePromise", function() { return makePromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPromise", function() { return fromPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromError", function() { return fromError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformOperation", function() { return transformOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOperation", function() { return createOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ "./node_modules/apollo-utilities/lib/index.js");
/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zen-observable-ts */ "./node_modules/zen-observable-ts/lib/index.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.js");
/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



function validateOperation(operation) {
    var OPERATION_FIELDS = [
        'query',
        'operationName',
        'variables',
        'extensions',
        'context',
    ];
    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
            throw new Error("illegal argument: " + key);
        }
    }
    return operation;
}
var LinkError = /** @class */ (function (_super) {
    __extends(LinkError, _super);
    function LinkError(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
    }
    return LinkError;
}(Error));

function isTerminating(link) {
    return link.request.length <= 1;
}
function toPromise(observable) {
    var completed = false;
    return new Promise(function (resolve, reject) {
        observable.subscribe({
            next: function (data) {
                if (completed) {
                    console.warn("Promise Wrapper does not support multiple results from Observable");
                }
                else {
                    completed = true;
                    resolve(data);
                }
            },
            error: reject,
        });
    });
}
// backwards compat
var makePromise = toPromise;
function fromPromise(promise) {
    return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_1__["default"](function (observer) {
        promise
            .then(function (value) {
            observer.next(value);
            observer.complete();
        })
            .catch(observer.error.bind(observer));
    });
}
function fromError(errorValue) {
    return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_1__["default"](function (observer) {
        observer.error(errorValue);
    });
}
function transformOperation(operation) {
    var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query,
    };
    // best guess at an operation name
    if (!transformedOperation.operationName) {
        transformedOperation.operationName =
            typeof transformedOperation.query !== 'string'
                ? Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__["getOperationName"])(transformedOperation.query)
                : '';
    }
    return transformedOperation;
}
function createOperation(starting, operation) {
    var context = __assign({}, starting);
    var setContext = function (next) {
        if (typeof next === 'function') {
            context = __assign({}, context, next(context));
        }
        else {
            context = __assign({}, context, next);
        }
    };
    var getContext = function () { return (__assign({}, context)); };
    Object.defineProperty(operation, 'setContext', {
        enumerable: false,
        value: setContext,
    });
    Object.defineProperty(operation, 'getContext', {
        enumerable: false,
        value: getContext,
    });
    Object.defineProperty(operation, 'toKey', {
        enumerable: false,
        value: function () { return getKey(operation); },
    });
    return operation;
}
function getKey(operation) {
    // XXX we're assuming here that variables will be serialized in the same order.
    // that might not always be true
    return Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__["print"])(operation.query) + "|" + JSON.stringify(operation.variables) + "|" + operation.operationName;
}
//# sourceMappingURL=linkUtils.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/directives.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/directives.js ***!
  \*********************************************************/
/*! exports provided: getDirectiveInfoFromField, shouldInclude, flattenSelections, getDirectiveNames, hasDirectives */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirectiveInfoFromField", function() { return getDirectiveInfoFromField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shouldInclude", function() { return shouldInclude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenSelections", function() { return flattenSelections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirectiveNames", function() { return getDirectiveNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasDirectives", function() { return hasDirectives; });
/* harmony import */ var _storeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storeUtils */ "./node_modules/apollo-utilities/lib/storeUtils.js");

function getDirectiveInfoFromField(field, variables) {
    if (field.directives && field.directives.length) {
        var directiveObj_1 = {};
        field.directives.forEach(function (directive) {
            directiveObj_1[directive.name.value] = Object(_storeUtils__WEBPACK_IMPORTED_MODULE_0__["argumentsObjectFromField"])(directive, variables);
        });
        return directiveObj_1;
    }
    return null;
}
function shouldInclude(selection, variables) {
    if (variables === void 0) { variables = {}; }
    if (!selection.directives) {
        return true;
    }
    var res = true;
    selection.directives.forEach(function (directive) {
        if (directive.name.value !== 'skip' && directive.name.value !== 'include') {
            return;
        }
        var directiveArguments = directive.arguments || [];
        var directiveName = directive.name.value;
        if (directiveArguments.length !== 1) {
            throw new Error("Incorrect number of arguments for the @" + directiveName + " directive.");
        }
        var ifArgument = directiveArguments[0];
        if (!ifArgument.name || ifArgument.name.value !== 'if') {
            throw new Error("Invalid argument for the @" + directiveName + " directive.");
        }
        var ifValue = directiveArguments[0].value;
        var evaledValue = false;
        if (!ifValue || ifValue.kind !== 'BooleanValue') {
            if (ifValue.kind !== 'Variable') {
                throw new Error("Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
            }
            else {
                evaledValue = variables[ifValue.name.value];
                if (evaledValue === undefined) {
                    throw new Error("Invalid variable referenced in @" + directiveName + " directive.");
                }
            }
        }
        else {
            evaledValue = ifValue.value;
        }
        if (directiveName === 'skip') {
            evaledValue = !evaledValue;
        }
        if (!evaledValue) {
            res = false;
        }
    });
    return res;
}
function flattenSelections(selection) {
    if (!selection.selectionSet ||
        !(selection.selectionSet.selections.length > 0))
        return [selection];
    return [selection].concat(selection.selectionSet.selections
        .map(function (selectionNode) {
        return [selectionNode].concat(flattenSelections(selectionNode));
    })
        .reduce(function (selections, selected) { return selections.concat(selected); }, []));
}
function getDirectiveNames(doc) {
    var directiveNames = doc.definitions
        .filter(function (definition) {
        return definition.selectionSet && definition.selectionSet.selections;
    })
        .map(function (x) { return flattenSelections(x); })
        .reduce(function (selections, selected) { return selections.concat(selected); }, [])
        .filter(function (selection) {
        return selection.directives && selection.directives.length > 0;
    })
        .map(function (selection) { return selection.directives; })
        .reduce(function (directives, directive) { return directives.concat(directive); }, [])
        .map(function (directive) { return directive.name.value; });
    return directiveNames;
}
function hasDirectives(names, doc) {
    return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });
}
//# sourceMappingURL=directives.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/fragments.js":
/*!********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/fragments.js ***!
  \********************************************************/
/*! exports provided: getFragmentQueryDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFragmentQueryDocument", function() { return getFragmentQueryDocument; });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function getFragmentQueryDocument(document, fragmentName) {
    var actualFragmentName = fragmentName;
    var fragments = [];
    document.definitions.forEach(function (definition) {
        if (definition.kind === 'OperationDefinition') {
            throw new Error("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : '') + ". " +
                'No operations are allowed when using a fragment as a query. Only fragments are allowed.');
        }
        if (definition.kind === 'FragmentDefinition') {
            fragments.push(definition);
        }
    });
    if (typeof actualFragmentName === 'undefined') {
        if (fragments.length !== 1) {
            throw new Error("Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
        }
        actualFragmentName = fragments[0].name.value;
    }
    var query = __assign({}, document, { definitions: [
            {
                kind: 'OperationDefinition',
                operation: 'query',
                selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                        {
                            kind: 'FragmentSpread',
                            name: {
                                kind: 'Name',
                                value: actualFragmentName,
                            },
                        },
                    ],
                },
            }
        ].concat(document.definitions) });
    return query;
}
//# sourceMappingURL=fragments.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/getFromAST.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/getFromAST.js ***!
  \*********************************************************/
/*! exports provided: getMutationDefinition, checkDocument, getOperationDefinition, getOperationDefinitionOrDie, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, createFragmentMap, getDefaultValues, variablesInOperation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMutationDefinition", function() { return getMutationDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkDocument", function() { return checkDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOperationDefinition", function() { return getOperationDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOperationDefinitionOrDie", function() { return getOperationDefinitionOrDie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOperationName", function() { return getOperationName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFragmentDefinitions", function() { return getFragmentDefinitions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQueryDefinition", function() { return getQueryDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFragmentDefinition", function() { return getFragmentDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMainDefinition", function() { return getMainDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFragmentMap", function() { return createFragmentMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultValues", function() { return getDefaultValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variablesInOperation", function() { return variablesInOperation; });
/* harmony import */ var _util_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/assign */ "./node_modules/apollo-utilities/lib/util/assign.js");
/* harmony import */ var _storeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storeUtils */ "./node_modules/apollo-utilities/lib/storeUtils.js");


function getMutationDefinition(doc) {
    checkDocument(doc);
    var mutationDef = doc.definitions.filter(function (definition) {
        return definition.kind === 'OperationDefinition' &&
            definition.operation === 'mutation';
    })[0];
    if (!mutationDef) {
        throw new Error('Must contain a mutation definition.');
    }
    return mutationDef;
}
function checkDocument(doc) {
    if (doc.kind !== 'Document') {
        throw new Error("Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
    }
    var operations = doc.definitions
        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })
        .map(function (definition) {
        if (definition.kind !== 'OperationDefinition') {
            throw new Error("Schema type definitions not allowed in queries. Found: \"" + definition.kind + "\"");
        }
        return definition;
    });
    if (operations.length > 1) {
        throw new Error("Ambiguous GraphQL document: contains " + operations.length + " operations");
    }
}
function getOperationDefinition(doc) {
    checkDocument(doc);
    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];
}
function getOperationDefinitionOrDie(document) {
    var def = getOperationDefinition(document);
    if (!def) {
        throw new Error("GraphQL document is missing an operation");
    }
    return def;
}
function getOperationName(doc) {
    return (doc.definitions
        .filter(function (definition) {
        return definition.kind === 'OperationDefinition' && definition.name;
    })
        .map(function (x) { return x.name.value; })[0] || null);
}
function getFragmentDefinitions(doc) {
    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });
}
function getQueryDefinition(doc) {
    var queryDef = getOperationDefinition(doc);
    if (!queryDef || queryDef.operation !== 'query') {
        throw new Error('Must contain a query definition.');
    }
    return queryDef;
}
function getFragmentDefinition(doc) {
    if (doc.kind !== 'Document') {
        throw new Error("Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
    }
    if (doc.definitions.length > 1) {
        throw new Error('Fragment must have exactly one definition.');
    }
    var fragmentDef = doc.definitions[0];
    if (fragmentDef.kind !== 'FragmentDefinition') {
        throw new Error('Must be a fragment definition.');
    }
    return fragmentDef;
}
function getMainDefinition(queryDoc) {
    checkDocument(queryDoc);
    var fragmentDefinition;
    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
        var definition = _a[_i];
        if (definition.kind === 'OperationDefinition') {
            var operation = definition.operation;
            if (operation === 'query' ||
                operation === 'mutation' ||
                operation === 'subscription') {
                return definition;
            }
        }
        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
            fragmentDefinition = definition;
        }
    }
    if (fragmentDefinition) {
        return fragmentDefinition;
    }
    throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');
}
function createFragmentMap(fragments) {
    if (fragments === void 0) { fragments = []; }
    var symTable = {};
    fragments.forEach(function (fragment) {
        symTable[fragment.name.value] = fragment;
    });
    return symTable;
}
function getDefaultValues(definition) {
    if (definition &&
        definition.variableDefinitions &&
        definition.variableDefinitions.length) {
        var defaultValues = definition.variableDefinitions
            .filter(function (_a) {
            var defaultValue = _a.defaultValue;
            return defaultValue;
        })
            .map(function (_a) {
            var variable = _a.variable, defaultValue = _a.defaultValue;
            var defaultValueObj = {};
            Object(_storeUtils__WEBPACK_IMPORTED_MODULE_1__["valueToObjectRepresentation"])(defaultValueObj, variable.name, defaultValue);
            return defaultValueObj;
        });
        return _util_assign__WEBPACK_IMPORTED_MODULE_0__["assign"].apply(void 0, [{}].concat(defaultValues));
    }
    return {};
}
function variablesInOperation(operation) {
    var names = new Set();
    if (operation.variableDefinitions) {
        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            names.add(definition.variable.name.value);
        }
    }
    return names;
}
//# sourceMappingURL=getFromAST.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/index.js ***!
  \****************************************************/
/*! exports provided: getDirectiveInfoFromField, shouldInclude, flattenSelections, getDirectiveNames, hasDirectives, getFragmentQueryDocument, getMutationDefinition, checkDocument, getOperationDefinition, getOperationDefinitionOrDie, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, createFragmentMap, getDefaultValues, variablesInOperation, removeDirectivesFromDocument, addTypenameToDocument, removeConnectionDirectiveFromDocument, getDirectivesFromDocument, isScalarValue, isNumberValue, valueToObjectRepresentation, storeKeyNameFromField, getStoreKeyName, argumentsObjectFromField, resultKeyNameFromField, isField, isInlineFragment, isIdValue, toIdValue, isJsonValue, valueFromNode, assign, cloneDeep, getEnv, isEnv, isProduction, isDevelopment, isTest, tryFunctionOrLogError, graphQLResultHasError, isEqual, maybeDeepFreeze, warnOnceInDevelopment, stripSymbols */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _directives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./directives */ "./node_modules/apollo-utilities/lib/directives.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDirectiveInfoFromField", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__["getDirectiveInfoFromField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shouldInclude", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__["shouldInclude"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flattenSelections", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__["flattenSelections"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDirectiveNames", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__["getDirectiveNames"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasDirectives", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__["hasDirectives"]; });

/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fragments */ "./node_modules/apollo-utilities/lib/fragments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFragmentQueryDocument", function() { return _fragments__WEBPACK_IMPORTED_MODULE_1__["getFragmentQueryDocument"]; });

/* harmony import */ var _getFromAST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getFromAST */ "./node_modules/apollo-utilities/lib/getFromAST.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMutationDefinition", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getMutationDefinition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkDocument", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["checkDocument"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOperationDefinition", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getOperationDefinition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOperationDefinitionOrDie", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getOperationDefinitionOrDie"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOperationName", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getOperationName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFragmentDefinitions", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getFragmentDefinitions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getQueryDefinition", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getQueryDefinition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFragmentDefinition", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getFragmentDefinition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMainDefinition", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getMainDefinition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFragmentMap", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["createFragmentMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultValues", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["getDefaultValues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variablesInOperation", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__["variablesInOperation"]; });

/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform */ "./node_modules/apollo-utilities/lib/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeDirectivesFromDocument", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__["removeDirectivesFromDocument"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addTypenameToDocument", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__["addTypenameToDocument"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeConnectionDirectiveFromDocument", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__["removeConnectionDirectiveFromDocument"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDirectivesFromDocument", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__["getDirectivesFromDocument"]; });

/* harmony import */ var _storeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storeUtils */ "./node_modules/apollo-utilities/lib/storeUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isScalarValue", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["isScalarValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumberValue", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["isNumberValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueToObjectRepresentation", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["valueToObjectRepresentation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "storeKeyNameFromField", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["storeKeyNameFromField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStoreKeyName", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["getStoreKeyName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argumentsObjectFromField", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["argumentsObjectFromField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resultKeyNameFromField", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["resultKeyNameFromField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isField", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["isField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isInlineFragment", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["isInlineFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIdValue", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["isIdValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toIdValue", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["toIdValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isJsonValue", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["isJsonValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueFromNode", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__["valueFromNode"]; });

/* harmony import */ var _util_assign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/assign */ "./node_modules/apollo-utilities/lib/util/assign.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return _util_assign__WEBPACK_IMPORTED_MODULE_5__["assign"]; });

/* harmony import */ var _util_cloneDeep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/cloneDeep */ "./node_modules/apollo-utilities/lib/util/cloneDeep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneDeep", function() { return _util_cloneDeep__WEBPACK_IMPORTED_MODULE_6__["cloneDeep"]; });

/* harmony import */ var _util_environment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/environment */ "./node_modules/apollo-utilities/lib/util/environment.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEnv", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__["getEnv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEnv", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__["isEnv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isProduction", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__["isProduction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDevelopment", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__["isDevelopment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTest", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__["isTest"]; });

/* harmony import */ var _util_errorHandling__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/errorHandling */ "./node_modules/apollo-utilities/lib/util/errorHandling.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tryFunctionOrLogError", function() { return _util_errorHandling__WEBPACK_IMPORTED_MODULE_8__["tryFunctionOrLogError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "graphQLResultHasError", function() { return _util_errorHandling__WEBPACK_IMPORTED_MODULE_8__["graphQLResultHasError"]; });

/* harmony import */ var _util_isEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util/isEqual */ "./node_modules/apollo-utilities/lib/util/isEqual.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return _util_isEqual__WEBPACK_IMPORTED_MODULE_9__["isEqual"]; });

/* harmony import */ var _util_maybeDeepFreeze__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/maybeDeepFreeze */ "./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maybeDeepFreeze", function() { return _util_maybeDeepFreeze__WEBPACK_IMPORTED_MODULE_10__["maybeDeepFreeze"]; });

/* harmony import */ var _util_warnOnce__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./util/warnOnce */ "./node_modules/apollo-utilities/lib/util/warnOnce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "warnOnceInDevelopment", function() { return _util_warnOnce__WEBPACK_IMPORTED_MODULE_11__["warnOnceInDevelopment"]; });

/* harmony import */ var _util_stripSymbols__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util/stripSymbols */ "./node_modules/apollo-utilities/lib/util/stripSymbols.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stripSymbols", function() { return _util_stripSymbols__WEBPACK_IMPORTED_MODULE_12__["stripSymbols"]; });














//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/storeUtils.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/storeUtils.js ***!
  \*********************************************************/
/*! exports provided: isScalarValue, isNumberValue, valueToObjectRepresentation, storeKeyNameFromField, getStoreKeyName, argumentsObjectFromField, resultKeyNameFromField, isField, isInlineFragment, isIdValue, toIdValue, isJsonValue, valueFromNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScalarValue", function() { return isScalarValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberValue", function() { return isNumberValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueToObjectRepresentation", function() { return valueToObjectRepresentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "storeKeyNameFromField", function() { return storeKeyNameFromField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStoreKeyName", function() { return getStoreKeyName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argumentsObjectFromField", function() { return argumentsObjectFromField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resultKeyNameFromField", function() { return resultKeyNameFromField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isField", function() { return isField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInlineFragment", function() { return isInlineFragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdValue", function() { return isIdValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toIdValue", function() { return toIdValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isJsonValue", function() { return isJsonValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueFromNode", function() { return valueFromNode; });
/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");
/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function isScalarValue(value) {
    return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;
}
function isNumberValue(value) {
    return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;
}
function isStringValue(value) {
    return value.kind === 'StringValue';
}
function isBooleanValue(value) {
    return value.kind === 'BooleanValue';
}
function isIntValue(value) {
    return value.kind === 'IntValue';
}
function isFloatValue(value) {
    return value.kind === 'FloatValue';
}
function isVariable(value) {
    return value.kind === 'Variable';
}
function isObjectValue(value) {
    return value.kind === 'ObjectValue';
}
function isListValue(value) {
    return value.kind === 'ListValue';
}
function isEnumValue(value) {
    return value.kind === 'EnumValue';
}
function isNullValue(value) {
    return value.kind === 'NullValue';
}
function valueToObjectRepresentation(argObj, name, value, variables) {
    if (isIntValue(value) || isFloatValue(value)) {
        argObj[name.value] = Number(value.value);
    }
    else if (isBooleanValue(value) || isStringValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isObjectValue(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function (obj) {
            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
    }
    else if (isVariable(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
    }
    else if (isListValue(value)) {
        argObj[name.value] = value.values.map(function (listValue) {
            var nestedArgArrayObj = {};
            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
            return nestedArgArrayObj[name.value];
        });
    }
    else if (isEnumValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isNullValue(value)) {
        argObj[name.value] = null;
    }
    else {
        throw new Error("The inline argument \"" + name.value + "\" of kind \"" + value.kind + "\"" +
            'is not supported. Use variables instead of inline arguments to ' +
            'overcome this limitation.');
    }
}
function storeKeyNameFromField(field, variables) {
    var directivesObj = null;
    if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function (directive) {
            directivesObj[directive.name.value] = {};
            if (directive.arguments) {
                directive.arguments.forEach(function (_a) {
                    var name = _a.name, value = _a.value;
                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                });
            }
        });
    }
    var argObj = null;
    if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj, name, value, variables);
        });
    }
    return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
    'connection',
    'include',
    'skip',
    'client',
    'rest',
    'export',
];
function getStoreKeyName(fieldName, args, directives) {
    if (directives &&
        directives['connection'] &&
        directives['connection']['key']) {
        if (directives['connection']['filter'] &&
            directives['connection']['filter'].length > 0) {
            var filterKeys = directives['connection']['filter']
                ? directives['connection']['filter']
                : [];
            filterKeys.sort();
            var queryArgs_1 = args;
            var filteredArgs_1 = {};
            filterKeys.forEach(function (key) {
                filteredArgs_1[key] = queryArgs_1[key];
            });
            return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
        }
        else {
            return directives['connection']['key'];
        }
    }
    var completeFieldName = fieldName;
    if (args) {
        var stringifiedArgs = fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(args);
        completeFieldName += "(" + stringifiedArgs + ")";
    }
    if (directives) {
        Object.keys(directives).forEach(function (key) {
            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                return;
            if (directives[key] && Object.keys(directives[key]).length) {
                completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
            }
            else {
                completeFieldName += "@" + key;
            }
        });
    }
    return completeFieldName;
}
function argumentsObjectFromField(field, variables) {
    if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj_1, name, value, variables);
        });
        return argObj_1;
    }
    return null;
}
function resultKeyNameFromField(field) {
    return field.alias ? field.alias.value : field.name.value;
}
function isField(selection) {
    return selection.kind === 'Field';
}
function isInlineFragment(selection) {
    return selection.kind === 'InlineFragment';
}
function isIdValue(idObject) {
    return idObject && idObject.type === 'id';
}
function toIdValue(idConfig, generated) {
    if (generated === void 0) { generated = false; }
    return __assign({ type: 'id', generated: generated }, (typeof idConfig === 'string'
        ? { id: idConfig, typename: undefined }
        : idConfig));
}
function isJsonValue(jsonObject) {
    return (jsonObject != null &&
        typeof jsonObject === 'object' &&
        jsonObject.type === 'json');
}
function defaultValueFromVariable(node) {
    throw new Error("Variable nodes are not supported by valueFromNode");
}
function valueFromNode(node, onVariable) {
    if (onVariable === void 0) { onVariable = defaultValueFromVariable; }
    switch (node.kind) {
        case 'Variable':
            return onVariable(node);
        case 'NullValue':
            return null;
        case 'IntValue':
            return parseInt(node.value, 10);
        case 'FloatValue':
            return parseFloat(node.value);
        case 'ListValue':
            return node.values.map(function (v) { return valueFromNode(v, onVariable); });
        case 'ObjectValue': {
            var value = {};
            for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                value[field.name.value] = valueFromNode(field.value, onVariable);
            }
            return value;
        }
        default:
            return node.value;
    }
}
//# sourceMappingURL=storeUtils.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/transform.js":
/*!********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/transform.js ***!
  \********************************************************/
/*! exports provided: removeDirectivesFromDocument, addTypenameToDocument, removeConnectionDirectiveFromDocument, getDirectivesFromDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeDirectivesFromDocument", function() { return removeDirectivesFromDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTypenameToDocument", function() { return addTypenameToDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeConnectionDirectiveFromDocument", function() { return removeConnectionDirectiveFromDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirectivesFromDocument", function() { return getDirectivesFromDocument; });
/* harmony import */ var _util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/cloneDeep */ "./node_modules/apollo-utilities/lib/util/cloneDeep.js");
/* harmony import */ var _getFromAST__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getFromAST */ "./node_modules/apollo-utilities/lib/getFromAST.js");


var TYPENAME_FIELD = {
    kind: 'Field',
    name: {
        kind: 'Name',
        value: '__typename',
    },
};
function isNotEmpty(op, fragments) {
    return (op.selectionSet.selections.filter(function (selectionSet) {
        return !(selectionSet &&
            selectionSet.kind === 'FragmentSpread' &&
            !isNotEmpty(fragments[selectionSet.name.value], fragments));
    }).length > 0);
}
function getDirectiveMatcher(directives) {
    return function directiveMatcher(directive) {
        return directives.some(function (dir) {
            if (dir.name && dir.name === directive.name.value)
                return true;
            if (dir.test && dir.test(directive))
                return true;
            return false;
        });
    };
}
function addTypenameToSelectionSet(selectionSet, isRoot) {
    if (isRoot === void 0) { isRoot = false; }
    if (selectionSet.selections) {
        if (!isRoot) {
            var alreadyHasThisField = selectionSet.selections.some(function (selection) {
                return (selection.kind === 'Field' &&
                    selection.name.value === '__typename');
            });
            if (!alreadyHasThisField) {
                selectionSet.selections.push(TYPENAME_FIELD);
            }
        }
        selectionSet.selections.forEach(function (selection) {
            if (selection.kind === 'Field') {
                if (selection.name.value.lastIndexOf('__', 0) !== 0 &&
                    selection.selectionSet) {
                    addTypenameToSelectionSet(selection.selectionSet);
                }
            }
            else if (selection.kind === 'InlineFragment') {
                if (selection.selectionSet) {
                    addTypenameToSelectionSet(selection.selectionSet);
                }
            }
        });
    }
}
function removeDirectivesFromSelectionSet(directives, selectionSet) {
    if (!selectionSet.selections)
        return selectionSet;
    var agressiveRemove = directives.some(function (dir) { return dir.remove; });
    selectionSet.selections = selectionSet.selections
        .map(function (selection) {
        if (selection.kind !== 'Field' ||
            !selection ||
            !selection.directives)
            return selection;
        var directiveMatcher = getDirectiveMatcher(directives);
        var remove;
        selection.directives = selection.directives.filter(function (directive) {
            var shouldKeep = !directiveMatcher(directive);
            if (!remove && !shouldKeep && agressiveRemove)
                remove = true;
            return shouldKeep;
        });
        return remove ? null : selection;
    })
        .filter(function (x) { return !!x; });
    selectionSet.selections.forEach(function (selection) {
        if ((selection.kind === 'Field' || selection.kind === 'InlineFragment') &&
            selection.selectionSet) {
            removeDirectivesFromSelectionSet(directives, selection.selectionSet);
        }
    });
    return selectionSet;
}
function removeDirectivesFromDocument(directives, doc) {
    var docClone = Object(_util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__["cloneDeep"])(doc);
    docClone.definitions.forEach(function (definition) {
        removeDirectivesFromSelectionSet(directives, definition.selectionSet);
    });
    var operation = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["getOperationDefinitionOrDie"])(docClone);
    var fragments = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["createFragmentMap"])(Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["getFragmentDefinitions"])(docClone));
    return isNotEmpty(operation, fragments) ? docClone : null;
}
function addTypenameToDocument(doc) {
    Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["checkDocument"])(doc);
    var docClone = Object(_util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__["cloneDeep"])(doc);
    docClone.definitions.forEach(function (definition) {
        var isRoot = definition.kind === 'OperationDefinition';
        addTypenameToSelectionSet(definition.selectionSet, isRoot);
    });
    return docClone;
}
var connectionRemoveConfig = {
    test: function (directive) {
        var willRemove = directive.name.value === 'connection';
        if (willRemove) {
            if (!directive.arguments ||
                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {
                console.warn('Removing an @connection directive even though it does not have a key. ' +
                    'You may want to use the key parameter to specify a store key.');
            }
        }
        return willRemove;
    },
};
function removeConnectionDirectiveFromDocument(doc) {
    Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["checkDocument"])(doc);
    return removeDirectivesFromDocument([connectionRemoveConfig], doc);
}
function hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {
    if (nestedCheck === void 0) { nestedCheck = true; }
    if (!(selectionSet && selectionSet.selections)) {
        return false;
    }
    var matchedSelections = selectionSet.selections.filter(function (selection) {
        return hasDirectivesInSelection(directives, selection, nestedCheck);
    });
    return matchedSelections.length > 0;
}
function hasDirectivesInSelection(directives, selection, nestedCheck) {
    if (nestedCheck === void 0) { nestedCheck = true; }
    if (selection.kind !== 'Field' || !selection) {
        return true;
    }
    if (!selection.directives) {
        return false;
    }
    var directiveMatcher = getDirectiveMatcher(directives);
    var matchedDirectives = selection.directives.filter(directiveMatcher);
    return (matchedDirectives.length > 0 ||
        (nestedCheck &&
            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));
}
function getDirectivesFromSelectionSet(directives, selectionSet) {
    selectionSet.selections = selectionSet.selections
        .filter(function (selection) {
        return hasDirectivesInSelection(directives, selection, true);
    })
        .map(function (selection) {
        if (hasDirectivesInSelection(directives, selection, false)) {
            return selection;
        }
        if ((selection.kind === 'Field' || selection.kind === 'InlineFragment') &&
            selection.selectionSet) {
            selection.selectionSet = getDirectivesFromSelectionSet(directives, selection.selectionSet);
        }
        return selection;
    });
    return selectionSet;
}
function getDirectivesFromDocument(directives, doc, includeAllFragments) {
    if (includeAllFragments === void 0) { includeAllFragments = false; }
    Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["checkDocument"])(doc);
    var docClone = Object(_util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__["cloneDeep"])(doc);
    docClone.definitions = docClone.definitions.map(function (definition) {
        if ((definition.kind === 'OperationDefinition' ||
            (definition.kind === 'FragmentDefinition' && !includeAllFragments)) &&
            definition.selectionSet) {
            definition.selectionSet = getDirectivesFromSelectionSet(directives, definition.selectionSet);
        }
        return definition;
    });
    var operation = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["getOperationDefinitionOrDie"])(docClone);
    var fragments = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["createFragmentMap"])(Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__["getFragmentDefinitions"])(docClone));
    return isNotEmpty(operation, fragments) ? docClone : null;
}
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/assign.js ***!
  \**********************************************************/
/*! exports provided: assign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        if (typeof source === 'undefined' || source === null) {
            return;
        }
        Object.keys(source).forEach(function (key) {
            target[key] = source[key];
        });
    });
    return target;
}
//# sourceMappingURL=assign.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/cloneDeep.js":
/*!*************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/cloneDeep.js ***!
  \*************************************************************/
/*! exports provided: cloneDeep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneDeep", function() { return cloneDeep; });
/* harmony import */ var fclone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fclone */ "./node_modules/fclone/dist/fclone.js");
/* harmony import */ var fclone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fclone__WEBPACK_IMPORTED_MODULE_0__);

function cloneDeep(value) {
    return fclone__WEBPACK_IMPORTED_MODULE_0___default()(value);
}
//# sourceMappingURL=cloneDeep.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/environment.js":
/*!***************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/environment.js ***!
  \***************************************************************/
/*! exports provided: getEnv, isEnv, isProduction, isDevelopment, isTest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnv", function() { return getEnv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEnv", function() { return isEnv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isProduction", function() { return isProduction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDevelopment", function() { return isDevelopment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTest", function() { return isTest; });
function getEnv() {
    if (typeof process !== 'undefined' && "development") {
        return "development";
    }
    return 'development';
}
function isEnv(env) {
    return getEnv() === env;
}
function isProduction() {
    return isEnv('production') === true;
}
function isDevelopment() {
    return isEnv('development') === true;
}
function isTest() {
    return isEnv('test') === true;
}
//# sourceMappingURL=environment.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/errorHandling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/errorHandling.js ***!
  \*****************************************************************/
/*! exports provided: tryFunctionOrLogError, graphQLResultHasError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tryFunctionOrLogError", function() { return tryFunctionOrLogError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graphQLResultHasError", function() { return graphQLResultHasError; });
function tryFunctionOrLogError(f) {
    try {
        return f();
    }
    catch (e) {
        if (console.error) {
            console.error(e);
        }
    }
}
function graphQLResultHasError(result) {
    return result.errors && result.errors.length;
}
//# sourceMappingURL=errorHandling.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/isEqual.js":
/*!***********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/isEqual.js ***!
  \***********************************************************/
/*! exports provided: isEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });
function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (a != null &&
        typeof a === 'object' &&
        b != null &&
        typeof b === 'object') {
        for (var key in a) {
            if (Object.prototype.hasOwnProperty.call(a, key)) {
                if (!Object.prototype.hasOwnProperty.call(b, key)) {
                    return false;
                }
                if (!isEqual(a[key], b[key])) {
                    return false;
                }
            }
        }
        for (var key in b) {
            if (!Object.prototype.hasOwnProperty.call(a, key)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
//# sourceMappingURL=isEqual.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js":
/*!*******************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js ***!
  \*******************************************************************/
/*! exports provided: maybeDeepFreeze */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maybeDeepFreeze", function() { return maybeDeepFreeze; });
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment */ "./node_modules/apollo-utilities/lib/util/environment.js");

function deepFreeze(o) {
    Object.freeze(o);
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
}
function maybeDeepFreeze(obj) {
    if (Object(_environment__WEBPACK_IMPORTED_MODULE_0__["isDevelopment"])() || Object(_environment__WEBPACK_IMPORTED_MODULE_0__["isTest"])()) {
        var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';
        if (!symbolIsPolyfilled) {
            return deepFreeze(obj);
        }
    }
    return obj;
}
//# sourceMappingURL=maybeDeepFreeze.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/stripSymbols.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/stripSymbols.js ***!
  \****************************************************************/
/*! exports provided: stripSymbols */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripSymbols", function() { return stripSymbols; });
function stripSymbols(data) {
    return JSON.parse(JSON.stringify(data));
}
//# sourceMappingURL=stripSymbols.js.map

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/warnOnce.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/warnOnce.js ***!
  \************************************************************/
/*! exports provided: warnOnceInDevelopment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warnOnceInDevelopment", function() { return warnOnceInDevelopment; });
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment */ "./node_modules/apollo-utilities/lib/util/environment.js");

var haveWarned = Object.create({});
function warnOnceInDevelopment(msg, type) {
    if (type === void 0) { type = 'warn'; }
    if (Object(_environment__WEBPACK_IMPORTED_MODULE_0__["isProduction"])()) {
        return;
    }
    if (!haveWarned[msg]) {
        if (!Object(_environment__WEBPACK_IMPORTED_MODULE_0__["isTest"])()) {
            haveWarned[msg] = true;
        }
        switch (type) {
            case 'error':
                console.error(msg);
                break;
            default:
                console.warn(msg);
        }
    }
}
//# sourceMappingURL=warnOnce.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(/*! ./../helpers/btoa */ "./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("development" !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/buffer/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


/***/ }),

/***/ "./node_modules/fclone/dist/fclone.js":
/*!********************************************!*\
  !*** ./node_modules/fclone/dist/fclone.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
  'use strict';

// see if it looks and smells like an iterable object, and do accept length === 0

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function isArrayLike(item) {
  if (Array.isArray(item)) return true;

  var len = item && item.length;
  return typeof len === 'number' && (len === 0 || len - 1 in item) && typeof item.indexOf === 'function';
}

function fclone(obj, refs) {
  if (!obj || "object" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;

  if (obj instanceof Date) {
    return new Date(obj);
  }

  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {
    return new Buffer(obj);
  }

  // typed array Int32Array etc.
  if (typeof obj.subarray === 'function' && /[A-Z][A-Za-z\d]+Array/.test(Object.prototype.toString.call(obj))) {
    return obj.subarray(0);
  }

  if (!refs) {
    refs = [];
  }

  if (isArrayLike(obj)) {
    refs[refs.length] = obj;
    var _l = obj.length;
    var i = -1;
    var _copy = [];

    while (_l > ++i) {
      _copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);
    }

    refs.length && refs.length--;
    return _copy;
  }

  refs[refs.length] = obj;
  var copy = {};

  if (obj instanceof Error) {
    copy.name = obj.name;
    copy.message = obj.message;
    copy.stack = obj.stack;
  }

  var keys = Object.keys(obj);
  var l = keys.length;

  while (l--) {
    var k = keys[l];
    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);
  }

  refs.length && refs.length--;
  return copy;
}

fclone.default = fclone;
  return fclone
}));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/graphql/jsutils/inspect.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inspect;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Used to print values in error messages.
 */
function inspect(value) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value) {
        if (typeof value.inspect === 'function') {
          return value.inspect();
        } else if (Array.isArray(value)) {
          return '[' + value.map(inspect).join(', ') + ']';
        }

        var properties = Object.keys(value).map(function (k) {
          return "".concat(k, ": ").concat(inspect(value[k]));
        }).join(', ');
        return properties ? '{ ' + properties + ' }' : '{}';
      }

      return String(value);

    default:
      return String(value);
  }
}

/***/ }),

/***/ "./node_modules/graphql/language/printer.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/language/printer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.print = print;

var _visitor = __webpack_require__(/*! ./visitor */ "./node_modules/graphql/language/visitor.js");

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */
function print(ast) {
  return (0, _visitor.visit)(ast, {
    leave: printDocASTReducer
  });
}

var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: function SchemaDefinition(_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (args.every(function (arg) {
      return arg.indexOf('\n') === -1;
    }) ? wrap('(', join(args, ', '), ')') : wrap('(\n', indent(join(args, '\n')), '\n)')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        locations = _ref31.locations;
    return 'directive @' + name + (args.every(function (arg) {
      return arg.indexOf('\n') === -1;
    }) ? wrap('(', join(args, ', '), ')') : wrap('(\n', indent(join(args, '\n')), '\n)')) + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter(function (x) {
    return x;
  }).join(separator || '') : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */


function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || '') : '';
}

function indent(maybeString) {
  return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 */


function printBlockString(value, isDescription) {
  var escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === ' ' || value[0] === '\t') && value.indexOf('\n') === -1 ? "\"\"\"".concat(escaped.replace(/"$/, '"\n'), "\"\"\"") : "\"\"\"\n".concat(isDescription ? escaped : indent(escaped), "\n\"\"\"");
}

/***/ }),

/***/ "./node_modules/graphql/language/visitor.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/language/visitor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.visitInParallel = visitInParallel;
exports.visitWithTypeInfo = visitWithTypeInfo;
exports.getVisitFn = getVisitFn;
exports.BREAK = exports.QueryDocumentKeys = void 0;

var _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ "./node_modules/graphql/jsutils/inspect.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */
var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
exports.QueryDocumentKeys = QueryDocumentKeys;
var BREAK = {};
/**
 * visit() will walk through an AST using a depth first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

exports.BREAK = BREAK;

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

  /* eslint-disable no-undef-init */
  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var k in node) {
            if (node.hasOwnProperty(k)) {
              clone[k] = node[k];
            }
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error('Invalid AST Node: ' + (0, _inspect.default)(node));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : visitorKeys[node.kind] || [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}

function isNode(maybeNode) {
  return Boolean(maybeNode && typeof maybeNode.kind === 'string');
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */


function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          false);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          true);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
/**
 * Creates a new visitor instance which maintains a provided TypeInfo instance
 * along with visiting visitor.
 */


function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter: function enter(node) {
      typeInfo.enter(node);
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      false);

      if (fn) {
        var result = fn.apply(visitor, arguments);

        if (result !== undefined) {
          typeInfo.leave(node);

          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }

        return result;
      }
    },
    leave: function leave(node) {
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      true);
      var result;

      if (fn) {
        result = fn.apply(visitor, arguments);
      }

      typeInfo.leave(node);
      return result;
    }
  };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */


function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/immutable-tuple/dist/tuple.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/immutable-tuple/dist/tuple.mjs ***!
  \*****************************************************/
/*! exports provided: default, tuple, lookup */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuple", function() { return tuple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookup", function() { return lookup; });
// A map data structure that holds object keys weakly, yet can also hold
// non-object keys, unlike the native `WeakMap`.
var UniversalWeakMap = function UniversalWeakMap() {
  // Since a `WeakMap` cannot hold primitive values as keys, we need a
  // backup `Map` instance to hold primitive keys. Both `this._weakMap`
  // and `this._strongMap` are lazily initialized.
  this._weakMap = null;
  this._strongMap = null;
  this.data = null;
};

// Since `get` and `set` are the only methods used, that's all I've
// implemented here.

UniversalWeakMap.prototype.get = function get (key) {
  var map = this._getMap(key, false);
  if (map) {
    return map.get(key);
  }
};

UniversalWeakMap.prototype.set = function set (key, value) {
  this._getMap(key, true).set(key, value);
  // An actual `Map` or `WeakMap` would return `this` here, but
  // returning the `value` is more convenient for the `tuple`
  // implementation.
  return value;
};

UniversalWeakMap.prototype._getMap = function _getMap (key, canCreate) {
  if (! canCreate) {
    return isObjRef(key) ? this._weakMap : this._strongMap;
  }
  if (isObjRef(key)) {
    return this._weakMap || (this._weakMap = new WeakMap);
  }
  return this._strongMap || (this._strongMap = new Map);
};

function isObjRef(value) {
  switch (typeof value) {
  case "object":
    if (value === null) {
      return false;
    }
  case "function":
    return true;
  default:
    return false;
  }
}

// Although `Symbol` is widely supported these days, we can safely fall
// back to using a non-enumerable string property without violating any
// assumptions elsewhere in the implementation.
var useSymbol = typeof Symbol === "function";

// Used to mark `tuple.prototype` so that all objects that inherit from
// any `tuple.prototype` object (there could be more than one) will test
// positive according to `tuple.isTuple`.
var brand = useSymbol
  ? Symbol.for("immutable-tuple")
  : "@@__IMMUTABLE_TUPLE__@@";

// Used to save a reference to the globally shared `UniversalWeakMap` that
// stores all known `tuple` objects.
var globalKey = useSymbol
  ? Symbol.for("immutable-tuple-root")
  : "@@__IMMUTABLE_TUPLE_ROOT__@@";

// Convenient helper for defining hidden immutable properties.
function def(obj, name, value, enumerable) {
  Object.defineProperty(obj, name, {
    value: value,
    enumerable: !! enumerable,
    writable: false,
    configurable: false
  });
  return value;
}

var freeze = Object.freeze || function (obj) {
  return obj;
};

// The `mustConvertThisToArray` value is true when the corresponding
// `Array` method does not attempt to modify `this`, which means we can
// pass a `tuple` object as `this` without first converting it to an
// `Array`.
function forEachArrayMethod(fn) {
  function call(name, mustConvertThisToArray) {
    var desc = Object.getOwnPropertyDescriptor(Array.prototype, name);
    fn(name, desc, !! mustConvertThisToArray);
  }

  call("every");
  call("filter");
  call("find");
  call("findIndex");
  call("forEach");
  call("includes");
  call("indexOf");
  call("join");
  call("lastIndexOf");
  call("map");
  call("reduce");
  call("reduceRight");
  call("slice");
  call("some");
  call("toLocaleString");
  call("toString");

  // The `reverse` and `sort` methods are usually destructive, but for
  // `tuple` objects they return a new `tuple` object that has been
  // appropriately reversed/sorted.
  call("reverse", true);
  call("sort", true);

  // Make `[...someTuple]` work.
  call(useSymbol && Symbol.iterator || "@@iterator");
}

// See [`universal-weak-map.js`](universal-weak-map.html).
// See [`util.js`](util.html).
// If this package is installed multiple times, there could be mutiple
// implementations of the `tuple` function with distinct `tuple.prototype`
// objects, but the shared pool of `tuple` objects must be the same across
// all implementations. While it would be ideal to use the `global`
// object, there's no reliable way to get the global object across all JS
// environments without using the `Function` constructor, so instead we
// use the global `Array` constructor as a shared namespace.
var root = Array[globalKey] || def(Array, globalKey, new UniversalWeakMap, false);

function lookup() {
  var arguments$1 = arguments;

  var node = root;

  // Because we are building a tree of *weak* maps, the tree will not
  // prevent objects in tuples from being garbage collected, since the
  // tree itself will be pruned over time when the corresponding `tuple`
  // objects become unreachable. In addition to internalization, this
  // property is a key advantage of the `immutable-tuple` package.
  var argc = arguments.length;
  for (var i = 0; i < argc; ++i) {
    var item = arguments$1[i];
    node = node.get(item) || node.set(item, new UniversalWeakMap);
  }

  // Return node.data rather than node itself to prevent tampering with
  // the UniversalWeakMap tree.
  return node.data || (node.data = Object.create(null));
}

// See [`lookup.js`](lookup.html).
// See [`util.js`](util.html).
// When called with any number of arguments, this function returns an
// object that inherits from `tuple.prototype` and is guaranteed to be
// `===` any other `tuple` object that has exactly the same items. In
// computer science jargon, `tuple` instances are "internalized" or just
// "interned," which allows for constant-time equality checking, and makes
// it possible for tuple objects to be used as `Map` or `WeakMap` keys, or
// stored in a `Set`.
function tuple() {
  var arguments$1 = arguments;

  var node = lookup.apply(null, arguments);

  if (node.tuple) {
    return node.tuple;
  }

  var t = Object.create(tuple.prototype);

  // Define immutable items with numeric indexes, and permanently fix the
  // `.length` property.
  var argc = arguments.length;
  for (var i = 0; i < argc; ++i) {
    t[i] = arguments$1[i];
  }

  def(t, "length", argc, false);

  // Remember this new `tuple` object so that we can return the same object
  // earlier next time.
  return freeze(node.tuple = t);
}

// Since the `immutable-tuple` package could be installed multiple times
// in an application, there is no guarantee that the `tuple` constructor
// or `tuple.prototype` will be unique, so `value instanceof tuple` is
// unreliable. Instead, to test if a value is a tuple, you should use
// `tuple.isTuple(value)`.
def(tuple.prototype, brand, true, false);
function isTuple(that) {
  return !! (that && that[brand] === true);
}

tuple.isTuple = isTuple;

function toArray(tuple) {
  var array = [];
  var i = tuple.length;
  while (i--) { array[i] = tuple[i]; }
  return array;
}

// Copy all generic non-destructive Array methods to `tuple.prototype`.
// This works because (for example) `Array.prototype.slice` can be invoked
// against any `Array`-like object.
forEachArrayMethod(function (name, desc, mustConvertThisToArray) {
  var method = desc && desc.value;
  if (typeof method === "function") {
    desc.value = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var result = method.apply(
        mustConvertThisToArray ? toArray(this) : this,
        args
      );
      // Of course, `tuple.prototype.slice` should return a `tuple` object,
      // not a new `Array`.
      return Array.isArray(result) ? tuple.apply(void 0, result) : result;
    };
    Object.defineProperty(tuple.prototype, name, desc);
  }
});

// Like `Array.prototype.concat`, except for the extra effort required to
// convert any tuple arguments to arrays, so that
// ```
// tuple(1).concat(tuple(2), 3) === tuple(1, 2, 3)
// ```
var ref = Array.prototype;
var concat = ref.concat;
tuple.prototype.concat = function () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return tuple.apply(void 0, concat.apply(toArray(this), args.map(
    function (item) { return isTuple(item) ? toArray(item) : item; }
  )));
};

/* harmony default export */ __webpack_exports__["default"] = (tuple);



/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/optimism/lib/cache.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Cache(options) {
  this.map = new Map;
  this.newest = null;
  this.oldest = null;
  this.max = options && options.max;
  this.dispose = options && options.dispose;
}

exports.Cache = Cache;

var Cp = Cache.prototype;

Cp.has = function (key) {
  return this.map.has(key);
};

Cp.get = function (key) {
  var entry = getEntry(this, key);
  return entry && entry.value;
};

function getEntry(cache, key) {
  var entry = cache.map.get(key);
  if (entry &&
      entry !== cache.newest) {
    var older = entry.older;
    var newer = entry.newer;

    if (newer) {
      newer.older = older;
    }

    if (older) {
      older.newer = newer;
    }

    entry.older = cache.newest;
    entry.older.newer = entry;

    entry.newer = null;
    cache.newest = entry;

    if (entry === cache.oldest) {
      cache.oldest = newer;
    }
  }

  return entry;
}

Cp.set = function (key, value) {
  var entry = getEntry(this, key);
  if (entry) {
    return entry.value = value;
  }

  entry = {
    key: key,
    value: value,
    newer: null,
    older: this.newest
  };

  if (this.newest) {
    this.newest.newer = entry;
  }

  this.newest = entry;
  this.oldest = this.oldest || entry;

  this.map.set(key, entry);

  if (typeof this.max === "number") {
    while (this.oldest &&
           this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  }

  return entry.value;
};

Cp.delete = function (key) {
  var entry = this.map.get(key);
  if (entry) {
    if (entry === this.newest) {
      this.newest = entry.older;
    }

    if (entry === this.oldest) {
      this.oldest = entry.newer;
    }

    if (entry.newer) {
      entry.newer.older = entry.older;
    }

    if (entry.older) {
      entry.older.newer = entry.newer;
    }

    this.map.delete(key);

    if (typeof this.dispose === "function") {
      this.dispose(key, entry.value);
    }

    return true;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/optimism/lib/entry.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/entry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getLocal = __webpack_require__(/*! ./local.js */ "./node_modules/optimism/lib/local.js").get;
var UNKNOWN_VALUE = Object.create(null);
var emptySetPool = [];
var entryPool = [];

// Don't let the emptySetPool or entryPool grow larger than this size,
// since unconstrained pool growth could lead to memory leaks.
exports.POOL_TARGET_SIZE = 100;

// Since this package might be used browsers, we should avoid using the
// Node built-in assert module.
function assert(condition, optionalMessage) {
  if (! condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}

function Entry(fn, key, args) {
  this.parents = new Set;
  this.childValues = new Map;

  // When this Entry has children that are dirty, this property becomes
  // a Set containing other Entry objects, borrowed from emptySetPool.
  // When the set becomes empty, it gets recycled back to emptySetPool.
  this.dirtyChildren = null;

  reset(this, fn, key, args);

  ++Entry.count;
}

Entry.count = 0;

function reset(entry, fn, key, args) {
  entry.fn = fn;
  entry.key = key;
  entry.args = args;
  entry.value = UNKNOWN_VALUE;
  entry.dirty = true;
  entry.subscribe = null;
  entry.unsubscribe = null;
  entry.recomputing = false;
  // Optional callback that will be invoked when entry.parents becomes
  // empty. The Entry object is given as the first parameter. If the
  // callback returns true, then this entry can be removed from the graph
  // and safely recycled into the entryPool.
  entry.reportOrphan = null;
}

Entry.acquire = function (fn, key, args) {
  var entry = entryPool.pop();
  if (entry) {
    reset(entry, fn, key, args);
    return entry;
  }
  return new Entry(fn, key, args);
};

function release(entry) {
  assert(entry.parents.size === 0);
  assert(entry.childValues.size === 0);
  assert(entry.dirtyChildren === null);
  if (entryPool.length < exports.POOL_TARGET_SIZE) {
    entryPool.push(entry);
  }
}

exports.Entry = Entry;

var Ep = Entry.prototype;

// The public API of Entry objects consists of the Entry constructor,
// along with the recompute, setDirty, and dispose methods.

Ep.recompute = function recompute() {
  if (! rememberParent(this) &&
      maybeReportOrphan(this)) {
    // The recipient of the entry.reportOrphan callback decided to dispose
    // of this orphan entry by calling entry.dispos(), which recycles it
    // into the entryPool, so we don't need to (and should not) proceed
    // with the recomputation.
    return;
  }

  return recomputeIfDirty(this);
};

// If the given entry has a reportOrphan method, and no remaining parents,
// call entry.reportOrphan and return true iff it returns true. The
// reportOrphan function should return true to indicate entry.dispose()
// has been called, and the entry has been removed from any other caches
// (see index.js for the only current example).
function maybeReportOrphan(entry) {
  var report = entry.reportOrphan;
  return typeof report === "function" &&
    entry.parents.size === 0 &&
    report(entry) === true;
}

Ep.setDirty = function setDirty() {
  if (this.dirty) return;
  this.dirty = true;
  this.value = UNKNOWN_VALUE;
  reportDirty(this);
  // We can go ahead and unsubscribe here, since any further dirty
  // notifications we receive will be redundant, and unsubscribing may
  // free up some resources, e.g. file watchers.
  unsubscribe(this);
};

Ep.dispose = function dispose() {
  var entry = this;
  forgetChildren(entry).forEach(maybeReportOrphan);
  unsubscribe(entry);

  // Because this entry has been kicked out of the cache (in index.js),
  // we've lost the ability to find out if/when this entry becomes dirty,
  // whether that happens through a subscription, because of a direct call
  // to entry.setDirty(), or because one of its children becomes dirty.
  // Because of this loss of future information, we have to assume the
  // worst (that this entry might have become dirty very soon), so we must
  // immediately mark this entry's parents as dirty. Normally we could
  // just call entry.setDirty() rather than calling parent.setDirty() for
  // each parent, but that would leave this entry in parent.childValues
  // and parent.dirtyChildren, which would prevent the child from being
  // truly forgotten.
  entry.parents.forEach(function (parent) {
    parent.setDirty();
    forgetChild(parent, entry);
  });

  // Since this entry has no parents and no children anymore, and the
  // caller of Entry#dispose has indicated that entry.value no longer
  // matters, we can safely recycle this Entry object for later use.
  release(entry);
};

function setClean(entry) {
  entry.dirty = false;

  if (mightBeDirty(entry)) {
    // This Entry may still have dirty children, in which case we can't
    // let our parents know we're clean just yet.
    return;
  }

  reportClean(entry);
}

function reportDirty(entry) {
  entry.parents.forEach(function (parent) {
    reportDirtyChild(parent, entry);
  });
}

function reportClean(entry) {
  entry.parents.forEach(function (parent) {
    reportCleanChild(parent, entry);
  });
}

function mightBeDirty(entry) {
  return entry.dirty ||
    (entry.dirtyChildren &&
     entry.dirtyChildren.size);
}

// Let a parent Entry know that one of its children may be dirty.
function reportDirtyChild(entry, child) {
  // Must have called rememberParent(child) before calling
  // reportDirtyChild(parent, child).
  assert(entry.childValues.has(child));
  assert(mightBeDirty(child));

  if (! entry.dirtyChildren) {
    entry.dirtyChildren = emptySetPool.pop() || new Set;

  } else if (entry.dirtyChildren.has(child)) {
    // If we already know this child is dirty, then we must have already
    // informed our own parents that we are dirty, so we can terminate
    // the recursion early.
    return;
  }

  entry.dirtyChildren.add(child);
  reportDirty(entry);
}

// Let a parent Entry know that one of its children is no longer dirty.
function reportCleanChild(entry, child) {
  var cv = entry.childValues;

  // Must have called rememberChild(child) before calling
  // reportCleanChild(parent, child).
  assert(cv.has(child));
  assert(! mightBeDirty(child));

  var childValue = cv.get(child);
  if (childValue === UNKNOWN_VALUE) {
    cv.set(child, child.value);
  } else if (childValue !== child.value) {
    entry.setDirty();
  }

  removeDirtyChild(entry, child);

  if (mightBeDirty(entry)) {
    return;
  }

  reportClean(entry);
}

function removeDirtyChild(entry, child) {
  var dc = entry.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < exports.POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      entry.dirtyChildren = null;
    }
  }
}

function rememberParent(entry) {
  var local = getLocal();
  var parent = local.currentParentEntry;
  if (parent) {
    entry.parents.add(parent);

    if (! parent.childValues.has(entry)) {
      parent.childValues.set(entry, UNKNOWN_VALUE);
    }

    if (mightBeDirty(entry)) {
      reportDirtyChild(parent, entry);
    } else {
      reportCleanChild(parent, entry);
    }

    return parent;
  }
}

// This is the most important method of the Entry API, because it
// determines whether the cached entry.value can be returned immediately,
// or must be recomputed. The overall performance of the caching system
// depends on the truth of the following observations: (1) this.dirty is
// usually false, (2) this.dirtyChildren is usually null/empty, and thus
// (3) this.value is usally returned very quickly, without recomputation.
function recomputeIfDirty(entry) {
  if (entry.dirty) {
    // If this Entry is explicitly dirty because someone called
    // entry.setDirty(), recompute.
    return reallyRecompute(entry);
  }

  if (mightBeDirty(entry)) {
    // Get fresh values for any dirty children, and if those values
    // disagree with this.childValues, mark this Entry explicitly dirty.
    entry.dirtyChildren.forEach(function (child) {
      assert(entry.childValues.has(child));
      try {
        recomputeIfDirty(child);
      } catch (e) {
        entry.setDirty();
      }
    });

    if (entry.dirty) {
      // If this Entry has become explicitly dirty after comparing the fresh
      // values of its dirty children against this.childValues, recompute.
      return reallyRecompute(entry);
    }
  }

  assert(entry.value !== UNKNOWN_VALUE);

  return entry.value;
}

function reallyRecompute(entry) {
  assert(! entry.recomputing, "already recomputing");
  entry.recomputing = true;

  // Since this recomputation is likely to re-remember some of this
  // entry's children, we forget our children here but do not call
  // maybeReportOrphan until after the recomputation finishes.
  var originalChildren = forgetChildren(entry);

  var local = getLocal();
  var parent = local.currentParentEntry;
  local.currentParentEntry = entry;

  var threw = true;
  try {
    entry.value = entry.fn.apply(null, entry.args);
    threw = false;

  } finally {
    entry.recomputing = false;

    assert(local.currentParentEntry === entry);
    local.currentParentEntry = parent;

    if (threw || ! subscribe(entry)) {
      // Mark this Entry dirty if entry.fn threw or we failed to
      // resubscribe. This is important because, if we have a subscribe
      // function and it failed, then we're going to miss important
      // notifications about the potential dirtiness of entry.value.
      entry.setDirty();
    } else {
      // If we successfully recomputed entry.value and did not fail to
      // (re)subscribe, then this Entry is no longer explicitly dirty.
      setClean(entry);
    }
  }

  // Now that we've had a chance to re-remember any children that were
  // involved in the recomputation, we can safely report any orphan
  // children that remain.
  originalChildren.forEach(maybeReportOrphan);

  return entry.value;
}

var reusableEmptyArray = [];

// Removes all children from this entry and returns an array of the
// removed children.
function forgetChildren(entry) {
  var children = reusableEmptyArray;

  if (entry.childValues.size > 0) {
    children = [];
    entry.childValues.forEach(function (value, child) {
      forgetChild(entry, child);
      children.push(child);
    });
  }

  // After we forget all our children, this.dirtyChildren must be empty
  // and therefor must have been reset to null.
  assert(entry.dirtyChildren === null);

  return children;
}

function forgetChild(entry, child) {
  child.parents.delete(entry);
  entry.childValues.delete(child);
  removeDirtyChild(entry, child);
}

function subscribe(entry) {
  if (typeof entry.subscribe === "function") {
    try {
      unsubscribe(entry); // Prevent double subscriptions.
      entry.unsubscribe = entry.subscribe.apply(null, entry.args);
    } catch (e) {
      // If this Entry has a subscribe function and it threw an exception
      // (or an unsubscribe function it previously returned now throws),
      // return false to indicate that we were not able to subscribe (or
      // unsubscribe), and this Entry should remain dirty.
      entry.setDirty();
      return false;
    }
  }

  // Returning true indicates either that there was no entry.subscribe
  // function or that it succeeded.
  return true;
}

function unsubscribe(entry) {
  var unsub = entry.unsubscribe;
  if (typeof unsub === "function") {
    entry.unsubscribe = null;
    unsub();
  }
}


/***/ }),

/***/ "./node_modules/optimism/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cache = __webpack_require__(/*! ./cache.js */ "./node_modules/optimism/lib/cache.js").Cache;
var tuple = __webpack_require__(/*! immutable-tuple */ "./node_modules/immutable-tuple/dist/tuple.mjs").tuple;
var Entry = __webpack_require__(/*! ./entry.js */ "./node_modules/optimism/lib/entry.js").Entry;
var getLocal = __webpack_require__(/*! ./local.js */ "./node_modules/optimism/lib/local.js").get;

function defaultMakeCacheKey() {
  return tuple.apply(null, arguments);
}

// Exported so that custom makeCacheKey functions can easily reuse the
// default implementation (with different arguments).
exports.defaultMakeCacheKey = defaultMakeCacheKey;

function normalizeOptions(options) {
  options = options || Object.create(null);

  if (typeof options.makeCacheKey !== "function") {
    options.makeCacheKey = defaultMakeCacheKey;
  }

  if (typeof options.max !== "number") {
    options.max = Math.pow(2, 16);
  }

  return options;
}

function wrap(fn, options) {
  options = normalizeOptions(options);

  // If this wrapped function is disposable, then its creator does not
  // care about its return value, and it should be removed from the cache
  // immediately when it no longer has any parents that depend on it.
  var disposable = !! options.disposable;

  var cache = new Cache({
    max: options.max,
    dispose: function (key, entry) {
      entry.dispose();
    }
  });

  function reportOrphan(entry) {
    if (disposable) {
      // Triggers the entry.dispose() call above.
      cache.delete(entry.key);
      return true;
    }
  }

  function optimistic() {
    if (disposable && ! getLocal().currentParentEntry) {
      // If there's no current parent computation, and this wrapped
      // function is disposable (meaning we don't care about entry.value,
      // just dependency tracking), then we can short-cut everything else
      // in this function, because entry.recompute() is going to recycle
      // the entry object without recomputing anything, anyway.
      return;
    }

    var key = options.makeCacheKey.apply(null, arguments);
    if (! key) {
      return fn.apply(null, arguments);
    }

    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];

    var entry = cache.get(key);
    if (entry) {
      entry.args = args;
    } else {
      cache.set(key, entry = Entry.acquire(fn, key, args));
      entry.subscribe = options.subscribe;
      if (disposable) {
        entry.reportOrphan = reportOrphan;
      }
    }

    var value = entry.recompute();

    // If options.disposable is truthy, the caller of wrap is telling us
    // they don't care about the result of entry.recompute(), so we should
    // avoid returning the value, so it won't be accidentally used.
    if (! disposable) {
      return value;
    }
  }

  optimistic.dirty = function () {
    var key = options.makeCacheKey.apply(null, arguments);
    if (! key) {
      return;
    }

    if (! cache.has(key)) {
      return;
    }

    cache.get(key).setDirty();
  };

  return optimistic;
}

exports.wrap = wrap;


/***/ }),

/***/ "./node_modules/optimism/lib/local.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/local.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var fakeNullFiber = new (function Fiber(){});
var localKey = "_optimism_local";

function getCurrentFiber() {
  return fakeNullFiber;
}

if (true) {
  try {
    var Fiber = module["eriuqer".split("").reverse().join("")]("fibers");
    // If we were able to require fibers, redefine the getCurrentFiber
    // function so that it has a chance to return Fiber.current.
    getCurrentFiber = function () {
      return Fiber.current || fakeNullFiber;
    };
  } catch (e) {}
}

// Returns an object unique to Fiber.current, if fibers are enabled.
// This object is used for Fiber-local storage in ./entry.js.
exports.get = function () {
  var fiber = getCurrentFiber();
  return fiber[localKey] || (fiber[localKey] = Object.create(null));
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/zen-observable-ts/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/zen-observable-ts/lib/index.js ***!
  \*****************************************************/
/*! exports provided: default, Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zenObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zenObservable */ "./node_modules/zen-observable-ts/lib/zenObservable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return _zenObservable__WEBPACK_IMPORTED_MODULE_0__["Observable"]; });



/* harmony default export */ __webpack_exports__["default"] = (_zenObservable__WEBPACK_IMPORTED_MODULE_0__["Observable"]);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/zen-observable-ts/lib/zenObservable.js":
/*!*************************************************************!*\
  !*** ./node_modules/zen-observable-ts/lib/zenObservable.js ***!
  \*************************************************************/
/*! exports provided: Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zen-observable */ "./node_modules/zen-observable/index.js");
/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zen_observable__WEBPACK_IMPORTED_MODULE_0__);
/* tslint:disable */

var Observable = zen_observable__WEBPACK_IMPORTED_MODULE_0___default.a;
//# sourceMappingURL=zenObservable.js.map

/***/ }),

/***/ "./node_modules/zen-observable/index.js":
/*!**********************************************!*\
  !*** ./node_modules/zen-observable/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/Observable.js */ "./node_modules/zen-observable/lib/Observable.js").Observable;


/***/ }),

/***/ "./node_modules/zen-observable/lib/Observable.js":
/*!*******************************************************!*\
  !*** ./node_modules/zen-observable/lib/Observable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// === Symbol Support ===

var hasSymbols = function () {
  return typeof Symbol === 'function';
};
var hasSymbol = function (name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function (name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

// === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];

  if (value == null) return undefined;

  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');

  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== undefined) {
    ctor = ctor[getSymbol('species')];
    if (ctor === null) {
      ctor = undefined;
    }
  }
  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;

  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = undefined;
  subscription._state = 'ready';
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';

  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);
    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;
      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;
      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({ type: type, value: value });
    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{ type: type, value: value }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription = function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription);

    // ASSERT: observer is an object
    // ASSERT: subscriber is callable

    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';

    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  _createClass(Subscription, [{
    key: 'unsubscribe',
    value: function unsubscribe() {
      if (this._state !== 'closed') {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    }
  }, {
    key: 'closed',
    get: function () {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver = function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: 'next',
    value: function next(value) {
      onNotify(this._subscription, 'next', value);
    }
  }, {
    key: 'error',
    value: function error(value) {
      onNotify(this._subscription, 'error', value);
    }
  }, {
    key: 'complete',
    value: function complete() {
      onNotify(this._subscription, 'complete');
    }
  }, {
    key: 'closed',
    get: function () {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable = exports.Observable = function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');

    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');

    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: 'subscribe',
    value: function subscribe(observer) {
      if (typeof observer !== 'object' || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }
      return new Subscription(observer, this._subscriber);
    }
  }, {
    key: 'forEach',
    value: function forEach(fn) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (typeof fn !== 'function') {
          reject(new TypeError(fn + ' is not a function'));
          return;
        }

        function done() {
          subscription.unsubscribe();
          resolve();
        }

        var subscription = _this.subscribe({
          next: function (value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },

          error: reject,
          complete: resolve
        });
      });
    }
  }, {
    key: 'map',
    value: function map(fn) {
      var _this2 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        return _this2.subscribe({
          next: function (value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'filter',
    value: function filter(fn) {
      var _this3 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        return _this3.subscribe({
          next: function (value) {
            try {
              if (!fn(value)) return;
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'reduce',
    value: function reduce(fn) {
      var _this4 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;

      return new C(function (observer) {
        return _this4.subscribe({
          next: function (value) {
            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));

            observer.next(acc);
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'concat',
    value: function concat() {
      var _this5 = this;

      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }

      var C = getSpecies(this);

      return new C(function (observer) {
        var subscription = void 0;

        function startNext(next) {
          subscription = next.subscribe({
            next: function (v) {
              observer.next(v);
            },
            error: function (e) {
              observer.error(e);
            },
            complete: function () {
              if (sources.length === 0) {
                subscription = undefined;
                observer.complete();
              } else {
                startNext(C.from(sources.shift()));
              }
            }
          });
        }

        startNext(_this5);

        return function () {
          if (subscription) {
            subscription.unsubscribe();
            subscription = undefined;
          }
        };
      });
    }
  }, {
    key: 'flatMap',
    value: function flatMap(fn) {
      var _this6 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        var subscriptions = [];

        var outer = _this6.subscribe({
          next: function (value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }

            var inner = C.from(value).subscribe({
              next: function (value) {
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });

            subscriptions.push(inner);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            completeIfDone();
          }
        });

        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }
  }, {
    key: getSymbol('observable'),
    value: function () {
      return this;
    }
  }], [{
    key: 'from',
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;

      if (x == null) throw new TypeError(x + ' is not an object');

      var method = getMethod(x, getSymbol('observable'));
      if (method) {
        var observable = method.call(x);

        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');

        if (isObservable(observable) && observable.constructor === C) return observable;

        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      if (hasSymbol('iterator')) {
        method = getMethod(x, getSymbol('iterator'));
        if (method) {
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var item = _step.value;

                  observer.next(item);
                  if (observer.closed) return;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              observer.complete();
            });
          });
        }
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;
            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      }

      throw new TypeError(x + ' is not observable');
    }
  }, {
    key: 'of',
    value: function of() {
      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      var C = typeof this === 'function' ? this : Observable;

      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;
          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }
          observer.complete();
        });
      });
    }
  }, {
    key: getSymbol('species'),
    get: function () {
      return this;
    }
  }]);

  return Observable;
}();

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: getSymbol('observable'),
      hostReportError: hostReportError
    },
    configurabe: true
  });
}

/***/ }),

/***/ 0:
/*!**********************************!*\
  !*** multi ./10api/modeloAPI.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\MODELO_PROJECTS\BIM_frontend\modelo3d\10api\modeloAPI.ts */"./10api/modeloAPI.ts");


/***/ })

/******/ });
});
//# sourceMappingURL=modelo3d.js.map
// Bridge modelo3d => modeloAPI

var modelo3d = {};

modelo3d.isSupportWebGL = function(doc) {
    return Modelo.isSupportWebGL(doc);
}

modelo3d.isSupportWebGL2 = function(doc) {
    return Modelo.isSupportWebGL2(doc);
}

//modelo3d.SKYBOX_WALLPAPER       = SkyBox.SKYBOX_WALLPAPER;
//modelo3d.SKYBOX_WALLPAPER_TILED = SkyBox.SKYBOX_WALLPAPER_TILED;
//modelo3d.SKYBOX_SKYDOME         = SkyBox.SKYBOX_EQUIRECTANGLE;

modelo3d.INITIALIZED        = Modelo.View.State.INITIALIZED;
modelo3d.UNINITIALIZED      = Modelo.View.State.UNINITIALIZED;
modelo3d.RENDERING          = Modelo.View.State.RENDERING;
modelo3d.INITIALIZED_PAUSED = Modelo.View.State.INITIALIZED_PAUSED;
modelo3d.RENDERING_PAUSED   = Modelo.View.State.RENDERING_PAUSED;
 
modelo3d.debug = function() {}

var gl = null;

